{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('./constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _DashConstants = require('../dash/constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _MetricsConstants = require('./constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _FragmentModel = require('./models/FragmentModel');\n\nvar _FragmentModel2 = _interopRequireDefault(_FragmentModel);\n\nvar _BufferController = require('./controllers/BufferController');\n\nvar _BufferController2 = _interopRequireDefault(_BufferController);\n\nvar _TextBufferController = require('./text/TextBufferController');\n\nvar _TextBufferController2 = _interopRequireDefault(_TextBufferController);\n\nvar _ScheduleController = require('./controllers/ScheduleController');\n\nvar _ScheduleController2 = _interopRequireDefault(_ScheduleController);\n\nvar _RepresentationController = require('../dash/controllers/RepresentationController');\n\nvar _RepresentationController2 = _interopRequireDefault(_RepresentationController);\n\nvar _LiveEdgeFinder = require('./utils/LiveEdgeFinder');\n\nvar _LiveEdgeFinder2 = _interopRequireDefault(_LiveEdgeFinder);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _SupervisorTools = require('./utils/SupervisorTools');\n\nvar _EventBus = require('../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _DashHandler = require('../dash/DashHandler');\n\nvar _DashHandler2 = _interopRequireDefault(_DashHandler);\n\nvar _Errors = require('../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _DashJSError = require('./vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _Debug = require('../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _RequestModifier = require('./utils/RequestModifier');\n\nvar _RequestModifier2 = _interopRequireDefault(_RequestModifier);\n\nvar _URLUtils = require('../streaming/utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nvar _BoxParser = require('./utils/BoxParser');\n\nvar _BoxParser2 = _interopRequireDefault(_BoxParser);\n\nvar _FragmentRequest = require('./vo/FragmentRequest');\n\nvar _FragmentRequest2 = _interopRequireDefault(_FragmentRequest);\n\nvar _PlayList = require('./vo/metrics/PlayList');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction StreamProcessor(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var streamInfo = config.streamInfo;\n  var type = config.type;\n  var errHandler = config.errHandler;\n  var mimeType = config.mimeType;\n  var timelineConverter = config.timelineConverter;\n  var adapter = config.adapter;\n  var manifestModel = config.manifestModel;\n  var mediaPlayerModel = config.mediaPlayerModel;\n  var fragmentModel = config.fragmentModel;\n  var abrController = config.abrController;\n  var playbackController = config.playbackController;\n  var mediaController = config.mediaController;\n  var textController = config.textController;\n  var dashMetrics = config.dashMetrics;\n  var settings = config.settings;\n  var boxParser = config.boxParser;\n  var instance = void 0,\n      logger = void 0,\n      isDynamic = void 0,\n      mediaInfo = void 0,\n      mediaInfoArr = void 0,\n      bufferController = void 0,\n      scheduleController = void 0,\n      representationController = void 0,\n      liveEdgeFinder = void 0,\n      indexHandler = void 0,\n      bufferingTime = void 0,\n      bufferPruned = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    resetInitialSettings();\n    eventBus.on(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance, {\n      priority: _EventBus2.default.EVENT_PRIORITY_HIGH\n    }); // High priority to be notified before Stream\n\n    eventBus.on(_Events2.default.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n    eventBus.on(_Events2.default.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\n    eventBus.on(_Events2.default.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\n    eventBus.on(_Events2.default.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n    eventBus.on(_Events2.default.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n    eventBus.on(_Events2.default.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\n    eventBus.on(_Events2.default.BUFFER_CLEARED, onBufferCleared, instance);\n    eventBus.on(_Events2.default.QUOTA_EXCEEDED, onQuotaExceeded, instance);\n    eventBus.on(_Events2.default.SEEK_TARGET, onSeekTarget, instance);\n  }\n\n  function initialize(mediaSource, hasVideoTrack) {\n    indexHandler = (0, _DashHandler2.default)(context).create({\n      streamInfo: streamInfo,\n      type: type,\n      timelineConverter: timelineConverter,\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      baseURLController: config.baseURLController,\n      errHandler: errHandler,\n      settings: settings,\n      boxParser: boxParser,\n      events: _Events2.default,\n      eventBus: eventBus,\n      errors: _Errors2.default,\n      debug: (0, _Debug2.default)(context).getInstance(),\n      requestModifier: (0, _RequestModifier2.default)(context).getInstance(),\n      dashConstants: _DashConstants2.default,\n      constants: _Constants2.default,\n      urlUtils: (0, _URLUtils2.default)(context).getInstance()\n    }); // Create live edge finder for dynamic streams\n\n    isDynamic = streamInfo.manifestInfo.isDynamic;\n\n    if (isDynamic) {\n      liveEdgeFinder = (0, _LiveEdgeFinder2.default)(context).create({\n        timelineConverter: timelineConverter\n      });\n    } // Create/initialize controllers\n\n\n    indexHandler.initialize(isDynamic);\n    abrController.registerStreamType(type, instance);\n    representationController = (0, _RepresentationController2.default)(context).create({\n      streamInfo: streamInfo,\n      type: type,\n      abrController: abrController,\n      dashMetrics: dashMetrics,\n      playbackController: playbackController,\n      timelineConverter: timelineConverter,\n      dashConstants: _DashConstants2.default,\n      events: _Events2.default,\n      eventBus: eventBus,\n      errors: _Errors2.default\n    });\n    bufferController = createBufferControllerForType(type);\n\n    if (bufferController) {\n      bufferController.initialize(mediaSource);\n    }\n\n    scheduleController = (0, _ScheduleController2.default)(context).create({\n      streamInfo: streamInfo,\n      type: type,\n      mimeType: mimeType,\n      adapter: adapter,\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      fragmentModel: fragmentModel,\n      abrController: abrController,\n      playbackController: playbackController,\n      textController: textController,\n      mediaController: mediaController,\n      bufferController: bufferController,\n      settings: settings\n    });\n    scheduleController.initialize(hasVideoTrack);\n    bufferingTime = 0;\n    bufferPruned = false;\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function resetInitialSettings() {\n    mediaInfoArr = [];\n    mediaInfo = null;\n    bufferingTime = 0;\n  }\n\n  function reset(errored, keepBuffers) {\n    if (indexHandler) {\n      indexHandler.reset();\n    }\n\n    if (bufferController) {\n      bufferController.reset(errored, keepBuffers);\n      bufferController = null;\n    }\n\n    if (scheduleController) {\n      scheduleController.reset();\n      scheduleController = null;\n    }\n\n    if (representationController) {\n      representationController.reset();\n      representationController = null;\n    }\n\n    if (liveEdgeFinder) {\n      liveEdgeFinder.reset();\n      liveEdgeFinder = null;\n    }\n\n    if (abrController && !keepBuffers) {\n      abrController.unRegisterStreamType(type);\n    }\n\n    eventBus.off(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    eventBus.off(_Events2.default.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n    eventBus.off(_Events2.default.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\n    eventBus.off(_Events2.default.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\n    eventBus.off(_Events2.default.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n    eventBus.off(_Events2.default.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n    eventBus.off(_Events2.default.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\n    eventBus.off(_Events2.default.BUFFER_CLEARED, onBufferCleared, instance);\n    eventBus.off(_Events2.default.SEEK_TARGET, onSeekTarget, instance);\n    resetInitialSettings();\n    type = null;\n    streamInfo = null;\n  }\n\n  function isUpdating() {\n    return representationController ? representationController.isUpdating() : false;\n  }\n\n  function onDataUpdateCompleted(e) {\n    if (!e.error) {\n      // Update representation if no error\n      scheduleController.setCurrentRepresentation(adapter.convertDataToRepresentationInfo(e.currentRepresentation));\n    }\n\n    if (!e.error || e.error.code === _Errors2.default.SEGMENTS_UPDATE_FAILED_ERROR_CODE) {\n      // Update has been postponed, update nevertheless DVR info\n      var activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id;\n\n      if (activeStreamId === streamInfo.id) {\n        addDVRMetric();\n      }\n    }\n  }\n\n  function onQualityChanged(e) {\n    var representationInfo = getRepresentationInfo(e.newQuality);\n    scheduleController.setCurrentRepresentation(representationInfo);\n    dashMetrics.pushPlayListTraceMetrics(new Date(), _PlayList.PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON);\n    dashMetrics.createPlaylistTraceMetrics(representationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\n  }\n\n  function onBufferLevelUpdated(e) {\n    dashMetrics.addBufferLevel(type, new Date(), e.bufferLevel * 1000);\n    var activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id;\n\n    if (!manifestModel.getValue().doNotUpdateDVRWindowOnBufferUpdated && streamInfo.id === activeStreamId) {\n      addDVRMetric();\n    }\n  }\n\n  function onBufferLevelStateChanged(e) {\n    dashMetrics.addBufferState(type, e.state, scheduleController.getBufferTarget());\n\n    if (e.state === _MetricsConstants2.default.BUFFER_EMPTY && !playbackController.isSeeking()) {\n      // logger.info('Buffer is empty! Stalling!');\n      dashMetrics.pushPlayListTraceMetrics(new Date(), _PlayList.PlayListTrace.REBUFFERING_REASON);\n    }\n  }\n\n  function onBufferCleared(e) {\n    // Remove executed requests not buffered anymore\n    fragmentModel.syncExecutedRequestsWithBufferedRange(bufferController.getBuffer().getAllBufferRanges(), streamInfo.duration); // If buffer removed ahead current time (QuotaExceededError or automatic buffer pruning) then adjust current index handler time\n\n    if (e.from > playbackController.getTime()) {\n      bufferingTime = e.from;\n      bufferPruned = true;\n    }\n  }\n\n  function onQuotaExceeded(e) {\n    bufferingTime = e.quotaExceededTime;\n    bufferPruned = true;\n  }\n\n  function addDVRMetric() {\n    var manifestInfo = streamInfo.manifestInfo;\n    var isDynamic = manifestInfo.isDynamic;\n    var range = timelineConverter.calcSegmentAvailabilityRange(representationController.getCurrentRepresentation(), isDynamic);\n    dashMetrics.addDVRInfo(getType(), playbackController.getTime(), manifestInfo, range);\n  }\n\n  function getRepresentationController() {\n    return representationController;\n  }\n\n  function getBuffer() {\n    return bufferController ? bufferController.getBuffer() : null;\n  }\n\n  function setBuffer(buffer) {\n    bufferController.setBuffer(buffer);\n  }\n\n  function getBufferController() {\n    return bufferController;\n  }\n\n  function getFragmentModel() {\n    return fragmentModel;\n  }\n\n  function updateStreamInfo(newStreamInfo) {\n    streamInfo = newStreamInfo;\n\n    if (settings.get().streaming.useAppendWindow) {\n      bufferController.updateAppendWindow();\n    }\n  }\n\n  function getStreamInfo() {\n    return streamInfo;\n  }\n\n  function selectMediaInfo(newMediaInfo) {\n    if (newMediaInfo !== mediaInfo && (!newMediaInfo || !mediaInfo || newMediaInfo.type === mediaInfo.type)) {\n      mediaInfo = newMediaInfo;\n    }\n\n    var newRealAdaptation = adapter.getRealAdaptation(streamInfo, mediaInfo);\n    var voRepresentations = adapter.getVoRepresentations(mediaInfo);\n\n    if (representationController) {\n      var realAdaptation = representationController.getData();\n      var maxQuality = abrController.getTopQualityIndexFor(type, streamInfo.id);\n      var minIdx = abrController.getMinAllowedIndexFor(type);\n      var quality = void 0,\n          averageThroughput = void 0;\n      var bitrate = null;\n\n      if ((realAdaptation === null || realAdaptation.id != newRealAdaptation.id) && type !== _Constants2.default.FRAGMENTED_TEXT) {\n        averageThroughput = abrController.getThroughputHistory().getAverageThroughput(type);\n        bitrate = averageThroughput || abrController.getInitialBitrateFor(type);\n        quality = abrController.getQualityForBitrate(mediaInfo, bitrate);\n      } else {\n        quality = abrController.getQualityFor(type);\n      }\n\n      if (minIdx !== undefined && quality < minIdx) {\n        quality = minIdx;\n      }\n\n      if (quality > maxQuality) {\n        quality = maxQuality;\n      }\n\n      indexHandler.setMimeType(mediaInfo ? mediaInfo.mimeType : null);\n      representationController.updateData(newRealAdaptation, voRepresentations, type, quality);\n    }\n  }\n\n  function addMediaInfo(newMediaInfo, selectNewMediaInfo) {\n    if (mediaInfoArr.indexOf(newMediaInfo) === -1) {\n      mediaInfoArr.push(newMediaInfo);\n    }\n\n    if (selectNewMediaInfo) {\n      this.selectMediaInfo(newMediaInfo);\n    }\n  }\n\n  function getMediaInfoArr() {\n    return mediaInfoArr;\n  }\n\n  function getMediaInfo() {\n    return mediaInfo;\n  }\n\n  function getMediaSource() {\n    return bufferController.getMediaSource();\n  }\n\n  function setMediaSource(mediaSource) {\n    bufferController.setMediaSource(mediaSource, getMediaInfoArr());\n  }\n\n  function dischargePreBuffer() {\n    bufferController.dischargePreBuffer();\n  }\n\n  function getScheduleController() {\n    return scheduleController;\n  }\n  /**\n  * Get a specific voRepresentation. If quality parameter is defined, this function will return the voRepresentation for this quality.\n  * Otherwise, this function will return the current voRepresentation used by the representationController.\n  * @param {number} quality - quality index of the voRepresentaion expected.\n  */\n\n\n  function getRepresentationInfo(quality) {\n    var voRepresentation = void 0;\n\n    if (quality !== undefined) {\n      (0, _SupervisorTools.checkInteger)(quality);\n      voRepresentation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n    } else {\n      voRepresentation = representationController ? representationController.getCurrentRepresentation() : null;\n    }\n\n    return adapter.convertDataToRepresentationInfo(voRepresentation);\n  }\n\n  function isBufferingCompleted() {\n    return bufferController ? bufferController.getIsBufferingCompleted() : false;\n  }\n\n  function getBufferLevel() {\n    return bufferController ? bufferController.getBufferLevel() : 0;\n  }\n\n  function onInitFragmentNeeded(e) {\n    // Event propagation may have been stopped (see MssHandler)\n    if (!e.sender) return;\n    if (adapter.getIsTextTrack(mimeType) && !textController.isTextEnabled()) return;\n\n    if (bufferController && e.representationId) {\n      if (!bufferController.appendInitSegment(e.representationId)) {\n        // Init segment not in cache, send new request\n        var request = indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation()) : null;\n        scheduleController.processInitRequest(request);\n      }\n    }\n  }\n\n  function onMediaFragmentNeeded(e) {\n    var request = void 0; // Don't schedule next fragments while pruning to avoid buffer inconsistencies\n\n    if (!bufferController.getIsPruningInProgress()) {\n      request = findNextRequest(e.seekTarget, e.replacement);\n\n      if (request) {\n        scheduleController.setSeekTarget(NaN);\n\n        if (!e.replacement) {\n          if (!isNaN(request.startTime + request.duration)) {\n            bufferingTime = request.startTime + request.duration;\n          }\n\n          request.delayLoadingTime = new Date().getTime() + scheduleController.getTimeToLoadDelay();\n          scheduleController.setTimeToLoadDelay(0);\n        }\n      }\n    }\n\n    scheduleController.processMediaRequest(request);\n  }\n  /**\n  * Probe the next request. This is used in the CMCD model to get information about the upcoming request. Note: No actual request is performed here.\n  * @return {FragmentRequest|null}\n  */\n\n\n  function probeNextRequest() {\n    var representationInfo = getRepresentationInfo();\n    var representation = representationController && representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null;\n    var request = indexHandler.getNextSegmentRequestIdempotent(getMediaInfo(), representation);\n    return request;\n  }\n\n  function findNextRequest(seekTarget, requestToReplace) {\n    var representationInfo = getRepresentationInfo();\n    var hasSeekTarget = !isNaN(seekTarget);\n    var currentTime = playbackController.getNormalizedTime();\n    var time = hasSeekTarget ? seekTarget : bufferingTime;\n    var bufferIsDivided = false;\n    var request = void 0;\n\n    if (isNaN(time) || getType() === _Constants2.default.FRAGMENTED_TEXT && !textController.isTextEnabled()) {\n      return null;\n    }\n    /**\n    * This is critical for IE/Safari/EDGE\n    * */\n\n\n    if (bufferController) {\n      var range = bufferController.getRangeAt(time);\n      var playingRange = bufferController.getRangeAt(currentTime);\n\n      if ((range !== null || playingRange !== null) && !hasSeekTarget) {\n        if (!range || playingRange && playingRange.start != range.start && playingRange.end != range.end) {\n          var hasDiscontinuities = bufferController.getBuffer().hasDiscontinuitiesAfter(currentTime);\n\n          if (hasDiscontinuities && getType() !== _Constants2.default.FRAGMENTED_TEXT) {\n            fragmentModel.removeExecutedRequestsAfterTime(playingRange.end);\n            bufferIsDivided = true;\n          }\n        }\n      }\n    }\n\n    if (requestToReplace) {\n      time = requestToReplace.startTime + requestToReplace.duration / 2;\n      request = getFragmentRequest(representationInfo, time, {\n        timeThreshold: 0,\n        ignoreIsFinished: true\n      });\n    } else {\n      // Use time just whenever is strictly needed\n      var useTime = hasSeekTarget || bufferPruned || bufferIsDivided;\n      request = getFragmentRequest(representationInfo, useTime ? time : undefined, {\n        keepIdx: !useTime\n      });\n      bufferPruned = false; // Then, check if this request was downloaded or not\n\n      while (request && request.action !== _FragmentRequest2.default.ACTION_COMPLETE && fragmentModel.isFragmentLoaded(request)) {\n        // loop until we found not loaded fragment, or no fragment\n        request = getFragmentRequest(representationInfo);\n      }\n    }\n\n    return request;\n  }\n\n  function onMediaFragmentLoaded(e) {\n    var chunk = e.chunk;\n    var bytes = chunk.bytes;\n    var quality = chunk.quality;\n    var currentRepresentation = getRepresentationInfo(quality);\n    var voRepresentation = representationController && currentRepresentation ? representationController.getRepresentationForQuality(currentRepresentation.quality) : null;\n    var eventStreamMedia = adapter.getEventsFor(currentRepresentation.mediaInfo);\n    var eventStreamTrack = adapter.getEventsFor(currentRepresentation, voRepresentation);\n\n    if (eventStreamMedia && eventStreamMedia.length > 0 || eventStreamTrack && eventStreamTrack.length > 0) {\n      var request = fragmentModel.getRequests({\n        state: _FragmentModel2.default.FRAGMENT_MODEL_EXECUTED,\n        quality: quality,\n        index: chunk.index\n      })[0];\n      var events = handleInbandEvents(bytes, request, eventStreamMedia, eventStreamTrack);\n      eventBus.trigger(_Events2.default.INBAND_EVENTS, {\n        events: events\n      }, {\n        streamId: streamInfo.id\n      });\n    }\n  }\n\n  function handleInbandEvents(data, request, mediaInbandEvents, trackInbandEvents) {\n    try {\n      var eventStreams = {};\n      var events = [];\n      /* Extract the possible schemeIdUri : If a DASH client detects an event message box with a scheme that is not defined in MPD, the client is expected to ignore it */\n\n      var inbandEvents = mediaInbandEvents.concat(trackInbandEvents);\n\n      for (var i = 0, ln = inbandEvents.length; i < ln; i++) {\n        eventStreams[inbandEvents[i].schemeIdUri + '/' + inbandEvents[i].value] = inbandEvents[i];\n      }\n\n      var isoFile = (0, _BoxParser2.default)(context).getInstance().parse(data);\n      var eventBoxes = isoFile.getBoxes('emsg');\n\n      if (!eventBoxes || eventBoxes.length === 0) {\n        return events;\n      }\n\n      var sidx = isoFile.getBox('sidx');\n      var mediaAnchorTime = sidx && !isNaN(sidx.earliest_presentation_time) && !isNaN(sidx.timescale) ? sidx.earliest_presentation_time / sidx.timescale : request && !isNaN(request.mediaStartTime) ? request.mediaStartTime : 0;\n      var fragmentMediaStartTime = Math.max(mediaAnchorTime, 0);\n      var voRepresentation = representationController.getCurrentRepresentation();\n\n      for (var _i = 0, _ln = eventBoxes.length; _i < _ln; _i++) {\n        var event = adapter.getEvent(eventBoxes[_i], eventStreams, fragmentMediaStartTime, voRepresentation);\n\n        if (event) {\n          events.push(event);\n        }\n      }\n\n      return events;\n    } catch (e) {\n      return [];\n    }\n  }\n\n  function createBuffer(previousBuffers) {\n    return getBuffer() || bufferController ? bufferController.createBuffer(mediaInfoArr, previousBuffers) : null;\n  }\n\n  function switchTrackAsked() {\n    scheduleController.switchTrackAsked();\n  }\n\n  function createBufferControllerForType(type) {\n    var controller = null;\n\n    if (!type) {\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, _Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + 'not properly defined'));\n      return null;\n    }\n\n    if (type === _Constants2.default.VIDEO || type === _Constants2.default.AUDIO) {\n      controller = (0, _BufferController2.default)(context).create({\n        streamInfo: streamInfo,\n        type: type,\n        mediaPlayerModel: mediaPlayerModel,\n        manifestModel: manifestModel,\n        fragmentModel: fragmentModel,\n        errHandler: errHandler,\n        mediaController: mediaController,\n        representationController: representationController,\n        adapter: adapter,\n        textController: textController,\n        abrController: abrController,\n        playbackController: playbackController,\n        settings: settings\n      });\n    } else {\n      controller = (0, _TextBufferController2.default)(context).create({\n        streamInfo: streamInfo,\n        type: type,\n        mimeType: mimeType,\n        mediaPlayerModel: mediaPlayerModel,\n        manifestModel: manifestModel,\n        fragmentModel: fragmentModel,\n        errHandler: errHandler,\n        mediaController: mediaController,\n        representationController: representationController,\n        adapter: adapter,\n        textController: textController,\n        abrController: abrController,\n        playbackController: playbackController,\n        settings: settings\n      });\n    }\n\n    return controller;\n  }\n\n  function getLiveStartTime() {\n    if (!isDynamic) return NaN;\n    if (!liveEdgeFinder) return NaN;\n    var liveStartTime = NaN;\n    var currentRepresentationInfo = getRepresentationInfo();\n    var liveEdge = liveEdgeFinder.getLiveEdge(currentRepresentationInfo);\n\n    if (isNaN(liveEdge)) {\n      return NaN;\n    }\n\n    var request = findRequestForLiveEdge(liveEdge, currentRepresentationInfo);\n\n    if (request) {\n      // When low latency mode is selected but browser doesn't support fetch\n      // start at the beginning of the segment to avoid consuming the whole buffer\n      if (settings.get().streaming.lowLatencyEnabled) {\n        liveStartTime = request.duration < mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay();\n      } else {\n        liveStartTime = request.startTime;\n      }\n    }\n\n    return liveStartTime;\n  }\n\n  function findRequestForLiveEdge(liveEdge, currentRepresentationInfo) {\n    try {\n      var request = null;\n      var liveDelay = playbackController.getLiveDelay();\n      var dvrWindowSize = !isNaN(streamInfo.manifestInfo.DVRWindowSize) ? streamInfo.manifestInfo.DVRWindowSize : liveDelay;\n      var dvrWindowSafetyMargin = 0.1 * dvrWindowSize;\n      var startTime = void 0; // Make sure that we have at least a valid request for the end of the DVR window, otherwise we might try forever\n\n      if (!isFinite(dvrWindowSize) || getFragmentRequest(currentRepresentationInfo, liveEdge - dvrWindowSize + dvrWindowSafetyMargin, {\n        ignoreIsFinished: true\n      })) {\n        // Try to find a request as close as possible to the targeted live edge\n        while (!request && liveDelay <= dvrWindowSize) {\n          startTime = liveEdge - liveDelay;\n          request = getFragmentRequest(currentRepresentationInfo, startTime, {\n            ignoreIsFinished: true\n          });\n\n          if (!request) {\n            liveDelay += 1; // Increase by one second for each iteration\n          }\n        }\n      }\n\n      if (request) {\n        playbackController.setLiveDelay(liveDelay, true);\n      }\n\n      logger.debug('live edge: ' + liveEdge + ', live delay: ' + liveDelay + ', live target: ' + startTime);\n      return request;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function onSeekTarget(e) {\n    bufferingTime = e.time;\n    scheduleController.setSeekTarget(e.time);\n  }\n\n  function setBufferingTime(value) {\n    bufferingTime = value;\n  }\n\n  function resetIndexHandler() {\n    if (indexHandler) {\n      indexHandler.resetIndex();\n    }\n  }\n\n  function getInitRequest(quality) {\n    (0, _SupervisorTools.checkInteger)(quality);\n    var representation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n    return indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representation) : null;\n  }\n\n  function getFragmentRequest(representationInfo, time, options) {\n    var fragRequest = null;\n\n    if (indexHandler) {\n      var representation = representationController && representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null; // if time and options are undefined, it means the next segment is requested\n      // otherwise, the segment at this specific time is requested.\n\n      if (time !== undefined && options !== undefined) {\n        fragRequest = indexHandler.getSegmentRequestForTime(getMediaInfo(), representation, time, options);\n      } else {\n        fragRequest = indexHandler.getNextSegmentRequest(getMediaInfo(), representation);\n      }\n    }\n\n    return fragRequest;\n  }\n\n  function finalisePlayList(time, reason) {\n    dashMetrics.pushPlayListTraceMetrics(time, reason);\n  }\n\n  instance = {\n    initialize: initialize,\n    getStreamId: getStreamId,\n    getType: getType,\n    isUpdating: isUpdating,\n    getBufferController: getBufferController,\n    getFragmentModel: getFragmentModel,\n    getScheduleController: getScheduleController,\n    getRepresentationController: getRepresentationController,\n    getRepresentationInfo: getRepresentationInfo,\n    getBufferLevel: getBufferLevel,\n    isBufferingCompleted: isBufferingCompleted,\n    createBuffer: createBuffer,\n    updateStreamInfo: updateStreamInfo,\n    getStreamInfo: getStreamInfo,\n    selectMediaInfo: selectMediaInfo,\n    addMediaInfo: addMediaInfo,\n    getLiveStartTime: getLiveStartTime,\n    switchTrackAsked: switchTrackAsked,\n    getMediaInfoArr: getMediaInfoArr,\n    getMediaInfo: getMediaInfo,\n    getMediaSource: getMediaSource,\n    setMediaSource: setMediaSource,\n    dischargePreBuffer: dischargePreBuffer,\n    getBuffer: getBuffer,\n    setBuffer: setBuffer,\n    setBufferingTime: setBufferingTime,\n    resetIndexHandler: resetIndexHandler,\n    getInitRequest: getInitRequest,\n    getFragmentRequest: getFragmentRequest,\n    finalisePlayList: finalisePlayList,\n    probeNextRequest: probeNextRequest,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nStreamProcessor.__dashjs_factory_name = 'StreamProcessor';\nexports.default = _FactoryMaker2.default.getClassFactory(StreamProcessor);","map":{"version":3,"mappings":"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","names":["StreamProcessor","config","context","eventBus","getInstance","streamInfo","type","errHandler","mimeType","timelineConverter","adapter","manifestModel","mediaPlayerModel","fragmentModel","abrController","playbackController","mediaController","textController","dashMetrics","settings","boxParser","instance","logger","isDynamic","mediaInfo","mediaInfoArr","bufferController","scheduleController","representationController","liveEdgeFinder","indexHandler","bufferingTime","bufferPruned","setup","getLogger","resetInitialSettings","on","Events","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","priority","EventBus","EVENT_PRIORITY_HIGH","QUALITY_CHANGE_REQUESTED","onQualityChanged","INIT_FRAGMENT_NEEDED","onInitFragmentNeeded","MEDIA_FRAGMENT_NEEDED","onMediaFragmentNeeded","MEDIA_FRAGMENT_LOADED","onMediaFragmentLoaded","BUFFER_LEVEL_UPDATED","onBufferLevelUpdated","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","BUFFER_CLEARED","onBufferCleared","QUOTA_EXCEEDED","onQuotaExceeded","SEEK_TARGET","onSeekTarget","initialize","mediaSource","hasVideoTrack","create","baseURLController","events","errors","Errors","debug","requestModifier","dashConstants","DashConstants","constants","Constants","urlUtils","manifestInfo","registerStreamType","createBufferControllerForType","getStreamId","id","getType","reset","errored","keepBuffers","unRegisterStreamType","off","isUpdating","e","error","setCurrentRepresentation","convertDataToRepresentationInfo","currentRepresentation","code","SEGMENTS_UPDATE_FAILED_ERROR_CODE","activeStreamId","getStreamController","getActiveStreamInfo","addDVRMetric","representationInfo","getRepresentationInfo","newQuality","pushPlayListTraceMetrics","Date","PlayListTrace","REPRESENTATION_SWITCH_STOP_REASON","createPlaylistTraceMetrics","getTime","getPlaybackRate","addBufferLevel","bufferLevel","getValue","doNotUpdateDVRWindowOnBufferUpdated","addBufferState","state","getBufferTarget","MetricsConstants","BUFFER_EMPTY","isSeeking","REBUFFERING_REASON","syncExecutedRequestsWithBufferedRange","getBuffer","getAllBufferRanges","duration","from","quotaExceededTime","range","calcSegmentAvailabilityRange","getCurrentRepresentation","addDVRInfo","getRepresentationController","setBuffer","buffer","getBufferController","getFragmentModel","updateStreamInfo","newStreamInfo","get","streaming","useAppendWindow","updateAppendWindow","getStreamInfo","selectMediaInfo","newMediaInfo","newRealAdaptation","getRealAdaptation","voRepresentations","getVoRepresentations","realAdaptation","getData","maxQuality","getTopQualityIndexFor","minIdx","getMinAllowedIndexFor","quality","averageThroughput","bitrate","FRAGMENTED_TEXT","getThroughputHistory","getAverageThroughput","getInitialBitrateFor","getQualityForBitrate","getQualityFor","undefined","setMimeType","updateData","addMediaInfo","selectNewMediaInfo","indexOf","push","getMediaInfoArr","getMediaInfo","getMediaSource","setMediaSource","dischargePreBuffer","getScheduleController","voRepresentation","getRepresentationForQuality","isBufferingCompleted","getIsBufferingCompleted","getBufferLevel","sender","getIsTextTrack","isTextEnabled","representationId","appendInitSegment","request","getInitRequest","processInitRequest","getIsPruningInProgress","findNextRequest","seekTarget","replacement","setSeekTarget","NaN","isNaN","startTime","delayLoadingTime","getTimeToLoadDelay","setTimeToLoadDelay","processMediaRequest","probeNextRequest","representation","getNextSegmentRequestIdempotent","requestToReplace","hasSeekTarget","currentTime","getNormalizedTime","time","bufferIsDivided","getRangeAt","playingRange","start","end","hasDiscontinuities","hasDiscontinuitiesAfter","removeExecutedRequestsAfterTime","getFragmentRequest","timeThreshold","ignoreIsFinished","useTime","keepIdx","action","FragmentRequest","ACTION_COMPLETE","isFragmentLoaded","chunk","bytes","eventStreamMedia","getEventsFor","eventStreamTrack","length","getRequests","FragmentModel","FRAGMENT_MODEL_EXECUTED","index","handleInbandEvents","trigger","INBAND_EVENTS","streamId","data","mediaInbandEvents","trackInbandEvents","eventStreams","inbandEvents","concat","i","ln","schemeIdUri","value","isoFile","parse","eventBoxes","getBoxes","sidx","getBox","mediaAnchorTime","earliest_presentation_time","timescale","mediaStartTime","fragmentMediaStartTime","Math","max","event","getEvent","createBuffer","previousBuffers","switchTrackAsked","controller","DashJSError","MEDIASOURCE_TYPE_UNSUPPORTED_CODE","MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE","VIDEO","AUDIO","getLiveStartTime","liveStartTime","currentRepresentationInfo","liveEdge","getLiveEdge","findRequestForLiveEdge","lowLatencyEnabled","getLiveDelay","liveDelay","dvrWindowSize","DVRWindowSize","dvrWindowSafetyMargin","isFinite","setLiveDelay","setBufferingTime","resetIndexHandler","resetIndex","options","fragRequest","getSegmentRequestForTime","getNextSegmentRequest","finalisePlayList","reason","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/StreamProcessor.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport DashConstants from '../dash/constants/DashConstants';\nimport MetricsConstants from './constants/MetricsConstants';\nimport FragmentModel from './models/FragmentModel';\nimport BufferController from './controllers/BufferController';\nimport TextBufferController from './text/TextBufferController';\nimport ScheduleController from './controllers/ScheduleController';\nimport RepresentationController from '../dash/controllers/RepresentationController';\nimport LiveEdgeFinder from './utils/LiveEdgeFinder';\nimport FactoryMaker from '../core/FactoryMaker';\nimport {checkInteger} from './utils/SupervisorTools';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport DashHandler from '../dash/DashHandler';\nimport Errors from '../core/errors/Errors';\nimport DashJSError from './vo/DashJSError';\nimport Debug from '../core/Debug';\nimport RequestModifier from './utils/RequestModifier';\nimport URLUtils from '../streaming/utils/URLUtils';\nimport BoxParser from './utils/BoxParser';\nimport FragmentRequest from './vo/FragmentRequest';\nimport {PlayListTrace} from './vo/metrics/PlayList';\n\nfunction StreamProcessor(config) {\n\n    config = config || {};\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let streamInfo = config.streamInfo;\n    let type = config.type;\n    let errHandler = config.errHandler;\n    let mimeType = config.mimeType;\n    let timelineConverter = config.timelineConverter;\n    let adapter = config.adapter;\n    let manifestModel = config.manifestModel;\n    let mediaPlayerModel = config.mediaPlayerModel;\n    let fragmentModel = config.fragmentModel;\n    let abrController = config.abrController;\n    let playbackController = config.playbackController;\n    let mediaController = config.mediaController;\n    let textController = config.textController;\n    let dashMetrics = config.dashMetrics;\n    let settings = config.settings;\n    let boxParser = config.boxParser;\n\n    let instance,\n        logger,\n        isDynamic,\n        mediaInfo,\n        mediaInfoArr,\n        bufferController,\n        scheduleController,\n        representationController,\n        liveEdgeFinder,\n        indexHandler,\n        bufferingTime,\n        bufferPruned;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance, { priority: EventBus.EVENT_PRIORITY_HIGH }); // High priority to be notified before Stream\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.on(Events.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.on(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, instance);\n        eventBus.on(Events.QUOTA_EXCEEDED, onQuotaExceeded, instance);\n        eventBus.on(Events.SEEK_TARGET, onSeekTarget, instance);\n    }\n\n    function initialize(mediaSource, hasVideoTrack) {\n        indexHandler = DashHandler(context).create({\n            streamInfo: streamInfo,\n            type: type,\n            timelineConverter: timelineConverter,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            baseURLController: config.baseURLController,\n            errHandler: errHandler,\n            settings: settings,\n            boxParser: boxParser,\n            events: Events,\n            eventBus: eventBus,\n            errors: Errors,\n            debug: Debug(context).getInstance(),\n            requestModifier: RequestModifier(context).getInstance(),\n            dashConstants: DashConstants,\n            constants: Constants,\n            urlUtils: URLUtils(context).getInstance()\n        });\n\n        // Create live edge finder for dynamic streams\n        isDynamic = streamInfo.manifestInfo.isDynamic;\n        if (isDynamic) {\n            liveEdgeFinder = LiveEdgeFinder(context).create({\n                timelineConverter: timelineConverter\n            });\n        }\n\n        // Create/initialize controllers\n        indexHandler.initialize(isDynamic);\n        abrController.registerStreamType(type, instance);\n\n        representationController = RepresentationController(context).create({\n            streamInfo: streamInfo,\n            type: type,\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            playbackController: playbackController,\n            timelineConverter: timelineConverter,\n            dashConstants: DashConstants,\n            events: Events,\n            eventBus: eventBus,\n            errors: Errors\n        });\n\n        bufferController = createBufferControllerForType(type);\n        if (bufferController) {\n            bufferController.initialize(mediaSource);\n        }\n\n        scheduleController = ScheduleController(context).create({\n            streamInfo: streamInfo,\n            type: type,\n            mimeType: mimeType,\n            adapter: adapter,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            fragmentModel: fragmentModel,\n            abrController: abrController,\n            playbackController: playbackController,\n            textController: textController,\n            mediaController: mediaController,\n            bufferController: bufferController,\n            settings: settings\n        });\n\n        scheduleController.initialize(hasVideoTrack);\n\n        bufferingTime = 0;\n        bufferPruned = false;\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function resetInitialSettings() {\n        mediaInfoArr = [];\n        mediaInfo = null;\n        bufferingTime = 0;\n    }\n\n    function reset(errored, keepBuffers) {\n        if (indexHandler) {\n            indexHandler.reset();\n        }\n\n        if (bufferController) {\n            bufferController.reset(errored, keepBuffers);\n            bufferController = null;\n        }\n\n        if (scheduleController) {\n            scheduleController.reset();\n            scheduleController = null;\n        }\n\n        if (representationController) {\n            representationController.reset();\n            representationController = null;\n        }\n\n        if (liveEdgeFinder) {\n            liveEdgeFinder.reset();\n            liveEdgeFinder = null;\n        }\n\n        if (abrController && !keepBuffers) {\n            abrController.unRegisterStreamType(type);\n        }\n\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.off(Events.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.off(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n        eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, instance);\n        eventBus.off(Events.SEEK_TARGET, onSeekTarget, instance);\n\n        resetInitialSettings();\n        type = null;\n        streamInfo = null;\n    }\n\n    function isUpdating() {\n        return representationController ? representationController.isUpdating() : false;\n    }\n\n\n    function onDataUpdateCompleted(e) {\n        if (!e.error) {\n            // Update representation if no error\n            scheduleController.setCurrentRepresentation(adapter.convertDataToRepresentationInfo(e.currentRepresentation));\n        }\n        if (!e.error || e.error.code === Errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE) {\n            // Update has been postponed, update nevertheless DVR info\n            const activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id;\n            if (activeStreamId === streamInfo.id) {\n                addDVRMetric();\n            }\n        }\n    }\n\n    function onQualityChanged(e) {\n        let representationInfo = getRepresentationInfo(e.newQuality);\n        scheduleController.setCurrentRepresentation(representationInfo);\n        dashMetrics.pushPlayListTraceMetrics(new Date(), PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON);\n        dashMetrics.createPlaylistTraceMetrics(representationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\n    }\n\n    function onBufferLevelUpdated(e) {\n        dashMetrics.addBufferLevel(type, new Date(), e.bufferLevel * 1000);\n        const activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id;\n        if (!manifestModel.getValue().doNotUpdateDVRWindowOnBufferUpdated && streamInfo.id === activeStreamId) {\n            addDVRMetric();\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        dashMetrics.addBufferState(type, e.state, scheduleController.getBufferTarget());\n        if (e.state === MetricsConstants.BUFFER_EMPTY && !playbackController.isSeeking()) {\n            // logger.info('Buffer is empty! Stalling!');\n            dashMetrics.pushPlayListTraceMetrics(new Date(), PlayListTrace.REBUFFERING_REASON);\n        }\n    }\n\n    function onBufferCleared(e) {\n        // Remove executed requests not buffered anymore\n        fragmentModel.syncExecutedRequestsWithBufferedRange(\n            bufferController.getBuffer().getAllBufferRanges(),\n            streamInfo.duration);\n\n        // If buffer removed ahead current time (QuotaExceededError or automatic buffer pruning) then adjust current index handler time\n        if (e.from > playbackController.getTime()) {\n            bufferingTime = e.from;\n            bufferPruned = true;\n        }\n    }\n\n    function onQuotaExceeded(e) {\n        bufferingTime = e.quotaExceededTime;\n        bufferPruned = true;\n    }\n\n    function addDVRMetric() {\n        const manifestInfo = streamInfo.manifestInfo;\n        const isDynamic = manifestInfo.isDynamic;\n        const range = timelineConverter.calcSegmentAvailabilityRange(representationController.getCurrentRepresentation(), isDynamic);\n        dashMetrics.addDVRInfo(getType(), playbackController.getTime(), manifestInfo, range);\n    }\n\n    function getRepresentationController() {\n        return representationController;\n    }\n\n    function getBuffer() {\n        return bufferController ? bufferController.getBuffer() : null;\n    }\n\n    function setBuffer(buffer) {\n        bufferController.setBuffer(buffer);\n    }\n\n    function getBufferController() {\n        return bufferController;\n    }\n\n    function getFragmentModel() {\n        return fragmentModel;\n    }\n\n    function updateStreamInfo(newStreamInfo) {\n        streamInfo = newStreamInfo;\n        if (settings.get().streaming.useAppendWindow) {\n            bufferController.updateAppendWindow();\n        }\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function selectMediaInfo(newMediaInfo) {\n        if (newMediaInfo !== mediaInfo && (!newMediaInfo || !mediaInfo || (newMediaInfo.type === mediaInfo.type))) {\n            mediaInfo = newMediaInfo;\n        }\n\n        const newRealAdaptation = adapter.getRealAdaptation(streamInfo, mediaInfo);\n        const voRepresentations = adapter.getVoRepresentations(mediaInfo);\n\n        if (representationController) {\n            const realAdaptation = representationController.getData();\n            const maxQuality = abrController.getTopQualityIndexFor(type, streamInfo.id);\n            const minIdx = abrController.getMinAllowedIndexFor(type);\n\n            let quality,\n                averageThroughput;\n            let bitrate = null;\n\n            if ((realAdaptation === null || (realAdaptation.id != newRealAdaptation.id)) && type !== Constants.FRAGMENTED_TEXT) {\n                averageThroughput = abrController.getThroughputHistory().getAverageThroughput(type);\n                bitrate = averageThroughput || abrController.getInitialBitrateFor(type);\n                quality = abrController.getQualityForBitrate(mediaInfo, bitrate);\n            } else {\n                quality = abrController.getQualityFor(type);\n            }\n\n            if (minIdx !== undefined && quality < minIdx) {\n                quality = minIdx;\n            }\n            if (quality > maxQuality) {\n                quality = maxQuality;\n            }\n            indexHandler.setMimeType(mediaInfo ? mediaInfo.mimeType : null);\n            representationController.updateData(newRealAdaptation, voRepresentations, type, quality);\n        }\n    }\n\n    function addMediaInfo(newMediaInfo, selectNewMediaInfo) {\n        if (mediaInfoArr.indexOf(newMediaInfo) === -1) {\n            mediaInfoArr.push(newMediaInfo);\n        }\n\n        if (selectNewMediaInfo) {\n            this.selectMediaInfo(newMediaInfo);\n        }\n    }\n\n    function getMediaInfoArr() {\n        return mediaInfoArr;\n    }\n\n    function getMediaInfo() {\n        return mediaInfo;\n    }\n\n    function getMediaSource() {\n        return bufferController.getMediaSource();\n    }\n\n    function setMediaSource(mediaSource) {\n        bufferController.setMediaSource(mediaSource, getMediaInfoArr());\n    }\n\n    function dischargePreBuffer() {\n        bufferController.dischargePreBuffer();\n    }\n\n    function getScheduleController() {\n        return scheduleController;\n    }\n\n    /**\n     * Get a specific voRepresentation. If quality parameter is defined, this function will return the voRepresentation for this quality.\n     * Otherwise, this function will return the current voRepresentation used by the representationController.\n     * @param {number} quality - quality index of the voRepresentaion expected.\n     */\n    function getRepresentationInfo(quality) {\n        let voRepresentation;\n\n        if (quality !== undefined) {\n            checkInteger(quality);\n            voRepresentation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n        } else {\n            voRepresentation = representationController ? representationController.getCurrentRepresentation() : null;\n        }\n\n        return adapter.convertDataToRepresentationInfo(voRepresentation);\n    }\n\n    function isBufferingCompleted() {\n        return bufferController ? bufferController.getIsBufferingCompleted() : false;\n    }\n\n    function getBufferLevel() {\n        return bufferController ? bufferController.getBufferLevel() : 0;\n    }\n\n    function onInitFragmentNeeded(e) {\n        // Event propagation may have been stopped (see MssHandler)\n        if (!e.sender) return;\n\n        if (adapter.getIsTextTrack(mimeType) && !textController.isTextEnabled()) return;\n\n        if (bufferController && e.representationId) {\n            if (!bufferController.appendInitSegment(e.representationId)) {\n                // Init segment not in cache, send new request\n                const request = indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation()) : null;\n                scheduleController.processInitRequest(request);\n            }\n        }\n    }\n\n    function onMediaFragmentNeeded(e) {\n        let request;\n\n        // Don't schedule next fragments while pruning to avoid buffer inconsistencies\n        if (!bufferController.getIsPruningInProgress()) {\n            request = findNextRequest(e.seekTarget, e.replacement);\n            if (request) {\n                scheduleController.setSeekTarget(NaN);\n                if (!e.replacement) {\n                    if (!isNaN(request.startTime + request.duration)) {\n                        bufferingTime = request.startTime + request.duration;\n                    }\n                    request.delayLoadingTime = new Date().getTime() + scheduleController.getTimeToLoadDelay();\n                    scheduleController.setTimeToLoadDelay(0);\n                }\n            }\n        }\n\n        scheduleController.processMediaRequest(request);\n    }\n\n    /**\n     * Probe the next request. This is used in the CMCD model to get information about the upcoming request. Note: No actual request is performed here.\n     * @return {FragmentRequest|null}\n     */\n    function probeNextRequest() {\n        const representationInfo = getRepresentationInfo();\n\n        const representation = representationController && representationInfo ?\n            representationController.getRepresentationForQuality(representationInfo.quality) : null;\n\n        let request = indexHandler.getNextSegmentRequestIdempotent(\n            getMediaInfo(),\n            representation\n        );\n\n        return request;\n    }\n\n    function findNextRequest(seekTarget, requestToReplace) {\n        const representationInfo = getRepresentationInfo();\n        const hasSeekTarget = !isNaN(seekTarget);\n        const currentTime = playbackController.getNormalizedTime();\n        let time = hasSeekTarget ? seekTarget : bufferingTime;\n        let bufferIsDivided = false;\n        let request;\n\n        if (isNaN(time) || (getType() === Constants.FRAGMENTED_TEXT && !textController.isTextEnabled())) {\n            return null;\n        }\n        /**\n         * This is critical for IE/Safari/EDGE\n         * */\n        if (bufferController) {\n            let range = bufferController.getRangeAt(time);\n            const playingRange = bufferController.getRangeAt(currentTime);\n            if ((range !== null || playingRange !== null) && !hasSeekTarget) {\n                if (!range || (playingRange && playingRange.start != range.start && playingRange.end != range.end)) {\n                    const hasDiscontinuities = bufferController.getBuffer().hasDiscontinuitiesAfter(currentTime);\n                    if (hasDiscontinuities && getType() !== Constants.FRAGMENTED_TEXT) {\n                        fragmentModel.removeExecutedRequestsAfterTime(playingRange.end);\n                        bufferIsDivided = true;\n                    }\n                }\n            }\n        }\n\n        if (requestToReplace) {\n            time = requestToReplace.startTime + (requestToReplace.duration / 2);\n            request = getFragmentRequest(representationInfo, time, {\n                timeThreshold: 0,\n                ignoreIsFinished: true\n            });\n        } else {\n            // Use time just whenever is strictly needed\n            const useTime = hasSeekTarget || bufferPruned || bufferIsDivided;\n            request = getFragmentRequest(representationInfo,\n                useTime ? time : undefined, {\n                    keepIdx: !useTime\n                });\n            bufferPruned = false;\n\n            // Then, check if this request was downloaded or not\n            while (request && request.action !== FragmentRequest.ACTION_COMPLETE && fragmentModel.isFragmentLoaded(request)) {\n                // loop until we found not loaded fragment, or no fragment\n                request = getFragmentRequest(representationInfo);\n            }\n        }\n\n        return request;\n    }\n\n    function onMediaFragmentLoaded(e) {\n        const chunk = e.chunk;\n\n        const bytes = chunk.bytes;\n        const quality = chunk.quality;\n        const currentRepresentation = getRepresentationInfo(quality);\n\n        const voRepresentation = representationController && currentRepresentation ? representationController.getRepresentationForQuality(currentRepresentation.quality) : null;\n        const eventStreamMedia = adapter.getEventsFor(currentRepresentation.mediaInfo);\n        const eventStreamTrack = adapter.getEventsFor(currentRepresentation, voRepresentation);\n\n        if (eventStreamMedia && eventStreamMedia.length > 0 || eventStreamTrack && eventStreamTrack.length > 0) {\n            const request = fragmentModel.getRequests({\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n                quality: quality,\n                index: chunk.index\n            })[0];\n\n            const events = handleInbandEvents(bytes, request, eventStreamMedia, eventStreamTrack);\n            eventBus.trigger(Events.INBAND_EVENTS,\n                { events: events },\n                { streamId: streamInfo.id }\n            );\n        }\n    }\n\n    function handleInbandEvents(data, request, mediaInbandEvents, trackInbandEvents) {\n        try {\n            const eventStreams = {};\n            const events = [];\n\n            /* Extract the possible schemeIdUri : If a DASH client detects an event message box with a scheme that is not defined in MPD, the client is expected to ignore it */\n            const inbandEvents = mediaInbandEvents.concat(trackInbandEvents);\n            for (let i = 0, ln = inbandEvents.length; i < ln; i++) {\n                eventStreams[inbandEvents[i].schemeIdUri + '/' + inbandEvents[i].value] = inbandEvents[i];\n            }\n\n            const isoFile = BoxParser(context).getInstance().parse(data);\n            const eventBoxes = isoFile.getBoxes('emsg');\n\n            if (!eventBoxes || eventBoxes.length === 0) {\n                return events;\n            }\n\n            const sidx = isoFile.getBox('sidx');\n            const mediaAnchorTime = sidx && !isNaN(sidx.earliest_presentation_time) && !isNaN(sidx.timescale) ? sidx.earliest_presentation_time / sidx.timescale : request && !isNaN(request.mediaStartTime) ? request.mediaStartTime : 0;\n            const fragmentMediaStartTime = Math.max(mediaAnchorTime, 0);\n            const voRepresentation = representationController.getCurrentRepresentation();\n\n            for (let i = 0, ln = eventBoxes.length; i < ln; i++) {\n                const event = adapter.getEvent(eventBoxes[i], eventStreams, fragmentMediaStartTime, voRepresentation);\n\n                if (event) {\n                    events.push(event);\n                }\n            }\n\n            return events;\n        } catch (e) {\n            return [];\n        }\n    }\n\n    function createBuffer(previousBuffers) {\n        return (getBuffer() || bufferController ? bufferController.createBuffer(mediaInfoArr, previousBuffers) : null);\n    }\n\n    function switchTrackAsked() {\n        scheduleController.switchTrackAsked();\n    }\n\n    function createBufferControllerForType(type) {\n        let controller = null;\n\n        if (!type) {\n            errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + 'not properly defined'));\n            return null;\n        }\n\n        if (type === Constants.VIDEO || type === Constants.AUDIO) {\n            controller = BufferController(context).create({\n                streamInfo: streamInfo,\n                type: type,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestModel: manifestModel,\n                fragmentModel: fragmentModel,\n                errHandler: errHandler,\n                mediaController: mediaController,\n                representationController: representationController,\n                adapter: adapter,\n                textController: textController,\n                abrController: abrController,\n                playbackController: playbackController,\n                settings: settings\n            });\n        } else {\n            controller = TextBufferController(context).create({\n                streamInfo: streamInfo,\n                type: type,\n                mimeType: mimeType,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestModel: manifestModel,\n                fragmentModel: fragmentModel,\n                errHandler: errHandler,\n                mediaController: mediaController,\n                representationController: representationController,\n                adapter: adapter,\n                textController: textController,\n                abrController: abrController,\n                playbackController: playbackController,\n                settings: settings\n            });\n        }\n\n        return controller;\n    }\n\n\n    function getLiveStartTime() {\n        if (!isDynamic) return NaN;\n        if (!liveEdgeFinder) return NaN;\n\n        let liveStartTime = NaN;\n        const currentRepresentationInfo = getRepresentationInfo();\n        const liveEdge = liveEdgeFinder.getLiveEdge(currentRepresentationInfo);\n\n        if (isNaN(liveEdge)) {\n            return NaN;\n        }\n\n        const request = findRequestForLiveEdge(liveEdge, currentRepresentationInfo);\n\n        if (request) {\n            // When low latency mode is selected but browser doesn't support fetch\n            // start at the beginning of the segment to avoid consuming the whole buffer\n            if (settings.get().streaming.lowLatencyEnabled) {\n                liveStartTime = request.duration < mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay();\n            } else {\n                liveStartTime = request.startTime;\n            }\n        }\n\n        return liveStartTime;\n    }\n\n    function findRequestForLiveEdge(liveEdge, currentRepresentationInfo) {\n        try {\n            let request = null;\n            let liveDelay = playbackController.getLiveDelay();\n            const dvrWindowSize = !isNaN(streamInfo.manifestInfo.DVRWindowSize) ? streamInfo.manifestInfo.DVRWindowSize : liveDelay;\n            const dvrWindowSafetyMargin = 0.1 * dvrWindowSize;\n            let startTime;\n\n            // Make sure that we have at least a valid request for the end of the DVR window, otherwise we might try forever\n            if (!isFinite(dvrWindowSize) || getFragmentRequest(currentRepresentationInfo, liveEdge - dvrWindowSize + dvrWindowSafetyMargin, {\n                ignoreIsFinished: true\n            })) {\n\n                // Try to find a request as close as possible to the targeted live edge\n                while (!request && liveDelay <= dvrWindowSize) {\n                    startTime = liveEdge - liveDelay;\n                    request = getFragmentRequest(currentRepresentationInfo, startTime, {\n                        ignoreIsFinished: true\n                    });\n                    if (!request) {\n                        liveDelay += 1; // Increase by one second for each iteration\n                    }\n                }\n            }\n\n            if (request) {\n                playbackController.setLiveDelay(liveDelay, true);\n            }\n            logger.debug('live edge: ' + liveEdge + ', live delay: ' + liveDelay + ', live target: ' + startTime);\n            return request;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    function onSeekTarget(e) {\n        bufferingTime = e.time;\n        scheduleController.setSeekTarget(e.time);\n    }\n\n    function setBufferingTime(value) {\n        bufferingTime = value;\n    }\n\n    function resetIndexHandler() {\n        if (indexHandler) {\n            indexHandler.resetIndex();\n        }\n    }\n\n    function getInitRequest(quality) {\n        checkInteger(quality);\n        const representation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n        return indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representation) : null;\n    }\n\n    function getFragmentRequest(representationInfo, time, options) {\n        let fragRequest = null;\n\n        if (indexHandler) {\n            const representation = representationController && representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null;\n\n            // if time and options are undefined, it means the next segment is requested\n            // otherwise, the segment at this specific time is requested.\n            if (time !== undefined && options !== undefined) {\n                fragRequest = indexHandler.getSegmentRequestForTime(getMediaInfo(), representation, time, options);\n            } else {\n                fragRequest = indexHandler.getNextSegmentRequest(getMediaInfo(), representation);\n            }\n        }\n\n        return fragRequest;\n    }\n\n    function finalisePlayList(time, reason) {\n        dashMetrics.pushPlayListTraceMetrics(time, reason);\n    }\n\n    instance = {\n        initialize: initialize,\n        getStreamId: getStreamId,\n        getType: getType,\n        isUpdating: isUpdating,\n        getBufferController: getBufferController,\n        getFragmentModel: getFragmentModel,\n        getScheduleController: getScheduleController,\n        getRepresentationController: getRepresentationController,\n        getRepresentationInfo: getRepresentationInfo,\n        getBufferLevel: getBufferLevel,\n        isBufferingCompleted: isBufferingCompleted,\n        createBuffer: createBuffer,\n        updateStreamInfo: updateStreamInfo,\n        getStreamInfo: getStreamInfo,\n        selectMediaInfo: selectMediaInfo,\n        addMediaInfo: addMediaInfo,\n        getLiveStartTime: getLiveStartTime,\n        switchTrackAsked: switchTrackAsked,\n        getMediaInfoArr: getMediaInfoArr,\n        getMediaInfo: getMediaInfo,\n        getMediaSource: getMediaSource,\n        setMediaSource: setMediaSource,\n        dischargePreBuffer: dischargePreBuffer,\n        getBuffer: getBuffer,\n        setBuffer: setBuffer,\n        setBufferingTime: setBufferingTime,\n        resetIndexHandler: resetIndexHandler,\n        getInitRequest: getInitRequest,\n        getFragmentRequest: getFragmentRequest,\n        finalisePlayList: finalisePlayList,\n        probeNextRequest: probeNextRequest,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nStreamProcessor.__dashjs_factory_name = 'StreamProcessor';\nexport default FactoryMaker.getClassFactory(StreamProcessor);\n"]},"metadata":{},"sourceType":"script"}