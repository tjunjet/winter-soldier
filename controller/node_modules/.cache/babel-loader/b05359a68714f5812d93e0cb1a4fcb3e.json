{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _FragmentRequest = require('../vo/FragmentRequest');\n\nvar _FragmentRequest2 = _interopRequireDefault(_FragmentRequest);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar FRAGMENT_MODEL_LOADING = 'loading';\nvar FRAGMENT_MODEL_EXECUTED = 'executed';\nvar FRAGMENT_MODEL_CANCELED = 'canceled';\nvar FRAGMENT_MODEL_FAILED = 'failed';\n\nfunction FragmentModel(config) {\n  config = config || {};\n  var eventBus = config.eventBus;\n  var events = config.events;\n  var dashMetrics = config.dashMetrics;\n  var fragmentLoader = config.fragmentLoader;\n  var debug = config.debug;\n  var streamInfo = config.streamInfo;\n  var type = config.type;\n  var instance = void 0,\n      logger = void 0,\n      executedRequests = void 0,\n      loadingRequests = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    resetInitialSettings();\n    eventBus.on(events.LOADING_COMPLETED, onLoadingCompleted, instance);\n    eventBus.on(events.LOADING_DATA_PROGRESS, onLoadingInProgress, instance);\n    eventBus.on(events.LOADING_ABANDONED, onLoadingAborted, instance);\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function isFragmentLoaded(request) {\n    var isEqualComplete = function isEqualComplete(req1, req2) {\n      return req1.action === _FragmentRequest2.default.ACTION_COMPLETE && req1.action === req2.action;\n    };\n\n    var isEqualMedia = function isEqualMedia(req1, req2) {\n      return !isNaN(req1.index) && req1.startTime === req2.startTime && req1.adaptationIndex === req2.adaptationIndex && req1.type === req2.type;\n    };\n\n    var isEqualInit = function isEqualInit(req1, req2) {\n      return isNaN(req1.index) && isNaN(req2.index) && req1.quality === req2.quality;\n    };\n\n    var check = function check(requests) {\n      var isLoaded = false;\n      requests.some(function (req) {\n        if (isEqualMedia(request, req) || isEqualInit(request, req) || isEqualComplete(request, req)) {\n          isLoaded = true;\n          return isLoaded;\n        }\n      });\n      return isLoaded;\n    };\n\n    if (!request) {\n      return false;\n    }\n\n    return check(executedRequests);\n  }\n\n  function isFragmentLoadedOrPending(request) {\n    var isLoaded = false;\n    var i = 0;\n    var req = void 0; // First, check if the fragment has already been loaded\n\n    isLoaded = isFragmentLoaded(request); // Then, check if the fragment is about to be loeaded\n\n    if (!isLoaded) {\n      for (i = 0; i < loadingRequests.length; i++) {\n        req = loadingRequests[i];\n\n        if (request.url === req.url && request.startTime === req.startTime) {\n          isLoaded = true;\n        }\n      }\n    }\n\n    return isLoaded;\n  }\n  /**\n  *\n  * Gets an array of {@link FragmentRequest} objects\n  *\n  * @param {Object} filter The object with properties by which the method filters the requests to be returned.\n  *  the only mandatory property is state, which must be a value from\n  *  other properties should match the properties of {@link FragmentRequest}. E.g.:\n  *  getRequests({state: FragmentModel.FRAGMENT_MODEL_EXECUTED, quality: 0}) - returns\n  *  all the requests from executedRequests array where requests.quality = filter.quality\n  *\n  * @returns {Array}\n  * @memberof FragmentModel#\n  */\n\n\n  function getRequests(filter) {\n    var states = filter ? filter.state instanceof Array ? filter.state : [filter.state] : [];\n    var filteredRequests = [];\n    states.forEach(function (state) {\n      var requests = getRequestsForState(state);\n      filteredRequests = filteredRequests.concat(filterRequests(requests, filter));\n    });\n    return filteredRequests;\n  }\n\n  function getRequestThreshold(req) {\n    return isNaN(req.duration) ? 0.25 : Math.min(req.duration / 8, 0.5);\n  }\n\n  function removeExecutedRequestsBeforeTime(time) {\n    executedRequests = executedRequests.filter(function (req) {\n      var threshold = getRequestThreshold(req);\n      return isNaN(req.startTime) || (time !== undefined ? req.startTime >= time - threshold : false);\n    });\n  }\n\n  function removeExecutedRequestsAfterTime(time) {\n    executedRequests = executedRequests.filter(function (req) {\n      return isNaN(req.startTime) || (time !== undefined ? req.startTime < time : false);\n    });\n  }\n\n  function removeExecutedRequestsInTimeRange(start, end) {\n    if (end <= start + 0.5) {\n      return;\n    }\n\n    executedRequests = executedRequests.filter(function (req) {\n      var threshold = getRequestThreshold(req);\n      return isNaN(req.startTime) || req.startTime >= end - threshold || isNaN(req.duration) || req.startTime + req.duration <= start + threshold;\n    });\n  } // Remove requests that are not \"represented\" by any of buffered ranges\n\n\n  function syncExecutedRequestsWithBufferedRange(bufferedRanges, streamDuration) {\n    if (!bufferedRanges || bufferedRanges.length === 0) {\n      removeExecutedRequestsBeforeTime();\n      return;\n    }\n\n    var start = 0;\n\n    for (var i = 0, ln = bufferedRanges.length; i < ln; i++) {\n      removeExecutedRequestsInTimeRange(start, bufferedRanges.start(i));\n      start = bufferedRanges.end(i);\n    }\n\n    if (streamDuration > 0) {\n      removeExecutedRequestsInTimeRange(start, streamDuration);\n    }\n  }\n\n  function abortRequests() {\n    logger.debug('abort requests');\n    fragmentLoader.abort();\n    loadingRequests = [];\n  }\n\n  function executeRequest(request) {\n    switch (request.action) {\n      case _FragmentRequest2.default.ACTION_COMPLETE:\n        executedRequests.push(request);\n        addSchedulingInfoMetrics(request, FRAGMENT_MODEL_EXECUTED);\n        logger.debug('STREAM_COMPLETED');\n        eventBus.trigger(events.STREAM_COMPLETED, {\n          request: request\n        }, {\n          streamId: request.mediaInfo.streamInfo.id,\n          mediaType: request.mediaType\n        });\n        break;\n\n      case _FragmentRequest2.default.ACTION_DOWNLOAD:\n        addSchedulingInfoMetrics(request, FRAGMENT_MODEL_LOADING);\n        loadingRequests.push(request);\n        loadCurrentFragment(request);\n        break;\n\n      default:\n        logger.warn('Unknown request action.');\n    }\n  }\n\n  function loadCurrentFragment(request) {\n    eventBus.trigger(events.FRAGMENT_LOADING_STARTED, {\n      request: request\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n    fragmentLoader.load(request);\n  }\n\n  function getRequestForTime(arr, time, threshold) {\n    // loop through the executed requests and pick the one for which the playback interval matches the given time\n    var lastIdx = arr.length - 1;\n\n    for (var i = lastIdx; i >= 0; i--) {\n      var req = arr[i];\n      var start = req.startTime;\n      var end = start + req.duration;\n      threshold = !isNaN(threshold) ? threshold : getRequestThreshold(req);\n\n      if (!isNaN(start) && !isNaN(end) && time + threshold >= start && time - threshold < end || isNaN(start) && isNaN(time)) {\n        return req;\n      }\n    }\n\n    return null;\n  }\n\n  function filterRequests(arr, filter) {\n    // for time use a specific filtration function\n    if (filter.hasOwnProperty('time')) {\n      return [getRequestForTime(arr, filter.time, filter.threshold)];\n    }\n\n    return arr.filter(function (request) {\n      for (var prop in filter) {\n        if (prop === 'state') continue;\n        if (filter.hasOwnProperty(prop) && request[prop] != filter[prop]) return false;\n      }\n\n      return true;\n    });\n  }\n\n  function getRequestsForState(state) {\n    var requests = void 0;\n\n    switch (state) {\n      case FRAGMENT_MODEL_LOADING:\n        requests = loadingRequests;\n        break;\n\n      case FRAGMENT_MODEL_EXECUTED:\n        requests = executedRequests;\n        break;\n\n      default:\n        requests = [];\n    }\n\n    return requests;\n  }\n\n  function addSchedulingInfoMetrics(request, state) {\n    dashMetrics.addSchedulingInfo(request, state);\n    dashMetrics.addRequestsQueue(request.mediaType, loadingRequests, executedRequests);\n  }\n\n  function onLoadingCompleted(e) {\n    if (e.sender !== fragmentLoader) return;\n    loadingRequests.splice(loadingRequests.indexOf(e.request), 1);\n\n    if (e.response && !e.error) {\n      executedRequests.push(e.request);\n    }\n\n    addSchedulingInfoMetrics(e.request, e.error ? FRAGMENT_MODEL_FAILED : FRAGMENT_MODEL_EXECUTED);\n    eventBus.trigger(events.FRAGMENT_LOADING_COMPLETED, {\n      request: e.request,\n      response: e.response,\n      error: e.error,\n      sender: this\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function onLoadingInProgress(e) {\n    if (e.sender !== fragmentLoader) return;\n    eventBus.trigger(events.FRAGMENT_LOADING_PROGRESS, {\n      request: e.request,\n      response: e.response,\n      error: e.error,\n      sender: this\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function onLoadingAborted(e) {\n    if (e.sender !== fragmentLoader) return;\n    eventBus.trigger(events.FRAGMENT_LOADING_ABANDONED, {\n      request: e.request\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function resetInitialSettings() {\n    executedRequests = [];\n    loadingRequests = [];\n  }\n\n  function reset() {\n    eventBus.off(events.LOADING_COMPLETED, onLoadingCompleted, this);\n    eventBus.off(events.LOADING_DATA_PROGRESS, onLoadingInProgress, this);\n    eventBus.off(events.LOADING_ABANDONED, onLoadingAborted, this);\n\n    if (fragmentLoader) {\n      fragmentLoader.reset();\n    }\n\n    resetInitialSettings();\n  }\n\n  function addExecutedRequest(request) {\n    executedRequests.push(request);\n  }\n\n  instance = {\n    getStreamId: getStreamId,\n    getType: getType,\n    getRequests: getRequests,\n    isFragmentLoaded: isFragmentLoaded,\n    isFragmentLoadedOrPending: isFragmentLoadedOrPending,\n    removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime,\n    removeExecutedRequestsAfterTime: removeExecutedRequestsAfterTime,\n    syncExecutedRequestsWithBufferedRange: syncExecutedRequestsWithBufferedRange,\n    abortRequests: abortRequests,\n    executeRequest: executeRequest,\n    reset: reset,\n    addExecutedRequest: addExecutedRequest\n  };\n  setup();\n  return instance;\n}\n\nFragmentModel.__dashjs_factory_name = 'FragmentModel';\n\nvar factory = _FactoryMaker2.default.getClassFactory(FragmentModel);\n\nfactory.FRAGMENT_MODEL_LOADING = FRAGMENT_MODEL_LOADING;\nfactory.FRAGMENT_MODEL_EXECUTED = FRAGMENT_MODEL_EXECUTED;\nfactory.FRAGMENT_MODEL_CANCELED = FRAGMENT_MODEL_CANCELED;\nfactory.FRAGMENT_MODEL_FAILED = FRAGMENT_MODEL_FAILED;\n\n_FactoryMaker2.default.updateClassFactory(FragmentModel.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"mappings":"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","names":["FRAGMENT_MODEL_LOADING","FRAGMENT_MODEL_EXECUTED","FRAGMENT_MODEL_CANCELED","FRAGMENT_MODEL_FAILED","FragmentModel","config","eventBus","events","dashMetrics","fragmentLoader","debug","streamInfo","type","instance","logger","executedRequests","loadingRequests","setup","getLogger","resetInitialSettings","on","LOADING_COMPLETED","onLoadingCompleted","LOADING_DATA_PROGRESS","onLoadingInProgress","LOADING_ABANDONED","onLoadingAborted","getStreamId","id","getType","isFragmentLoaded","request","isEqualComplete","req1","req2","action","FragmentRequest","ACTION_COMPLETE","isEqualMedia","isNaN","index","startTime","adaptationIndex","isEqualInit","quality","check","requests","isLoaded","some","req","isFragmentLoadedOrPending","i","length","url","getRequests","filter","states","state","Array","filteredRequests","forEach","getRequestsForState","concat","filterRequests","getRequestThreshold","duration","Math","min","removeExecutedRequestsBeforeTime","time","threshold","undefined","removeExecutedRequestsAfterTime","removeExecutedRequestsInTimeRange","start","end","syncExecutedRequestsWithBufferedRange","bufferedRanges","streamDuration","ln","abortRequests","abort","executeRequest","push","addSchedulingInfoMetrics","trigger","STREAM_COMPLETED","streamId","mediaInfo","mediaType","ACTION_DOWNLOAD","loadCurrentFragment","warn","FRAGMENT_LOADING_STARTED","load","getRequestForTime","arr","lastIdx","hasOwnProperty","prop","addSchedulingInfo","addRequestsQueue","e","sender","splice","indexOf","response","error","FRAGMENT_LOADING_COMPLETED","FRAGMENT_LOADING_PROGRESS","FRAGMENT_LOADING_ABANDONED","reset","off","addExecutedRequest","__dashjs_factory_name","factory","FactoryMaker","getClassFactory","updateClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/models/FragmentModel.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport FragmentRequest from '../vo/FragmentRequest';\n\nconst FRAGMENT_MODEL_LOADING = 'loading';\nconst FRAGMENT_MODEL_EXECUTED = 'executed';\nconst FRAGMENT_MODEL_CANCELED = 'canceled';\nconst FRAGMENT_MODEL_FAILED = 'failed';\n\nfunction FragmentModel(config) {\n\n    config = config || {};\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const dashMetrics = config.dashMetrics;\n    const fragmentLoader = config.fragmentLoader;\n    const debug = config.debug;\n    const streamInfo = config.streamInfo;\n    const type = config.type;\n\n    let instance,\n        logger,\n        executedRequests,\n        loadingRequests;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n        eventBus.on(events.LOADING_COMPLETED, onLoadingCompleted, instance);\n        eventBus.on(events.LOADING_DATA_PROGRESS, onLoadingInProgress, instance);\n        eventBus.on(events.LOADING_ABANDONED, onLoadingAborted, instance);\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function isFragmentLoaded(request) {\n        const isEqualComplete = function (req1, req2) {\n            return ((req1.action === FragmentRequest.ACTION_COMPLETE) && (req1.action === req2.action));\n        };\n\n        const isEqualMedia = function (req1, req2) {\n            return !isNaN(req1.index) && (req1.startTime === req2.startTime) && (req1.adaptationIndex === req2.adaptationIndex) && (req1.type === req2.type);\n        };\n\n        const isEqualInit = function (req1, req2) {\n            return isNaN(req1.index) && isNaN(req2.index) && (req1.quality === req2.quality);\n        };\n\n        const check = function (requests) {\n            let isLoaded = false;\n\n            requests.some(req => {\n                if (isEqualMedia(request, req) || isEqualInit(request, req) || isEqualComplete(request, req)) {\n                    isLoaded = true;\n                    return isLoaded;\n                }\n            });\n            return isLoaded;\n        };\n\n        if (!request) {\n            return false;\n        }\n\n        return check(executedRequests);\n    }\n\n    function isFragmentLoadedOrPending(request) {\n        let isLoaded = false;\n        let i = 0;\n        let req;\n\n        // First, check if the fragment has already been loaded\n        isLoaded = isFragmentLoaded(request);\n\n        // Then, check if the fragment is about to be loeaded\n        if (!isLoaded) {\n            for (i = 0; i < loadingRequests.length; i++) {\n                req = loadingRequests[i];\n                if ((request.url === req.url) && (request.startTime === req.startTime)) {\n                    isLoaded = true;\n                }\n            }\n        }\n\n        return isLoaded;\n    }\n\n    /**\n     *\n     * Gets an array of {@link FragmentRequest} objects\n     *\n     * @param {Object} filter The object with properties by which the method filters the requests to be returned.\n     *  the only mandatory property is state, which must be a value from\n     *  other properties should match the properties of {@link FragmentRequest}. E.g.:\n     *  getRequests({state: FragmentModel.FRAGMENT_MODEL_EXECUTED, quality: 0}) - returns\n     *  all the requests from executedRequests array where requests.quality = filter.quality\n     *\n     * @returns {Array}\n     * @memberof FragmentModel#\n     */\n    function getRequests(filter) {\n        const states = filter ? filter.state instanceof Array ? filter.state : [filter.state] : [];\n\n        let filteredRequests = [];\n        states.forEach(state => {\n            const requests = getRequestsForState(state);\n            filteredRequests = filteredRequests.concat(filterRequests(requests, filter));\n        });\n\n        return filteredRequests;\n    }\n\n    function getRequestThreshold(req) {\n        return isNaN(req.duration) ? 0.25 : Math.min(req.duration / 8, 0.5);\n    }\n\n    function removeExecutedRequestsBeforeTime(time) {\n        executedRequests = executedRequests.filter(req => {\n            const threshold = getRequestThreshold(req);\n            return isNaN(req.startTime) || (time !== undefined ? req.startTime >= time - threshold : false);\n        });\n    }\n\n    function removeExecutedRequestsAfterTime(time) {\n        executedRequests = executedRequests.filter(req => {\n            return isNaN(req.startTime) || (time !== undefined ? req.startTime < time : false);\n        });\n    }\n\n    function removeExecutedRequestsInTimeRange(start, end) {\n        if (end <= start + 0.5) {\n            return;\n        }\n\n        executedRequests = executedRequests.filter(req => {\n            const threshold = getRequestThreshold(req);\n            return (isNaN(req.startTime) || req.startTime >= (end - threshold)) ||\n                (isNaN(req.duration) || (req.startTime + req.duration) <= (start + threshold));\n        });\n    }\n\n    // Remove requests that are not \"represented\" by any of buffered ranges\n    function syncExecutedRequestsWithBufferedRange(bufferedRanges, streamDuration) {\n        if (!bufferedRanges || bufferedRanges.length === 0) {\n            removeExecutedRequestsBeforeTime();\n            return;\n        }\n\n        let start = 0;\n        for (let i = 0, ln = bufferedRanges.length; i < ln; i++) {\n            removeExecutedRequestsInTimeRange(start, bufferedRanges.start(i));\n            start = bufferedRanges.end(i);\n        }\n        if (streamDuration > 0) {\n            removeExecutedRequestsInTimeRange(start, streamDuration);\n        }\n    }\n\n    function abortRequests() {\n        logger.debug('abort requests');\n        fragmentLoader.abort();\n        loadingRequests = [];\n    }\n\n    function executeRequest(request) {\n        switch (request.action) {\n            case FragmentRequest.ACTION_COMPLETE:\n                executedRequests.push(request);\n                addSchedulingInfoMetrics(request, FRAGMENT_MODEL_EXECUTED);\n                logger.debug('STREAM_COMPLETED');\n                eventBus.trigger(events.STREAM_COMPLETED,\n                    { request: request },\n                    { streamId: request.mediaInfo.streamInfo.id, mediaType: request.mediaType }\n                );\n                break;\n            case FragmentRequest.ACTION_DOWNLOAD:\n                addSchedulingInfoMetrics(request, FRAGMENT_MODEL_LOADING);\n                loadingRequests.push(request);\n                loadCurrentFragment(request);\n                break;\n            default:\n                logger.warn('Unknown request action.');\n        }\n    }\n\n    function loadCurrentFragment(request) {\n        eventBus.trigger(events.FRAGMENT_LOADING_STARTED,\n            { request: request },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n        fragmentLoader.load(request);\n    }\n\n    function getRequestForTime(arr, time, threshold) {\n        // loop through the executed requests and pick the one for which the playback interval matches the given time\n        const lastIdx = arr.length - 1;\n        for (let i = lastIdx; i >= 0; i--) {\n            const req = arr[i];\n            const start = req.startTime;\n            const end = start + req.duration;\n            threshold = !isNaN(threshold) ? threshold : getRequestThreshold(req);\n            if ((!isNaN(start) && !isNaN(end) && ((time + threshold) >= start) && ((time - threshold) < end)) || (isNaN(start) && isNaN(time))) {\n                return req;\n            }\n        }\n        return null;\n    }\n\n    function filterRequests(arr, filter) {\n        // for time use a specific filtration function\n        if (filter.hasOwnProperty('time')) {\n            return [getRequestForTime(arr, filter.time, filter.threshold)];\n        }\n\n        return arr.filter(request => {\n            for (const prop in filter) {\n                if (prop === 'state') continue;\n                if (filter.hasOwnProperty(prop) && request[prop] != filter[prop]) return false;\n            }\n\n            return true;\n        });\n    }\n\n    function getRequestsForState(state) {\n        let requests;\n        switch (state) {\n            case FRAGMENT_MODEL_LOADING:\n                requests = loadingRequests;\n                break;\n            case FRAGMENT_MODEL_EXECUTED:\n                requests = executedRequests;\n                break;\n            default:\n                requests = [];\n        }\n        return requests;\n    }\n\n    function addSchedulingInfoMetrics(request, state) {\n        dashMetrics.addSchedulingInfo(request, state);\n        dashMetrics.addRequestsQueue(request.mediaType, loadingRequests, executedRequests);\n    }\n\n    function onLoadingCompleted(e) {\n        if (e.sender !== fragmentLoader) return;\n\n        loadingRequests.splice(loadingRequests.indexOf(e.request), 1);\n\n        if (e.response && !e.error) {\n            executedRequests.push(e.request);\n        }\n\n        addSchedulingInfoMetrics(e.request, e.error ? FRAGMENT_MODEL_FAILED : FRAGMENT_MODEL_EXECUTED);\n\n        eventBus.trigger(events.FRAGMENT_LOADING_COMPLETED,\n            {\n                request: e.request,\n                response: e.response,\n                error: e.error,\n                sender: this\n            },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function onLoadingInProgress(e) {\n        if (e.sender !== fragmentLoader) return;\n\n        eventBus.trigger(events.FRAGMENT_LOADING_PROGRESS,\n            {\n                request: e.request,\n                response: e.response,\n                error: e.error,\n                sender: this\n            },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function onLoadingAborted(e) {\n        if (e.sender !== fragmentLoader) return;\n\n        eventBus.trigger(events.FRAGMENT_LOADING_ABANDONED,\n            { request: e.request },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function resetInitialSettings() {\n        executedRequests = [];\n        loadingRequests = [];\n    }\n\n    function reset() {\n        eventBus.off(events.LOADING_COMPLETED, onLoadingCompleted, this);\n        eventBus.off(events.LOADING_DATA_PROGRESS, onLoadingInProgress, this);\n        eventBus.off(events.LOADING_ABANDONED, onLoadingAborted, this);\n\n        if (fragmentLoader) {\n            fragmentLoader.reset();\n        }\n        resetInitialSettings();\n    }\n\n    function addExecutedRequest(request) {\n        executedRequests.push(request);\n    }\n\n    instance = {\n        getStreamId: getStreamId,\n        getType: getType,\n        getRequests: getRequests,\n        isFragmentLoaded: isFragmentLoaded,\n        isFragmentLoadedOrPending: isFragmentLoadedOrPending,\n        removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime,\n        removeExecutedRequestsAfterTime: removeExecutedRequestsAfterTime,\n        syncExecutedRequestsWithBufferedRange: syncExecutedRequestsWithBufferedRange,\n        abortRequests: abortRequests,\n        executeRequest: executeRequest,\n        reset: reset,\n        addExecutedRequest: addExecutedRequest\n    };\n\n    setup();\n    return instance;\n}\n\nFragmentModel.__dashjs_factory_name = 'FragmentModel';\nconst factory = FactoryMaker.getClassFactory(FragmentModel);\nfactory.FRAGMENT_MODEL_LOADING = FRAGMENT_MODEL_LOADING;\nfactory.FRAGMENT_MODEL_EXECUTED = FRAGMENT_MODEL_EXECUTED;\nfactory.FRAGMENT_MODEL_CANCELED = FRAGMENT_MODEL_CANCELED;\nfactory.FRAGMENT_MODEL_FAILED = FRAGMENT_MODEL_FAILED;\nFactoryMaker.updateClassFactory(FragmentModel.__dashjs_factory_name, factory);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}