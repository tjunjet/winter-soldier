{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction MediaController() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      tracks = void 0,\n      settings = void 0,\n      initialSettings = void 0,\n      domStorage = void 0;\n  var validTrackSwitchModes = [_Constants2.default.TRACK_SWITCH_MODE_ALWAYS_REPLACE, _Constants2.default.TRACK_SWITCH_MODE_NEVER_REPLACE];\n  var validTrackSelectionModes = [_Constants2.default.TRACK_SELECTION_MODE_HIGHEST_BITRATE, _Constants2.default.TRACK_SELECTION_MODE_FIRST_TRACK, _Constants2.default.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY, _Constants2.default.TRACK_SELECTION_MODE_WIDEST_RANGE];\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    reset();\n  }\n  /**\n  * @param {string} type\n  * @param {StreamInfo} streamInfo\n  * @memberof MediaController#\n  */\n\n\n  function checkInitialMediaSettingsForType(type, streamInfo) {\n    var settings = getInitialSettings(type);\n    var tracksForType = getTracksFor(type, streamInfo);\n    var tracks = [];\n\n    if (!settings) {\n      settings = domStorage.getSavedMediaSettings(type);\n      setInitialSettings(type, settings);\n    }\n\n    if (!tracksForType || tracksForType.length === 0) return;\n\n    if (settings) {\n      tracksForType.forEach(function (track) {\n        if (matchSettings(settings, track)) {\n          tracks.push(track);\n        }\n      });\n    }\n\n    if (tracks.length === 0) {\n      setTrack(this.selectInitialTrack(type, tracksForType), true);\n    } else {\n      if (tracks.length > 1) {\n        setTrack(this.selectInitialTrack(type, tracks));\n      } else {\n        setTrack(tracks[0]);\n      }\n    }\n  }\n  /**\n  * @param {MediaInfo} track\n  * @memberof MediaController#\n  */\n\n\n  function addTrack(track) {\n    if (!track) return;\n    var mediaType = track.type;\n    if (!isMultiTrackSupportedByType(mediaType)) return;\n    var streamId = track.streamInfo.id;\n\n    if (!tracks[streamId]) {\n      tracks[streamId] = createTrackInfo();\n    }\n\n    var mediaTracks = tracks[streamId][mediaType].list;\n\n    for (var i = 0, len = mediaTracks.length; i < len; ++i) {\n      //track is already set.\n      if (isTracksEqual(mediaTracks[i], track)) {\n        return;\n      }\n    }\n\n    mediaTracks.push(track);\n    var initSettings = getInitialSettings(mediaType);\n\n    if (initSettings && matchSettings(initSettings, track) && !getCurrentTrackFor(mediaType, track.streamInfo)) {\n      setTrack(track);\n    }\n  }\n  /**\n  * @param {string} type\n  * @param {StreamInfo} streamInfo\n  * @returns {Array}\n  * @memberof MediaController#\n  */\n\n\n  function getTracksFor(type, streamInfo) {\n    if (!type || !streamInfo) return [];\n    var id = streamInfo.id;\n    if (!tracks[id] || !tracks[id][type]) return [];\n    return tracks[id][type].list;\n  }\n  /**\n  * @param {string} type\n  * @param {StreamInfo} streamInfo\n  * @returns {Object|null}\n  * @memberof MediaController#\n  */\n\n\n  function getCurrentTrackFor(type, streamInfo) {\n    if (!type || !streamInfo || streamInfo && !tracks[streamInfo.id]) return null;\n    return tracks[streamInfo.id][type].current;\n  }\n  /**\n  * @param {MediaInfo} track\n  * @returns {boolean}\n  * @memberof MediaController#\n  */\n\n\n  function isCurrentTrack(track) {\n    if (!track) {\n      return false;\n    }\n\n    var type = track.type;\n    var id = track.streamInfo.id;\n    return tracks[id] && tracks[id][type] && isTracksEqual(tracks[id][type].current, track);\n  }\n  /**\n  * @param {MediaInfo} track\n  * @param {boolean} noSettingsSave specify if settings must be not be saved\n  * @memberof MediaController#\n  */\n\n\n  function setTrack(track, noSettingsSave) {\n    if (!track || !track.streamInfo) return;\n    var type = track.type;\n    var streamInfo = track.streamInfo;\n    var id = streamInfo.id;\n    var current = getCurrentTrackFor(type, streamInfo);\n    if (!tracks[id] || !tracks[id][type] || isTracksEqual(track, current)) return;\n    tracks[id][type].current = track;\n\n    if (tracks[id][type].current && !(noSettingsSave && type === _Constants2.default.FRAGMENTED_TEXT)) {\n      eventBus.trigger(_Events2.default.CURRENT_TRACK_CHANGED, {\n        oldMediaInfo: current,\n        newMediaInfo: track,\n        switchMode: getSwitchMode(type)\n      });\n    }\n\n    if (!noSettingsSave) {\n      var _settings = extractSettings(track);\n\n      if (!_settings || !tracks[id][type].storeLastSettings) return;\n\n      if (_settings.roles) {\n        _settings.role = _settings.roles[0];\n        delete _settings.roles;\n      }\n\n      if (_settings.accessibility) {\n        _settings.accessibility = _settings.accessibility[0];\n      }\n\n      if (_settings.audioChannelConfiguration) {\n        _settings.audioChannelConfiguration = _settings.audioChannelConfiguration[0];\n      }\n\n      domStorage.setSavedMediaSettings(type, _settings);\n    }\n  }\n  /**\n  * @param {string} type\n  * @param {Object} value\n  * @memberof MediaController#\n  */\n\n\n  function setInitialSettings(type, value) {\n    if (!type || !value) return;\n    initialSettings[type] = value;\n  }\n  /**\n  * @param {string} type\n  * @returns {Object|null}\n  * @memberof MediaController#\n  */\n\n\n  function getInitialSettings(type) {\n    if (!type) return null;\n    return initialSettings[type];\n  }\n  /**\n  * @memberof MediaController#\n  */\n\n\n  function saveTextSettingsDisabled() {\n    domStorage.setSavedMediaSettings(_Constants2.default.FRAGMENTED_TEXT, null);\n  }\n  /**\n  * @param {string} type\n  * @param {string} mode\n  * @memberof MediaController#\n  * @deprecated Please use updateSettings({streaming: { trackSwitchMode: mode } }) instead\n  */\n\n\n  function setSwitchMode(type, mode) {\n    logger.warn('deprecated: Please use updateSettings({streaming: { trackSwitchMode: mode } }) instead');\n    var isModeSupported = validTrackSwitchModes.indexOf(mode) !== -1;\n\n    if (!isModeSupported) {\n      logger.warn('Track switch mode is not supported: ' + mode);\n      return;\n    }\n\n    var switchMode = {};\n    switchMode[type] = mode;\n    settings.update({\n      streaming: {\n        trackSwitchMode: switchMode\n      }\n    });\n  }\n  /**\n  * @param {string} type\n  * @returns {string} mode\n  * @memberof MediaController#\n  */\n\n\n  function getSwitchMode(type) {\n    return settings.get().streaming.trackSwitchMode[type];\n  }\n  /**\n  * @param {string} mode\n  * @memberof MediaController#\n  * @deprecated Please use updateSettings({streaming: { selectionModeForInitialTrack: mode } }) instead\n  */\n\n\n  function setSelectionModeForInitialTrack(mode) {\n    logger.warn('deprecated: Please use updateSettings({streaming: { selectionModeForInitialTrack: mode } }) instead');\n    var isModeSupported = validTrackSelectionModes.indexOf(mode) !== -1;\n\n    if (!isModeSupported) {\n      logger.warn('Track selection mode is not supported: ' + mode);\n      return;\n    }\n\n    settings.update({\n      streaming: {\n        selectionModeForInitialTrack: mode\n      }\n    });\n  }\n  /**\n  * @returns {string} mode\n  * @memberof MediaController#\n  */\n\n\n  function getSelectionModeForInitialTrack() {\n    return settings.get().streaming.selectionModeForInitialTrack;\n  }\n  /**\n  * @param {string} type\n  * @returns {boolean}\n  * @memberof MediaController#\n  */\n\n\n  function isMultiTrackSupportedByType(type) {\n    return type === _Constants2.default.AUDIO || type === _Constants2.default.VIDEO || type === _Constants2.default.TEXT || type === _Constants2.default.FRAGMENTED_TEXT || type === _Constants2.default.IMAGE;\n  }\n  /**\n  * @param {MediaInfo} t1 - first track to compare\n  * @param {MediaInfo} t2 - second track to compare\n  * @returns {boolean}\n  * @memberof MediaController#\n  */\n\n\n  function isTracksEqual(t1, t2) {\n    if (!t1 && !t2) {\n      return true;\n    }\n\n    if (!t1 || !t2) {\n      return false;\n    }\n\n    var sameId = t1.id === t2.id;\n    var sameViewpoint = t1.viewpoint === t2.viewpoint;\n    var sameLang = t1.lang === t2.lang;\n    var sameRoles = t1.roles.toString() === t2.roles.toString();\n    var sameAccessibility = t1.accessibility.toString() === t2.accessibility.toString();\n    var sameAudioChannelConfiguration = t1.audioChannelConfiguration.toString() === t2.audioChannelConfiguration.toString();\n    return sameId && sameViewpoint && sameLang && sameRoles && sameAccessibility && sameAudioChannelConfiguration;\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.domStorage) {\n      domStorage = config.domStorage;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n  }\n  /**\n  * @memberof MediaController#\n  */\n\n\n  function reset() {\n    tracks = {};\n    resetInitialSettings();\n  }\n\n  function extractSettings(mediaInfo) {\n    var settings = {\n      lang: mediaInfo.lang,\n      viewpoint: mediaInfo.viewpoint,\n      roles: mediaInfo.roles,\n      accessibility: mediaInfo.accessibility,\n      audioChannelConfiguration: mediaInfo.audioChannelConfiguration\n    };\n    var notEmpty = settings.lang || settings.viewpoint || settings.role && settings.role.length > 0 || settings.accessibility && settings.accessibility.length > 0 || settings.audioChannelConfiguration && settings.audioChannelConfiguration.length > 0;\n    return notEmpty ? settings : null;\n  }\n\n  function matchSettings(settings, track) {\n    var matchLang = !settings.lang || track.lang.match(settings.lang);\n    var matchIndex = settings.index === undefined || settings.index === null || track.index === settings.index;\n    var matchViewPoint = !settings.viewpoint || settings.viewpoint === track.viewpoint;\n    var matchRole = !settings.role || !!track.roles.filter(function (item) {\n      return item === settings.role;\n    })[0];\n    var matchAccessibility = !settings.accessibility || !!track.accessibility.filter(function (item) {\n      return item === settings.accessibility;\n    })[0];\n    var matchAudioChannelConfiguration = !settings.audioChannelConfiguration || !!track.audioChannelConfiguration.filter(function (item) {\n      return item === settings.audioChannelConfiguration;\n    })[0];\n    return matchLang && matchIndex && matchViewPoint && matchRole && matchAccessibility && matchAudioChannelConfiguration;\n  }\n\n  function resetInitialSettings() {\n    initialSettings = {\n      audio: null,\n      video: null,\n      fragmentedText: null\n    };\n  }\n\n  function getTracksWithHighestBitrate(trackArr) {\n    var max = 0;\n    var result = [];\n    var tmp = void 0;\n    trackArr.forEach(function (track) {\n      tmp = Math.max.apply(Math, track.bitrateList.map(function (obj) {\n        return obj.bandwidth;\n      }));\n\n      if (tmp > max) {\n        max = tmp;\n        result = [track];\n      } else if (tmp === max) {\n        result.push(track);\n      }\n    });\n    return result;\n  }\n\n  function getTracksWithHighestEfficiency(trackArr) {\n    var min = Infinity;\n    var result = [];\n    var tmp = void 0;\n    trackArr.forEach(function (track) {\n      var sum = track.bitrateList.reduce(function (acc, obj) {\n        var resolution = Math.max(1, obj.width * obj.height);\n        var efficiency = obj.bandwidth / resolution;\n        return acc + efficiency;\n      }, 0);\n      tmp = sum / track.bitrateList.length;\n\n      if (tmp < min) {\n        min = tmp;\n        result = [track];\n      } else if (tmp === min) {\n        result.push(track);\n      }\n    });\n    return result;\n  }\n\n  function getTracksWithWidestRange(trackArr) {\n    var max = 0;\n    var result = [];\n    var tmp = void 0;\n    trackArr.forEach(function (track) {\n      tmp = track.representationCount;\n\n      if (tmp > max) {\n        max = tmp;\n        result = [track];\n      } else if (tmp === max) {\n        result.push(track);\n      }\n    });\n    return result;\n  }\n\n  function selectInitialTrack(type, tracks) {\n    if (type === _Constants2.default.FRAGMENTED_TEXT) return tracks[0];\n    var mode = getSelectionModeForInitialTrack();\n    var tmpArr = [];\n\n    switch (mode) {\n      case _Constants2.default.TRACK_SELECTION_MODE_HIGHEST_BITRATE:\n        tmpArr = getTracksWithHighestBitrate(tracks);\n\n        if (tmpArr.length > 1) {\n          tmpArr = getTracksWithWidestRange(tmpArr);\n        }\n\n        break;\n\n      case _Constants2.default.TRACK_SELECTION_MODE_FIRST_TRACK:\n        tmpArr.push(tracks[0]);\n        break;\n\n      case _Constants2.default.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY:\n        tmpArr = getTracksWithHighestEfficiency(tracks);\n\n        if (tmpArr.length > 1) {\n          tmpArr = getTracksWithHighestBitrate(tmpArr);\n        }\n\n        break;\n\n      case _Constants2.default.TRACK_SELECTION_MODE_WIDEST_RANGE:\n        tmpArr = getTracksWithWidestRange(tracks);\n\n        if (tmpArr.length > 1) {\n          tmpArr = getTracksWithHighestBitrate(tracks);\n        }\n\n        break;\n\n      default:\n        logger.warn('Track selection mode is not supported: ' + mode);\n        break;\n    }\n\n    return tmpArr[0];\n  }\n\n  function createTrackInfo() {\n    return {\n      audio: {\n        list: [],\n        storeLastSettings: true,\n        current: null\n      },\n      video: {\n        list: [],\n        storeLastSettings: true,\n        current: null\n      },\n      text: {\n        list: [],\n        storeLastSettings: true,\n        current: null\n      },\n      fragmentedText: {\n        list: [],\n        storeLastSettings: true,\n        current: null\n      },\n      image: {\n        list: [],\n        storeLastSettings: true,\n        current: null\n      }\n    };\n  }\n\n  instance = {\n    checkInitialMediaSettingsForType: checkInitialMediaSettingsForType,\n    addTrack: addTrack,\n    getTracksFor: getTracksFor,\n    getCurrentTrackFor: getCurrentTrackFor,\n    isCurrentTrack: isCurrentTrack,\n    setTrack: setTrack,\n    setInitialSettings: setInitialSettings,\n    getInitialSettings: getInitialSettings,\n    setSwitchMode: setSwitchMode,\n    getSwitchMode: getSwitchMode,\n    selectInitialTrack: selectInitialTrack,\n    getTracksWithHighestBitrate: getTracksWithHighestBitrate,\n    getTracksWithHighestEfficiency: getTracksWithHighestEfficiency,\n    getTracksWithWidestRange: getTracksWithWidestRange,\n    setSelectionModeForInitialTrack: setSelectionModeForInitialTrack,\n    getSelectionModeForInitialTrack: getSelectionModeForInitialTrack,\n    isMultiTrackSupportedByType: isMultiTrackSupportedByType,\n    isTracksEqual: isTracksEqual,\n    matchSettings: matchSettings,\n    saveTextSettingsDisabled: saveTextSettingsDisabled,\n    setConfig: setConfig,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nMediaController.__dashjs_factory_name = 'MediaController';\n\nvar factory = _FactoryMaker2.default.getSingletonFactory(MediaController);\n\n_FactoryMaker2.default.updateSingletonFactory(MediaController.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"mappings":"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","names":["MediaController","context","eventBus","getInstance","instance","logger","tracks","settings","initialSettings","domStorage","validTrackSwitchModes","Constants","TRACK_SWITCH_MODE_ALWAYS_REPLACE","TRACK_SWITCH_MODE_NEVER_REPLACE","validTrackSelectionModes","TRACK_SELECTION_MODE_HIGHEST_BITRATE","TRACK_SELECTION_MODE_FIRST_TRACK","TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY","TRACK_SELECTION_MODE_WIDEST_RANGE","setup","getLogger","reset","checkInitialMediaSettingsForType","type","streamInfo","getInitialSettings","tracksForType","getTracksFor","getSavedMediaSettings","setInitialSettings","length","forEach","track","matchSettings","push","setTrack","selectInitialTrack","addTrack","mediaType","isMultiTrackSupportedByType","streamId","id","createTrackInfo","mediaTracks","list","i","len","isTracksEqual","initSettings","getCurrentTrackFor","current","isCurrentTrack","noSettingsSave","FRAGMENTED_TEXT","trigger","Events","CURRENT_TRACK_CHANGED","oldMediaInfo","newMediaInfo","switchMode","getSwitchMode","extractSettings","storeLastSettings","roles","role","accessibility","audioChannelConfiguration","setSavedMediaSettings","value","saveTextSettingsDisabled","setSwitchMode","mode","warn","isModeSupported","indexOf","update","streaming","trackSwitchMode","get","setSelectionModeForInitialTrack","selectionModeForInitialTrack","getSelectionModeForInitialTrack","AUDIO","VIDEO","TEXT","IMAGE","t1","t2","sameId","sameViewpoint","viewpoint","sameLang","lang","sameRoles","toString","sameAccessibility","sameAudioChannelConfiguration","setConfig","config","resetInitialSettings","mediaInfo","notEmpty","matchLang","match","matchIndex","index","undefined","matchViewPoint","matchRole","filter","item","matchAccessibility","matchAudioChannelConfiguration","audio","video","fragmentedText","getTracksWithHighestBitrate","trackArr","max","result","tmp","Math","apply","bitrateList","map","obj","bandwidth","getTracksWithHighestEfficiency","min","Infinity","sum","reduce","acc","resolution","width","height","efficiency","getTracksWithWidestRange","representationCount","tmpArr","text","image","__dashjs_factory_name","factory","FactoryMaker","getSingletonFactory","updateSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/controllers/MediaController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport Events from '../../core/events/Events';\nimport EventBus from '../../core/EventBus';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nfunction MediaController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        tracks,\n        settings,\n        initialSettings,\n        domStorage;\n\n    const validTrackSwitchModes = [\n        Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE,\n        Constants.TRACK_SWITCH_MODE_NEVER_REPLACE\n    ];\n\n    const validTrackSelectionModes = [\n        Constants.TRACK_SELECTION_MODE_HIGHEST_BITRATE,\n        Constants.TRACK_SELECTION_MODE_FIRST_TRACK,\n        Constants.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY,\n        Constants.TRACK_SELECTION_MODE_WIDEST_RANGE\n    ];\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        reset();\n    }\n\n    /**\n     * @param {string} type\n     * @param {StreamInfo} streamInfo\n     * @memberof MediaController#\n     */\n    function checkInitialMediaSettingsForType(type, streamInfo) {\n        let settings = getInitialSettings(type);\n        const tracksForType = getTracksFor(type, streamInfo);\n        const tracks = [];\n\n        if (!settings) {\n            settings = domStorage.getSavedMediaSettings(type);\n            setInitialSettings(type, settings);\n        }\n\n        if (!tracksForType || (tracksForType.length === 0)) return;\n\n        if (settings) {\n            tracksForType.forEach(function (track) {\n                if (matchSettings(settings, track)) {\n                    tracks.push(track);\n                }\n            });\n        }\n\n        if (tracks.length === 0) {\n            setTrack(this.selectInitialTrack(type, tracksForType), true);\n        } else {\n            if (tracks.length > 1) {\n                setTrack(this.selectInitialTrack(type, tracks));\n            } else {\n                setTrack(tracks[0]);\n            }\n        }\n    }\n\n    /**\n     * @param {MediaInfo} track\n     * @memberof MediaController#\n     */\n    function addTrack(track) {\n        if (!track) return;\n\n        const mediaType = track.type;\n        if (!isMultiTrackSupportedByType(mediaType)) return;\n\n        let streamId = track.streamInfo.id;\n        if (!tracks[streamId]) {\n            tracks[streamId] = createTrackInfo();\n        }\n\n        const mediaTracks = tracks[streamId][mediaType].list;\n        for (let i = 0, len = mediaTracks.length; i < len; ++i) {\n            //track is already set.\n            if (isTracksEqual(mediaTracks[i], track)) {\n                return;\n            }\n        }\n\n        mediaTracks.push(track);\n\n        let initSettings = getInitialSettings(mediaType);\n        if (initSettings && (matchSettings(initSettings, track)) && !getCurrentTrackFor(mediaType, track.streamInfo)) {\n            setTrack(track);\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @param {StreamInfo} streamInfo\n     * @returns {Array}\n     * @memberof MediaController#\n     */\n    function getTracksFor(type, streamInfo) {\n        if (!type || !streamInfo) return [];\n\n        const id = streamInfo.id;\n\n        if (!tracks[id] || !tracks[id][type]) return [];\n\n        return tracks[id][type].list;\n    }\n\n    /**\n     * @param {string} type\n     * @param {StreamInfo} streamInfo\n     * @returns {Object|null}\n     * @memberof MediaController#\n     */\n    function getCurrentTrackFor(type, streamInfo) {\n        if (!type || !streamInfo || (streamInfo && !tracks[streamInfo.id])) return null;\n        return tracks[streamInfo.id][type].current;\n    }\n\n    /**\n     * @param {MediaInfo} track\n     * @returns {boolean}\n     * @memberof MediaController#\n     */\n    function isCurrentTrack(track) {\n        if (!track) {\n            return false;\n        }\n        const type = track.type;\n        const id = track.streamInfo.id;\n\n        return (tracks[id] && tracks[id][type] && isTracksEqual(tracks[id][type].current, track));\n    }\n\n    /**\n     * @param {MediaInfo} track\n     * @param {boolean} noSettingsSave specify if settings must be not be saved\n     * @memberof MediaController#\n     */\n    function setTrack(track, noSettingsSave) {\n        if (!track || !track.streamInfo) return;\n\n        const type = track.type;\n        const streamInfo = track.streamInfo;\n        const id = streamInfo.id;\n        const current = getCurrentTrackFor(type, streamInfo);\n\n        if (!tracks[id] || !tracks[id][type] || isTracksEqual(track, current)) return;\n\n        tracks[id][type].current = track;\n\n        if (tracks[id][type].current && !(noSettingsSave && type === Constants.FRAGMENTED_TEXT)) {\n            eventBus.trigger(Events.CURRENT_TRACK_CHANGED, {\n                oldMediaInfo: current,\n                newMediaInfo: track,\n                switchMode: getSwitchMode(type)\n            });\n        }\n\n        if (!noSettingsSave) {\n\n            let settings = extractSettings(track);\n\n            if (!settings || !tracks[id][type].storeLastSettings) return;\n\n            if (settings.roles) {\n                settings.role = settings.roles[0];\n                delete settings.roles;\n            }\n\n            if (settings.accessibility) {\n                settings.accessibility = settings.accessibility[0];\n            }\n\n            if (settings.audioChannelConfiguration) {\n                settings.audioChannelConfiguration = settings.audioChannelConfiguration[0];\n            }\n\n            domStorage.setSavedMediaSettings(type, settings);\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @param {Object} value\n     * @memberof MediaController#\n     */\n    function setInitialSettings(type, value) {\n        if (!type || !value) return;\n\n        initialSettings[type] = value;\n    }\n\n    /**\n     * @param {string} type\n     * @returns {Object|null}\n     * @memberof MediaController#\n     */\n    function getInitialSettings(type) {\n        if (!type) return null;\n\n        return initialSettings[type];\n    }\n\n    /**\n     * @memberof MediaController#\n     */\n    function saveTextSettingsDisabled() {\n        domStorage.setSavedMediaSettings(Constants.FRAGMENTED_TEXT, null);\n    }\n\n    /**\n     * @param {string} type\n     * @param {string} mode\n     * @memberof MediaController#\n     * @deprecated Please use updateSettings({streaming: { trackSwitchMode: mode } }) instead\n     */\n    function setSwitchMode(type, mode) {\n        logger.warn('deprecated: Please use updateSettings({streaming: { trackSwitchMode: mode } }) instead');\n        const isModeSupported = (validTrackSwitchModes.indexOf(mode) !== -1);\n\n        if (!isModeSupported) {\n            logger.warn('Track switch mode is not supported: ' + mode);\n            return;\n        }\n\n        let switchMode = {};\n        switchMode[type] = mode;\n\n        settings.update({\n            streaming: {\n                trackSwitchMode: switchMode\n            }\n        });\n    }\n\n    /**\n     * @param {string} type\n     * @returns {string} mode\n     * @memberof MediaController#\n     */\n    function getSwitchMode(type) {\n        return settings.get().streaming.trackSwitchMode[type];\n    }\n\n    /**\n     * @param {string} mode\n     * @memberof MediaController#\n     * @deprecated Please use updateSettings({streaming: { selectionModeForInitialTrack: mode } }) instead\n     */\n    function setSelectionModeForInitialTrack(mode) {\n        logger.warn('deprecated: Please use updateSettings({streaming: { selectionModeForInitialTrack: mode } }) instead');\n        const isModeSupported = (validTrackSelectionModes.indexOf(mode) !== -1);\n\n        if (!isModeSupported) {\n            logger.warn('Track selection mode is not supported: ' + mode);\n            return;\n        }\n\n        settings.update({\n            streaming: {\n                selectionModeForInitialTrack: mode\n            }\n        });\n    }\n\n    /**\n     * @returns {string} mode\n     * @memberof MediaController#\n     */\n    function getSelectionModeForInitialTrack() {\n        return settings.get().streaming.selectionModeForInitialTrack;\n    }\n\n    /**\n     * @param {string} type\n     * @returns {boolean}\n     * @memberof MediaController#\n     */\n    function isMultiTrackSupportedByType(type) {\n        return (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.TEXT ||\n            type === Constants.FRAGMENTED_TEXT || type === Constants.IMAGE);\n    }\n\n    /**\n     * @param {MediaInfo} t1 - first track to compare\n     * @param {MediaInfo} t2 - second track to compare\n     * @returns {boolean}\n     * @memberof MediaController#\n     */\n    function isTracksEqual(t1, t2) {\n        if (!t1 && !t2) {\n            return true;\n        }\n\n        if (!t1 || !t2) {\n            return false;\n        }\n\n        const sameId = t1.id === t2.id;\n        const sameViewpoint = t1.viewpoint === t2.viewpoint;\n        const sameLang = t1.lang === t2.lang;\n        const sameRoles = t1.roles.toString() === t2.roles.toString();\n        const sameAccessibility = t1.accessibility.toString() === t2.accessibility.toString();\n        const sameAudioChannelConfiguration = t1.audioChannelConfiguration.toString() === t2.audioChannelConfiguration.toString();\n\n        return (sameId && sameViewpoint && sameLang && sameRoles && sameAccessibility && sameAudioChannelConfiguration);\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.domStorage) {\n            domStorage = config.domStorage;\n        }\n\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    /**\n     * @memberof MediaController#\n     */\n    function reset() {\n        tracks = {};\n        resetInitialSettings();\n    }\n\n    function extractSettings(mediaInfo) {\n        const settings = {\n            lang: mediaInfo.lang,\n            viewpoint: mediaInfo.viewpoint,\n            roles: mediaInfo.roles,\n            accessibility: mediaInfo.accessibility,\n            audioChannelConfiguration: mediaInfo.audioChannelConfiguration\n        };\n        let notEmpty = settings.lang || settings.viewpoint || (settings.role && settings.role.length > 0) ||\n        (settings.accessibility && settings.accessibility.length > 0) || (settings.audioChannelConfiguration && settings.audioChannelConfiguration.length > 0);\n\n        return notEmpty ? settings : null;\n    }\n\n    function matchSettings(settings, track) {\n        const matchLang = !settings.lang || (track.lang.match(settings.lang));\n        const matchIndex = (settings.index === undefined) || (settings.index === null) || (track.index === settings.index);\n        const matchViewPoint = !settings.viewpoint || (settings.viewpoint === track.viewpoint);\n        const matchRole = !settings.role || !!track.roles.filter(function (item) {\n            return item === settings.role;\n        })[0];\n        let matchAccessibility = !settings.accessibility || !!track.accessibility.filter(function (item) {\n            return item === settings.accessibility;\n        })[0];\n        let matchAudioChannelConfiguration = !settings.audioChannelConfiguration || !!track.audioChannelConfiguration.filter(function (item) {\n            return item === settings.audioChannelConfiguration;\n        })[0];\n\n        return (matchLang && matchIndex && matchViewPoint && matchRole && matchAccessibility && matchAudioChannelConfiguration);\n    }\n\n    function resetInitialSettings() {\n        initialSettings = {\n            audio: null,\n            video: null,\n            fragmentedText: null\n        };\n    }\n\n    function getTracksWithHighestBitrate (trackArr) {\n        let max = 0;\n        let result = [];\n        let tmp;\n\n        trackArr.forEach(function (track) {\n            tmp = Math.max.apply(Math, track.bitrateList.map(function (obj) { return obj.bandwidth; }));\n\n            if (tmp > max) {\n                max = tmp;\n                result = [track];\n            } else if (tmp === max) {\n                result.push(track);\n            }\n        });\n\n        return result;\n    }\n\n    function getTracksWithHighestEfficiency (trackArr) {\n        let min = Infinity;\n        let result = [];\n        let tmp;\n\n        trackArr.forEach(function (track) {\n            const sum = track.bitrateList.reduce(function (acc, obj) {\n                const resolution = Math.max(1, obj.width * obj.height);\n                const efficiency = obj.bandwidth / resolution;\n                return acc + efficiency;\n            }, 0);\n            tmp = sum / track.bitrateList.length;\n\n            if (tmp < min) {\n                min = tmp;\n                result = [track];\n            } else if (tmp === min) {\n                result.push(track);\n            }\n        });\n\n        return result;\n    }\n\n    function getTracksWithWidestRange (trackArr) {\n        let max = 0;\n        let result = [];\n        let tmp;\n\n        trackArr.forEach(function (track) {\n            tmp = track.representationCount;\n\n            if (tmp > max) {\n                max = tmp;\n                result = [track];\n            } else if (tmp === max) {\n                result.push(track);\n            }\n        });\n\n        return result;\n    }\n\n    function selectInitialTrack(type, tracks) {\n        if (type === Constants.FRAGMENTED_TEXT) return tracks[0];\n\n        let mode = getSelectionModeForInitialTrack();\n        let tmpArr = [];\n\n        switch (mode) {\n            case Constants.TRACK_SELECTION_MODE_HIGHEST_BITRATE:\n                tmpArr = getTracksWithHighestBitrate(tracks);\n\n                if (tmpArr.length > 1) {\n                    tmpArr = getTracksWithWidestRange(tmpArr);\n                }\n                break;\n            case Constants.TRACK_SELECTION_MODE_FIRST_TRACK:\n                tmpArr.push(tracks[0]);\n                break;\n            case Constants.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY:\n                tmpArr = getTracksWithHighestEfficiency(tracks);\n\n                if (tmpArr.length > 1) {\n                    tmpArr = getTracksWithHighestBitrate(tmpArr);\n                }\n                break;\n            case Constants.TRACK_SELECTION_MODE_WIDEST_RANGE:\n                tmpArr = getTracksWithWidestRange(tracks);\n\n                if (tmpArr.length > 1) {\n                    tmpArr = getTracksWithHighestBitrate(tracks);\n                }\n                break;\n            default:\n                logger.warn('Track selection mode is not supported: ' + mode);\n                break;\n        }\n\n        return tmpArr[0];\n    }\n\n    function createTrackInfo() {\n        return {\n            audio: {\n                list: [],\n                storeLastSettings: true,\n                current: null\n            },\n            video: {\n                list: [],\n                storeLastSettings: true,\n                current: null\n            },\n            text: {\n                list: [],\n                storeLastSettings: true,\n                current: null\n            },\n            fragmentedText: {\n                list: [],\n                storeLastSettings: true,\n                current: null\n            },\n            image: {\n                list: [],\n                storeLastSettings: true,\n                current: null\n            }\n        };\n    }\n\n    instance = {\n        checkInitialMediaSettingsForType: checkInitialMediaSettingsForType,\n        addTrack: addTrack,\n        getTracksFor: getTracksFor,\n        getCurrentTrackFor: getCurrentTrackFor,\n        isCurrentTrack: isCurrentTrack,\n        setTrack: setTrack,\n        setInitialSettings: setInitialSettings,\n        getInitialSettings: getInitialSettings,\n        setSwitchMode: setSwitchMode,\n        getSwitchMode: getSwitchMode,\n        selectInitialTrack: selectInitialTrack,\n        getTracksWithHighestBitrate: getTracksWithHighestBitrate,\n        getTracksWithHighestEfficiency: getTracksWithHighestEfficiency,\n        getTracksWithWidestRange: getTracksWithWidestRange,\n        setSelectionModeForInitialTrack: setSelectionModeForInitialTrack,\n        getSelectionModeForInitialTrack: getSelectionModeForInitialTrack,\n        isMultiTrackSupportedByType: isMultiTrackSupportedByType,\n        isTracksEqual: isTracksEqual,\n        matchSettings: matchSettings,\n        saveTextSettingsDisabled: saveTextSettingsDisabled,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nMediaController.__dashjs_factory_name = 'MediaController';\nconst factory = FactoryMaker.getSingletonFactory(MediaController);\nFactoryMaker.updateSingletonFactory(MediaController.__dashjs_factory_name, factory);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}