{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Settings = require('../../core/Settings');\n\nvar _Settings2 = _interopRequireDefault(_Settings);\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* @module FetchLoader\n* @ignore\n* @description Manages download of resources via HTTP using fetch.\n* @param {Object} cfg - dependencies from parent\n*/\n\n\nfunction FetchLoader(cfg) {\n  cfg = cfg || {};\n  var context = this.context;\n  var requestModifier = cfg.requestModifier;\n  var boxParser = cfg.boxParser;\n  var settings = (0, _Settings2.default)(context).getInstance();\n  var instance = void 0;\n\n  function load(httpRequest) {\n    // Variables will be used in the callback functions\n    var requestStartTime = new Date();\n    var request = httpRequest.request;\n    var headers = new Headers();\n    /*jshint ignore:line*/\n\n    if (request.range) {\n      headers.append('Range', 'bytes=' + request.range);\n    }\n\n    if (httpRequest.headers) {\n      for (var header in httpRequest.headers) {\n        var value = httpRequest.headers[header];\n\n        if (value) {\n          headers.append(header, value);\n        }\n      }\n    }\n\n    if (!request.requestStartDate) {\n      request.requestStartDate = requestStartTime;\n    }\n\n    if (requestModifier) {\n      // modifyRequestHeader expects a XMLHttpRequest object so,\n      // to keep backward compatibility, we should expose a setRequestHeader method\n      // TODO: Remove RequestModifier dependency on XMLHttpRequest object and define\n      // a more generic way to intercept/modify requests\n      requestModifier.modifyRequestHeader({\n        setRequestHeader: function setRequestHeader(header, value) {\n          headers.append(header, value);\n        }\n      });\n    }\n\n    var abortController = void 0;\n\n    if (typeof window.AbortController === 'function') {\n      abortController = new AbortController();\n      /*jshint ignore:line*/\n\n      httpRequest.abortController = abortController;\n      abortController.signal.onabort = httpRequest.onabort;\n    }\n\n    var reqOptions = {\n      method: httpRequest.method,\n      headers: headers,\n      credentials: httpRequest.withCredentials ? 'include' : undefined,\n      signal: abortController ? abortController.signal : undefined\n    };\n    fetch(httpRequest.url, reqOptions).then(function (response) {\n      if (!httpRequest.response) {\n        httpRequest.response = {};\n      }\n\n      httpRequest.response.status = response.status;\n      httpRequest.response.statusText = response.statusText;\n      httpRequest.response.responseURL = response.url;\n\n      if (!response.ok) {\n        httpRequest.onerror();\n      }\n\n      var responseHeaders = '';\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = response.headers.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          responseHeaders += key + ': ' + response.headers.get(key) + '\\r\\n';\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      httpRequest.response.responseHeaders = responseHeaders;\n\n      if (!response.body) {\n        // Fetch returning a ReadableStream response body is not currently supported by all browsers.\n        // Browser compatibility: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n        // If it is not supported, returning the whole segment when it's ready (as xhr)\n        return response.arrayBuffer().then(function (buffer) {\n          httpRequest.response.response = buffer;\n          var event = {\n            loaded: buffer.byteLength,\n            total: buffer.byteLength,\n            stream: false\n          };\n          httpRequest.progress(event);\n          httpRequest.onload();\n          httpRequest.onend();\n          return;\n        });\n      }\n\n      var totalBytes = parseInt(response.headers.get('Content-Length'), 10);\n      var bytesReceived = 0;\n      var signaledFirstByte = false;\n      var remaining = new Uint8Array();\n      var offset = 0;\n      httpRequest.reader = response.body.getReader();\n      var downloadedData = [];\n      var startTimeData = [];\n      var endTimeData = [];\n      var lastChunkWasFinished = true;\n      var calculationMode = settings.get().streaming.abr.fetchThroughputCalculationMode;\n\n      var processResult = function processResult(_ref) {\n        var value = _ref.value,\n            done = _ref.done; // Bug fix Parse whenever data is coming [value] better than 1ms looking that increase CPU\n\n        if (done) {\n          if (remaining) {\n            // If there is pending data, call progress so network metrics\n            // are correctly generated\n            // Same structure as https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/\n            httpRequest.progress({\n              loaded: bytesReceived,\n              total: isNaN(totalBytes) ? bytesReceived : totalBytes,\n              lengthComputable: true,\n              time: calculateDownloadedTime(calculationMode, startTimeData, endTimeData, downloadedData, bytesReceived),\n              stream: true\n            });\n            httpRequest.response.response = remaining.buffer;\n          }\n\n          httpRequest.onload();\n          httpRequest.onend();\n          return;\n        }\n\n        if (value && value.length > 0) {\n          remaining = concatTypedArray(remaining, value);\n          bytesReceived += value.length;\n          downloadedData.push({\n            ts: Date.now(),\n            bytes: value.length\n          });\n\n          if (calculationMode === _Constants2.default.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING && lastChunkWasFinished) {\n            // Parse the payload and capture the the 'moof' box\n            var _boxesInfo = boxParser.findLastTopIsoBoxCompleted(['moof'], remaining, offset);\n\n            if (_boxesInfo.found) {\n              // Store the beginning time of each chunk download in array StartTimeData\n              lastChunkWasFinished = false;\n              startTimeData.push({\n                ts: performance.now(),\n\n                /* jshint ignore:line */\n                bytes: value.length\n              });\n            }\n          }\n\n          var boxesInfo = boxParser.findLastTopIsoBoxCompleted(['moov', 'mdat'], remaining, offset);\n\n          if (boxesInfo.found) {\n            var end = boxesInfo.lastCompletedOffset + boxesInfo.size; // Store the end time of each chunk download  with its size in array EndTimeData\n\n            if (calculationMode === _Constants2.default.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING) {\n              lastChunkWasFinished = true;\n              endTimeData.push({\n                ts: performance.now(),\n\n                /* jshint ignore:line */\n                bytes: remaining.length\n              });\n            } // If we are going to pass full buffer, avoid copying it and pass\n            // complete buffer. Otherwise clone the part of the buffer that is completed\n            // and adjust remaining buffer. A clone is needed because ArrayBuffer of a typed-array\n            // keeps a reference to the original data\n\n\n            var data = void 0;\n\n            if (end === remaining.length) {\n              data = remaining;\n              remaining = new Uint8Array();\n            } else {\n              data = new Uint8Array(remaining.subarray(0, end));\n              remaining = remaining.subarray(end);\n            } // Announce progress but don't track traces. Throughput measures are quite unstable\n            // when they are based in small amount of data\n\n\n            httpRequest.progress({\n              data: data.buffer,\n              lengthComputable: false,\n              noTrace: true\n            });\n            offset = 0;\n          } else {\n            offset = boxesInfo.lastCompletedOffset; // Call progress so it generates traces that will be later used to know when the first byte\n            // were received\n\n            if (!signaledFirstByte) {\n              httpRequest.progress({\n                lengthComputable: false,\n                noTrace: true\n              });\n              signaledFirstByte = true;\n            }\n          }\n        }\n\n        read(httpRequest, processResult);\n      };\n\n      read(httpRequest, processResult);\n    }).catch(function (e) {\n      if (httpRequest.onerror) {\n        httpRequest.onerror(e);\n      }\n    });\n  }\n\n  function read(httpRequest, processResult) {\n    httpRequest.reader.read().then(processResult).catch(function (e) {\n      if (httpRequest.onerror && httpRequest.response.status === 200) {\n        // Error, but response code is 200, trigger error\n        httpRequest.onerror(e);\n      }\n    });\n  }\n\n  function concatTypedArray(remaining, data) {\n    if (remaining.length === 0) {\n      return data;\n    }\n\n    var result = new Uint8Array(remaining.length + data.length);\n    result.set(remaining);\n    result.set(data, remaining.length);\n    return result;\n  }\n\n  function abort(request) {\n    if (request.abortController) {\n      // For firefox and edge\n      request.abortController.abort();\n    } else if (request.reader) {\n      // For Chrome\n      try {\n        request.reader.cancel();\n        request.onabort();\n      } catch (e) {// throw exceptions (TypeError) when reader was previously closed,\n        // for example, because a network issue\n      }\n    }\n  } // Compute the download time of a segment\n\n\n  function calculateDownloadedTime(calculationMode, startTimeData, endTimeData, downloadedData, bytesReceived) {\n    switch (calculationMode) {\n      case _Constants2.default.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING:\n        return _calculateDownloadedTimeByMoofParsing(startTimeData, endTimeData);\n\n      case _Constants2.default.ABR_FETCH_THROUGHPUT_CALCULATION_DOWNLOADED_DATA:\n        return _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived);\n\n      default:\n        return _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived);\n    }\n  }\n\n  function _calculateDownloadedTimeByMoofParsing(startTimeData, endTimeData) {\n    try {\n      var datum = void 0,\n          datumE = void 0; // Filter the first and last chunks in a segment in both arrays [StartTimeData and EndTimeData]\n\n      datum = startTimeData.filter(function (data, i) {\n        return i > 0 && i < startTimeData.length - 1;\n      });\n      datumE = endTimeData.filter(function (dataE, i) {\n        return i > 0 && i < endTimeData.length - 1;\n      }); // Compute the download time of a segment based on the filtered data [last chunk end time - first chunk beginning time]\n\n      var segDownloadTime = 0;\n\n      if (datum.length > 1) {\n        for (var i = 0; i < datum.length; i++) {\n          if (datum[i] && datumE[i]) {\n            var chunkDownladTime = datumE[i].ts - datum[i].ts;\n            segDownloadTime += chunkDownladTime;\n          }\n        }\n\n        return segDownloadTime;\n      }\n\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived) {\n    try {\n      downloadedData = downloadedData.filter(function (data) {\n        return data.bytes > bytesReceived / 4 / downloadedData.length;\n      });\n\n      if (downloadedData.length > 1) {\n        var time = 0;\n        var avgTimeDistance = (downloadedData[downloadedData.length - 1].ts - downloadedData[0].ts) / downloadedData.length;\n        downloadedData.forEach(function (data, index) {\n          // To be counted the data has to be over a threshold\n          var next = downloadedData[index + 1];\n\n          if (next) {\n            var distance = next.ts - data.ts;\n            time += distance < avgTimeDistance ? distance : 0;\n          }\n        });\n        return time;\n      }\n\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  instance = {\n    load: load,\n    abort: abort,\n    calculateDownloadedTime: calculateDownloadedTime\n  };\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nFetchLoader.__dashjs_factory_name = 'FetchLoader';\n\nvar factory = _FactoryMaker2.default.getClassFactory(FetchLoader);\n\nexports.default = factory;","map":{"version":3,"mappings":";;;;;;AA+BA;;;;AACA;;;;AACA;;;;;;;;AAEA;AAAA;;;;;;;;AAMA,SAASA,WAAT,CAAqBC,GAArB,EAA0B;EAEtBA,MAAMA,OAAO,EAAbA;EACA,IAAMC,UAAU,KAAKA,OAArB;EACA,IAAMC,kBAAkBF,IAAIE,eAA5B;EACA,IAAMC,YAAYH,IAAIG,SAAtB;EACA,IAAMC,WAAW,wBAASH,OAAT,EAAkBI,WAAlB,EAAjB;EACA,IAAIC,iBAAJ;;EAEA,SAASC,IAAT,CAAcC,WAAd,EAA2B;IAEvB;IACA,IAAMC,mBAAmB,IAAIC,IAAJ,EAAzB;IACA,IAAMC,UAAUH,YAAYG,OAA5B;IAEA,IAAMC,UAAU,IAAIC,OAAJ,EAAhB;IAA+B;;IAC/B,IAAIF,QAAQG,KAAZ,EAAmB;MACfF,QAAQG,MAARH,CAAe,OAAfA,EAAwB,WAAWD,QAAQG,KAA3CF;IAGJ;;IAAA,IAAIJ,YAAYI,OAAhB,EAAyB;MACrB,KAAK,IAAII,MAAT,IAAmBR,YAAYI,OAA/B,EAAwC;QACpC,IAAIK,QAAQT,YAAYI,OAAZJ,CAAoBQ,MAApBR,CAAZ;;QACA,IAAIS,KAAJ,EAAW;UACPL,QAAQG,MAARH,CAAeI,MAAfJ,EAAuBK,KAAvBL;QAEP;MACJ;IAED;;IAAA,IAAI,CAACD,QAAQO,gBAAb,EAA+B;MAC3BP,QAAQO,gBAARP,GAA2BF,gBAA3BE;IAGJ;;IAAA,IAAIT,eAAJ,EAAqB;MACjB;MACA;MACA;MACA;MACAA,gBAAgBiB,mBAAhBjB,CAAoC;QAChCkB,kBAAkB,0BAAUJ,MAAV,EAAkBC,KAAlB,EAAyB;UACvCL,QAAQG,MAARH,CAAeI,MAAfJ,EAAuBK,KAAvBL;QAF4B;MAAA,CAApCV;IAOJ;;IAAA,IAAImB,wBAAJ;;IACA,IAAI,OAAOC,OAAOC,eAAd,KAAkC,UAAtC,EAAkD;MAC9CF,kBAAkB,IAAIE,eAAJ,EAAlBF;MAAyC;;MACzCb,YAAYa,eAAZb,GAA8Ba,eAA9Bb;MACAa,gBAAgBG,MAAhBH,CAAuBI,OAAvBJ,GAAiCb,YAAYiB,OAA7CJ;IAGJ;;IAAA,IAAMK,aAAa;MACfC,QAAQnB,YAAYmB,MADL;MAEff,SAASA,OAFM;MAGfgB,aAAapB,YAAYqB,eAAZrB,GAA8B,SAA9BA,GAA0CsB,SAHxC;MAIfN,QAAQH,kBAAkBA,gBAAgBG,MAAlCH,GAA2CS;IAJpC,CAAnB;IAOAC,MAAMvB,YAAYwB,GAAlBD,EAAuBL,UAAvBK,EAAmCE,IAAnCF,CAAwC,UAAUG,QAAV,EAAoB;MACxD,IAAI,CAAC1B,YAAY0B,QAAjB,EAA2B;QACvB1B,YAAY0B,QAAZ1B,GAAuB,EAAvBA;MAEJA;;MAAAA,YAAY0B,QAAZ1B,CAAqB2B,MAArB3B,GAA8B0B,SAASC,MAAvC3B;MACAA,YAAY0B,QAAZ1B,CAAqB4B,UAArB5B,GAAkC0B,SAASE,UAA3C5B;MACAA,YAAY0B,QAAZ1B,CAAqB6B,WAArB7B,GAAmC0B,SAASF,GAA5CxB;;MAEA,IAAI,CAAC0B,SAASI,EAAd,EAAkB;QACd9B,YAAY+B,OAAZ/B;MAGJ;;MAAA,IAAIgC,kBAAkB,EAAtB;MAZwD;MAAA;MAAA;;MAAA;QAaxD,qBAAkBN,SAAStB,OAATsB,CAAiBO,IAAjBP,GAAlBQ,eAAkBR,GAAlB,2GAA2C;UAAA,IAAhCS,GAAgC;UACvCH,mBAAmBG,MAAM,IAANA,GAAaT,SAAStB,OAATsB,CAAiBU,GAAjBV,CAAqBS,GAArBT,CAAbS,GAAyC,MAA5DH;QAdoD;MAAA;QAAAK;QAAAC;MAAA;QAAA;UAAA;YAAAC;UAAA;QAAA;UAAA;YAAA;UAAA;QAAA;MAgBxDvC;;MAAAA,YAAY0B,QAAZ1B,CAAqBgC,eAArBhC,GAAuCgC,eAAvChC;;MAEA,IAAI,CAAC0B,SAASc,IAAd,EAAoB;QAChB;QACA;QACA;QACA,OAAOd,SAASe,WAATf,GAAuBD,IAAvBC,CAA4B,UAAUgB,MAAV,EAAkB;UACjD1C,YAAY0B,QAAZ1B,CAAqB0B,QAArB1B,GAAgC0C,MAAhC1C;UACA,IAAM2C,QAAQ;YACVC,QAAQF,OAAOG,UADL;YAEVC,OAAOJ,OAAOG,UAFJ;YAGVE,QAAQ;UAHE,CAAd;UAKA/C,YAAYgD,QAAZhD,CAAqB2C,KAArB3C;UACAA,YAAYiD,MAAZjD;UACAA,YAAYkD,KAAZlD;UACA;QAVG,EAAP;MAcJ;;MAAA,IAAMmD,aAAaC,SAAS1B,SAAStB,OAATsB,CAAiBU,GAAjBV,CAAqB,gBAArBA,CAAT0B,EAAiD,EAAjDA,CAAnB;MACA,IAAIC,gBAAgB,CAApB;MACA,IAAIC,oBAAoB,KAAxB;MACA,IAAIC,YAAY,IAAIC,UAAJ,EAAhB;MACA,IAAIC,SAAS,CAAb;MAEAzD,YAAY0D,MAAZ1D,GAAqB0B,SAASc,IAATd,CAAciC,SAAdjC,EAArB1B;MACA,IAAI4D,iBAAiB,EAArB;MACA,IAAIC,gBAAgB,EAApB;MACA,IAAIC,cAAc,EAAlB;MACA,IAAIC,uBAAuB,IAA3B;MACA,IAAMC,kBAAkBpE,SAASwC,GAATxC,GAAeqE,SAAfrE,CAAyBsE,GAAzBtE,CAA6BuE,8BAArD;;MAEA,IAAMC,gBAAgB,SAAhBA,aAAgB,OAA2B;QAAA,IAAf3D,KAAe,QAAfA,KAAe;QAAA,IAAR4D,IAAQ,QAARA,IAAQ,EAAE;;QAC/C,IAAIA,IAAJ,EAAU;UACN,IAAId,SAAJ,EAAe;YACX;YACA;YACA;YACAvD,YAAYgD,QAAZhD,CAAqB;cACjB4C,QAAQS,aADS;cAEjBP,OAAOwB,MAAMnB,UAANmB,IAAoBjB,aAApBiB,GAAoCnB,UAF1B;cAGjBoB,kBAAkB,IAHD;cAIjBC,MAAMC,wBAAwBT,eAAxBS,EAAyCZ,aAAzCY,EAAwDX,WAAxDW,EAAqEb,cAArEa,EAAqFpB,aAArFoB,CAJW;cAKjB1B,QAAQ;YALS,CAArB/C;YAQAA,YAAY0B,QAAZ1B,CAAqB0B,QAArB1B,GAAgCuD,UAAUb,MAA1C1C;UAEJA;;UAAAA,YAAYiD,MAAZjD;UACAA,YAAYkD,KAAZlD;UACA;QAGJ;;QAAA,IAAIS,SAASA,MAAMiE,MAANjE,GAAe,CAA5B,EAA+B;UAC3B8C,YAAYoB,iBAAiBpB,SAAjBoB,EAA4BlE,KAA5BkE,CAAZpB;UACAF,iBAAiB5C,MAAMiE,MAAvBrB;UAEAO,eAAegB,IAAfhB,CAAoB;YAChBiB,IAAI3E,KAAK4E,GAAL5E,EADY;YAEhB6E,OAAOtE,MAAMiE;UAFG,CAApBd;;UAKA,IAAII,oBAAoBgB,oBAAUC,6CAA9BjB,IAA+ED,oBAAnF,EAAyG;YACrG;YACA,IAAMmB,aAAYvF,UAAUwF,0BAAVxF,CAAqC,CAAC,MAAD,CAArCA,EAA+C4D,SAA/C5D,EAA0D8D,MAA1D9D,CAAlB;;YACA,IAAIuF,WAAUE,KAAd,EAAqB;cACjB;cACArB,uBAAuB,KAAvBA;cACAF,cAAce,IAAdf,CAAmB;gBACfgB,IAAIQ,YAAYP,GAAZO,EADW;;gBACQ;gBACvBN,OAAOtE,MAAMiE;cAFE,CAAnBb;YAKP;UAED;;UAAA,IAAMqB,YAAYvF,UAAUwF,0BAAVxF,CAAqC,CAAC,MAAD,EAAS,MAAT,CAArCA,EAAuD4D,SAAvD5D,EAAkE8D,MAAlE9D,CAAlB;;UACA,IAAIuF,UAAUE,KAAd,EAAqB;YACjB,IAAME,MAAMJ,UAAUK,mBAAVL,GAAgCA,UAAUM,IAAtD,CADiB,CAGjB;;YACA,IAAIxB,oBAAoBgB,oBAAUC,6CAAlC,EAAiF;cAC7ElB,uBAAuB,IAAvBA;cACAD,YAAYc,IAAZd,CAAiB;gBACbe,IAAIQ,YAAYP,GAAZO,EADS;;gBACU;gBACvBN,OAAOxB,UAAUmB;cAFJ,CAAjBZ;YAMJ,CAZiB,CAYjB;YACA;YACA;YACA;;;YACA,IAAI2B,aAAJ;;YACA,IAAIH,QAAQ/B,UAAUmB,MAAtB,EAA8B;cAC1Be,OAAOlC,SAAPkC;cACAlC,YAAY,IAAIC,UAAJ,EAAZD;YAFJ,OAGO;cACHkC,OAAO,IAAIjC,UAAJ,CAAeD,UAAUmC,QAAVnC,CAAmB,CAAnBA,EAAsB+B,GAAtB/B,CAAf,CAAPkC;cACAlC,YAAYA,UAAUmC,QAAVnC,CAAmB+B,GAAnB/B,CAAZA;YAEJ,CAxBiB,CAwBjB;YACA;;;YACAvD,YAAYgD,QAAZhD,CAAqB;cACjByF,MAAMA,KAAK/C,MADM;cAEjB6B,kBAAkB,KAFD;cAGjBoB,SAAS;YAHQ,CAArB3F;YAMAyD,SAAS,CAATA;UAhCJ,OAiCO;YACHA,SAASyB,UAAUK,mBAAnB9B,CADG,CAEH;YACA;;YACA,IAAI,CAACH,iBAAL,EAAwB;cACpBtD,YAAYgD,QAAZhD,CAAqB;gBACjBuE,kBAAkB,KADD;gBAEjBoB,SAAS;cAFQ,CAArB3F;cAIAsD,oBAAoB,IAApBA;YAEP;UACJ;QACDsC;;QAAAA,KAAK5F,WAAL4F,EAAkBxB,aAAlBwB;MA1FJ;;MA4FAA,KAAK5F,WAAL4F,EAAkBxB,aAAlBwB;IA7IJ,GA+IKC,KA/ILtE,CA+IW,UAAUuE,CAAV,EAAa;MAChB,IAAI9F,YAAY+B,OAAhB,EAAyB;QACrB/B,YAAY+B,OAAZ/B,CAAoB8F,CAApB9F;MAEP;IAnJL;EAsJJ;;EAAA,SAAS4F,IAAT,CAAc5F,WAAd,EAA2BoE,aAA3B,EAA0C;IACtCpE,YAAY0D,MAAZ1D,CAAmB4F,IAAnB5F,GACKyB,IADLzB,CACUoE,aADVpE,EAEK6F,KAFL7F,CAEW,UAAU8F,CAAV,EAAa;MAChB,IAAI9F,YAAY+B,OAAZ/B,IAAuBA,YAAY0B,QAAZ1B,CAAqB2B,MAArB3B,KAAgC,GAA3D,EAAgE;QAC5D;QACAA,YAAY+B,OAAZ/B,CAAoB8F,CAApB9F;MAEP;IAPL;EAUJ;;EAAA,SAAS2E,gBAAT,CAA0BpB,SAA1B,EAAqCkC,IAArC,EAA2C;IACvC,IAAIlC,UAAUmB,MAAVnB,KAAqB,CAAzB,EAA4B;MACxB,OAAOkC,IAAP;IAEJ;;IAAA,IAAMM,SAAS,IAAIvC,UAAJ,CAAeD,UAAUmB,MAAVnB,GAAmBkC,KAAKf,MAAvC,CAAf;IACAqB,OAAOC,GAAPD,CAAWxC,SAAXwC;IACAA,OAAOC,GAAPD,CAAWN,IAAXM,EAAiBxC,UAAUmB,MAA3BqB;IACA,OAAOA,MAAP;EAGJ;;EAAA,SAASE,KAAT,CAAe9F,OAAf,EAAwB;IACpB,IAAIA,QAAQU,eAAZ,EAA6B;MACzB;MACAV,QAAQU,eAARV,CAAwB8F,KAAxB9F;IAFJ,OAGO,IAAIA,QAAQuD,MAAZ,EAAoB;MACvB;MACA,IAAI;QACAvD,QAAQuD,MAARvD,CAAe+F,MAAf/F;QACAA,QAAQc,OAARd;MACF,CAHF,CAGE,OAAO2F,CAAP,EAAU,CACR;QACA;MAEP;IACJ;EAED,CAtPsB,CAsPtB;;;EACA,SAASrB,uBAAT,CAAiCT,eAAjC,EAAkDH,aAAlD,EAAiEC,WAAjE,EAA8EF,cAA9E,EAA8FP,aAA9F,EAA6G;IACzG,QAAQW,eAAR;MACI,KAAKgB,oBAAUC,6CAAf;QACI,OAAOkB,sCAAsCtC,aAAtCsC,EAAqDrC,WAArDqC,CAAP;;MACJ,KAAKnB,oBAAUoB,gDAAf;QACI,OAAOC,wCAAwCzC,cAAxCyC,EAAwDhD,aAAxDgD,CAAP;;MACJ;QACI,OAAOA,wCAAwCzC,cAAxCyC,EAAwDhD,aAAxDgD,CAAP;IANR;EAUJ;;EAAA,SAASF,qCAAT,CAA+CtC,aAA/C,EAA8DC,WAA9D,EAA2E;IACvE,IAAI;MACA,IAAIwC,cAAJ;MAAA,IAAWC,eAAX,CADA,CAEA;;MACAD,QAAQzC,cAAc2C,MAAd3C,CAAqB,UAAC4B,IAAD,EAAOgB,CAAP;QAAA,OAAaA,IAAI,CAAJA,IAASA,IAAI5C,cAAca,MAAdb,GAAuB,CAAjD;MAArB,EAARyC;MACAC,SAASzC,YAAY0C,MAAZ1C,CAAmB,UAAC4C,KAAD,EAAQD,CAAR;QAAA,OAAcA,IAAI,CAAJA,IAASA,IAAI3C,YAAYY,MAAZZ,GAAqB,CAAhD;MAAnB,EAATyC,CAJA,CAKA;;MACA,IAAII,kBAAkB,CAAtB;;MACA,IAAIL,MAAM5B,MAAN4B,GAAe,CAAnB,EAAsB;QAClB,KAAK,IAAIG,IAAI,CAAb,EAAgBA,IAAIH,MAAM5B,MAA1B,EAAkC+B,GAAlC,EAAuC;UACnC,IAAIH,MAAMG,CAANH,KAAYC,OAAOE,CAAPF,CAAhB,EAA2B;YACvB,IAAIK,mBAAmBL,OAAOE,CAAPF,EAAU1B,EAAV0B,GAAeD,MAAMG,CAANH,EAASzB,EAA/C;YACA8B,mBAAmBC,gBAAnBD;UAEP;QAED;;QAAA,OAAOA,eAAP;MAEJ;;MAAA,OAAO,IAAP;IACF,CAlBF,CAkBE,OAAOb,CAAP,EAAU;MACR,OAAO,IAAP;IAEP;EAED;;EAAA,SAASO,uCAAT,CAAiDzC,cAAjD,EAAiEP,aAAjE,EAAgF;IAC5E,IAAI;MACAO,iBAAiBA,eAAe4C,MAAf5C,CAAsB;QAAA,OAAQ6B,KAAKV,KAALU,GAAepC,gBAAgB,CAAhBA,GAAqBO,eAAec,MAA3D;MAAtB,EAAjBd;;MACA,IAAIA,eAAec,MAAfd,GAAwB,CAA5B,EAA+B;QAC3B,IAAIY,OAAO,CAAX;QACA,IAAMqC,kBAAkB,CAACjD,eAAeA,eAAec,MAAfd,GAAwB,CAAvCA,EAA0CiB,EAA1CjB,GAA+CA,eAAe,CAAfA,EAAkBiB,EAAlE,IAAwEjB,eAAec,MAA/G;QACAd,eAAekD,OAAflD,CAAuB,UAAC6B,IAAD,EAAOsB,KAAP,EAAiB;UACpC;UACA,IAAMC,OAAOpD,eAAemD,QAAQ,CAAvBnD,CAAb;;UACA,IAAIoD,IAAJ,EAAU;YACN,IAAMC,WAAWD,KAAKnC,EAALmC,GAAUvB,KAAKZ,EAAhC;YACAL,QAAQyC,WAAWJ,eAAXI,GAA6BA,QAA7BA,GAAwC,CAAhDzC;UAEP;QAPD;QAQA,OAAOA,IAAP;MAEJ;;MAAA,OAAO,IAAP;IACF,CAhBF,CAgBE,OAAOsB,CAAP,EAAU;MACR,OAAO,IAAP;IAEP;EAEDhG;;EAAAA,WAAW;IACPC,MAAMA,IADC;IAEPkG,OAAOA,KAFA;IAGPxB,yBAAyBA;EAHlB,CAAX3E;EAMA,OAAOA,QAAP;AA/VJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkWAP,YAAY2H,qBAAZ3H,GAAoC,aAApCA;;AAEA,IAAM4H,UAAUC,uBAAaC,eAAbD,CAA6B7H,WAA7B6H,CAAhB;;kBACeD,O","names":["FetchLoader","cfg","context","requestModifier","boxParser","settings","getInstance","instance","load","httpRequest","requestStartTime","Date","request","headers","Headers","range","append","header","value","requestStartDate","modifyRequestHeader","setRequestHeader","abortController","window","AbortController","signal","onabort","reqOptions","method","credentials","withCredentials","undefined","fetch","url","then","response","status","statusText","responseURL","ok","onerror","responseHeaders","keys","Symbol","key","get","_didIteratorError","_iteratorError","_iterator","body","arrayBuffer","buffer","event","loaded","byteLength","total","stream","progress","onload","onend","totalBytes","parseInt","bytesReceived","signaledFirstByte","remaining","Uint8Array","offset","reader","getReader","downloadedData","startTimeData","endTimeData","lastChunkWasFinished","calculationMode","streaming","abr","fetchThroughputCalculationMode","processResult","done","isNaN","lengthComputable","time","calculateDownloadedTime","length","concatTypedArray","push","ts","now","bytes","Constants","ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING","boxesInfo","findLastTopIsoBoxCompleted","found","performance","end","lastCompletedOffset","size","data","subarray","noTrace","read","catch","e","result","set","abort","cancel","_calculateDownloadedTimeByMoofParsing","ABR_FETCH_THROUGHPUT_CALCULATION_DOWNLOADED_DATA","_calculateDownloadedTimeByBytesReceived","datum","datumE","filter","i","dataE","segDownloadTime","chunkDownladTime","avgTimeDistance","forEach","index","next","distance","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/net/FetchLoader.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Settings from '../../core/Settings';\nimport Constants from '../constants/Constants';\n\n/**\n * @module FetchLoader\n * @ignore\n * @description Manages download of resources via HTTP using fetch.\n * @param {Object} cfg - dependencies from parent\n */\nfunction FetchLoader(cfg) {\n\n    cfg = cfg || {};\n    const context = this.context;\n    const requestModifier = cfg.requestModifier;\n    const boxParser = cfg.boxParser;\n    const settings = Settings(context).getInstance();\n    let instance;\n\n    function load(httpRequest) {\n\n        // Variables will be used in the callback functions\n        const requestStartTime = new Date();\n        const request = httpRequest.request;\n\n        const headers = new Headers(); /*jshint ignore:line*/\n        if (request.range) {\n            headers.append('Range', 'bytes=' + request.range);\n        }\n\n        if (httpRequest.headers) {\n            for (let header in httpRequest.headers) {\n                let value = httpRequest.headers[header];\n                if (value) {\n                    headers.append(header, value);\n                }\n            }\n        }\n\n        if (!request.requestStartDate) {\n            request.requestStartDate = requestStartTime;\n        }\n\n        if (requestModifier) {\n            // modifyRequestHeader expects a XMLHttpRequest object so,\n            // to keep backward compatibility, we should expose a setRequestHeader method\n            // TODO: Remove RequestModifier dependency on XMLHttpRequest object and define\n            // a more generic way to intercept/modify requests\n            requestModifier.modifyRequestHeader({\n                setRequestHeader: function (header, value) {\n                    headers.append(header, value);\n                }\n            });\n        }\n\n        let abortController;\n        if (typeof window.AbortController === 'function') {\n            abortController = new AbortController(); /*jshint ignore:line*/\n            httpRequest.abortController = abortController;\n            abortController.signal.onabort = httpRequest.onabort;\n        }\n\n        const reqOptions = {\n            method: httpRequest.method,\n            headers: headers,\n            credentials: httpRequest.withCredentials ? 'include' : undefined,\n            signal: abortController ? abortController.signal : undefined\n        };\n\n        fetch(httpRequest.url, reqOptions).then(function (response) {\n            if (!httpRequest.response) {\n                httpRequest.response = {};\n            }\n            httpRequest.response.status = response.status;\n            httpRequest.response.statusText = response.statusText;\n            httpRequest.response.responseURL = response.url;\n\n            if (!response.ok) {\n                httpRequest.onerror();\n            }\n\n            let responseHeaders = '';\n            for (const key of response.headers.keys()) {\n                responseHeaders += key + ': ' + response.headers.get(key) + '\\r\\n';\n            }\n            httpRequest.response.responseHeaders = responseHeaders;\n\n            if (!response.body) {\n                // Fetch returning a ReadableStream response body is not currently supported by all browsers.\n                // Browser compatibility: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n                // If it is not supported, returning the whole segment when it's ready (as xhr)\n                return response.arrayBuffer().then(function (buffer) {\n                    httpRequest.response.response = buffer;\n                    const event = {\n                        loaded: buffer.byteLength,\n                        total: buffer.byteLength,\n                        stream: false\n                    };\n                    httpRequest.progress(event);\n                    httpRequest.onload();\n                    httpRequest.onend();\n                    return;\n                });\n            }\n\n            const totalBytes = parseInt(response.headers.get('Content-Length'), 10);\n            let bytesReceived = 0;\n            let signaledFirstByte = false;\n            let remaining = new Uint8Array();\n            let offset = 0;\n\n            httpRequest.reader = response.body.getReader();\n            let downloadedData = [];\n            let startTimeData = [];\n            let endTimeData = [];\n            let lastChunkWasFinished = true;\n            const calculationMode = settings.get().streaming.abr.fetchThroughputCalculationMode;\n\n            const processResult = function ({ value, done }) { // Bug fix Parse whenever data is coming [value] better than 1ms looking that increase CPU\n                if (done) {\n                    if (remaining) {\n                        // If there is pending data, call progress so network metrics\n                        // are correctly generated\n                        // Same structure as https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/\n                        httpRequest.progress({\n                            loaded: bytesReceived,\n                            total: isNaN(totalBytes) ? bytesReceived : totalBytes,\n                            lengthComputable: true,\n                            time: calculateDownloadedTime(calculationMode, startTimeData, endTimeData, downloadedData, bytesReceived),\n                            stream: true\n                        });\n\n                        httpRequest.response.response = remaining.buffer;\n                    }\n                    httpRequest.onload();\n                    httpRequest.onend();\n                    return;\n                }\n\n                if (value && value.length > 0) {\n                    remaining = concatTypedArray(remaining, value);\n                    bytesReceived += value.length;\n\n                    downloadedData.push({\n                        ts: Date.now(),\n                        bytes: value.length\n                    });\n\n                    if (calculationMode === Constants.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING && lastChunkWasFinished) {\n                        // Parse the payload and capture the the 'moof' box\n                        const boxesInfo = boxParser.findLastTopIsoBoxCompleted(['moof'], remaining, offset);\n                        if (boxesInfo.found) {\n                            // Store the beginning time of each chunk download in array StartTimeData\n                            lastChunkWasFinished = false;\n                            startTimeData.push({\n                                ts: performance.now(), /* jshint ignore:line */\n                                bytes: value.length\n                            });\n                        }\n                    }\n\n                    const boxesInfo = boxParser.findLastTopIsoBoxCompleted(['moov', 'mdat'], remaining, offset);\n                    if (boxesInfo.found) {\n                        const end = boxesInfo.lastCompletedOffset + boxesInfo.size;\n\n                        // Store the end time of each chunk download  with its size in array EndTimeData\n                        if (calculationMode === Constants.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING) {\n                            lastChunkWasFinished = true;\n                            endTimeData.push({\n                                ts: performance.now(), /* jshint ignore:line */\n                                bytes: remaining.length\n                            });\n                        }\n\n                        // If we are going to pass full buffer, avoid copying it and pass\n                        // complete buffer. Otherwise clone the part of the buffer that is completed\n                        // and adjust remaining buffer. A clone is needed because ArrayBuffer of a typed-array\n                        // keeps a reference to the original data\n                        let data;\n                        if (end === remaining.length) {\n                            data = remaining;\n                            remaining = new Uint8Array();\n                        } else {\n                            data = new Uint8Array(remaining.subarray(0, end));\n                            remaining = remaining.subarray(end);\n                        }\n                        // Announce progress but don't track traces. Throughput measures are quite unstable\n                        // when they are based in small amount of data\n                        httpRequest.progress({\n                            data: data.buffer,\n                            lengthComputable: false,\n                            noTrace: true\n                        });\n\n                        offset = 0;\n                    } else {\n                        offset = boxesInfo.lastCompletedOffset;\n                        // Call progress so it generates traces that will be later used to know when the first byte\n                        // were received\n                        if (!signaledFirstByte) {\n                            httpRequest.progress({\n                                lengthComputable: false,\n                                noTrace: true\n                            });\n                            signaledFirstByte = true;\n                        }\n                    }\n                }\n                read(httpRequest, processResult);\n            };\n            read(httpRequest, processResult);\n        })\n            .catch(function (e) {\n                if (httpRequest.onerror) {\n                    httpRequest.onerror(e);\n                }\n            });\n    }\n\n    function read(httpRequest, processResult) {\n        httpRequest.reader.read()\n            .then(processResult)\n            .catch(function (e) {\n                if (httpRequest.onerror && httpRequest.response.status === 200) {\n                    // Error, but response code is 200, trigger error\n                    httpRequest.onerror(e);\n                }\n            });\n    }\n\n    function concatTypedArray(remaining, data) {\n        if (remaining.length === 0) {\n            return data;\n        }\n        const result = new Uint8Array(remaining.length + data.length);\n        result.set(remaining);\n        result.set(data, remaining.length);\n        return result;\n    }\n\n    function abort(request) {\n        if (request.abortController) {\n            // For firefox and edge\n            request.abortController.abort();\n        } else if (request.reader) {\n            // For Chrome\n            try {\n                request.reader.cancel();\n                request.onabort();\n            } catch (e) {\n                // throw exceptions (TypeError) when reader was previously closed,\n                // for example, because a network issue\n            }\n        }\n    }\n\n    // Compute the download time of a segment\n    function calculateDownloadedTime(calculationMode, startTimeData, endTimeData, downloadedData, bytesReceived) {\n        switch (calculationMode) {\n            case Constants.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING:\n                return _calculateDownloadedTimeByMoofParsing(startTimeData, endTimeData);\n            case Constants.ABR_FETCH_THROUGHPUT_CALCULATION_DOWNLOADED_DATA:\n                return _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived);\n            default:\n                return _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived);\n        }\n    }\n\n    function _calculateDownloadedTimeByMoofParsing(startTimeData, endTimeData) {\n        try {\n            let datum, datumE;\n            // Filter the first and last chunks in a segment in both arrays [StartTimeData and EndTimeData]\n            datum = startTimeData.filter((data, i) => i > 0 && i < startTimeData.length - 1);\n            datumE = endTimeData.filter((dataE, i) => i > 0 && i < endTimeData.length - 1);\n            // Compute the download time of a segment based on the filtered data [last chunk end time - first chunk beginning time]\n            let segDownloadTime = 0;\n            if (datum.length > 1) {\n                for (let i = 0; i < datum.length; i++) {\n                    if (datum[i] && datumE[i]) {\n                        let chunkDownladTime = datumE[i].ts - datum[i].ts;\n                        segDownloadTime += chunkDownladTime;\n                    }\n                }\n\n                return segDownloadTime;\n            }\n            return null;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    function _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived) {\n        try {\n            downloadedData = downloadedData.filter(data => data.bytes > ((bytesReceived / 4) / downloadedData.length));\n            if (downloadedData.length > 1) {\n                let time = 0;\n                const avgTimeDistance = (downloadedData[downloadedData.length - 1].ts - downloadedData[0].ts) / downloadedData.length;\n                downloadedData.forEach((data, index) => {\n                    // To be counted the data has to be over a threshold\n                    const next = downloadedData[index + 1];\n                    if (next) {\n                        const distance = next.ts - data.ts;\n                        time += distance < avgTimeDistance ? distance : 0;\n                    }\n                });\n                return time;\n            }\n            return null;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    instance = {\n        load: load,\n        abort: abort,\n        calculateDownloadedTime: calculateDownloadedTime\n    };\n\n    return instance;\n}\n\nFetchLoader.__dashjs_factory_name = 'FetchLoader';\n\nconst factory = FactoryMaker.getClassFactory(FetchLoader);\nexport default factory;\n\n"]},"metadata":{},"sourceType":"script"}