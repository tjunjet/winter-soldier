{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EBMLParser = require('../streaming/utils/EBMLParser');\n\nvar _EBMLParser2 = _interopRequireDefault(_EBMLParser);\n\nvar _Constants = require('../streaming/constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Segment = require('./vo/Segment');\n\nvar _Segment2 = _interopRequireDefault(_Segment);\n\nvar _FragmentRequest = require('../streaming/vo/FragmentRequest');\n\nvar _FragmentRequest2 = _interopRequireDefault(_FragmentRequest);\n\nvar _URLLoader = require('../streaming/net/URLLoader');\n\nvar _URLLoader2 = _interopRequireDefault(_URLLoader);\n\nvar _DashJSError = require('../streaming/vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction WebmSegmentBaseLoader() {\n  var context = this.context;\n  var instance = void 0,\n      logger = void 0,\n      WebM = void 0,\n      errHandler = void 0,\n      requestModifier = void 0,\n      dashMetrics = void 0,\n      mediaPlayerModel = void 0,\n      urlLoader = void 0,\n      settings = void 0,\n      eventBus = void 0,\n      events = void 0,\n      errors = void 0,\n      baseURLController = void 0;\n\n  function setup() {\n    WebM = {\n      EBML: {\n        tag: 0x1A45DFA3,\n        required: true\n      },\n      Segment: {\n        tag: 0x18538067,\n        required: true,\n        SeekHead: {\n          tag: 0x114D9B74,\n          required: true\n        },\n        Info: {\n          tag: 0x1549A966,\n          required: true,\n          TimecodeScale: {\n            tag: 0x2AD7B1,\n            required: true,\n            parse: 'getMatroskaUint'\n          },\n          Duration: {\n            tag: 0x4489,\n            required: true,\n            parse: 'getMatroskaFloat'\n          }\n        },\n        Tracks: {\n          tag: 0x1654AE6B,\n          required: true\n        },\n        Cues: {\n          tag: 0x1C53BB6B,\n          required: true,\n          CuePoint: {\n            tag: 0xBB,\n            required: true,\n            CueTime: {\n              tag: 0xB3,\n              required: true,\n              parse: 'getMatroskaUint'\n            },\n            CueTrackPositions: {\n              tag: 0xB7,\n              required: true,\n              CueTrack: {\n                tag: 0xF7,\n                required: true,\n                parse: 'getMatroskaUint'\n              },\n              CueClusterPosition: {\n                tag: 0xF1,\n                required: true,\n                parse: 'getMatroskaUint'\n              }\n            }\n          }\n        }\n      },\n      Void: {\n        tag: 0xEC,\n        required: true\n      }\n    };\n  }\n\n  function initialize() {\n    urlLoader = (0, _URLLoader2.default)(context).create({\n      errHandler: errHandler,\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      requestModifier: requestModifier,\n      useFetch: settings ? settings.get().streaming.lowLatencyEnabled : null,\n      errors: errors\n    });\n  }\n\n  function setConfig(config) {\n    if (!config.baseURLController || !config.dashMetrics || !config.mediaPlayerModel || !config.errHandler) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n\n    baseURLController = config.baseURLController;\n    dashMetrics = config.dashMetrics;\n    mediaPlayerModel = config.mediaPlayerModel;\n    errHandler = config.errHandler;\n    settings = config.settings;\n    events = config.events;\n    eventBus = config.eventBus;\n    errors = config.errors;\n    logger = config.debug.getLogger(instance);\n    requestModifier = config.requestModifier;\n  }\n\n  function parseCues(ab) {\n    var cues = [];\n    var ebmlParser = (0, _EBMLParser2.default)(context).create({\n      data: ab\n    });\n    var cue = void 0,\n        cueTrack = void 0;\n    ebmlParser.consumeTagAndSize(WebM.Segment.Cues);\n\n    while (ebmlParser.moreData() && ebmlParser.consumeTagAndSize(WebM.Segment.Cues.CuePoint, true)) {\n      cue = {};\n      cue.CueTime = ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTime);\n      cue.CueTracks = [];\n\n      while (ebmlParser.moreData() && ebmlParser.consumeTag(WebM.Segment.Cues.CuePoint.CueTrackPositions, true)) {\n        var cueTrackPositionSize = ebmlParser.getMatroskaCodedNum();\n        var startPos = ebmlParser.getPos();\n        cueTrack = {};\n        cueTrack.Track = ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTrackPositions.CueTrack);\n\n        if (cueTrack.Track === 0) {\n          throw new Error('Cue track cannot be 0');\n        }\n\n        cueTrack.ClusterPosition = ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTrackPositions.CueClusterPosition);\n        cue.CueTracks.push(cueTrack); // we're not interested any other elements - skip remaining bytes\n\n        ebmlParser.setPos(startPos + cueTrackPositionSize);\n      }\n\n      if (cue.CueTracks.length === 0) {\n        throw new Error('Mandatory cuetrack not found');\n      }\n\n      cues.push(cue);\n    }\n\n    if (cues.length === 0) {\n      throw new Error('mandatory cuepoint not found');\n    }\n\n    return cues;\n  }\n\n  function parseSegments(data, segmentStart, segmentEnd, segmentDuration) {\n    var duration = void 0,\n        parsed = void 0,\n        segments = void 0,\n        segment = void 0,\n        i = void 0,\n        len = void 0,\n        start = void 0,\n        end = void 0;\n    parsed = parseCues(data);\n    segments = []; // we are assuming one cue track per cue point\n    // both duration and media range require the i + 1 segment\n    // the final segment has to use global segment parameters\n\n    for (i = 0, len = parsed.length; i < len; i += 1) {\n      segment = new _Segment2.default();\n      duration = 0;\n\n      if (i < parsed.length - 1) {\n        duration = parsed[i + 1].CueTime - parsed[i].CueTime;\n      } else {\n        duration = segmentDuration - parsed[i].CueTime;\n      } // note that we don't explicitly set segment.media as this will be\n      // computed when all BaseURLs are resolved later\n\n\n      segment.duration = duration;\n      segment.startTime = parsed[i].CueTime;\n      segment.timescale = 1000; // hardcoded for ms\n\n      start = parsed[i].CueTracks[0].ClusterPosition + segmentStart;\n\n      if (i < parsed.length - 1) {\n        end = parsed[i + 1].CueTracks[0].ClusterPosition + segmentStart - 1;\n      } else {\n        end = segmentEnd - 1;\n      }\n\n      segment.mediaRange = start + '-' + end;\n      segments.push(segment);\n    }\n\n    logger.debug('Parsed cues: ' + segments.length + ' cues.');\n    return segments;\n  }\n\n  function parseEbmlHeader(data, media, theRange, callback) {\n    if (!data || data.byteLength === 0) {\n      callback(null);\n      return;\n    }\n\n    var ebmlParser = (0, _EBMLParser2.default)(context).create({\n      data: data\n    });\n    var duration = void 0,\n        segments = void 0,\n        segmentEnd = void 0,\n        segmentStart = void 0;\n    var parts = theRange ? theRange.split('-') : null;\n    var request = null;\n    var info = {\n      url: media,\n      range: {\n        start: parts ? parseFloat(parts[0]) : null,\n        end: parts ? parseFloat(parts[1]) : null\n      },\n      request: request\n    };\n    logger.debug('Parse EBML header: ' + info.url); // skip over the header itself\n\n    ebmlParser.skipOverElement(WebM.EBML);\n    ebmlParser.consumeTag(WebM.Segment); // segments start here\n\n    segmentEnd = ebmlParser.getMatroskaCodedNum();\n    segmentEnd += ebmlParser.getPos();\n    segmentStart = ebmlParser.getPos(); // skip over any top level elements to get to the segment info\n\n    while (ebmlParser.moreData() && !ebmlParser.consumeTagAndSize(WebM.Segment.Info, true)) {\n      if (!(ebmlParser.skipOverElement(WebM.Segment.SeekHead, true) || ebmlParser.skipOverElement(WebM.Segment.Tracks, true) || ebmlParser.skipOverElement(WebM.Segment.Cues, true) || ebmlParser.skipOverElement(WebM.Void, true))) {\n        throw new Error('no valid top level element found');\n      }\n    } // we only need one thing in segment info, duration\n\n\n    while (duration === undefined) {\n      var infoTag = ebmlParser.getMatroskaCodedNum(true);\n      var infoElementSize = ebmlParser.getMatroskaCodedNum();\n\n      switch (infoTag) {\n        case WebM.Segment.Info.Duration.tag:\n          duration = ebmlParser[WebM.Segment.Info.Duration.parse](infoElementSize);\n          break;\n\n        default:\n          ebmlParser.setPos(ebmlParser.getPos() + infoElementSize);\n          break;\n      }\n    } // once we have what we need from segment info, we jump right to the\n    // cues\n\n\n    request = getFragmentRequest(info);\n\n    var onload = function onload(response) {\n      segments = parseSegments(response, segmentStart, segmentEnd, duration);\n      callback(segments);\n    };\n\n    var onloadend = function onloadend() {\n      logger.error('Download Error: Cues ' + info.url);\n      callback(null);\n    };\n\n    urlLoader.load({\n      request: request,\n      success: onload,\n      error: onloadend\n    });\n    logger.debug('Perform cues load: ' + info.url + ' bytes=' + info.range.start + '-' + info.range.end);\n  }\n\n  function checkConfig() {\n    if (!baseURLController || !baseURLController.hasOwnProperty('resolve')) {\n      throw new Error('setConfig function has to be called previously');\n    }\n  }\n\n  function loadInitialization(streamId, mediaType, representation, loadingInfo) {\n    checkConfig();\n    var request = null;\n    var baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n    var initRange = representation ? representation.range.split('-') : null;\n    var info = loadingInfo || {\n      range: {\n        start: initRange ? parseFloat(initRange[0]) : null,\n        end: initRange ? parseFloat(initRange[1]) : null\n      },\n      request: request,\n      url: baseUrl ? baseUrl.url : undefined,\n      init: true,\n      mediaType: mediaType\n    };\n    logger.info('Start loading initialization.');\n    request = getFragmentRequest(info);\n\n    var onload = function onload() {\n      // note that we don't explicitly set rep.initialization as this\n      // will be computed when all BaseURLs are resolved later\n      eventBus.trigger(events.INITIALIZATION_LOADED, {\n        representation: representation\n      }, {\n        streamId: streamId,\n        mediaType: mediaType\n      });\n    };\n\n    var onloadend = function onloadend() {\n      eventBus.trigger(events.INITIALIZATION_LOADED, {\n        representation: representation\n      }, {\n        streamId: streamId,\n        mediaType: mediaType\n      });\n    };\n\n    urlLoader.load({\n      request: request,\n      success: onload,\n      error: onloadend\n    });\n    logger.debug('Perform init load: ' + info.url);\n  }\n\n  function loadSegments(streamId, mediaType, representation, theRange, callback) {\n    checkConfig();\n    var request = null;\n    var baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n    var media = baseUrl ? baseUrl.url : undefined;\n    var bytesToLoad = 8192;\n    var info = {\n      bytesLoaded: 0,\n      bytesToLoad: bytesToLoad,\n      range: {\n        start: 0,\n        end: bytesToLoad\n      },\n      request: request,\n      url: media,\n      init: false,\n      mediaType: mediaType\n    };\n    callback = !callback ? onLoaded : callback;\n    request = getFragmentRequest(info); // first load the header, but preserve the manifest range so we can\n    // load the cues after parsing the header\n    // NOTE: we expect segment info to appear in the first 8192 bytes\n\n    logger.debug('Parsing ebml header');\n\n    var onload = function onload(response) {\n      parseEbmlHeader(response, media, theRange, function (segments) {\n        callback(streamId, mediaType, segments, representation);\n      });\n    };\n\n    var onloadend = function onloadend() {\n      callback(streamId, mediaType, null, representation);\n    };\n\n    urlLoader.load({\n      request: request,\n      success: onload,\n      error: onloadend\n    });\n  }\n\n  function onLoaded(streamId, mediaType, segments, representation) {\n    eventBus.trigger(events.SEGMENTS_LOADED, {\n      segments: segments,\n      representation: representation,\n      error: segments ? undefined : new _DashJSError2.default(errors.SEGMENT_BASE_LOADER_ERROR_CODE, errors.SEGMENT_BASE_LOADER_ERROR_MESSAGE)\n    }, {\n      streamId: streamId,\n      mediaType: mediaType\n    });\n  }\n\n  function getFragmentRequest(info) {\n    var request = new _FragmentRequest2.default();\n    request.setInfo(info);\n    return request;\n  }\n\n  function reset() {\n    errHandler = null;\n    requestModifier = null;\n  }\n\n  instance = {\n    setConfig: setConfig,\n    initialize: initialize,\n    loadInitialization: loadInitialization,\n    loadSegments: loadSegments,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nWebmSegmentBaseLoader.__dashjs_factory_name = 'WebmSegmentBaseLoader';\nexports.default = _FactoryMaker2.default.getSingletonFactory(WebmSegmentBaseLoader);","map":{"version":3,"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AAEA;;AAAA,SAASA,qBAAT,GAAiC;EAE7B,IAAMC,UAAU,KAAKA,OAArB;EAEA,IAAIC,iBAAJ;EAAA,IACIC,eADJ;EAAA,IAEIC,aAFJ;EAAA,IAGIC,mBAHJ;EAAA,IAIIC,wBAJJ;EAAA,IAKIC,oBALJ;EAAA,IAMIC,yBANJ;EAAA,IAOIC,kBAPJ;EAAA,IAQIC,iBARJ;EAAA,IASIC,iBATJ;EAAA,IAUIC,eAVJ;EAAA,IAWIC,eAXJ;EAAA,IAYIC,0BAZJ;;EAcA,SAASC,KAAT,GAAiB;IACbX,OAAO;MACHY,MAAM;QACFC,KAAK,UADH;QAEFC,UAAU;MAFR,CADH;MAKHC,SAAS;QACLF,KAAK,UADA;QAELC,UAAU,IAFL;QAGLE,UAAU;UACNH,KAAK,UADC;UAENC,UAAU;QAFJ,CAHL;QAOLG,MAAM;UACFJ,KAAK,UADH;UAEFC,UAAU,IAFR;UAGFI,eAAe;YACXL,KAAK,QADM;YAEXC,UAAU,IAFC;YAGXK,OAAO;UAHI,CAHb;UAQFC,UAAU;YACNP,KAAK,MADC;YAENC,UAAU,IAFJ;YAGNK,OAAO;UAHD;QARR,CAPD;QAqBLE,QAAQ;UACJR,KAAK,UADD;UAEJC,UAAU;QAFN,CArBH;QAyBLQ,MAAM;UACFT,KAAK,UADH;UAEFC,UAAU,IAFR;UAGFS,UAAU;YACNV,KAAK,IADC;YAENC,UAAU,IAFJ;YAGNU,SAAS;cACLX,KAAK,IADA;cAELC,UAAU,IAFL;cAGLK,OAAO;YAHF,CAHH;YAQNM,mBAAmB;cACfZ,KAAK,IADU;cAEfC,UAAU,IAFK;cAGfY,UAAU;gBACNb,KAAK,IADC;gBAENC,UAAU,IAFJ;gBAGNK,OAAO;cAHD,CAHK;cAQfQ,oBAAoB;gBAChBd,KAAK,IADW;gBAEhBC,UAAU,IAFM;gBAGhBK,OAAO;cAHS;YARL;UARb;QAHR;MAzBD,CALN;MA0DHS,MAAM;QACFf,KAAK,IADH;QAEFC,UAAU;MAFR;IA1DH,CAAPd;EAiEJ;;EAAA,SAAS6B,UAAT,GAAsB;IAClBxB,YAAY,yBAAUR,OAAV,EAAmBiC,MAAnB,CAA0B;MAClC7B,YAAYA,UADsB;MAElCE,aAAaA,WAFqB;MAGlCC,kBAAkBA,gBAHgB;MAIlCF,iBAAiBA,eAJiB;MAKlC6B,UAAUzB,WAAWA,SAAS0B,GAAT1B,GAAe2B,SAAf3B,CAAyB4B,iBAApC5B,GAAwD,IALhC;MAMlCG,QAAQA;IAN0B,CAA1B,CAAZJ;EAUJ;;EAAA,SAAS8B,SAAT,CAAmBC,MAAnB,EAA2B;IACvB,IAAI,CAACA,OAAO1B,iBAAR,IAA6B,CAAC0B,OAAOjC,WAArC,IAAoD,CAACiC,OAAOhC,gBAA5D,IAAgF,CAACgC,OAAOnC,UAA5F,EAAwG;MACpG,MAAM,IAAIoC,KAAJ,CAAUC,oBAAUC,oBAApB,CAAN;IAEJ7B;;IAAAA,oBAAoB0B,OAAO1B,iBAA3BA;IACAP,cAAciC,OAAOjC,WAArBA;IACAC,mBAAmBgC,OAAOhC,gBAA1BA;IACAH,aAAamC,OAAOnC,UAApBA;IACAK,WAAW8B,OAAO9B,QAAlBA;IACAE,SAAS4B,OAAO5B,MAAhBA;IACAD,WAAW6B,OAAO7B,QAAlBA;IACAE,SAAS2B,OAAO3B,MAAhBA;IACAV,SAASqC,OAAOI,KAAPJ,CAAaK,SAAbL,CAAuBtC,QAAvBsC,CAATrC;IACAG,kBAAkBkC,OAAOlC,eAAzBA;EAGJ;;EAAA,SAASwC,SAAT,CAAmBC,EAAnB,EAAuB;IACnB,IAAIC,OAAO,EAAX;IACA,IAAIC,aAAa,0BAAWhD,OAAX,EAAoBiC,MAApB,CAA2B;MACxCgB,MAAMH;IADkC,CAA3B,CAAjB;IAGA,IAAII,YAAJ;IAAA,IACIC,iBADJ;IAGAH,WAAWI,iBAAXJ,CAA6B7C,KAAKe,OAALf,CAAasB,IAA1CuB;;IAEA,OAAOA,WAAWK,QAAXL,MACHA,WAAWI,iBAAXJ,CAA6B7C,KAAKe,OAALf,CAAasB,IAAbtB,CAAkBuB,QAA/CsB,EAAyD,IAAzDA,CADJ,EACoE;MAChEE,MAAM,EAANA;MAEAA,IAAIvB,OAAJuB,GAAcF,WAAWM,QAAXN,CAAoB7C,KAAKe,OAALf,CAAasB,IAAbtB,CAAkBuB,QAAlBvB,CAA2BwB,OAA/CqB,CAAdE;MAEAA,IAAIK,SAAJL,GAAgB,EAAhBA;;MACA,OAAOF,WAAWK,QAAXL,MACHA,WAAWQ,UAAXR,CAAsB7C,KAAKe,OAALf,CAAasB,IAAbtB,CAAkBuB,QAAlBvB,CAA2ByB,iBAAjDoB,EAAoE,IAApEA,CADJ,EAC+E;QAC3E,IAAMS,uBAAuBT,WAAWU,mBAAXV,EAA7B;QACA,IAAMW,WAAWX,WAAWY,MAAXZ,EAAjB;QACAG,WAAW,EAAXA;QAEAA,SAASU,KAATV,GAAiBH,WAAWM,QAAXN,CAAoB7C,KAAKe,OAALf,CAAasB,IAAbtB,CAAkBuB,QAAlBvB,CAA2ByB,iBAA3BzB,CAA6C0B,QAAjEmB,CAAjBG;;QACA,IAAIA,SAASU,KAATV,KAAmB,CAAvB,EAA0B;UACtB,MAAM,IAAIX,KAAJ,CAAU,uBAAV,CAAN;QAGJW;;QAAAA,SAASW,eAATX,GACIH,WAAWM,QAAXN,CAAoB7C,KAAKe,OAALf,CAAasB,IAAbtB,CAAkBuB,QAAlBvB,CAA2ByB,iBAA3BzB,CAA6C2B,kBAAjEkB,CADJG;QAGAD,IAAIK,SAAJL,CAAca,IAAdb,CAAmBC,QAAnBD,EAb2E,CAe3E;;QACAF,WAAWgB,MAAXhB,CAAkBW,WAAWF,oBAA7BT;MAGJ;;MAAA,IAAIE,IAAIK,SAAJL,CAAce,MAAdf,KAAyB,CAA7B,EAAgC;QAC5B,MAAM,IAAIV,KAAJ,CAAU,8BAAV,CAAN;MAEJO;;MAAAA,KAAKgB,IAALhB,CAAUG,GAAVH;IAGJ;;IAAA,IAAIA,KAAKkB,MAALlB,KAAgB,CAApB,EAAuB;MACnB,MAAM,IAAIP,KAAJ,CAAU,8BAAV,CAAN;IAEJ;;IAAA,OAAOO,IAAP;EAGJ;;EAAA,SAASmB,aAAT,CAAuBjB,IAAvB,EAA6BkB,YAA7B,EAA2CC,UAA3C,EAAuDC,eAAvD,EAAwE;IACpE,IAAIC,iBAAJ;IAAA,IACIC,eADJ;IAAA,IAEIC,iBAFJ;IAAA,IAGIC,gBAHJ;IAAA,IAIIC,UAJJ;IAAA,IAKIC,YALJ;IAAA,IAMIC,cANJ;IAAA,IAOIC,YAPJ;IASAN,SAAS1B,UAAUI,IAAVJ,CAAT0B;IACAC,WAAW,EAAXA,CAXoE,CAapE;IACA;IACA;;IACA,KAAKE,IAAI,CAAJA,EAAOC,MAAMJ,OAAON,MAAzB,EAAiCS,IAAIC,GAArC,EAA0CD,KAAK,CAA/C,EAAkD;MAC9CD,UAAU,IAAIvD,iBAAJ,EAAVuD;MACAH,WAAW,CAAXA;;MAEA,IAAII,IAAIH,OAAON,MAAPM,GAAgB,CAAxB,EAA2B;QACvBD,WAAWC,OAAOG,IAAI,CAAXH,EAAc5C,OAAd4C,GAAwBA,OAAOG,CAAPH,EAAU5C,OAA7C2C;MADJ,OAEO;QACHA,WAAWD,kBAAkBE,OAAOG,CAAPH,EAAU5C,OAAvC2C;MAGJ,CAV8C,CAU9C;MACA;;;MACAG,QAAQH,QAARG,GAAmBH,QAAnBG;MACAA,QAAQK,SAARL,GAAoBF,OAAOG,CAAPH,EAAU5C,OAA9B8C;MACAA,QAAQM,SAARN,GAAoB,IAApBA,CAd8C,CAcpB;;MAC1BG,QAAQL,OAAOG,CAAPH,EAAUhB,SAAVgB,CAAoB,CAApBA,EAAuBT,eAAvBS,GAAyCJ,YAAjDS;;MAEA,IAAIF,IAAIH,OAAON,MAAPM,GAAgB,CAAxB,EAA2B;QACvBM,MAAMN,OAAOG,IAAI,CAAXH,EAAchB,SAAdgB,CAAwB,CAAxBA,EAA2BT,eAA3BS,GAA6CJ,YAA7CI,GAA4D,CAAlEM;MADJ,OAEO;QACHA,MAAMT,aAAa,CAAnBS;MAGJJ;;MAAAA,QAAQO,UAARP,GAAqBG,QAAQ,GAARA,GAAcC,GAAnCJ;MACAD,SAAST,IAATS,CAAcC,OAAdD;IAGJtE;;IAAAA,OAAOyC,KAAPzC,CAAa,kBAAkBsE,SAASP,MAA3B,GAAoC,QAAjD/D;IAEA,OAAOsE,QAAP;EAGJ;;EAAA,SAASS,eAAT,CAAyBhC,IAAzB,EAA+BiC,KAA/B,EAAsCC,QAAtC,EAAgDC,QAAhD,EAA0D;IACtD,IAAI,CAACnC,IAAD,IAASA,KAAKoC,UAALpC,KAAoB,CAAjC,EAAoC;MAChCmC,SAAS,IAATA;MACA;IAEJ;;IAAA,IAAIpC,aAAa,0BAAWhD,OAAX,EAAoBiC,MAApB,CAA2B;MACxCgB,MAAMA;IADkC,CAA3B,CAAjB;IAGA,IAAIqB,iBAAJ;IAAA,IACIE,iBADJ;IAAA,IAEIJ,mBAFJ;IAAA,IAGID,qBAHJ;IAIA,IAAImB,QAAQH,WAAWA,SAASI,KAATJ,CAAe,GAAfA,CAAXA,GAAiC,IAA7C;IACA,IAAIK,UAAU,IAAd;IACA,IAAIC,OAAO;MACPC,KAAKR,KADE;MAEPS,OAAO;QACHf,OAAOU,QAAQM,WAAWN,MAAM,CAANA,CAAXM,CAARN,GAA+B,IADnC;QAEHT,KAAKS,QAAQM,WAAWN,MAAM,CAANA,CAAXM,CAARN,GAA+B;MAFjC,CAFA;MAMPE,SAASA;IANF,CAAX;IASAtF,OAAOyC,KAAPzC,CAAa,wBAAwBuF,KAAKC,GAA1CxF,EAvBsD,CAyBtD;;IACA8C,WAAW6C,eAAX7C,CAA2B7C,KAAKY,IAAhCiC;IACAA,WAAWQ,UAAXR,CAAsB7C,KAAKe,OAA3B8B,EA3BsD,CA6BtD;;IACAoB,aAAapB,WAAWU,mBAAXV,EAAboB;IACAA,cAAcpB,WAAWY,MAAXZ,EAAdoB;IACAD,eAAenB,WAAWY,MAAXZ,EAAfmB,CAhCsD,CAkCtD;;IACA,OAAOnB,WAAWK,QAAXL,MACH,CAACA,WAAWI,iBAAXJ,CAA6B7C,KAAKe,OAALf,CAAaiB,IAA1C4B,EAAgD,IAAhDA,CADL,EAC4D;MACxD,IAAI,EAAEA,WAAW6C,eAAX7C,CAA2B7C,KAAKe,OAALf,CAAagB,QAAxC6B,EAAkD,IAAlDA,KACEA,WAAW6C,eAAX7C,CAA2B7C,KAAKe,OAALf,CAAaqB,MAAxCwB,EAAgD,IAAhDA,CADFA,IAEEA,WAAW6C,eAAX7C,CAA2B7C,KAAKe,OAALf,CAAasB,IAAxCuB,EAA8C,IAA9CA,CAFFA,IAGEA,WAAW6C,eAAX7C,CAA2B7C,KAAK4B,IAAhCiB,EAAsC,IAAtCA,CAHJ,CAAJ,EAGsD;QAClD,MAAM,IAAIR,KAAJ,CAAU,kCAAV,CAAN;MAEP;IAED,CA7CsD,CA6CtD;;;IACA,OAAO8B,aAAawB,SAApB,EAA+B;MAC3B,IAAIC,UAAU/C,WAAWU,mBAAXV,CAA+B,IAA/BA,CAAd;MACA,IAAIgD,kBAAkBhD,WAAWU,mBAAXV,EAAtB;;MAEA,QAAQ+C,OAAR;QACI,KAAK5F,KAAKe,OAALf,CAAaiB,IAAbjB,CAAkBoB,QAAlBpB,CAA2Ba,GAAhC;UACIsD,WAAWtB,WAAW7C,KAAKe,OAALf,CAAaiB,IAAbjB,CAAkBoB,QAAlBpB,CAA2BmB,KAAtC0B,EAA6CgD,eAA7ChD,CAAXsB;UACA;;QACJ;UACItB,WAAWgB,MAAXhB,CAAkBA,WAAWY,MAAXZ,KAAsBgD,eAAxChD;UACA;MANR;IAUJ,CA5DsD,CA4DtD;IACA;;;IAEAwC,UAAUS,mBAAmBR,IAAnBQ,CAAVT;;IAEA,IAAMU,SAAS,SAATA,MAAS,CAAUC,QAAV,EAAoB;MAC/B3B,WAAWN,cAAciC,QAAdjC,EAAwBC,YAAxBD,EAAsCE,UAAtCF,EAAkDI,QAAlDJ,CAAXM;MACAY,SAASZ,QAATY;IAFJ;;IAKA,IAAMgB,YAAY,SAAZA,SAAY,GAAY;MAC1BlG,OAAOmG,KAAPnG,CAAa,0BAA0BuF,KAAKC,GAA5CxF;MACAkF,SAAS,IAATA;IAFJ;;IAKA5E,UAAU8F,IAAV9F,CAAe;MACXgF,SAASA,OADE;MAEXe,SAASL,MAFE;MAGXG,OAAOD;IAHI,CAAf5F;IAMAN,OAAOyC,KAAPzC,CAAa,wBAAwBuF,KAAKC,GAA7B,GAAmC,SAAnC,GAA+CD,KAAKE,KAALF,CAAWb,KAA1D,GAAkE,GAAlE,GAAwEa,KAAKE,KAALF,CAAWZ,GAAhG3E;EAGJ;;EAAA,SAASsG,WAAT,GAAuB;IACnB,IAAI,CAAC3F,iBAAD,IAAsB,CAACA,kBAAkB4F,cAAlB5F,CAAiC,SAAjCA,CAA3B,EAAwE;MACpE,MAAM,IAAI2B,KAAJ,CAAU,gDAAV,CAAN;IAEP;EAED;;EAAA,SAASkE,kBAAT,CAA4BC,QAA5B,EAAsCC,SAAtC,EAAiDC,cAAjD,EAAiEC,WAAjE,EAA8E;IAC1EN;IACA,IAAIhB,UAAU,IAAd;IACA,IAAIuB,UAAUF,iBAAiBhG,kBAAkBmG,OAAlBnG,CAA0BgG,eAAeI,IAAzCpG,CAAjBgG,GAAkE,IAAhF;IACA,IAAIK,YAAYL,iBAAiBA,eAAelB,KAAfkB,CAAqBtB,KAArBsB,CAA2B,GAA3BA,CAAjBA,GAAmD,IAAnE;IACA,IAAIpB,OAAOqB,eAAe;MACtBnB,OAAO;QACHf,OAAOsC,YAAYtB,WAAWsB,UAAU,CAAVA,CAAXtB,CAAZsB,GAAuC,IAD3C;QAEHrC,KAAKqC,YAAYtB,WAAWsB,UAAU,CAAVA,CAAXtB,CAAZsB,GAAuC;MAFzC,CADe;MAKtB1B,SAASA,OALa;MAMtBE,KAAKqB,UAAUA,QAAQrB,GAAlBqB,GAAwBjB,SANP;MAOtBqB,MAAM,IAPgB;MAQtBP,WAAWA;IARW,CAA1B;IAWA1G,OAAOuF,IAAPvF,CAAY,+BAAZA;IAEAsF,UAAUS,mBAAmBR,IAAnBQ,CAAVT;;IAEA,IAAMU,SAAS,SAATA,MAAS,GAAY;MACvB;MACA;MACAxF,SAAS0G,OAAT1G,CAAiBC,OAAO0G,qBAAxB3G,EACI;QAAEmG,gBAAgBA;MAAlB,CADJnG,EAEI;QAAEiG,UAAUA,QAAZ;QAAsBC,WAAWA;MAAjC,CAFJlG;IAHJ;;IASA,IAAM0F,YAAY,SAAZA,SAAY,GAAY;MAC1B1F,SAAS0G,OAAT1G,CAAiBC,OAAO0G,qBAAxB3G,EACI;QAAEmG,gBAAgBA;MAAlB,CADJnG,EAEI;QAAEiG,UAAUA,QAAZ;QAAsBC,WAAWA;MAAjC,CAFJlG;IADJ;;IAOAF,UAAU8F,IAAV9F,CAAe;MACXgF,SAASA,OADE;MAEXe,SAASL,MAFE;MAGXG,OAAOD;IAHI,CAAf5F;IAMAN,OAAOyC,KAAPzC,CAAa,wBAAwBuF,KAAKC,GAA1CxF;EAGJ;;EAAA,SAASoH,YAAT,CAAsBX,QAAtB,EAAgCC,SAAhC,EAA2CC,cAA3C,EAA2D1B,QAA3D,EAAqEC,QAArE,EAA+E;IAC3EoB;IACA,IAAIhB,UAAU,IAAd;IACA,IAAIuB,UAAUF,iBAAiBhG,kBAAkBmG,OAAlBnG,CAA0BgG,eAAeI,IAAzCpG,CAAjBgG,GAAkE,IAAhF;IACA,IAAI3B,QAAQ6B,UAAUA,QAAQrB,GAAlBqB,GAAwBjB,SAApC;IACA,IAAIyB,cAAc,IAAlB;IACA,IAAI9B,OAAO;MACP+B,aAAa,CADN;MAEPD,aAAaA,WAFN;MAGP5B,OAAO;QACHf,OAAO,CADJ;QAEHC,KAAK0C;MAFF,CAHA;MAOP/B,SAASA,OAPF;MAQPE,KAAKR,KARE;MASPiC,MAAM,KATC;MAUPP,WAAWA;IAVJ,CAAX;IAaAxB,WAAW,CAACA,QAAD,GAAYqC,QAAZ,GAAuBrC,QAAlCA;IACAI,UAAUS,mBAAmBR,IAAnBQ,CAAVT,CApB2E,CAsB3E;IACA;IACA;;IACAtF,OAAOyC,KAAPzC,CAAa,qBAAbA;;IAEA,IAAMgG,SAAS,SAATA,MAAS,CAAUC,QAAV,EAAoB;MAC/BlB,gBAAgBkB,QAAhBlB,EAA0BC,KAA1BD,EAAiCE,QAAjCF,EAA2C,UAAUT,QAAV,EAAoB;QAC3DY,SAASuB,QAATvB,EAAmBwB,SAAnBxB,EAA8BZ,QAA9BY,EAAwCyB,cAAxCzB;MADJ;IADJ;;IAMA,IAAMgB,YAAY,SAAZA,SAAY,GAAY;MAC1BhB,SAASuB,QAATvB,EAAmBwB,SAAnBxB,EAA8B,IAA9BA,EAAoCyB,cAApCzB;IADJ;;IAIA5E,UAAU8F,IAAV9F,CAAe;MACXgF,SAASA,OADE;MAEXe,SAASL,MAFE;MAGXG,OAAOD;IAHI,CAAf5F;EAOJ;;EAAA,SAASiH,QAAT,CAAkBd,QAAlB,EAA4BC,SAA5B,EAAuCpC,QAAvC,EAAiDqC,cAAjD,EAAiE;IAC7DnG,SAAS0G,OAAT1G,CAAiBC,OAAO+G,eAAxBhH,EACI;MACI8D,UAAUA,QADd;MAEIqC,gBAAgBA,cAFpB;MAGIR,OAAO7B,WAAWsB,SAAXtB,GAAuB,IAAImD,qBAAJ,CAAgB/G,OAAOgH,8BAAvB,EAAuDhH,OAAOiH,iCAA9D;IAHlC,CADJnH,EAMI;MAAEiG,UAAUA,QAAZ;MAAsBC,WAAWA;IAAjC,CANJlG;EAUJ;;EAAA,SAASuF,kBAAT,CAA4BR,IAA5B,EAAkC;IAC9B,IAAMD,UAAU,IAAIsC,yBAAJ,EAAhB;IACAtC,QAAQuC,OAARvC,CAAgBC,IAAhBD;IACA,OAAOA,OAAP;EAGJ;;EAAA,SAASwC,KAAT,GAAiB;IACb5H,aAAa,IAAbA;IACAC,kBAAkB,IAAlBA;EAGJJ;;EAAAA,WAAW;IACPqC,WAAWA,SADJ;IAEPN,YAAYA,UAFL;IAGP0E,oBAAoBA,kBAHb;IAIPY,cAAcA,YAJP;IAKPU,OAAOA;EALA,CAAX/H;EAQAa;EAEA,OAAOb,QAAP;AAGJF;;AAAAA,sBAAsBkI,qBAAtBlI,GAA8C,uBAA9CA;kBACemI,uBAAaC,mBAAbD,CAAiCnI,qBAAjCmI,C","names":["WebmSegmentBaseLoader","context","instance","logger","WebM","errHandler","requestModifier","dashMetrics","mediaPlayerModel","urlLoader","settings","eventBus","events","errors","baseURLController","setup","EBML","tag","required","Segment","SeekHead","Info","TimecodeScale","parse","Duration","Tracks","Cues","CuePoint","CueTime","CueTrackPositions","CueTrack","CueClusterPosition","Void","initialize","create","useFetch","get","streaming","lowLatencyEnabled","setConfig","config","Error","Constants","MISSING_CONFIG_ERROR","debug","getLogger","parseCues","ab","cues","ebmlParser","data","cue","cueTrack","consumeTagAndSize","moreData","parseTag","CueTracks","consumeTag","cueTrackPositionSize","getMatroskaCodedNum","startPos","getPos","Track","ClusterPosition","push","setPos","length","parseSegments","segmentStart","segmentEnd","segmentDuration","duration","parsed","segments","segment","i","len","start","end","startTime","timescale","mediaRange","parseEbmlHeader","media","theRange","callback","byteLength","parts","split","request","info","url","range","parseFloat","skipOverElement","undefined","infoTag","infoElementSize","getFragmentRequest","onload","response","onloadend","error","load","success","checkConfig","hasOwnProperty","loadInitialization","streamId","mediaType","representation","loadingInfo","baseUrl","resolve","path","initRange","init","trigger","INITIALIZATION_LOADED","loadSegments","bytesToLoad","bytesLoaded","onLoaded","SEGMENTS_LOADED","DashJSError","SEGMENT_BASE_LOADER_ERROR_CODE","SEGMENT_BASE_LOADER_ERROR_MESSAGE","FragmentRequest","setInfo","reset","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/dash/WebmSegmentBaseLoader.js"],"sourcesContent":["import EBMLParser from '../streaming/utils/EBMLParser';\nimport Constants from '../streaming/constants/Constants';\nimport FactoryMaker from '../core/FactoryMaker';\nimport Segment from './vo/Segment';\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport URLLoader from '../streaming/net/URLLoader';\nimport DashJSError from '../streaming/vo/DashJSError';\n\nfunction WebmSegmentBaseLoader() {\n\n    const context = this.context;\n\n    let instance,\n        logger,\n        WebM,\n        errHandler,\n        requestModifier,\n        dashMetrics,\n        mediaPlayerModel,\n        urlLoader,\n        settings,\n        eventBus,\n        events,\n        errors,\n        baseURLController;\n\n    function setup() {\n        WebM = {\n            EBML: {\n                tag: 0x1A45DFA3,\n                required: true\n            },\n            Segment: {\n                tag: 0x18538067,\n                required: true,\n                SeekHead: {\n                    tag: 0x114D9B74,\n                    required: true\n                },\n                Info: {\n                    tag: 0x1549A966,\n                    required: true,\n                    TimecodeScale: {\n                        tag: 0x2AD7B1,\n                        required: true,\n                        parse: 'getMatroskaUint'\n                    },\n                    Duration: {\n                        tag: 0x4489,\n                        required: true,\n                        parse: 'getMatroskaFloat'\n                    }\n                },\n                Tracks: {\n                    tag: 0x1654AE6B,\n                    required: true\n                },\n                Cues: {\n                    tag: 0x1C53BB6B,\n                    required: true,\n                    CuePoint: {\n                        tag: 0xBB,\n                        required: true,\n                        CueTime: {\n                            tag: 0xB3,\n                            required: true,\n                            parse: 'getMatroskaUint'\n                        },\n                        CueTrackPositions: {\n                            tag: 0xB7,\n                            required: true,\n                            CueTrack: {\n                                tag: 0xF7,\n                                required: true,\n                                parse: 'getMatroskaUint'\n                            },\n                            CueClusterPosition: {\n                                tag: 0xF1,\n                                required: true,\n                                parse: 'getMatroskaUint'\n                            }\n                        }\n                    }\n                }\n            },\n            Void: {\n                tag: 0xEC,\n                required: true\n            }\n        };\n    }\n\n    function initialize() {\n        urlLoader = URLLoader(context).create({\n            errHandler: errHandler,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            requestModifier: requestModifier,\n            useFetch: settings ? settings.get().streaming.lowLatencyEnabled : null,\n            errors: errors\n        });\n    }\n\n    function setConfig(config) {\n        if (!config.baseURLController || !config.dashMetrics || !config.mediaPlayerModel || !config.errHandler) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n        baseURLController = config.baseURLController;\n        dashMetrics = config.dashMetrics;\n        mediaPlayerModel = config.mediaPlayerModel;\n        errHandler = config.errHandler;\n        settings = config.settings;\n        events = config.events;\n        eventBus = config.eventBus;\n        errors = config.errors;\n        logger = config.debug.getLogger(instance);\n        requestModifier = config.requestModifier;\n    }\n\n    function parseCues(ab) {\n        let cues = [];\n        let ebmlParser = EBMLParser(context).create({\n            data: ab\n        });\n        let cue,\n            cueTrack;\n\n        ebmlParser.consumeTagAndSize(WebM.Segment.Cues);\n\n        while (ebmlParser.moreData() &&\n            ebmlParser.consumeTagAndSize(WebM.Segment.Cues.CuePoint, true)) {\n            cue = {};\n\n            cue.CueTime = ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTime);\n\n            cue.CueTracks = [];\n            while (ebmlParser.moreData() &&\n                ebmlParser.consumeTag(WebM.Segment.Cues.CuePoint.CueTrackPositions, true)) {\n                const cueTrackPositionSize = ebmlParser.getMatroskaCodedNum();\n                const startPos = ebmlParser.getPos();\n                cueTrack = {};\n\n                cueTrack.Track = ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTrackPositions.CueTrack);\n                if (cueTrack.Track === 0) {\n                    throw new Error('Cue track cannot be 0');\n                }\n\n                cueTrack.ClusterPosition =\n                    ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTrackPositions.CueClusterPosition);\n\n                cue.CueTracks.push(cueTrack);\n\n                // we're not interested any other elements - skip remaining bytes\n                ebmlParser.setPos(startPos + cueTrackPositionSize);\n            }\n\n            if (cue.CueTracks.length === 0) {\n                throw new Error('Mandatory cuetrack not found');\n            }\n            cues.push(cue);\n        }\n\n        if (cues.length === 0) {\n            throw new Error('mandatory cuepoint not found');\n        }\n        return cues;\n    }\n\n    function parseSegments(data, segmentStart, segmentEnd, segmentDuration) {\n        let duration,\n            parsed,\n            segments,\n            segment,\n            i,\n            len,\n            start,\n            end;\n\n        parsed = parseCues(data);\n        segments = [];\n\n        // we are assuming one cue track per cue point\n        // both duration and media range require the i + 1 segment\n        // the final segment has to use global segment parameters\n        for (i = 0, len = parsed.length; i < len; i += 1) {\n            segment = new Segment();\n            duration = 0;\n\n            if (i < parsed.length - 1) {\n                duration = parsed[i + 1].CueTime - parsed[i].CueTime;\n            } else {\n                duration = segmentDuration - parsed[i].CueTime;\n            }\n\n            // note that we don't explicitly set segment.media as this will be\n            // computed when all BaseURLs are resolved later\n            segment.duration = duration;\n            segment.startTime = parsed[i].CueTime;\n            segment.timescale = 1000; // hardcoded for ms\n            start = parsed[i].CueTracks[0].ClusterPosition + segmentStart;\n\n            if (i < parsed.length - 1) {\n                end = parsed[i + 1].CueTracks[0].ClusterPosition + segmentStart - 1;\n            } else {\n                end = segmentEnd - 1;\n            }\n\n            segment.mediaRange = start + '-' + end;\n            segments.push(segment);\n        }\n\n        logger.debug('Parsed cues: ' + segments.length + ' cues.');\n\n        return segments;\n    }\n\n    function parseEbmlHeader(data, media, theRange, callback) {\n        if (!data || data.byteLength === 0) {\n            callback(null);\n            return;\n        }\n        let ebmlParser = EBMLParser(context).create({\n            data: data\n        });\n        let duration,\n            segments,\n            segmentEnd,\n            segmentStart;\n        let parts = theRange ? theRange.split('-') : null;\n        let request = null;\n        let info = {\n            url: media,\n            range: {\n                start: parts ? parseFloat(parts[0]) : null,\n                end: parts ? parseFloat(parts[1]) : null\n            },\n            request: request\n        };\n\n        logger.debug('Parse EBML header: ' + info.url);\n\n        // skip over the header itself\n        ebmlParser.skipOverElement(WebM.EBML);\n        ebmlParser.consumeTag(WebM.Segment);\n\n        // segments start here\n        segmentEnd = ebmlParser.getMatroskaCodedNum();\n        segmentEnd += ebmlParser.getPos();\n        segmentStart = ebmlParser.getPos();\n\n        // skip over any top level elements to get to the segment info\n        while (ebmlParser.moreData() &&\n            !ebmlParser.consumeTagAndSize(WebM.Segment.Info, true)) {\n            if (!(ebmlParser.skipOverElement(WebM.Segment.SeekHead, true) ||\n                    ebmlParser.skipOverElement(WebM.Segment.Tracks, true) ||\n                    ebmlParser.skipOverElement(WebM.Segment.Cues, true) ||\n                    ebmlParser.skipOverElement(WebM.Void, true))) {\n                throw new Error('no valid top level element found');\n            }\n        }\n\n        // we only need one thing in segment info, duration\n        while (duration === undefined) {\n            let infoTag = ebmlParser.getMatroskaCodedNum(true);\n            let infoElementSize = ebmlParser.getMatroskaCodedNum();\n\n            switch (infoTag) {\n                case WebM.Segment.Info.Duration.tag:\n                    duration = ebmlParser[WebM.Segment.Info.Duration.parse](infoElementSize);\n                    break;\n                default:\n                    ebmlParser.setPos(ebmlParser.getPos() + infoElementSize);\n                    break;\n            }\n        }\n\n        // once we have what we need from segment info, we jump right to the\n        // cues\n\n        request = getFragmentRequest(info);\n\n        const onload = function (response) {\n            segments = parseSegments(response, segmentStart, segmentEnd, duration);\n            callback(segments);\n        };\n\n        const onloadend = function () {\n            logger.error('Download Error: Cues ' + info.url);\n            callback(null);\n        };\n\n        urlLoader.load({\n            request: request,\n            success: onload,\n            error: onloadend\n        });\n\n        logger.debug('Perform cues load: ' + info.url + ' bytes=' + info.range.start + '-' + info.range.end);\n    }\n\n    function checkConfig() {\n        if (!baseURLController || !baseURLController.hasOwnProperty('resolve')) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    function loadInitialization(streamId, mediaType, representation, loadingInfo) {\n        checkConfig();\n        let request = null;\n        let baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n        let initRange = representation ? representation.range.split('-') : null;\n        let info = loadingInfo || {\n            range: {\n                start: initRange ? parseFloat(initRange[0]) : null,\n                end: initRange ? parseFloat(initRange[1]) : null\n            },\n            request: request,\n            url: baseUrl ? baseUrl.url : undefined,\n            init: true,\n            mediaType: mediaType\n        };\n\n        logger.info('Start loading initialization.');\n\n        request = getFragmentRequest(info);\n\n        const onload = function () {\n            // note that we don't explicitly set rep.initialization as this\n            // will be computed when all BaseURLs are resolved later\n            eventBus.trigger(events.INITIALIZATION_LOADED,\n                { representation: representation },\n                { streamId: streamId, mediaType: mediaType }\n            );\n        };\n\n        const onloadend = function () {\n            eventBus.trigger(events.INITIALIZATION_LOADED,\n                { representation: representation },\n                { streamId: streamId, mediaType: mediaType }\n            );\n        };\n\n        urlLoader.load({\n            request: request,\n            success: onload,\n            error: onloadend\n        });\n\n        logger.debug('Perform init load: ' + info.url);\n    }\n\n    function loadSegments(streamId, mediaType, representation, theRange, callback) {\n        checkConfig();\n        let request = null;\n        let baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n        let media = baseUrl ? baseUrl.url : undefined;\n        let bytesToLoad = 8192;\n        let info = {\n            bytesLoaded: 0,\n            bytesToLoad: bytesToLoad,\n            range: {\n                start: 0,\n                end: bytesToLoad\n            },\n            request: request,\n            url: media,\n            init: false,\n            mediaType: mediaType\n        };\n\n        callback = !callback ? onLoaded : callback;\n        request = getFragmentRequest(info);\n\n        // first load the header, but preserve the manifest range so we can\n        // load the cues after parsing the header\n        // NOTE: we expect segment info to appear in the first 8192 bytes\n        logger.debug('Parsing ebml header');\n\n        const onload = function (response) {\n            parseEbmlHeader(response, media, theRange, function (segments) {\n                callback(streamId, mediaType, segments, representation);\n            });\n        };\n\n        const onloadend = function () {\n            callback(streamId, mediaType, null, representation);\n        };\n\n        urlLoader.load({\n            request: request,\n            success: onload,\n            error: onloadend\n        });\n    }\n\n    function onLoaded(streamId, mediaType, segments, representation) {\n        eventBus.trigger(events.SEGMENTS_LOADED,\n            {\n                segments: segments,\n                representation: representation,\n                error: segments ? undefined : new DashJSError(errors.SEGMENT_BASE_LOADER_ERROR_CODE, errors.SEGMENT_BASE_LOADER_ERROR_MESSAGE)\n            },\n            { streamId: streamId, mediaType: mediaType }\n        );\n    }\n\n    function getFragmentRequest(info) {\n        const request = new FragmentRequest();\n        request.setInfo(info);\n        return request;\n    }\n\n    function reset() {\n        errHandler = null;\n        requestModifier = null;\n    }\n\n    instance = {\n        setConfig: setConfig,\n        initialize: initialize,\n        loadInitialization: loadInitialization,\n        loadSegments: loadSegments,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nWebmSegmentBaseLoader.__dashjs_factory_name = 'WebmSegmentBaseLoader';\nexport default FactoryMaker.getSingletonFactory(WebmSegmentBaseLoader);\n"]},"metadata":{},"sourceType":"script"}