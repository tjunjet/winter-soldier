{"ast":null,"code":"'use strict';\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2015-2016, DASH Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  1. Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  2. Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (exports) {\n  \"use strict\";\n  /**\n  *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n  */\n\n  var specialCea608CharsCodes = {\n    0x2a: 0xe1,\n    // lowercase a, acute accent\n    0x5c: 0xe9,\n    // lowercase e, acute accent\n    0x5e: 0xed,\n    // lowercase i, acute accent\n    0x5f: 0xf3,\n    // lowercase o, acute accent\n    0x60: 0xfa,\n    // lowercase u, acute accent\n    0x7b: 0xe7,\n    // lowercase c with cedilla\n    0x7c: 0xf7,\n    // division symbol\n    0x7d: 0xd1,\n    // uppercase N tilde\n    0x7e: 0xf1,\n    // lowercase n tilde\n    0x7f: 0x2588,\n    // Full block\n    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n    // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n    0x80: 0xae,\n    // Registered symbol (R)\n    0x81: 0xb0,\n    // degree sign\n    0x82: 0xbd,\n    // 1/2 symbol\n    0x83: 0xbf,\n    // Inverted (open) question mark\n    0x84: 0x2122,\n    // Trademark symbol (TM)\n    0x85: 0xa2,\n    // Cents symbol\n    0x86: 0xa3,\n    // Pounds sterling\n    0x87: 0x266a,\n    // Music 8'th note\n    0x88: 0xe0,\n    // lowercase a, grave accent\n    0x89: 0x20,\n    // transparent space (regular)\n    0x8a: 0xe8,\n    // lowercase e, grave accent\n    0x8b: 0xe2,\n    // lowercase a, circumflex accent\n    0x8c: 0xea,\n    // lowercase e, circumflex accent\n    0x8d: 0xee,\n    // lowercase i, circumflex accent\n    0x8e: 0xf4,\n    // lowercase o, circumflex accent\n    0x8f: 0xfb,\n    // lowercase u, circumflex accent\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n    0x90: 0xc1,\n    // capital letter A with acute\n    0x91: 0xc9,\n    // capital letter E with acute\n    0x92: 0xd3,\n    // capital letter O with acute\n    0x93: 0xda,\n    // capital letter U with acute\n    0x94: 0xdc,\n    // capital letter U with diaresis\n    0x95: 0xfc,\n    // lowercase letter U with diaeresis\n    0x96: 0x2018,\n    // opening single quote\n    0x97: 0xa1,\n    // inverted exclamation mark\n    0x98: 0x2a,\n    // asterisk\n    0x99: 0x2019,\n    // closing single quote\n    0x9a: 0x2501,\n    // box drawings heavy horizontal\n    0x9b: 0xa9,\n    // copyright sign\n    0x9c: 0x2120,\n    // Service mark\n    0x9d: 0x2022,\n    // (round) bullet\n    0x9e: 0x201c,\n    // Left double quotation mark\n    0x9f: 0x201d,\n    // Right double quotation mark\n    0xa0: 0xc0,\n    // uppercase A, grave accent\n    0xa1: 0xc2,\n    // uppercase A, circumflex\n    0xa2: 0xc7,\n    // uppercase C with cedilla\n    0xa3: 0xc8,\n    // uppercase E, grave accent\n    0xa4: 0xca,\n    // uppercase E, circumflex\n    0xa5: 0xcb,\n    // capital letter E with diaresis\n    0xa6: 0xeb,\n    // lowercase letter e with diaresis\n    0xa7: 0xce,\n    // uppercase I, circumflex\n    0xa8: 0xcf,\n    // uppercase I, with diaresis\n    0xa9: 0xef,\n    // lowercase i, with diaresis\n    0xaa: 0xd4,\n    // uppercase O, circumflex\n    0xab: 0xd9,\n    // uppercase U, grave accent\n    0xac: 0xf9,\n    // lowercase u, grave accent\n    0xad: 0xdb,\n    // uppercase U, circumflex\n    0xae: 0xab,\n    // left-pointing double angle quotation mark\n    0xaf: 0xbb,\n    // right-pointing double angle quotation mark\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n    0xb0: 0xc3,\n    // Uppercase A, tilde\n    0xb1: 0xe3,\n    // Lowercase a, tilde\n    0xb2: 0xcd,\n    // Uppercase I, acute accent\n    0xb3: 0xcc,\n    // Uppercase I, grave accent\n    0xb4: 0xec,\n    // Lowercase i, grave accent\n    0xb5: 0xd2,\n    // Uppercase O, grave accent\n    0xb6: 0xf2,\n    // Lowercase o, grave accent\n    0xb7: 0xd5,\n    // Uppercase O, tilde\n    0xb8: 0xf5,\n    // Lowercase o, tilde\n    0xb9: 0x7b,\n    // Open curly brace\n    0xba: 0x7d,\n    // Closing curly brace\n    0xbb: 0x5c,\n    // Backslash\n    0xbc: 0x5e,\n    // Caret\n    0xbd: 0x5f,\n    // Underscore\n    0xbe: 0x7c,\n    // Pipe (vertical line)\n    0xbf: 0x223c,\n    // Tilde operator\n    0xc0: 0xc4,\n    // Uppercase A, umlaut\n    0xc1: 0xe4,\n    // Lowercase A, umlaut\n    0xc2: 0xd6,\n    // Uppercase O, umlaut\n    0xc3: 0xf6,\n    // Lowercase o, umlaut\n    0xc4: 0xdf,\n    // Esszett (sharp S)\n    0xc5: 0xa5,\n    // Yen symbol\n    0xc6: 0xa4,\n    // Generic currency sign\n    0xc7: 0x2503,\n    // Box drawings heavy vertical\n    0xc8: 0xc5,\n    // Uppercase A, ring\n    0xc9: 0xe5,\n    // Lowercase A, ring\n    0xca: 0xd8,\n    // Uppercase O, stroke\n    0xcb: 0xf8,\n    // Lowercase o, strok\n    0xcc: 0x250f,\n    // Box drawings heavy down and right\n    0xcd: 0x2513,\n    // Box drawings heavy down and left\n    0xce: 0x2517,\n    // Box drawings heavy up and right\n    0xcf: 0x251b // Box drawings heavy up and left\n\n  };\n  /**\n     * Get Unicode Character from CEA-608 byte code\n     */\n\n  var getCharForByte = function getCharForByte(byte) {\n    var charCode = byte;\n\n    if (specialCea608CharsCodes.hasOwnProperty(byte)) {\n      charCode = specialCea608CharsCodes[byte];\n    }\n\n    return String.fromCharCode(charCode);\n  };\n\n  var NR_ROWS = 15,\n      NR_COLS = 32; // Tables to look up row from PAC data\n\n  var rowsLowCh1 = {\n    0x11: 1,\n    0x12: 3,\n    0x15: 5,\n    0x16: 7,\n    0x17: 9,\n    0x10: 11,\n    0x13: 12,\n    0x14: 14\n  };\n  var rowsHighCh1 = {\n    0x11: 2,\n    0x12: 4,\n    0x15: 6,\n    0x16: 8,\n    0x17: 10,\n    0x13: 13,\n    0x14: 15\n  };\n  var rowsLowCh2 = {\n    0x19: 1,\n    0x1A: 3,\n    0x1D: 5,\n    0x1E: 7,\n    0x1F: 9,\n    0x18: 11,\n    0x1B: 12,\n    0x1C: 14\n  };\n  var rowsHighCh2 = {\n    0x19: 2,\n    0x1A: 4,\n    0x1D: 6,\n    0x1E: 8,\n    0x1F: 10,\n    0x1B: 13,\n    0x1C: 15\n  };\n  var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\n  /**\n  * Simple logger class to be able to write with time-stamps and filter on level.\n  */\n\n  var logger = {\n    verboseFilter: {\n      'DATA': 3,\n      'DEBUG': 3,\n      'INFO': 2,\n      'WARNING': 2,\n      'TEXT': 1,\n      'ERROR': 0\n    },\n    time: null,\n    verboseLevel: 0,\n    // Only write errors\n    setTime: function setTime(newTime) {\n      this.time = newTime;\n    },\n    log: function log(severity, msg) {\n      var minLevel = this.verboseFilter[severity];\n\n      if (this.verboseLevel >= minLevel) {\n        console.log(this.time + \" [\" + severity + \"] \" + msg);\n      }\n    }\n  };\n\n  var numArrayToHexArray = function numArrayToHexArray(numArray) {\n    var hexArray = [];\n\n    for (var j = 0; j < numArray.length; j++) {\n      hexArray.push(numArray[j].toString(16));\n    }\n\n    return hexArray;\n  };\n  /**\n  * State of CEA-608 pen or character\n  * @constructor\n  */\n\n\n  var PenState = function PenState(foreground, underline, italics, background, flash) {\n    this.foreground = foreground || \"white\";\n    this.underline = underline || false;\n    this.italics = italics || false;\n    this.background = background || \"black\";\n    this.flash = flash || false;\n  };\n\n  PenState.prototype = {\n    reset: function reset() {\n      this.foreground = \"white\";\n      this.underline = false;\n      this.italics = false;\n      this.background = \"black\";\n      this.flash = false;\n    },\n    setStyles: function setStyles(styles) {\n      var attribs = [\"foreground\", \"underline\", \"italics\", \"background\", \"flash\"];\n\n      for (var i = 0; i < attribs.length; i++) {\n        var style = attribs[i];\n\n        if (styles.hasOwnProperty(style)) {\n          this[style] = styles[style];\n        }\n      }\n    },\n    isDefault: function isDefault() {\n      return this.foreground === \"white\" && !this.underline && !this.italics && this.background === \"black\" && !this.flash;\n    },\n    equals: function equals(other) {\n      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n    },\n    copy: function copy(newPenState) {\n      this.foreground = newPenState.foreground;\n      this.underline = newPenState.underline;\n      this.italics = newPenState.italics;\n      this.background = newPenState.background;\n      this.flash = newPenState.flash;\n    },\n    toString: function toString() {\n      return \"color=\" + this.foreground + \", underline=\" + this.underline + \", italics=\" + this.italics + \", background=\" + this.background + \", flash=\" + this.flash;\n    }\n  };\n  /**\n  * Unicode character with styling and background.\n  * @constructor\n  */\n\n  var StyledUnicodeChar = function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {\n    this.uchar = uchar || ' '; // unicode character\n\n    this.penState = new PenState(foreground, underline, italics, background, flash);\n  };\n\n  StyledUnicodeChar.prototype = {\n    reset: function reset() {\n      this.uchar = ' ';\n      this.penState.reset();\n    },\n    setChar: function setChar(uchar, newPenState) {\n      this.uchar = uchar;\n      this.penState.copy(newPenState);\n    },\n    setPenState: function setPenState(newPenState) {\n      this.penState.copy(newPenState);\n    },\n    equals: function equals(other) {\n      return this.uchar === other.uchar && this.penState.equals(other.penState);\n    },\n    copy: function copy(newChar) {\n      this.uchar = newChar.uchar;\n      this.penState.copy(newChar.penState);\n    },\n    isEmpty: function isEmpty() {\n      return this.uchar === ' ' && this.penState.isDefault();\n    }\n  };\n  /**\n  * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n  * @constructor\n  */\n\n  var Row = function Row() {\n    this.chars = [];\n\n    for (var i = 0; i < NR_COLS; i++) {\n      this.chars.push(new StyledUnicodeChar());\n    }\n\n    this.pos = 0;\n    this.currPenState = new PenState();\n  };\n\n  Row.prototype = {\n    equals: function equals(other) {\n      var equal = true;\n\n      for (var i = 0; i < NR_COLS; i++) {\n        if (!this.chars[i].equals(other.chars[i])) {\n          equal = false;\n          break;\n        }\n      }\n\n      return equal;\n    },\n    copy: function copy(other) {\n      for (var i = 0; i < NR_COLS; i++) {\n        this.chars[i].copy(other.chars[i]);\n      }\n    },\n    isEmpty: function isEmpty() {\n      var empty = true;\n\n      for (var i = 0; i < NR_COLS; i++) {\n        if (!this.chars[i].isEmpty()) {\n          empty = false;\n          break;\n        }\n      }\n\n      return empty;\n    },\n\n    /**\n    *  Set the cursor to a valid column.\n    */\n    setCursor: function setCursor(absPos) {\n      if (this.pos !== absPos) {\n        this.pos = absPos;\n      }\n\n      if (this.pos < 0) {\n        logger.log(\"ERROR\", \"Negative cursor position \" + this.pos);\n        this.pos = 0;\n      } else if (this.pos > NR_COLS) {\n        logger.log(\"ERROR\", \"Too large cursor position \" + this.pos);\n        this.pos = NR_COLS;\n      }\n    },\n\n    /** \n    * Move the cursor relative to current position.\n    */\n    moveCursor: function moveCursor(relPos) {\n      var newPos = this.pos + relPos;\n\n      if (relPos > 1) {\n        for (var i = this.pos + 1; i < newPos + 1; i++) {\n          this.chars[i].setPenState(this.currPenState);\n        }\n      }\n\n      this.setCursor(newPos);\n    },\n\n    /**\n    * Backspace, move one step back and clear character.\n    */\n    backSpace: function backSpace() {\n      this.moveCursor(-1);\n      this.chars[this.pos].setChar(' ', this.currPenState);\n    },\n    insertChar: function insertChar(byte) {\n      if (byte >= 0x90) {\n        //Extended char\n        this.backSpace();\n      }\n\n      var char = getCharForByte(byte);\n\n      if (this.pos >= NR_COLS) {\n        logger.log(\"ERROR\", \"Cannot insert \" + byte.toString(16) + \" (\" + char + \") at position \" + this.pos + \". Skipping it!\");\n        return;\n      }\n\n      this.chars[this.pos].setChar(char, this.currPenState);\n      this.moveCursor(1);\n    },\n    clearFromPos: function clearFromPos(startPos) {\n      var i;\n\n      for (i = startPos; i < NR_COLS; i++) {\n        this.chars[i].reset();\n      }\n    },\n    clear: function clear() {\n      this.clearFromPos(0);\n      this.pos = 0;\n      this.currPenState.reset();\n    },\n    clearToEndOfRow: function clearToEndOfRow() {\n      this.clearFromPos(this.pos);\n    },\n    getTextString: function getTextString() {\n      var chars = [];\n      var empty = true;\n\n      for (var i = 0; i < NR_COLS; i++) {\n        var char = this.chars[i].uchar;\n\n        if (char !== \" \") {\n          empty = false;\n        }\n\n        chars.push(char);\n      }\n\n      if (empty) {\n        return \"\";\n      } else {\n        return chars.join(\"\");\n      }\n    },\n    setPenStyles: function setPenStyles(styles) {\n      this.currPenState.setStyles(styles);\n      var currChar = this.chars[this.pos];\n      currChar.setPenState(this.currPenState);\n    }\n  };\n  /**\n  * Keep a CEA-608 screen of 32x15 styled characters\n  * @constructor\n  */\n\n  var CaptionScreen = function CaptionScreen() {\n    this.rows = [];\n\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)\n    }\n\n    this.currRow = NR_ROWS - 1;\n    this.nrRollUpRows = null;\n    this.reset();\n  };\n\n  CaptionScreen.prototype = {\n    reset: function reset() {\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      }\n\n      this.currRow = NR_ROWS - 1;\n    },\n    equals: function equals(other) {\n      var equal = true;\n\n      for (var i = 0; i < NR_ROWS; i++) {\n        if (!this.rows[i].equals(other.rows[i])) {\n          equal = false;\n          break;\n        }\n      }\n\n      return equal;\n    },\n    copy: function copy(other) {\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].copy(other.rows[i]);\n      }\n    },\n    isEmpty: function isEmpty() {\n      var empty = true;\n\n      for (var i = 0; i < NR_ROWS; i++) {\n        if (!this.rows[i].isEmpty()) {\n          empty = false;\n          break;\n        }\n      }\n\n      return empty;\n    },\n    backSpace: function backSpace() {\n      var row = this.rows[this.currRow];\n      row.backSpace();\n    },\n    clearToEndOfRow: function clearToEndOfRow() {\n      var row = this.rows[this.currRow];\n      row.clearToEndOfRow();\n    },\n\n    /**\n    * Insert a character (without styling) in the current row.\n    */\n    insertChar: function insertChar(char) {\n      var row = this.rows[this.currRow];\n      row.insertChar(char);\n    },\n    setPen: function setPen(styles) {\n      var row = this.rows[this.currRow];\n      row.setPenStyles(styles);\n    },\n    moveCursor: function moveCursor(relPos) {\n      var row = this.rows[this.currRow];\n      row.moveCursor(relPos);\n    },\n    setCursor: function setCursor(absPos) {\n      logger.log(\"INFO\", \"setCursor: \" + absPos);\n      var row = this.rows[this.currRow];\n      row.setCursor(absPos);\n    },\n    setPAC: function setPAC(pacData) {\n      logger.log(\"INFO\", \"pacData = \" + JSON.stringify(pacData));\n      var newRow = pacData.row - 1;\n\n      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n        newRow = this.nrRollUpRows - 1;\n      }\n\n      this.currRow = newRow;\n      var row = this.rows[this.currRow];\n\n      if (pacData.indent !== null) {\n        var indent = pacData.indent;\n        var prevPos = Math.max(indent - 1, 0);\n        row.setCursor(pacData.indent);\n        pacData.color = row.chars[prevPos].penState.foreground;\n      }\n\n      var styles = {\n        foreground: pacData.color,\n        underline: pacData.underline,\n        italics: pacData.italics,\n        background: 'black',\n        flash: false\n      };\n      this.setPen(styles);\n    },\n\n    /**\n    * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n    */\n    setBkgData: function setBkgData(bkgData) {\n      logger.log(\"INFO\", \"bkgData = \" + JSON.stringify(bkgData));\n      this.backSpace();\n      this.setPen(bkgData);\n      this.insertChar(0x20); //Space\n    },\n    setRollUpRows: function setRollUpRows(nrRows) {\n      this.nrRollUpRows = nrRows;\n    },\n    rollUp: function rollUp() {\n      if (this.nrRollUpRows === null) {\n        logger.log(\"DEBUG\", \"roll_up but nrRollUpRows not set yet\");\n        return; //Not properly setup\n      }\n\n      logger.log(\"TEXT\", this.getDisplayText());\n      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n      var topRow = this.rows.splice(topRowIndex, 1)[0];\n      topRow.clear();\n      this.rows.splice(this.currRow, 0, topRow);\n      logger.log(\"INFO\", \"Rolling up\"); //logger.log(\"TEXT\", this.get_display_text())\n    },\n\n    /**\n          * Get all non-empty rows with as unicode text. \n          */\n    getDisplayText: function getDisplayText(asOneRow) {\n      asOneRow = asOneRow || false;\n      var displayText = [];\n      var text = \"\";\n      var rowNr = -1;\n\n      for (var i = 0; i < NR_ROWS; i++) {\n        var rowText = this.rows[i].getTextString();\n\n        if (rowText) {\n          rowNr = i + 1;\n\n          if (asOneRow) {\n            displayText.push(\"Row \" + rowNr + ': \"' + rowText + '\"');\n          } else {\n            displayText.push(rowText.trim());\n          }\n        }\n      }\n\n      if (displayText.length > 0) {\n        if (asOneRow) {\n          text = \"[\" + displayText.join(\" | \") + \"]\";\n        } else {\n          text = displayText.join(\"\\n\");\n        }\n      }\n\n      return text;\n    },\n    getTextAndFormat: function getTextAndFormat() {\n      return this.rows;\n    }\n  };\n  /**\n  * Handle a CEA-608 channel and send decoded data to outputFilter\n  * @constructor\n  * @param {Number} channelNumber (1 or 2)\n  * @param {CueHandler} outputFilter Output from channel1 newCue(startTime, endTime, captionScreen)\n  */\n\n  var Cea608Channel = function Cea608Channel(channelNumber, outputFilter) {\n    this.chNr = channelNumber;\n    this.outputFilter = outputFilter;\n    this.mode = null;\n    this.verbose = 0;\n    this.displayedMemory = new CaptionScreen();\n    this.nonDisplayedMemory = new CaptionScreen();\n    this.lastOutputScreen = new CaptionScreen();\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null; // Keeps track of where a cue started.\n  };\n\n  Cea608Channel.prototype = {\n    modes: [\"MODE_ROLL-UP\", \"MODE_POP-ON\", \"MODE_PAINT-ON\", \"MODE_TEXT\"],\n    reset: function reset() {\n      this.mode = null;\n      this.displayedMemory.reset();\n      this.nonDisplayedMemory.reset();\n      this.lastOutputScreen.reset();\n      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n      this.writeScreen = this.displayedMemory;\n      this.mode = null;\n      this.cueStartTime = null;\n      this.lastCueEndTime = null;\n    },\n    getHandler: function getHandler() {\n      return this.outputFilter;\n    },\n    setHandler: function setHandler(newHandler) {\n      this.outputFilter = newHandler;\n    },\n    setPAC: function setPAC(pacData) {\n      this.writeScreen.setPAC(pacData);\n    },\n    setBkgData: function setBkgData(bkgData) {\n      this.writeScreen.setBkgData(bkgData);\n    },\n    setMode: function setMode(newMode) {\n      if (newMode === this.mode) {\n        return;\n      }\n\n      this.mode = newMode;\n      logger.log(\"INFO\", \"MODE=\" + newMode);\n\n      if (this.mode == \"MODE_POP-ON\") {\n        this.writeScreen = this.nonDisplayedMemory;\n      } else {\n        this.writeScreen = this.displayedMemory;\n        this.writeScreen.reset();\n      }\n\n      if (this.mode !== \"MODE_ROLL-UP\") {\n        this.displayedMemory.nrRollUpRows = null;\n        this.nonDisplayedMemory.nrRollUpRows = null;\n      }\n\n      this.mode = newMode;\n    },\n    insertChars: function insertChars(chars) {\n      for (var i = 0; i < chars.length; i++) {\n        this.writeScreen.insertChar(chars[i]);\n      }\n\n      var screen = this.writeScreen === this.displayedMemory ? \"DISP\" : \"NON_DISP\";\n      logger.log(\"INFO\", screen + \": \" + this.writeScreen.getDisplayText(true));\n\n      if (this.mode === \"MODE_PAINT-ON\" || this.mode === \"MODE_ROLL-UP\") {\n        logger.log(\"TEXT\", \"DISPLAYED: \" + this.displayedMemory.getDisplayText(true));\n        this.outputDataUpdate();\n      }\n    },\n    cc_RCL: function cc_RCL() {\n      // Resume Caption Loading (switch mode to Pop On)\n      logger.log(\"INFO\", \"RCL - Resume Caption Loading\");\n      this.setMode(\"MODE_POP-ON\");\n    },\n    cc_BS: function cc_BS() {\n      // BackSpace\n      logger.log(\"INFO\", \"BS - BackSpace\");\n\n      if (this.mode === \"MODE_TEXT\") {\n        return;\n      }\n\n      this.writeScreen.backSpace();\n\n      if (this.writeScreen === this.displayedMemory) {\n        this.outputDataUpdate();\n      }\n    },\n    cc_AOF: function cc_AOF() {\n      // Reserved (formerly Alarm Off)\n      return;\n    },\n    cc_AON: function cc_AON() {\n      // Reserved (formerly Alarm On)\n      return;\n    },\n    cc_DER: function cc_DER() {\n      // Delete to End of Row\n      logger.log(\"INFO\", \"DER- Delete to End of Row\");\n      this.writeScreen.clearToEndOfRow();\n      this.outputDataUpdate();\n    },\n    cc_RU: function cc_RU(nrRows) {\n      //Roll-Up Captions-2,3,or 4 Rows\n      logger.log(\"INFO\", \"RU(\" + nrRows + \") - Roll Up\");\n      this.writeScreen = this.displayedMemory;\n      this.setMode(\"MODE_ROLL-UP\");\n      this.writeScreen.setRollUpRows(nrRows);\n    },\n    cc_FON: function cc_FON() {\n      //Flash On\n      logger.log(\"INFO\", \"FON - Flash On\");\n      this.writeScreen.setPen({\n        flash: true\n      });\n    },\n    cc_RDC: function cc_RDC() {\n      // Resume Direct Captioning (switch mode to PaintOn)\n      logger.log(\"INFO\", \"RDC - Resume Direct Captioning\");\n      this.setMode(\"MODE_PAINT-ON\");\n    },\n    cc_TR: function cc_TR() {\n      // Text Restart in text mode (not supported, however)\n      logger.log(\"INFO\", \"TR\");\n      this.setMode(\"MODE_TEXT\");\n    },\n    cc_RTD: function cc_RTD() {\n      // Resume Text Display in Text mode (not supported, however)\n      logger.log(\"INFO\", \"RTD\");\n      this.setMode(\"MODE_TEXT\");\n    },\n    cc_EDM: function cc_EDM() {\n      // Erase Displayed Memory\n      logger.log(\"INFO\", \"EDM - Erase Displayed Memory\");\n      this.displayedMemory.reset();\n      this.outputDataUpdate();\n    },\n    cc_CR: function cc_CR() {\n      // Carriage Return\n      logger.log(\"CR - Carriage Return\");\n      this.writeScreen.rollUp();\n      this.outputDataUpdate();\n    },\n    cc_ENM: function cc_ENM() {\n      //Erase Non-Displayed Memory\n      logger.log(\"INFO\", \"ENM - Erase Non-displayed Memory\");\n      this.nonDisplayedMemory.reset();\n    },\n    cc_EOC: function cc_EOC() {\n      //End of Caption (Flip Memories)\n      logger.log(\"INFO\", \"EOC - End Of Caption\");\n\n      if (this.mode === \"MODE_POP-ON\") {\n        var tmp = this.displayedMemory;\n        this.displayedMemory = this.nonDisplayedMemory;\n        this.nonDisplayedMemory = tmp;\n        this.writeScreen = this.nonDisplayedMemory;\n        logger.log(\"TEXT\", \"DISP: \" + this.displayedMemory.getDisplayText());\n      }\n\n      this.outputDataUpdate();\n    },\n    cc_TO: function cc_TO(nrCols) {\n      // Tab Offset 1,2, or 3 columns\n      logger.log(\"INFO\", \"TO(\" + nrCols + \") - Tab Offset\");\n      this.writeScreen.moveCursor(nrCols);\n    },\n    cc_MIDROW: function cc_MIDROW(secondByte) {\n      // Parse MIDROW command\n      var styles = {\n        flash: false\n      };\n      styles.underline = secondByte % 2 === 1;\n      styles.italics = secondByte >= 0x2e;\n\n      if (!styles.italics) {\n        var colorIndex = Math.floor(secondByte / 2) - 0x10;\n        var colors = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\"];\n        styles.foreground = colors[colorIndex];\n      } else {\n        styles.foreground = \"white\";\n      }\n\n      logger.log(\"INFO\", \"MIDROW: \" + JSON.stringify(styles));\n      this.writeScreen.setPen(styles);\n    },\n    outputDataUpdate: function outputDataUpdate() {\n      var t = logger.time;\n\n      if (t === null) {\n        return;\n      }\n\n      if (this.outputFilter) {\n        if (this.outputFilter.updateData) {\n          this.outputFilter.updateData(t, this.displayedMemory);\n        }\n\n        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n          // Start of a new cue\n          this.cueStartTime = t;\n        } else {\n          if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n            if (this.outputFilter.newCue) {\n              this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);\n            }\n\n            this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;\n          }\n        }\n\n        this.lastOutputScreen.copy(this.displayedMemory);\n      }\n    },\n    cueSplitAtTime: function cueSplitAtTime(t) {\n      if (this.outputFilter) {\n        if (!this.displayedMemory.isEmpty()) {\n          if (this.outputFilter.newCue) {\n            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n          }\n\n          this.cueStartTime = t;\n        }\n      }\n    }\n  };\n  /**\n  * Parse CEA-608 data and send decoded data to out1 and out2.\n  * @constructor\n  * @param {Number} field  CEA-608 field (1 or 2)\n  * @param {CueHandler} out1 Output from channel1 newCue(startTime, endTime, captionScreen)\n  * @param {CueHandler} out2 Output from channel2 newCue(startTime, endTime, captionScreen)\n  */\n\n  var Cea608Parser = function Cea608Parser(field, out1, out2) {\n    this.field = field || 1;\n    this.outputs = [out1, out2];\n    this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];\n    this.currChNr = -1; // Will be 1 or 2\n\n    this.lastCmdA = null; // First byte of last command\n\n    this.lastCmdB = null; // Second byte of last command\n\n    this.bufferedData = [];\n    this.startTime = null;\n    this.lastTime = null;\n    this.dataCounters = {\n      'padding': 0,\n      'char': 0,\n      'cmd': 0,\n      'other': 0\n    };\n  };\n\n  Cea608Parser.prototype = {\n    getHandler: function getHandler(index) {\n      return this.channels[index].getHandler();\n    },\n    setHandler: function setHandler(index, newHandler) {\n      this.channels[index].setHandler(newHandler);\n    },\n\n    /**\n    * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n    */\n    addData: function addData(t, byteList) {\n      var cmdFound,\n          a,\n          b,\n          charsFound = false;\n      this.lastTime = t;\n      logger.setTime(t);\n\n      for (var i = 0; i < byteList.length; i += 2) {\n        a = byteList[i] & 0x7f;\n        b = byteList[i + 1] & 0x7f;\n\n        if (a >= 0x10 && a <= 0x1f && a === this.lastCmdA && b === this.lastCmdB) {\n          this.lastCmdA = null;\n          this.lastCmdB = null;\n          logger.log(\"DEBUG\", \"Repeated command (\" + numArrayToHexArray([a, b]) + \") is dropped\");\n          continue; // Repeated commands are dropped (once)\n        }\n\n        if (a === 0 && b === 0) {\n          this.dataCounters.padding += 2;\n          continue;\n        } else {\n          logger.log(\"DATA\", \"[\" + numArrayToHexArray([byteList[i], byteList[i + 1]]) + \"] -> (\" + numArrayToHexArray([a, b]) + \")\");\n        }\n\n        cmdFound = this.parseCmd(a, b);\n\n        if (!cmdFound) {\n          cmdFound = this.parseMidrow(a, b);\n        }\n\n        if (!cmdFound) {\n          cmdFound = this.parsePAC(a, b);\n        }\n\n        if (!cmdFound) {\n          cmdFound = this.parseBackgroundAttributes(a, b);\n        }\n\n        if (!cmdFound) {\n          charsFound = this.parseChars(a, b);\n\n          if (charsFound) {\n            if (this.currChNr && this.currChNr >= 0) {\n              var channel = this.channels[this.currChNr - 1];\n              channel.insertChars(charsFound);\n            } else {\n              logger.log(\"WARNING\", \"No channel found yet. TEXT-MODE?\");\n            }\n          }\n        }\n\n        if (cmdFound) {\n          this.dataCounters.cmd += 2;\n        } else if (charsFound) {\n          this.dataCounters.char += 2;\n        } else {\n          this.dataCounters.other += 2;\n          logger.log(\"WARNING\", \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + \" orig: \" + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n        }\n      }\n    },\n\n    /**\n    * Parse Command.\n    * @returns {Boolean} Tells if a command was found\n    */\n    parseCmd: function parseCmd(a, b) {\n      var chNr = null;\n      var cond1 = (a === 0x14 || a === 0x15 || a === 0x1C || a === 0x1D) && 0x20 <= b && b <= 0x2F;\n      var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;\n\n      if (!(cond1 || cond2)) {\n        return false;\n      }\n\n      if (a === 0x14 || a === 0x15 || a === 0x17) {\n        chNr = 1;\n      } else {\n        chNr = 2; // (a === 0x1C || a === 0x1D || a=== 0x1f)\n      }\n\n      var channel = this.channels[chNr - 1];\n\n      if (a === 0x14 || a === 0x15 || a === 0x1C || a === 0x1D) {\n        if (b === 0x20) {\n          channel.cc_RCL();\n        } else if (b === 0x21) {\n          channel.cc_BS();\n        } else if (b === 0x22) {\n          channel.cc_AOF();\n        } else if (b === 0x23) {\n          channel.cc_AON();\n        } else if (b === 0x24) {\n          channel.cc_DER();\n        } else if (b === 0x25) {\n          channel.cc_RU(2);\n        } else if (b === 0x26) {\n          channel.cc_RU(3);\n        } else if (b === 0x27) {\n          channel.cc_RU(4);\n        } else if (b === 0x28) {\n          channel.cc_FON();\n        } else if (b === 0x29) {\n          channel.cc_RDC();\n        } else if (b === 0x2A) {\n          channel.cc_TR();\n        } else if (b === 0x2B) {\n          channel.cc_RTD();\n        } else if (b === 0x2C) {\n          channel.cc_EDM();\n        } else if (b === 0x2D) {\n          channel.cc_CR();\n        } else if (b === 0x2E) {\n          channel.cc_ENM();\n        } else if (b === 0x2F) {\n          channel.cc_EOC();\n        }\n      } else {\n        //a == 0x17 || a == 0x1F\n        channel.cc_TO(b - 0x20);\n      }\n\n      this.lastCmdA = a;\n      this.lastCmdB = b;\n      this.currChNr = chNr;\n      return true;\n    },\n\n    /**\n    * Parse midrow styling command\n    * @returns {Boolean}\n    */\n    parseMidrow: function parseMidrow(a, b) {\n      var chNr = null;\n\n      if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {\n        if (a === 0x11) {\n          chNr = 1;\n        } else {\n          chNr = 2;\n        }\n\n        if (chNr !== this.currChNr) {\n          logger.log(\"ERROR\", \"Mismatch channel in midrow parsing\");\n          return false;\n        }\n\n        var channel = this.channels[chNr - 1]; // cea608 spec says midrow codes should inject a space\n\n        channel.insertChars([0x20]);\n        channel.cc_MIDROW(b);\n        logger.log(\"DEBUG\", \"MIDROW (\" + numArrayToHexArray([a, b]) + \")\");\n        this.lastCmdA = a;\n        this.lastCmdB = b;\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n    * Parse Preable Access Codes (Table 53).\n    * @returns {Boolean} Tells if PAC found\n    */\n    parsePAC: function parsePAC(a, b) {\n      var chNr = null;\n      var row = null;\n      var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;\n      var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;\n\n      if (!(case1 || case2)) {\n        return false;\n      }\n\n      chNr = a <= 0x17 ? 1 : 2;\n\n      if (0x40 <= b && b <= 0x5F) {\n        row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n      } else {\n        // 0x60 <= b <= 0x7F\n        row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n      }\n\n      var pacData = this.interpretPAC(row, b);\n      var channel = this.channels[chNr - 1];\n      channel.setPAC(pacData);\n      this.lastCmdA = a;\n      this.lastCmdB = b;\n      this.currChNr = chNr;\n      return true;\n    },\n\n    /**\n    * Interpret the second byte of the pac, and return the information.\n    * @returns {Object} pacData with style parameters.\n    */\n    interpretPAC: function interpretPAC(row, byte) {\n      var pacIndex = byte;\n      var pacData = {\n        color: null,\n        italics: false,\n        indent: null,\n        underline: false,\n        row: row\n      };\n\n      if (byte > 0x5F) {\n        pacIndex = byte - 0x60;\n      } else {\n        pacIndex = byte - 0x40;\n      }\n\n      pacData.underline = (pacIndex & 1) === 1;\n\n      if (pacIndex <= 0xd) {\n        pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n      } else if (pacIndex <= 0xf) {\n        pacData.italics = true;\n        pacData.color = 'white';\n      } else {\n        pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n      }\n\n      return pacData; // Note that row has zero offset. The spec uses 1.\n    },\n\n    /**\n           * Parse characters.\n           * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n           */\n    parseChars: function parseChars(a, b) {\n      var channelNr = null,\n          charCodes = null,\n          charCode1 = null,\n          charCode2 = null;\n\n      if (a >= 0x19) {\n        channelNr = 2;\n        charCode1 = a - 8;\n      } else {\n        channelNr = 1;\n        charCode1 = a;\n      }\n\n      if (0x11 <= charCode1 && charCode1 <= 0x13) {\n        // Special character\n        var oneCode = b;\n\n        if (charCode1 === 0x11) {\n          oneCode = b + 0x50;\n        } else if (charCode1 === 0x12) {\n          oneCode = b + 0x70;\n        } else {\n          oneCode = b + 0x90;\n        }\n\n        logger.log(\"INFO\", \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n        charCodes = [oneCode];\n        this.lastCmdA = a;\n        this.lastCmdB = b;\n      } else if (0x20 <= a && a <= 0x7f) {\n        charCodes = b === 0 ? [a] : [a, b];\n        this.lastCmdA = null;\n        this.lastCmdB = null;\n      }\n\n      if (charCodes) {\n        var hexCodes = numArrayToHexArray(charCodes);\n        logger.log(\"DEBUG\", \"Char codes =  \" + hexCodes.join(\",\"));\n      }\n\n      return charCodes;\n    },\n\n    /**\n    * Parse extended background attributes as well as new foreground color black.\n    * @returns{Boolean} Tells if background attributes are found\n    */\n    parseBackgroundAttributes: function parseBackgroundAttributes(a, b) {\n      var bkgData, index, chNr, channel;\n      var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;\n      var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;\n\n      if (!(case1 || case2)) {\n        return false;\n      }\n\n      bkgData = {};\n\n      if (a === 0x10 || a === 0x18) {\n        index = Math.floor((b - 0x20) / 2);\n        bkgData.background = backgroundColors[index];\n\n        if (b % 2 === 1) {\n          bkgData.background = bkgData.background + \"_semi\";\n        }\n      } else if (b === 0x2d) {\n        bkgData.background = \"transparent\";\n      } else {\n        bkgData.foreground = \"black\";\n\n        if (b === 0x2f) {\n          bkgData.underline = true;\n        }\n      }\n\n      chNr = a < 0x18 ? 1 : 2;\n      channel = this.channels[chNr - 1];\n      channel.setBkgData(bkgData);\n      this.lastCmdA = a;\n      this.lastCmdB = b;\n      return true;\n    },\n\n    /**\n    * Reset state of parser and its channels.\n    */\n    reset: function reset() {\n      for (var i = 0; i < this.channels.length; i++) {\n        if (this.channels[i]) {\n          this.channels[i].reset();\n        }\n      }\n\n      this.lastCmdA = null;\n      this.lastCmdB = null;\n    },\n\n    /**\n    * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n    */\n    cueSplitAtTime: function cueSplitAtTime(t) {\n      for (var i = 0; i < this.channels.length; i++) {\n        if (this.channels[i]) {\n          this.channels[i].cueSplitAtTime(t);\n        }\n      }\n    }\n  };\n  /**\n  * Find ranges corresponding to SEA CEA-608 NALUS in sizeprepended NALU array.\n  * @param {raw} dataView of binary data\n  * @param {startPos} start position in raw\n  * @param {size} total size of data in raw to consider\n  * @returns \n  */\n\n  var findCea608Nalus = function findCea608Nalus(raw, startPos, size) {\n    var nalSize = 0,\n        cursor = startPos,\n        nalType = 0,\n        cea608NaluRanges = [],\n        // Check SEI data according to ANSI-SCTE 128\n    isCEA608SEI = function isCEA608SEI(payloadType, payloadSize, raw, pos) {\n      if (payloadType !== 4 || payloadSize < 8) {\n        return null;\n      }\n\n      var countryCode = raw.getUint8(pos);\n      var providerCode = raw.getUint16(pos + 1);\n      var userIdentifier = raw.getUint32(pos + 3);\n      var userDataTypeCode = raw.getUint8(pos + 7);\n      return countryCode == 0xB5 && providerCode == 0x31 && userIdentifier == 0x47413934 && userDataTypeCode == 0x3;\n    };\n\n    while (cursor < startPos + size) {\n      nalSize = raw.getUint32(cursor);\n      nalType = raw.getUint8(cursor + 4) & 0x1F; //console.log(time + \"  NAL \" + nalType);\n\n      if (nalType === 6) {\n        // SEI NAL Unit. The NAL header is the first byte\n        //console.log(\"SEI NALU of size \" + nalSize + \" at time \" + time);\n        var pos = cursor + 5;\n        var payloadType = -1;\n\n        while (pos < cursor + 4 + nalSize - 1) {\n          // The last byte should be rbsp_trailing_bits\n          payloadType = 0;\n          var b = 0xFF;\n\n          while (b === 0xFF) {\n            b = raw.getUint8(pos);\n            payloadType += b;\n            pos++;\n          }\n\n          var payloadSize = 0;\n          b = 0xFF;\n\n          while (b === 0xFF) {\n            b = raw.getUint8(pos);\n            payloadSize += b;\n            pos++;\n          }\n\n          if (isCEA608SEI(payloadType, payloadSize, raw, pos)) {\n            //console.log(\"CEA608 SEI \" + time + \" \" + payloadSize);\n            cea608NaluRanges.push([pos, payloadSize]);\n          }\n\n          pos += payloadSize;\n        }\n      }\n\n      cursor += nalSize + 4;\n    }\n\n    return cea608NaluRanges;\n  };\n\n  var extractCea608DataFromRange = function extractCea608DataFromRange(raw, cea608Range) {\n    var pos = cea608Range[0];\n    var fieldData = [[], []];\n    pos += 8; // Skip the identifier up to userDataTypeCode\n\n    var ccCount = raw.getUint8(pos) & 0x1f;\n    pos += 2; // Advance 1 and skip reserved byte\n\n    for (var i = 0; i < ccCount; i++) {\n      var byte = raw.getUint8(pos);\n      var ccValid = byte & 0x4;\n      var ccType = byte & 0x3;\n      pos++;\n      var ccData1 = raw.getUint8(pos); // Keep parity bit\n\n      pos++;\n      var ccData2 = raw.getUint8(pos); // Keep parity bit\n\n      pos++;\n\n      if (ccValid && (ccData1 & 0x7f) + (ccData2 & 0x7f) !== 0) {\n        //Check validity and non-empty data\n        if (ccType === 0) {\n          fieldData[0].push(ccData1);\n          fieldData[0].push(ccData2);\n        } else if (ccType === 1) {\n          fieldData[1].push(ccData1);\n          fieldData[1].push(ccData2);\n        }\n      }\n    }\n\n    return fieldData;\n  };\n\n  exports.logger = logger;\n  exports.PenState = PenState;\n  exports.CaptionScreen = CaptionScreen;\n  exports.Cea608Parser = Cea608Parser;\n  exports.findCea608Nalus = findCea608Nalus;\n  exports.extractCea608DataFromRange = extractCea608DataFromRange;\n})(typeof exports === 'undefined' ? undefined.cea608parser = {} : exports);","map":{"version":3,"mappings":"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","names":["exports","specialCea608CharsCodes","getCharForByte","byte","charCode","hasOwnProperty","String","fromCharCode","NR_ROWS","NR_COLS","rowsLowCh1","rowsHighCh1","rowsLowCh2","rowsHighCh2","backgroundColors","logger","verboseFilter","time","verboseLevel","setTime","newTime","log","severity","msg","minLevel","console","numArrayToHexArray","numArray","hexArray","j","length","push","toString","PenState","foreground","underline","italics","background","flash","prototype","reset","setStyles","styles","attribs","i","style","isDefault","equals","other","copy","newPenState","StyledUnicodeChar","uchar","penState","setChar","setPenState","newChar","isEmpty","Row","chars","pos","currPenState","equal","empty","setCursor","absPos","moveCursor","relPos","newPos","backSpace","insertChar","char","clearFromPos","startPos","clear","clearToEndOfRow","getTextString","join","setPenStyles","currChar","CaptionScreen","rows","currRow","nrRollUpRows","row","setPen","setPAC","pacData","JSON","stringify","newRow","indent","prevPos","Math","max","color","setBkgData","bkgData","setRollUpRows","nrRows","rollUp","getDisplayText","topRowIndex","topRow","splice","asOneRow","displayText","text","rowNr","rowText","trim","getTextAndFormat","Cea608Channel","channelNumber","outputFilter","chNr","mode","verbose","displayedMemory","nonDisplayedMemory","lastOutputScreen","currRollUpRow","writeScreen","cueStartTime","modes","lastCueEndTime","getHandler","setHandler","newHandler","setMode","newMode","insertChars","screen","outputDataUpdate","cc_RCL","cc_BS","cc_AOF","cc_AON","cc_DER","cc_RU","cc_FON","cc_RDC","cc_TR","cc_RTD","cc_EDM","cc_CR","cc_ENM","cc_EOC","tmp","cc_TO","nrCols","cc_MIDROW","secondByte","colorIndex","floor","colors","t","updateData","newCue","cueSplitAtTime","Cea608Parser","field","out1","out2","outputs","channels","currChNr","lastCmdA","lastCmdB","bufferedData","startTime","lastTime","dataCounters","index","addData","byteList","cmdFound","a","b","charsFound","padding","parseCmd","parseMidrow","parsePAC","parseBackgroundAttributes","parseChars","channel","cmd","cond1","cond2","case1","case2","interpretPAC","pacIndex","channelNr","charCodes","charCode1","charCode2","oneCode","hexCodes","findCea608Nalus","raw","size","nalSize","cursor","nalType","cea608NaluRanges","isCEA608SEI","payloadType","payloadSize","countryCode","getUint8","providerCode","getUint16","userIdentifier","getUint32","userDataTypeCode","extractCea608DataFromRange","cea608Range","fieldData","ccCount","ccValid","ccType","ccData1","ccData2","undefined","cea608parser"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/externals/cea608-parser.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n(function(exports) {\n\n    \"use strict\";\n\n    /**\n     *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n     */\n\n    var specialCea608CharsCodes = {\n        0x2a : 0xe1, // lowercase a, acute accent\n        0x5c : 0xe9, // lowercase e, acute accent\n        0x5e : 0xed, // lowercase i, acute accent\n        0x5f : 0xf3, // lowercase o, acute accent\n        0x60 : 0xfa, // lowercase u, acute accent\n        0x7b : 0xe7, // lowercase c with cedilla\n        0x7c : 0xf7, // division symbol\n        0x7d : 0xd1, // uppercase N tilde\n        0x7e : 0xf1, // lowercase n tilde\n        0x7f : 0x2588, // Full block\n        // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n        // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n        // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n        0x80 : 0xae, // Registered symbol (R)\n        0x81 : 0xb0, // degree sign\n        0x82 : 0xbd, // 1/2 symbol\n        0x83 : 0xbf, // Inverted (open) question mark\n        0x84 : 0x2122, // Trademark symbol (TM)\n        0x85 : 0xa2, // Cents symbol\n        0x86 : 0xa3, // Pounds sterling\n        0x87 : 0x266a, // Music 8'th note\n        0x88 : 0xe0, // lowercase a, grave accent\n        0x89 : 0x20, // transparent space (regular)\n        0x8a : 0xe8, // lowercase e, grave accent\n        0x8b : 0xe2, // lowercase a, circumflex accent\n        0x8c : 0xea, // lowercase e, circumflex accent\n        0x8d : 0xee, // lowercase i, circumflex accent\n        0x8e : 0xf4, // lowercase o, circumflex accent\n        0x8f : 0xfb, // lowercase u, circumflex accent\n        // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n        // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n        0x90 : 0xc1, // capital letter A with acute\n        0x91 : 0xc9, // capital letter E with acute\n        0x92 : 0xd3, // capital letter O with acute\n        0x93 : 0xda, // capital letter U with acute\n        0x94 : 0xdc, // capital letter U with diaresis\n        0x95 : 0xfc, // lowercase letter U with diaeresis\n        0x96 : 0x2018, // opening single quote\n        0x97 : 0xa1, // inverted exclamation mark\n        0x98 : 0x2a, // asterisk\n        0x99 : 0x2019, // closing single quote\n        0x9a : 0x2501, // box drawings heavy horizontal\n        0x9b : 0xa9, // copyright sign\n        0x9c : 0x2120, // Service mark\n        0x9d : 0x2022, // (round) bullet\n        0x9e : 0x201c, // Left double quotation mark\n        0x9f : 0x201d, // Right double quotation mark\n        0xa0 : 0xc0, // uppercase A, grave accent\n        0xa1 : 0xc2, // uppercase A, circumflex\n        0xa2 : 0xc7, // uppercase C with cedilla\n        0xa3 : 0xc8, // uppercase E, grave accent\n        0xa4 : 0xca, // uppercase E, circumflex\n        0xa5 : 0xcb, // capital letter E with diaresis\n        0xa6 : 0xeb, // lowercase letter e with diaresis\n        0xa7 : 0xce, // uppercase I, circumflex\n        0xa8 : 0xcf, // uppercase I, with diaresis\n        0xa9 : 0xef, // lowercase i, with diaresis\n        0xaa : 0xd4, // uppercase O, circumflex\n        0xab : 0xd9, // uppercase U, grave accent\n        0xac : 0xf9, // lowercase u, grave accent\n        0xad : 0xdb, // uppercase U, circumflex\n        0xae : 0xab, // left-pointing double angle quotation mark\n        0xaf : 0xbb, // right-pointing double angle quotation mark\n        // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n        // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n        0xb0 : 0xc3, // Uppercase A, tilde\n        0xb1 : 0xe3, // Lowercase a, tilde\n        0xb2 : 0xcd, // Uppercase I, acute accent\n        0xb3 : 0xcc, // Uppercase I, grave accent\n        0xb4 : 0xec, // Lowercase i, grave accent\n        0xb5 : 0xd2, // Uppercase O, grave accent\n        0xb6 : 0xf2, // Lowercase o, grave accent\n        0xb7 : 0xd5, // Uppercase O, tilde\n        0xb8 : 0xf5, // Lowercase o, tilde\n        0xb9 : 0x7b, // Open curly brace\n        0xba : 0x7d, // Closing curly brace\n        0xbb : 0x5c, // Backslash\n        0xbc : 0x5e, // Caret\n        0xbd : 0x5f, // Underscore\n        0xbe : 0x7c, // Pipe (vertical line)\n        0xbf : 0x223c, // Tilde operator\n        0xc0 : 0xc4, // Uppercase A, umlaut\n        0xc1 : 0xe4, // Lowercase A, umlaut\n        0xc2 : 0xd6, // Uppercase O, umlaut\n        0xc3 : 0xf6, // Lowercase o, umlaut\n        0xc4 : 0xdf, // Esszett (sharp S)\n        0xc5 : 0xa5, // Yen symbol\n        0xc6 : 0xa4, // Generic currency sign\n        0xc7 : 0x2503, // Box drawings heavy vertical\n        0xc8 : 0xc5, // Uppercase A, ring\n        0xc9 : 0xe5, // Lowercase A, ring\n        0xca : 0xd8, // Uppercase O, stroke\n        0xcb : 0xf8, // Lowercase o, strok\n        0xcc : 0x250f, // Box drawings heavy down and right\n        0xcd : 0x2513, // Box drawings heavy down and left\n        0xce : 0x2517, // Box drawings heavy up and right\n        0xcf : 0x251b // Box drawings heavy up and left\n    };\n\n    /**\n     * Get Unicode Character from CEA-608 byte code\n     */\n    var getCharForByte = function(byte) {\n        var charCode = byte;\n        if (specialCea608CharsCodes.hasOwnProperty(byte)) {\n            charCode = specialCea608CharsCodes[byte];\n        }\n        return String.fromCharCode(charCode);\n    };\n\n    var NR_ROWS = 15,\n        NR_COLS = 32;\n    // Tables to look up row from PAC data\n    var rowsLowCh1 = {0x11 : 1, 0x12 : 3, 0x15 : 5, 0x16 : 7, 0x17 : 9, 0x10 : 11, 0x13 : 12, 0x14 : 14};\n    var rowsHighCh1 = {0x11 : 2, 0x12 : 4, 0x15 : 6, 0x16 : 8, 0x17 : 10, 0x13 : 13, 0x14 : 15};\n    var rowsLowCh2 = {0x19 : 1, 0x1A : 3, 0x1D : 5, 0x1E : 7, 0x1F : 9, 0x18 : 11, 0x1B : 12, 0x1C : 14};\n    var rowsHighCh2 = {0x19 : 2, 0x1A : 4, 0x1D : 6, 0x1E : 8, 0x1F : 10, 0x1B : 13, 0x1C : 15};\n\n    var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\n\n    /**\n     * Simple logger class to be able to write with time-stamps and filter on level.\n     */\n    var logger = {\n        verboseFilter : {'DATA' : 3, 'DEBUG' : 3, 'INFO' : 2, 'WARNING' : 2, 'TEXT' : 1, 'ERROR' : 0},\n        time : null,\n        verboseLevel : 0, // Only write errors\n        setTime : function(newTime) {\n            this.time = newTime;\n        },\n        log : function(severity, msg) {\n            var minLevel = this.verboseFilter[severity];\n            if (this.verboseLevel >= minLevel) {\n                console.log(this.time + \" [\" + severity + \"] \" + msg);\n            }\n        }\n    };\n\n    var numArrayToHexArray = function(numArray) {\n        var hexArray = [];\n        for (var j = 0; j < numArray.length; j++) {\n            hexArray.push(numArray[j].toString(16));\n        }\n        return hexArray;\n    };\n\n    /**\n     * State of CEA-608 pen or character\n     * @constructor\n     */\n    var PenState = function(foreground, underline, italics, background, flash) {\n        this.foreground = foreground || \"white\";\n        this.underline = underline || false;\n        this.italics = italics || false;\n        this.background = background || \"black\";\n        this.flash = flash || false;\n    };\n\n    PenState.prototype = {\n        \n        reset : function() {\n            this.foreground = \"white\";\n            this.underline = false;\n            this.italics = false;\n            this.background = \"black\";\n            this.flash = false;\n        },\n        \n        setStyles : function(styles) {\n            var attribs = [\"foreground\", \"underline\", \"italics\", \"background\", \"flash\"];\n            for (var i = 0 ; i < attribs.length; i++) {\n                var style = attribs[i];\n                if (styles.hasOwnProperty(style)) {\n                    this[style] = styles[style];\n                }\n            }\n        },\n        \n        isDefault : function() {\n            return (this.foreground === \"white\" && !this.underline && !this.italics && \n                    this.background === \"black\" && !this.flash);\n        },\n\n        equals : function(other) {\n            return ( (this.foreground === other.foreground) && \n                     (this.underline === other.underline) &&\n                     (this.italics === other.italics) &&\n                     (this.background === other.background) &&\n                     (this.flash === other.flash) );\n        },\n\n        copy : function(newPenState) {\n            this.foreground = newPenState.foreground;\n            this.underline = newPenState.underline;\n            this.italics = newPenState.italics;\n            this.background = newPenState.background;\n            this.flash = newPenState.flash;\n        },\n        \n        toString: function() {\n            return (\"color=\" + this.foreground + \", underline=\" + this.underline + \", italics=\" + this.italics +\n                \", background=\" + this.background + \", flash=\" + this.flash);\n        }\n    };\n\n    /**\n     * Unicode character with styling and background.\n     * @constructor\n     */\n    var StyledUnicodeChar = function(uchar, foreground, underline, italics, background, flash) {\n        this.uchar = uchar || ' '; // unicode character\n        this.penState = new PenState(foreground, underline,italics, background, flash);\n    };\n\n    StyledUnicodeChar.prototype = {\n        \n        reset: function() {\n            this.uchar = ' ';\n            this.penState.reset();\n        },\n        \n        setChar: function(uchar, newPenState) {\n            this.uchar = uchar;\n            this.penState.copy(newPenState);\n        },\n        \n        setPenState: function(newPenState) {\n            this.penState.copy(newPenState);\n        },\n        \n        equals: function(other) {\n            return this.uchar === other.uchar && this.penState.equals(other.penState);\n        },\n        \n        copy: function(newChar) {\n            this.uchar = newChar.uchar;\n            this.penState.copy(newChar.penState);\n        },\n        \n        isEmpty : function() {\n            return this.uchar === ' ' && this.penState.isDefault();\n        }\n    };\n\n    /**\n     * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n     * @constructor\n     */\n    var Row = function() {\n        this.chars = [];\n        for (var i = 0 ; i < NR_COLS ; i++) {\n            this.chars.push(new StyledUnicodeChar());\n        }\n        this.pos = 0;\n        this.currPenState = new PenState();\n    };\n\n    Row.prototype = {\n        \n        equals: function(other) {\n            var equal = true;\n            for (var i = 0 ; i < NR_COLS; i ++) {\n                if (!this.chars[i].equals(other.chars[i])) {\n                    equal = false;\n                    break;\n                }\n            }\n            return equal;\n        },\n        \n        copy: function(other) {\n            for (var i = 0 ; i < NR_COLS; i ++) {\n                this.chars[i].copy(other.chars[i]);\n            }\n        },\n        \n        isEmpty : function() {\n            var empty = true;\n            for (var i = 0 ; i < NR_COLS; i ++) {\n                if (!this.chars[i].isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n            return empty;\n        },\n\n        /**\n         *  Set the cursor to a valid column.\n         */\n        setCursor : function(absPos) {\n            if (this.pos !== absPos) {\n                this.pos = absPos;\n            }\n            if (this.pos < 0) {\n                logger.log(\"ERROR\", \"Negative cursor position \" + this.pos);\n                this.pos = 0;\n            } else if (this.pos > NR_COLS) {\n                logger.log(\"ERROR\", \"Too large cursor position \" + this.pos);\n                this.pos = NR_COLS;\n            }\n        },\n\n        /** \n         * Move the cursor relative to current position.\n         */\n        moveCursor : function(relPos) {\n            var newPos = this.pos + relPos;\n            if (relPos > 1) {\n                for (var i = this.pos+1; i < newPos+1 ; i++) {\n                    this.chars[i].setPenState(this.currPenState);\n                }\n            }\n            this.setCursor(newPos);\n        },\n\n        /**\n         * Backspace, move one step back and clear character.\n         */\n        backSpace : function () {\n            this.moveCursor(-1);\n            this.chars[this.pos].setChar(' ', this.currPenState);\n        },\n\n        insertChar: function(byte) {\n            if (byte >= 0x90) { //Extended char\n                this.backSpace();\n            }\n            var char = getCharForByte(byte);\n            if (this.pos >= NR_COLS) {\n                logger.log(\"ERROR\", \"Cannot insert \" + byte.toString(16) +  \n                            \" (\" + char + \") at position \" + this.pos + \". Skipping it!\");\n                return;\n            }\n            this.chars[this.pos].setChar(char, this.currPenState);\n            this.moveCursor(1);\n        },\n\n        clearFromPos : function(startPos) {\n            var i;\n            for (i = startPos ; i < NR_COLS ; i++) {\n                this.chars[i].reset();\n            }\n        },\n\n        clear : function() {\n            this.clearFromPos(0);\n            this.pos = 0;\n            this.currPenState.reset();\n        },\n\n        clearToEndOfRow : function() {\n            this.clearFromPos(this.pos);\n        },\n\n        getTextString: function() {\n            var chars = [];\n            var empty = true;\n            for (var i = 0 ; i < NR_COLS ; i++) {\n                var char = this.chars[i].uchar;\n                if (char !== \" \") {\n                    empty = false;\n                }\n                chars.push(char);\n            }\n            if (empty) {\n                return \"\";\n            } else {\n                return chars.join(\"\");\n            }\n        },\n\n        setPenStyles: function(styles) {\n            this.currPenState.setStyles(styles);\n            var currChar = this.chars[this.pos];\n            currChar.setPenState(this.currPenState);\n        }\n    };\n\n    /**\n     * Keep a CEA-608 screen of 32x15 styled characters\n     * @constructor\n    */\n    var CaptionScreen = function() {\n\n        this.rows = [];\n        for (var i = 0 ; i <  NR_ROWS; i++) {\n            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)\n        }\n        this.currRow = NR_ROWS - 1;\n        this.nrRollUpRows = null;\n        this.reset();\n    };\n\n    CaptionScreen.prototype = {\n\n        reset : function() {\n            for (var i = 0 ; i < NR_ROWS ; i++) {\n                this.rows[i].clear();\n            }\n            this.currRow = NR_ROWS - 1;\n        },\n\n        equals : function(other) {\n            var equal = true;\n            for (var i = 0 ; i < NR_ROWS ; i++) {\n                if (!this.rows[i].equals(other.rows[i])) {\n                    equal = false;\n                    break;\n                }\n            }\n            return equal;\n        },\n\n        copy : function(other) {\n            for (var i = 0 ; i < NR_ROWS ; i++) {\n                this.rows[i].copy(other.rows[i]);\n            }\n        },\n\n        isEmpty : function() {\n            var empty = true;\n            for (var i = 0 ; i < NR_ROWS ; i++) {\n                if (!this.rows[i].isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n            return empty;\n        },\n\n        backSpace : function() {\n            var row = this.rows[this.currRow]; \n            row.backSpace();\n        },\n\n        clearToEndOfRow : function() {\n            var row = this.rows[this.currRow];\n            row.clearToEndOfRow();\n        },\n\n        /**\n         * Insert a character (without styling) in the current row.\n         */\n        insertChar : function(char) {\n            var row = this.rows[this.currRow];\n            row.insertChar(char);\n        },\n\n        setPen : function(styles) {\n            var row = this.rows[this.currRow];\n            row.setPenStyles(styles);\n        },\n\n        moveCursor : function(relPos) {\n            var row = this.rows[this.currRow];\n            row.moveCursor(relPos); \n        },\n\n        setCursor : function(absPos) {\n            logger.log(\"INFO\", \"setCursor: \" + absPos);\n            var row = this.rows[this.currRow];\n            row.setCursor(absPos);\n        },\n\n        setPAC : function(pacData) {\n            logger.log(\"INFO\", \"pacData = \" + JSON.stringify(pacData));\n            var newRow = pacData.row - 1;\n            if (this.nrRollUpRows  && newRow < this.nrRollUpRows - 1) {\n                    newRow = this.nrRollUpRows-1;\n            }\n            this.currRow = newRow;\n            var row = this.rows[this.currRow];\n            if (pacData.indent !== null) {\n                var indent = pacData.indent;\n                var prevPos = Math.max(indent-1, 0);\n                row.setCursor(pacData.indent);\n                pacData.color = row.chars[prevPos].penState.foreground;\n            }\n            var styles = {foreground : pacData.color, underline : pacData.underline, italics : pacData.italics, background : 'black', flash : false};\n            this.setPen(styles);\n        },\n\n        /**\n         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n         */\n        setBkgData : function(bkgData) {\n\n            logger.log(\"INFO\", \"bkgData = \" + JSON.stringify(bkgData));\n            this.backSpace();\n            this.setPen(bkgData);\n            this.insertChar(0x20); //Space\n        },\n\n        setRollUpRows : function(nrRows) {\n            this.nrRollUpRows = nrRows;\n        },\n\n        rollUp : function() {\n            if (this.nrRollUpRows === null) {\n                logger.log(\"DEBUG\", \"roll_up but nrRollUpRows not set yet\");\n                return; //Not properly setup\n            }\n            logger.log(\"TEXT\", this.getDisplayText());\n            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n            var topRow = this.rows.splice(topRowIndex, 1)[0];\n            topRow.clear();\n            this.rows.splice(this.currRow, 0, topRow);\n            logger.log(\"INFO\", \"Rolling up\");\n            //logger.log(\"TEXT\", this.get_display_text())\n        },\n\n       /**\n        * Get all non-empty rows with as unicode text. \n        */        \n        getDisplayText : function(asOneRow) {\n            asOneRow = asOneRow || false;\n            var displayText = [];\n            var text = \"\";\n            var rowNr = -1;\n            for (var i = 0 ; i < NR_ROWS ; i++) {\n                var rowText = this.rows[i].getTextString();\n                if (rowText) {\n                    rowNr = i+1;\n                    if (asOneRow) {\n                        displayText.push(\"Row \" + rowNr + ': \"' + rowText + '\"');\n                    } else {\n                        displayText.push(rowText.trim());\n                    }\n                }\n            }\n            if (displayText.length > 0) {\n                if (asOneRow) {\n                    text = \"[\" + displayText.join(\" | \") + \"]\";\n                } else {\n                    text = displayText.join(\"\\n\");\n                }\n            }\n            return text;\n        },\n\n        getTextAndFormat : function() {\n            return this.rows;\n        }\n    };\n\n    /**\n     * Handle a CEA-608 channel and send decoded data to outputFilter\n     * @constructor\n     * @param {Number} channelNumber (1 or 2)\n     * @param {CueHandler} outputFilter Output from channel1 newCue(startTime, endTime, captionScreen)\n    */\n    var Cea608Channel = function(channelNumber, outputFilter) {\n\n        this.chNr = channelNumber;\n        this.outputFilter = outputFilter;\n        this.mode = null;\n        this.verbose = 0;\n        this.displayedMemory = new CaptionScreen();\n        this.nonDisplayedMemory = new CaptionScreen();\n        this.lastOutputScreen = new CaptionScreen();\n        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS-1];\n        this.writeScreen = this.displayedMemory;\n        this.mode = null;\n        this.cueStartTime = null; // Keeps track of where a cue started.\n    };\n\n    Cea608Channel.prototype = {\n        \n        modes : [\"MODE_ROLL-UP\", \"MODE_POP-ON\", \"MODE_PAINT-ON\", \"MODE_TEXT\"],\n        \n        reset : function() {\n            this.mode = null;\n            this.displayedMemory.reset();\n            this.nonDisplayedMemory.reset();\n            this.lastOutputScreen.reset();\n            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS-1];\n            this.writeScreen = this.displayedMemory;\n            this.mode = null;\n            this.cueStartTime = null;\n            this.lastCueEndTime = null;\n        },\n\n        getHandler : function() {\n            return this.outputFilter;\n        },\n\n        setHandler : function(newHandler) {\n            this.outputFilter = newHandler;\n        },\n\n        setPAC : function(pacData) {\n            this.writeScreen.setPAC(pacData);\n        },\n\n        setBkgData : function(bkgData) {\n            this.writeScreen.setBkgData(bkgData);\n        },\n\n        setMode : function(newMode) {\n            if (newMode === this.mode) {\n                return;\n            }\n            this.mode = newMode;\n            logger.log(\"INFO\", \"MODE=\" + newMode);\n            if (this.mode == \"MODE_POP-ON\") {\n                this.writeScreen = this.nonDisplayedMemory;\n            } else {\n                this.writeScreen = this.displayedMemory;\n                this.writeScreen.reset();\n            }\n            if (this.mode !== \"MODE_ROLL-UP\") {\n                this.displayedMemory.nrRollUpRows = null;\n                this.nonDisplayedMemory.nrRollUpRows = null;\n            }\n            this.mode = newMode;\n        },\n\n        insertChars : function(chars) {\n            for (var i = 0 ; i < chars.length ; i++) {\n                this.writeScreen.insertChar(chars[i]);\n            }\n            var screen = this.writeScreen === this.displayedMemory ? \"DISP\" : \"NON_DISP\";\n            logger.log(\"INFO\", screen + \": \" + this.writeScreen.getDisplayText(true));\n            if (this.mode === \"MODE_PAINT-ON\" || this.mode === \"MODE_ROLL-UP\") {\n                logger.log(\"TEXT\", \"DISPLAYED: \" + this.displayedMemory.getDisplayText(true));\n                this.outputDataUpdate();\n            }\n        },\n\n        cc_RCL: function() { // Resume Caption Loading (switch mode to Pop On)\n            logger.log(\"INFO\", \"RCL - Resume Caption Loading\");\n            this.setMode(\"MODE_POP-ON\");\n        },\n        cc_BS: function() { // BackSpace\n            logger.log(\"INFO\", \"BS - BackSpace\");\n            if (this.mode === \"MODE_TEXT\") {\n                return;\n            }\n            this.writeScreen.backSpace();\n            if (this.writeScreen === this.displayedMemory) {\n                this.outputDataUpdate();\n            }\n        },\n        cc_AOF : function() { // Reserved (formerly Alarm Off)\n            return;\n        },\n        cc_AON: function() { // Reserved (formerly Alarm On)\n            return;\n        },\n        cc_DER: function() { // Delete to End of Row\n            logger.log(\"INFO\", \"DER- Delete to End of Row\");\n            this.writeScreen.clearToEndOfRow();\n            this.outputDataUpdate();\n        },\n        cc_RU: function(nrRows) { //Roll-Up Captions-2,3,or 4 Rows\n            logger.log(\"INFO\", \"RU(\" + nrRows +\") - Roll Up\");\n            this.writeScreen = this.displayedMemory;\n            this.setMode(\"MODE_ROLL-UP\");\n            this.writeScreen.setRollUpRows(nrRows);\n        },\n        cc_FON: function() { //Flash On\n            logger.log(\"INFO\", \"FON - Flash On\");\n            this.writeScreen.setPen({flash : true});\n        },\n        cc_RDC: function() { // Resume Direct Captioning (switch mode to PaintOn)\n            logger.log(\"INFO\", \"RDC - Resume Direct Captioning\");\n            this.setMode(\"MODE_PAINT-ON\");\n        },\n        cc_TR: function() { // Text Restart in text mode (not supported, however)\n            logger.log(\"INFO\", \"TR\");\n            this.setMode(\"MODE_TEXT\");\n        },\n        cc_RTD: function() { // Resume Text Display in Text mode (not supported, however)\n            logger.log(\"INFO\", \"RTD\");\n            this.setMode(\"MODE_TEXT\");\n        },\n        cc_EDM: function() { // Erase Displayed Memory\n            logger.log(\"INFO\", \"EDM - Erase Displayed Memory\");\n            this.displayedMemory.reset();\n            this.outputDataUpdate();\n        },\n        cc_CR: function() { // Carriage Return\n            logger.log(\"CR - Carriage Return\");\n            this.writeScreen.rollUp();\n            this.outputDataUpdate();\n        },\n        cc_ENM: function() { //Erase Non-Displayed Memory\n            logger.log(\"INFO\", \"ENM - Erase Non-displayed Memory\");\n            this.nonDisplayedMemory.reset();\n        },\n        cc_EOC: function() { //End of Caption (Flip Memories)\n            logger.log(\"INFO\", \"EOC - End Of Caption\");\n            if (this.mode === \"MODE_POP-ON\") {\n                var tmp = this.displayedMemory;\n                this.displayedMemory = this.nonDisplayedMemory;\n                this.nonDisplayedMemory = tmp;\n                this.writeScreen = this.nonDisplayedMemory;\n                logger.log(\"TEXT\", \"DISP: \" + this.displayedMemory.getDisplayText());\n            }\n            this.outputDataUpdate();\n        },\n        cc_TO: function(nrCols) { // Tab Offset 1,2, or 3 columns\n            logger.log(\"INFO\", \"TO(\" + nrCols + \") - Tab Offset\");\n            this.writeScreen.moveCursor(nrCols);\n        },\n        cc_MIDROW: function(secondByte) { // Parse MIDROW command\n            var styles = {flash : false};\n            styles.underline = secondByte % 2 === 1;\n            styles.italics = secondByte >= 0x2e;\n            if (!styles.italics) {\n                var colorIndex = Math.floor(secondByte/2) - 0x10;\n                var colors = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\"];\n                styles.foreground = colors[colorIndex];\n            } else {\n                styles.foreground = \"white\";\n            }\n            logger.log(\"INFO\", \"MIDROW: \" + JSON.stringify(styles));\n            this.writeScreen.setPen(styles);\n        },\n\n        outputDataUpdate: function() {\n            var t = logger.time;\n            if (t === null) {\n                return;\n            }\n            if (this.outputFilter) {\n                if (this.outputFilter.updateData) {\n                    this.outputFilter.updateData(t, this.displayedMemory);\n                }\n                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) { // Start of a new cue\n                    this.cueStartTime = t;\n                } else {\n                    if (!this.displayedMemory.equals(this.lastOutputScreen)) { \n                        if (this.outputFilter.newCue) {\n                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);\n                        }\n                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;\n                    }\n                }\n                this.lastOutputScreen.copy(this.displayedMemory);\n            }\n        },\n\n        cueSplitAtTime : function(t) {\n            if (this.outputFilter) {\n                if (!this.displayedMemory.isEmpty()) {\n                    if (this.outputFilter.newCue) {\n                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n                    }\n                    this.cueStartTime = t;\n                }\n            }\n        }\n    };\n\n    /**\n     * Parse CEA-608 data and send decoded data to out1 and out2.\n     * @constructor\n     * @param {Number} field  CEA-608 field (1 or 2)\n     * @param {CueHandler} out1 Output from channel1 newCue(startTime, endTime, captionScreen)\n     * @param {CueHandler} out2 Output from channel2 newCue(startTime, endTime, captionScreen)\n     */\n    var Cea608Parser = function(field, out1, out2) {\n        this.field = field || 1;\n        this.outputs = [out1, out2];\n        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];\n        this.currChNr = -1; // Will be 1 or 2\n        this.lastCmdA = null; // First byte of last command\n        this.lastCmdB = null; // Second byte of last command\n        this.bufferedData = [];\n        this.startTime = null;\n        this.lastTime = null;\n        this.dataCounters = {'padding' : 0, 'char' : 0, 'cmd' : 0, 'other' : 0};\n    };\n\n    Cea608Parser.prototype = {\n        \n        getHandler : function(index) {\n            return this.channels[index].getHandler();\n        },\n        \n        setHandler : function(index, newHandler) {\n            this.channels[index].setHandler(newHandler);\n        },\n\n        /**\n         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n         */\n        addData : function(t, byteList) {\n            var cmdFound, a, b, \n            charsFound = false;\n            \n            this.lastTime = t;\n            logger.setTime(t);\n\n            for (var i = 0 ; i < byteList.length ; i+=2) {\n                a = byteList[i] & 0x7f;\n                b = byteList[i+1] & 0x7f;\n\n                if (a >= 0x10 && a <= 0x1f && a === this.lastCmdA && b === this.lastCmdB) {\n                    this.lastCmdA = null;\n                    this.lastCmdB = null;\n                    logger.log(\"DEBUG\", \"Repeated command (\" + numArrayToHexArray([a, b]) + \") is dropped\");\n                    continue; // Repeated commands are dropped (once)\n                }\n\n                if (a === 0 && b === 0) {\n                    this.dataCounters.padding += 2;\n                    continue;\n                } else {\n                    logger.log(\"DATA\", \"[\" + numArrayToHexArray([byteList[i], byteList[i+1]]) +\"] -> (\" + numArrayToHexArray([a, b]) + \")\");\n                }\n                cmdFound = this.parseCmd(a, b);\n                if (!cmdFound) {\n                    cmdFound = this.parseMidrow(a, b);\n                }\n                if (!cmdFound) {\n                    cmdFound = this.parsePAC(a, b);\n                }\n                if (!cmdFound) {\n                    cmdFound = this.parseBackgroundAttributes(a, b);\n                }\n                if (!cmdFound) {\n                    charsFound = this.parseChars(a, b);\n                    if (charsFound) {\n                        if (this.currChNr && this.currChNr >=0) {\n                            var channel = this.channels[this.currChNr-1];\n                            channel.insertChars(charsFound);\n                        } else {\n                            logger.log(\"WARNING\", \"No channel found yet. TEXT-MODE?\");\n                        }\n                    }\n                }\n                if (cmdFound) {\n                    this.dataCounters.cmd += 2;\n                } else if (charsFound) {\n                    this.dataCounters.char += 2;\n                } else {\n                    this.dataCounters.other += 2;\n                    logger.log(\"WARNING\", \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) +\n                                \" orig: \" + numArrayToHexArray([byteList[i], byteList[i+1]]));\n                }\n            }\n        },\n\n        /**\n         * Parse Command.\n         * @returns {Boolean} Tells if a command was found\n         */\n        parseCmd: function(a, b) {\n            var chNr = null;\n\n            var cond1 = (a === 0x14 || a === 0x15 || a === 0x1C || a === 0x1D) && (0x20 <= b && b <= 0x2F);\n            var cond2 = (a === 0x17 || a === 0x1F) && (0x21 <= b && b <= 0x23);\n            if (!(cond1 || cond2)) {\n                return false;\n            }\n                 \n            if (a === 0x14 || a === 0x15 || a === 0x17) {\n                chNr = 1;\n            } else {\n                chNr = 2; // (a === 0x1C || a === 0x1D || a=== 0x1f)\n            }\n\n            var channel = this.channels[chNr - 1];\n\n            if (a === 0x14 || a === 0x15 || a === 0x1C || a === 0x1D) {\n                if (b === 0x20) {\n                    channel.cc_RCL();\n                } else if (b === 0x21) {\n                    channel.cc_BS();\n                } else if (b === 0x22) {\n                    channel.cc_AOF();\n                } else if (b === 0x23) {\n                    channel.cc_AON();\n                } else if (b === 0x24) {\n                    channel.cc_DER();\n                } else if (b === 0x25) {\n                    channel.cc_RU(2);\n                } else if (b === 0x26) {\n                    channel.cc_RU(3);\n                } else if (b === 0x27) {\n                    channel.cc_RU(4);\n                } else if (b === 0x28) {\n                    channel.cc_FON();\n                } else if (b === 0x29) {\n                    channel.cc_RDC();\n                } else if (b === 0x2A) {\n                    channel.cc_TR();\n                } else if (b === 0x2B) {\n                    channel.cc_RTD();\n                } else if (b === 0x2C) {\n                    channel.cc_EDM();\n                } else if (b === 0x2D) {\n                    channel.cc_CR();\n                } else if (b === 0x2E) {\n                    channel.cc_ENM();\n                } else if (b === 0x2F) {\n                    channel.cc_EOC();\n                }\n            } else { //a == 0x17 || a == 0x1F\n                channel.cc_TO(b - 0x20);\n            }\n            this.lastCmdA = a;\n            this.lastCmdB = b;\n            this.currChNr = chNr;\n            return true;\n        },\n\n        /**\n         * Parse midrow styling command\n         * @returns {Boolean}\n         */\n        parseMidrow : function(a, b) {\n            var chNr = null;\n                \n            if ( ((a === 0x11) || (a === 0x19)) && 0x20 <= b && b <= 0x2f) {\n                if (a === 0x11) {\n                    chNr = 1;\n                } else  {\n                    chNr = 2;\n                }\n                if (chNr !== this.currChNr) {\n                    logger.log(\"ERROR\", \"Mismatch channel in midrow parsing\");\n                    return false;\n                }\n                var channel = this.channels[chNr-1];\n                // cea608 spec says midrow codes should inject a space\n                channel.insertChars([0x20]);\n                channel.cc_MIDROW(b);\n                logger.log(\"DEBUG\", \"MIDROW (\" + numArrayToHexArray([a, b]) + \")\");\n                this.lastCmdA = a;\n                this.lastCmdB = b;\n                return true;\n            }\n            return false;\n        },\n        /**\n         * Parse Preable Access Codes (Table 53).\n         * @returns {Boolean} Tells if PAC found\n         */\n        parsePAC : function(a, b) {\n\n           var chNr = null;\n           var row = null;\n            \n            var case1 = ((0x11 <= a  && a <= 0x17) || (0x19 <= a && a <= 0x1F)) && (0x40 <= b && b <= 0x7F);\n            var case2 = (a === 0x10 || a === 0x18) && (0x40 <= b && b <= 0x5F);\n            if (! (case1 || case2)) {\n                return false;\n            }\n\n            chNr = (a <= 0x17) ? 1 : 2;\n\n            if (0x40 <= b && b <= 0x5F) {\n                row = (chNr === 1) ? rowsLowCh1[a] : rowsLowCh2[a];\n            } else { // 0x60 <= b <= 0x7F\n                row = (chNr === 1) ? rowsHighCh1[a] : rowsHighCh2[a];\n            }\n            var pacData = this.interpretPAC(row, b);\n            var channel = this.channels[chNr-1];\n            channel.setPAC(pacData);\n            this.lastCmdA = a;\n            this.lastCmdB = b;\n            this.currChNr = chNr;\n            return true;\n        },\n\n        /**\n         * Interpret the second byte of the pac, and return the information.\n         * @returns {Object} pacData with style parameters.\n         */\n        interpretPAC : function (row, byte) {\n            var pacIndex = byte;\n            var pacData = {color : null, italics : false, indent : null, underline : false, row : row};\n            \n            if (byte > 0x5F) {\n                pacIndex = byte - 0x60;\n            } else {\n                pacIndex = byte - 0x40;\n            }\n            pacData.underline = (pacIndex & 1) === 1;\n            if (pacIndex <= 0xd) {\n                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex/2)];\n            } else if (pacIndex <= 0xf) {\n                pacData.italics = true;\n                pacData.color = 'white';\n            } else {\n                pacData.indent = (Math.floor((pacIndex-0x10)/2))*4;\n            }\n            return pacData; // Note that row has zero offset. The spec uses 1.\n        },\n\n        /**\n         * Parse characters.\n         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n         */\n        parseChars : function(a, b) {\n\n           var  channelNr = null,\n                charCodes = null,\n                charCode1 = null,\n                charCode2 = null;\n\n            if (a >= 0x19) {\n                channelNr = 2;\n                charCode1 = a - 8;\n            } else {\n                channelNr = 1;\n                charCode1 = a;\n            }\n            if (0x11 <= charCode1 && charCode1 <= 0x13) {\n                // Special character\n                var oneCode = b;\n                if (charCode1 === 0x11) {\n                    oneCode = b + 0x50;\n                } else if (charCode1 === 0x12) {\n                    oneCode = b + 0x70;\n                } else {\n                    oneCode = b + 0x90;\n                }\n                logger.log(\"INFO\", \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n                charCodes = [oneCode];\n                this.lastCmdA = a;\n                this.lastCmdB = b;\n            } else if (0x20 <= a && a <= 0x7f) {\n                charCodes = (b === 0) ? [a] : [a, b];\n                this.lastCmdA = null;\n                this.lastCmdB = null;\n            }\n            if (charCodes) {\n                var hexCodes = numArrayToHexArray(charCodes);\n                logger.log(\"DEBUG\", \"Char codes =  \" + hexCodes.join(\",\"));\n            }\n            return charCodes;\n        },\n        \n        /**\n        * Parse extended background attributes as well as new foreground color black.\n        * @returns{Boolean} Tells if background attributes are found\n        */\n        parseBackgroundAttributes : function(a, b) {\n           var  bkgData,\n                index,\n                chNr,\n                channel;\n\n            var case1 = (a === 0x10 || a === 0x18) && (0x20 <= b && b <= 0x2f);\n            var case2 = (a === 0x17 || a === 0x1f) && (0x2d <=b && b <= 0x2f);\n            if (!(case1 || case2)) {\n                return false;\n            }\n            bkgData = {};\n            if (a  === 0x10 || a === 0x18) {\n                index = Math.floor((b-0x20)/2);\n                bkgData.background = backgroundColors[index];\n                if (b % 2 === 1) {\n                    bkgData.background = bkgData.background + \"_semi\";\n                }\n            } else if (b === 0x2d) {\n                bkgData.background = \"transparent\";\n            } else {\n                bkgData.foreground = \"black\";\n                if (b === 0x2f) {\n                    bkgData.underline = true;\n                }\n            }\n            chNr = (a < 0x18) ? 1 : 2;\n            channel = this.channels[chNr-1];\n            channel.setBkgData(bkgData);\n            this.lastCmdA = a;\n            this.lastCmdB = b;\n            return true;\n        },\n\n        /**\n         * Reset state of parser and its channels.\n         */\n        reset : function() {\n            for (var i=0 ; i < this.channels.length ; i++) {\n                if (this.channels[i]) {\n                    this.channels[i].reset();\n                }\n            }\n            this.lastCmdA = null;\n            this.lastCmdB = null;\n        },\n\n        /**\n         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n         */\n        cueSplitAtTime : function(t) {\n            for (var i=0 ; i < this.channels.length ; i++) {\n                if (this.channels[i]) {\n                    this.channels[i].cueSplitAtTime(t);\n                }\n            }\n        },\n    };\n\n    /**\n     * Find ranges corresponding to SEA CEA-608 NALUS in sizeprepended NALU array.\n     * @param {raw} dataView of binary data\n     * @param {startPos} start position in raw\n     * @param {size} total size of data in raw to consider\n     * @returns \n     */\n    var findCea608Nalus = function(raw, startPos, size) {\n        var nalSize = 0,\n            cursor = startPos,\n            nalType = 0,\n            cea608NaluRanges = [],\n            // Check SEI data according to ANSI-SCTE 128\n            isCEA608SEI = function (payloadType, payloadSize, raw, pos) {\n                if (payloadType !== 4 || payloadSize < 8) {\n                    return null;\n                }\n                var countryCode = raw.getUint8(pos);\n                var providerCode = raw.getUint16(pos + 1);\n                var userIdentifier = raw.getUint32(pos + 3);\n                var userDataTypeCode = raw.getUint8(pos + 7);\n                return countryCode == 0xB5 && providerCode == 0x31 && userIdentifier == 0x47413934 && userDataTypeCode == 0x3;\n            };\n        while (cursor < startPos + size) {\n            nalSize = raw.getUint32(cursor);\n            nalType = raw.getUint8(cursor + 4) & 0x1F;\n            //console.log(time + \"  NAL \" + nalType);\n            if (nalType === 6) {\n                // SEI NAL Unit. The NAL header is the first byte\n                //console.log(\"SEI NALU of size \" + nalSize + \" at time \" + time);\n                var pos = cursor + 5;\n                var payloadType = -1;\n                while (pos < cursor + 4 + nalSize - 1) { // The last byte should be rbsp_trailing_bits\n                    payloadType = 0;\n                    var b = 0xFF;\n                    while (b === 0xFF) {\n                        b = raw.getUint8(pos);\n                        payloadType += b;\n                        pos++;\n                    }\n                    var payloadSize = 0;\n                    b = 0xFF;\n                    while (b === 0xFF) {\n                        b = raw.getUint8(pos);\n                        payloadSize += b;\n                        pos++;\n                    }\n                    if (isCEA608SEI(payloadType, payloadSize, raw, pos)) {\n                        //console.log(\"CEA608 SEI \" + time + \" \" + payloadSize);\n                        cea608NaluRanges.push([pos, payloadSize]);\n                    }\n                    pos += payloadSize;\n                }\n            }\n            cursor += nalSize + 4;\n        }\n        return cea608NaluRanges;\n    };\n    \n    var extractCea608DataFromRange = function(raw, cea608Range) {\n        var pos = cea608Range[0];\n        var fieldData = [[], []];\n\n        pos += 8; // Skip the identifier up to userDataTypeCode\n        var ccCount = raw.getUint8(pos) & 0x1f;\n        pos += 2; // Advance 1 and skip reserved byte\n          \n        for (var i = 0; i < ccCount; i++) {\n            var byte = raw.getUint8(pos);\n            var ccValid = byte & 0x4;\n            var ccType = byte & 0x3;\n            pos++;\n            var ccData1 = raw.getUint8(pos); // Keep parity bit\n            pos++;\n            var ccData2 = raw.getUint8(pos); // Keep parity bit\n            pos++;\n            if (ccValid && ((ccData1 & 0x7f) + (ccData2 & 0x7f) !== 0)) { //Check validity and non-empty data\n                if (ccType === 0) {\n                    fieldData[0].push(ccData1);\n                    fieldData[0].push(ccData2);\n                } else if (ccType === 1) {\n                    fieldData[1].push(ccData1);\n                    fieldData[1].push(ccData2);\n                }\n            }\n        }\n        return fieldData;\n    };\n\n    exports.logger = logger;\n    exports.PenState = PenState;\n    exports.CaptionScreen = CaptionScreen;  \n    exports.Cea608Parser = Cea608Parser;\n    exports.findCea608Nalus = findCea608Nalus;\n    exports.extractCea608DataFromRange = extractCea608DataFromRange;\n\n}(typeof exports === 'undefined' ? this.cea608parser = {} : exports));\n"]},"metadata":{},"sourceType":"script"}