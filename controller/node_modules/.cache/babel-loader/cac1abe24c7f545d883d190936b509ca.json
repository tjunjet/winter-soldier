{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DashConstants = require('./constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _RepresentationInfo = require('./vo/RepresentationInfo');\n\nvar _RepresentationInfo2 = _interopRequireDefault(_RepresentationInfo);\n\nvar _MediaInfo = require('./vo/MediaInfo');\n\nvar _MediaInfo2 = _interopRequireDefault(_MediaInfo);\n\nvar _StreamInfo = require('./vo/StreamInfo');\n\nvar _StreamInfo2 = _interopRequireDefault(_StreamInfo);\n\nvar _ManifestInfo = require('./vo/ManifestInfo');\n\nvar _ManifestInfo2 = _interopRequireDefault(_ManifestInfo);\n\nvar _Event = require('./vo/Event');\n\nvar _Event2 = _interopRequireDefault(_Event);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _DashManifestModel = require('./models/DashManifestModel');\n\nvar _DashManifestModel2 = _interopRequireDefault(_DashManifestModel);\n\nvar _PatchManifestModel = require('./models/PatchManifestModel');\n\nvar _PatchManifestModel2 = _interopRequireDefault(_PatchManifestModel);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* @module DashAdapter\n*/\n\n\nfunction DashAdapter() {\n  var instance = void 0,\n      dashManifestModel = void 0,\n      patchManifestModel = void 0,\n      voPeriods = void 0,\n      voAdaptations = void 0,\n      currentMediaInfo = void 0,\n      constants = void 0,\n      cea608parser = void 0;\n  var context = this.context;\n  var PROFILE_DVB = 'urn:dvb:dash:profile:dvb-dash:2014';\n\n  function setup() {\n    dashManifestModel = (0, _DashManifestModel2.default)(context).getInstance();\n    patchManifestModel = (0, _PatchManifestModel2.default)(context).getInstance();\n    reset();\n  } // #region PUBLIC FUNCTIONS\n  // --------------------------------------------------\n\n\n  function getVoAdaptations() {\n    return voAdaptations;\n  }\n\n  function getVoPeriods() {\n    return voPeriods;\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.constants) {\n      constants = config.constants;\n    }\n\n    if (config.cea608parser) {\n      cea608parser = config.cea608parser;\n    }\n\n    if (config.errHandler) {\n      dashManifestModel.setConfig({\n        errHandler: config.errHandler\n      });\n    }\n\n    if (config.BASE64) {\n      dashManifestModel.setConfig({\n        BASE64: config.BASE64\n      });\n    }\n  }\n  /**\n  * Creates an instance of RepresentationInfo based on a representation value object\n  * @param {object} voRepresentation\n  * @returns {RepresentationInfo|null} representationInfo\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function convertRepresentationToRepresentationInfo(voRepresentation) {\n    if (voRepresentation) {\n      var representationInfo = new _RepresentationInfo2.default();\n      var realAdaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\n      var realRepresentation = dashManifestModel.getRepresentationFor(voRepresentation.index, realAdaptation);\n      representationInfo.id = voRepresentation.id;\n      representationInfo.quality = voRepresentation.index;\n      representationInfo.bandwidth = dashManifestModel.getBandwidth(realRepresentation);\n      representationInfo.DVRWindow = voRepresentation.segmentAvailabilityRange;\n      representationInfo.fragmentDuration = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length > 0 ? voRepresentation.segments[0].duration : NaN);\n      representationInfo.MSETimeOffset = voRepresentation.MSETimeOffset;\n      representationInfo.mediaInfo = convertAdaptationToMediaInfo(voRepresentation.adaptation);\n      return representationInfo;\n    } else {\n      return null;\n    }\n  }\n  /**\n  * Returns a MediaInfo object for a given media type.\n  * @param {object} streamInfo\n  * @param {MediaType }type\n  * @returns {null|MediaInfo} mediaInfo\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getMediaInfoForType(streamInfo, type) {\n    if (voPeriods.length === 0 || !streamInfo) {\n      return null;\n    }\n\n    var selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voPeriods);\n    if (!selectedVoPeriod) return null;\n    var periodId = selectedVoPeriod.id;\n    voAdaptations[periodId] = voAdaptations[periodId] || dashManifestModel.getAdaptationsForPeriod(selectedVoPeriod);\n    var realAdaptation = getAdaptationForType(streamInfo.index, type, streamInfo);\n    if (!realAdaptation) return null;\n    var idx = dashManifestModel.getIndexForAdaptation(realAdaptation, voPeriods[0].mpd.manifest, streamInfo.index);\n    return convertAdaptationToMediaInfo(voAdaptations[periodId][idx]);\n  }\n  /**\n  * Checks if the role of the specified AdaptationSet is set to main\n  * @param {object} adaptation\n  * @returns {boolean}\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getIsMain(adaptation) {\n    return dashManifestModel.getRolesForAdaptation(adaptation).filter(function (role) {\n      return role.value === _DashConstants2.default.MAIN;\n    })[0];\n  }\n  /**\n  * Returns the AdaptationSet for a given period and a given mediaType.\n  * @param {number} periodIndex\n  * @param {MediaType} type\n  * @param {object} streamInfo\n  * @returns {null|object} adaptation\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getAdaptationForType(periodIndex, type, streamInfo) {\n    var adaptations = dashManifestModel.getAdaptationsForType(voPeriods[0].mpd.manifest, periodIndex, type);\n    if (!adaptations || adaptations.length === 0) return null;\n\n    if (adaptations.length > 1 && streamInfo) {\n      var allMediaInfoForType = getAllMediaInfoForType(streamInfo, type);\n\n      if (currentMediaInfo[streamInfo.id] && currentMediaInfo[streamInfo.id][type]) {\n        for (var i = 0, ln = adaptations.length; i < ln; i++) {\n          if (areMediaInfosEqual(currentMediaInfo[streamInfo.id][type], allMediaInfoForType[i])) {\n            return adaptations[i];\n          }\n        }\n      }\n\n      for (var _i = 0, _ln = adaptations.length; _i < _ln; _i++) {\n        if (getIsMain(adaptations[_i])) {\n          return adaptations[_i];\n        }\n      }\n    }\n\n    return adaptations[0];\n  }\n  /**\n  * Compares two mediaInfo objects\n  * @param {MediaInfo} mInfoOne\n  * @param {MediaInfo} mInfoTwo\n  * @returns {boolean}\n  */\n\n\n  function areMediaInfosEqual(mInfoOne, mInfoTwo) {\n    if (!mInfoOne || !mInfoTwo) {\n      return false;\n    }\n\n    var sameId = mInfoOne.id === mInfoTwo.id;\n    var sameViewpoint = mInfoOne.viewpoint === mInfoTwo.viewpoint;\n    var sameLang = mInfoOne.lang === mInfoTwo.lang;\n    var sameRoles = mInfoOne.roles.toString() === mInfoTwo.roles.toString();\n    var sameAccessibility = mInfoOne.accessibility.toString() === mInfoTwo.accessibility.toString();\n    var sameAudioChannelConfiguration = mInfoOne.audioChannelConfiguration.toString() === mInfoTwo.audioChannelConfiguration.toString();\n    return sameId && sameViewpoint && sameLang && sameRoles && sameAccessibility && sameAudioChannelConfiguration;\n  }\n  /**\n  * Returns the mediaInfo for a given mediaType\n  * @param {object} streamInfo\n  * @param {MediaType} type\n  * @param {object} externalManifest Set to null or undefined if no external manifest is to be used\n  * @returns {Array} mediaArr\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getAllMediaInfoForType(streamInfo, type, externalManifest) {\n    var voLocalPeriods = voPeriods;\n    var manifest = externalManifest;\n    var mediaArr = [];\n    var data = void 0,\n        media = void 0,\n        idx = void 0,\n        i = void 0,\n        j = void 0,\n        ln = void 0,\n        periodId = void 0;\n\n    if (manifest) {\n      checkConfig();\n      voLocalPeriods = getRegularPeriods(manifest);\n    } else {\n      if (voPeriods.length > 0) {\n        manifest = voPeriods[0].mpd.manifest;\n      } else {\n        return mediaArr;\n      }\n    }\n\n    var selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voLocalPeriods);\n\n    if (selectedVoPeriod) {\n      periodId = selectedVoPeriod.id;\n    }\n\n    var adaptationsForType = dashManifestModel.getAdaptationsForType(manifest, streamInfo ? streamInfo.index : null, type !== constants.EMBEDDED_TEXT ? type : constants.VIDEO);\n    if (!adaptationsForType || adaptationsForType.length === 0) return mediaArr;\n    voAdaptations[periodId] = voAdaptations[periodId] || dashManifestModel.getAdaptationsForPeriod(selectedVoPeriod);\n\n    for (i = 0, ln = adaptationsForType.length; i < ln; i++) {\n      data = adaptationsForType[i];\n      idx = dashManifestModel.getIndexForAdaptation(data, manifest, streamInfo.index);\n      media = convertAdaptationToMediaInfo(voAdaptations[periodId][idx]);\n\n      if (type === constants.EMBEDDED_TEXT) {\n        var accessibilityLength = media.accessibility.length;\n\n        for (j = 0; j < accessibilityLength; j++) {\n          if (!media) {\n            continue;\n          }\n\n          var accessibility = media.accessibility[j];\n\n          if (accessibility.indexOf('cea-608:') === 0) {\n            var value = accessibility.substring(8);\n            var parts = value.split(';');\n\n            if (parts[0].substring(0, 2) === 'CC') {\n              for (j = 0; j < parts.length; j++) {\n                if (!media) {\n                  media = convertAdaptationToMediaInfo.call(this, voAdaptations[periodId][idx]);\n                }\n\n                convertVideoInfoToEmbeddedTextInfo(media, parts[j].substring(0, 3), parts[j].substring(4));\n                mediaArr.push(media);\n                media = null;\n              }\n            } else {\n              for (j = 0; j < parts.length; j++) {\n                // Only languages for CC1, CC2, ...\n                if (!media) {\n                  media = convertAdaptationToMediaInfo.call(this, voAdaptations[periodId][idx]);\n                }\n\n                convertVideoInfoToEmbeddedTextInfo(media, 'CC' + (j + 1), parts[j]);\n                mediaArr.push(media);\n                media = null;\n              }\n            }\n          } else if (accessibility.indexOf('cea-608') === 0) {\n            // Nothing known. We interpret it as CC1=eng\n            convertVideoInfoToEmbeddedTextInfo(media, constants.CC1, 'eng');\n            mediaArr.push(media);\n            media = null;\n          }\n        }\n      } else if (type === constants.IMAGE) {\n        convertVideoInfoToThumbnailInfo(media);\n        mediaArr.push(media);\n        media = null;\n      } else if (media) {\n        mediaArr.push(media);\n      }\n    }\n\n    return mediaArr;\n  }\n  /**\n  * @param {object} newManifest\n  * @returns {*}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function updatePeriods(newManifest) {\n    if (!newManifest) return null;\n    checkConfig();\n    voPeriods = getRegularPeriods(newManifest);\n    voAdaptations = {};\n  }\n  /**\n  * @param {object} externalManifest\n  * @param {number} maxStreamsInfo\n  * @returns {Array} streams\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getStreamsInfo(externalManifest, maxStreamsInfo) {\n    var streams = [];\n    var voLocalPeriods = voPeriods; //if manifest is defined, getStreamsInfo is for an outside manifest, not the current one\n\n    if (externalManifest) {\n      checkConfig();\n      voLocalPeriods = getRegularPeriods(externalManifest);\n    }\n\n    if (voLocalPeriods.length > 0) {\n      if (!maxStreamsInfo || maxStreamsInfo > voLocalPeriods.length) {\n        maxStreamsInfo = voLocalPeriods.length;\n      }\n\n      for (var i = 0; i < maxStreamsInfo; i++) {\n        streams.push(convertPeriodToStreamInfo(voLocalPeriods[i]));\n      }\n    }\n\n    return streams;\n  }\n  /**\n  *\n  * @param {object} streamInfo\n  * @param {object} mediaInfo\n  * @returns {object} realAdaptation\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getRealAdaptation(streamInfo, mediaInfo) {\n    var id = void 0,\n        realAdaptation = void 0;\n    var selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voPeriods);\n    id = mediaInfo ? mediaInfo.id : null;\n\n    if (voPeriods.length > 0 && selectedVoPeriod) {\n      realAdaptation = id ? dashManifestModel.getAdaptationForId(id, voPeriods[0].mpd.manifest, selectedVoPeriod.index) : dashManifestModel.getAdaptationForIndex(mediaInfo ? mediaInfo.index : null, voPeriods[0].mpd.manifest, selectedVoPeriod.index);\n    }\n\n    return realAdaptation;\n  }\n  /**\n  * Return all EssentialProperties of a Representation\n  * @param {object} representation\n  * @return {array}\n  */\n\n\n  function getEssentialPropertiesForRepresentation(representation) {\n    try {\n      return dashManifestModel.getEssentialPropertiesForRepresentation(representation);\n    } catch (e) {\n      return [];\n    }\n  }\n  /**\n  * Returns the period by index\n  * @param {number} index\n  * @return {object}\n  */\n\n\n  function getRealPeriodByIndex(index) {\n    return dashManifestModel.getRealPeriodForIndex(index, voPeriods[0].mpd.manifest);\n  }\n  /**\n  * Returns all voRepresentations for a given mediaInfo\n  * @param {object} mediaInfo\n  * @returns {Array} voReps\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getVoRepresentations(mediaInfo) {\n    var voReps = void 0;\n    var voAdaptation = getAdaptationForMediaInfo(mediaInfo);\n    voReps = dashManifestModel.getRepresentationsForAdaptation(voAdaptation);\n    return voReps;\n  }\n  /**\n  *\n  * @param {object} eventBox\n  * @param {object} eventStreams\n  * @param {number} mediaStartTime\n  * @param {object} voRepresentation\n  * @returns {null|Event}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getEvent(eventBox, eventStreams, mediaStartTime, voRepresentation) {\n    try {\n      if (!eventBox || !eventStreams || isNaN(mediaStartTime) || !voRepresentation) {\n        return null;\n      }\n\n      var schemeIdUri = eventBox.scheme_id_uri;\n      var value = eventBox.value;\n\n      if (!eventStreams[schemeIdUri + '/' + value]) {\n        return null;\n      }\n\n      var event = new _Event2.default();\n      var timescale = eventBox.timescale || 1;\n      var periodStart = voRepresentation.adaptation.period.start;\n      var eventStream = eventStreams[schemeIdUri + '/' + value];\n      var presentationTimeOffset = !isNaN(voRepresentation.presentationTimeOffset) ? voRepresentation.presentationTimeOffset : !isNaN(eventStream.presentationTimeOffset) ? eventStream.presentationTimeOffset : 0;\n      var presentationTimeDelta = eventBox.presentation_time_delta / timescale; // In case of version 1 events the presentation_time is parsed as presentation_time_delta\n\n      var calculatedPresentationTime = void 0;\n\n      if (eventBox.version === 0) {\n        calculatedPresentationTime = periodStart + mediaStartTime - presentationTimeOffset + presentationTimeDelta;\n      } else {\n        calculatedPresentationTime = periodStart - presentationTimeOffset + presentationTimeDelta;\n      }\n\n      var duration = eventBox.event_duration;\n      var id = eventBox.id;\n      var messageData = eventBox.message_data;\n      event.eventStream = eventStream;\n      event.eventStream.value = value;\n      event.eventStream.timescale = timescale;\n      event.duration = duration;\n      event.id = id;\n      event.calculatedPresentationTime = calculatedPresentationTime;\n      event.messageData = messageData;\n      event.presentationTimeDelta = presentationTimeDelta;\n      return event;\n    } catch (e) {\n      return null;\n    }\n  }\n  /**\n  *\n  * @param {object} info\n  * @param {object} voRepresentation\n  * @returns {Array}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getEventsFor(info, voRepresentation) {\n    var events = [];\n\n    if (voPeriods.length > 0) {\n      var manifest = voPeriods[0].mpd.manifest;\n\n      if (info instanceof _StreamInfo2.default) {\n        events = dashManifestModel.getEventsForPeriod(getPeriodForStreamInfo(info, voPeriods));\n      } else if (info instanceof _MediaInfo2.default) {\n        events = dashManifestModel.getEventStreamForAdaptationSet(manifest, getAdaptationForMediaInfo(info));\n      } else if (info instanceof _RepresentationInfo2.default) {\n        events = dashManifestModel.getEventStreamForRepresentation(manifest, voRepresentation);\n      }\n    }\n\n    return events;\n  }\n  /**\n  *\n  * @param {number} streamId\n  * @param {MediaType} type\n  * @param {object} mediaInfo\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function setCurrentMediaInfo(streamId, type, mediaInfo) {\n    currentMediaInfo[streamId] = currentMediaInfo[streamId] || {};\n    currentMediaInfo[streamId][type] = currentMediaInfo[streamId][type] || {};\n    currentMediaInfo[streamId][type] = mediaInfo;\n  }\n  /**\n  *\n  * @param {String} type\n  * @returns {boolean}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getIsTextTrack(type) {\n    return dashManifestModel.getIsTextTrack(type);\n  }\n  /**\n  * Returns the UTC Timing Sources specified in the manifest\n  * @returns {Array} utcTimingSources\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getUTCTimingSources() {\n    var manifest = getManifest();\n    return dashManifestModel.getUTCTimingSources(manifest);\n  }\n  /**\n  * Returns the suggestedPresentationDelay as specified in the manifest\n  * @returns {String} suggestedPresentationDelay\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getSuggestedPresentationDelay() {\n    var mpd = voPeriods.length > 0 ? voPeriods[0].mpd : null;\n    return dashManifestModel.getSuggestedPresentationDelay(mpd);\n  }\n  /**\n  * Returns the availabilityStartTime as specified in the manifest\n  * @param {object} externalManifest Omit this value if no external manifest should be used\n  * @returns {string} availabilityStartTime\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getAvailabilityStartTime(externalManifest) {\n    var mpd = getMpd(externalManifest);\n    return dashManifestModel.getAvailabilityStartTime(mpd);\n  }\n  /**\n  * Returns a boolean indicating if the manifest is dynamic or not\n  * @param {object} externalManifest Omit this value if no external manifest should be used\n  * @returns {boolean}\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getIsDynamic(externalManifest) {\n    var manifest = getManifest(externalManifest);\n    return dashManifestModel.getIsDynamic(manifest);\n  }\n  /**\n  * Returns the duration of the MPD\n  * @param {object} externalManifest Omit this value if no external manifest should be used\n  * @returns {number} duration\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getDuration(externalManifest) {\n    var manifest = getManifest(externalManifest);\n    return dashManifestModel.getDuration(manifest);\n  }\n  /**\n  * Returns all periods of the MPD\n  * @param {object} externalManifest Omit this value if no external manifest should be used\n  * @returns {Array} periods\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getRegularPeriods(externalManifest) {\n    var mpd = getMpd(externalManifest);\n    return dashManifestModel.getRegularPeriods(mpd);\n  }\n  /**\n  * Returns an MPD object\n  * @param {object} externalManifest Omit this value if no external manifest should be used\n  * @returns {object} MPD\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getMpd(externalManifest) {\n    var manifest = getManifest(externalManifest);\n    return dashManifestModel.getMpd(manifest);\n  }\n  /**\n  * Returns the location element of the MPD\n  * @param {object} manifest\n  * @returns {String} location\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getLocation(manifest) {\n    return dashManifestModel.getLocation(manifest);\n  }\n  /**\n  * Returns the manifest update period used for dynamic manifests\n  * @param {object} manifest\n  * @param {number} latencyOfLastUpdate\n  * @returns {NaN|number} manifestUpdatePeriod\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getManifestUpdatePeriod(manifest) {\n    var latencyOfLastUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return dashManifestModel.getManifestUpdatePeriod(manifest, latencyOfLastUpdate);\n  }\n  /**\n  * Returns the publish time from the manifest\n  * @param {object} manifest\n  * @returns {Date|null} publishTime\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getPublishTime(manifest) {\n    return dashManifestModel.getPublishTime(manifest);\n  }\n  /**\n  * Returns the patch location of the MPD if one exists and it is still valid\n  * @param {object} manifest\n  * @returns {(String|null)} patch location\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getPatchLocation(manifest) {\n    var patchLocation = dashManifestModel.getPatchLocation(manifest);\n    var publishTime = dashManifestModel.getPublishTime(manifest); // short-circuit when no patch location or publish time exists\n\n    if (!patchLocation || !publishTime) {\n      return null;\n    } // if a ttl is provided, ensure patch location has not expired\n\n\n    if (patchLocation.hasOwnProperty('ttl') && publishTime) {\n      // attribute describes number of seconds as a double\n      var ttl = parseFloat(patchLocation.ttl) * 1000; // check if the patch location has expired, if so do not consider it\n\n      if (publishTime.getTime() + ttl <= new Date().getTime()) {\n        return null;\n      }\n    } // the patch location exists and, if a ttl applies, has not expired\n\n\n    return patchLocation.__text;\n  }\n  /**\n  * Checks if the manifest has a DVB profile\n  * @param {object} manifest\n  * @returns {boolean}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getIsDVB(manifest) {\n    return dashManifestModel.hasProfile(manifest, PROFILE_DVB);\n  }\n  /**\n  * Checks if the manifest is actually just a patch manifest\n  * @param  {object} manifest\n  * @return {boolean}\n  */\n\n\n  function getIsPatch(manifest) {\n    return patchManifestModel.getIsPatch(manifest);\n  }\n  /**\n  *\n  * @param {object} node\n  * @returns {Array}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getBaseURLsFromElement(node) {\n    return dashManifestModel.getBaseURLsFromElement(node);\n  }\n  /**\n  *\n  * @returns {*}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getRepresentationSortFunction() {\n    return dashManifestModel.getRepresentationSortFunction();\n  }\n  /**\n  * Returns the codec for a given adaptation set and a given representation id.\n  * @param {object} adaptation\n  * @param {number} representationId\n  * @param {boolean} addResolutionInfo Defines whether to include resolution information in the output\n  * @returns {String} codec\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getCodec(adaptation, representationId, addResolutionInfo) {\n    return dashManifestModel.getCodec(adaptation, representationId, addResolutionInfo);\n  }\n  /**\n  * Returns the bandwidth for a given representation id\n  * @param {number} representationId\n  * @param {number} periodIdx\n  * @returns {number} bandwidth\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getBandwidthForRepresentation(representationId, periodIdx) {\n    var representation = void 0;\n    var period = getPeriod(periodIdx);\n    representation = findRepresentation(period, representationId);\n    return representation ? representation.bandwidth : null;\n  }\n  /**\n  * Returns the index for a given representation id\n  * @param {string} representationId\n  * @param {number} periodIdx\n  * @returns {number} index\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getIndexForRepresentation(representationId, periodIdx) {\n    var period = getPeriod(periodIdx);\n    return findRepresentationIndex(period, representationId);\n  }\n  /**\n  * This method returns the current max index based on what is defined in the MPD.\n  *\n  * @param {string} bufferType - String 'audio' or 'video',\n  * @param {number} periodIdx - Make sure this is the period index not id\n  * @return {number}\n  * @memberof module:DashAdapter\n  * @instance\n  */\n\n\n  function getMaxIndexForBufferType(bufferType, periodIdx) {\n    var period = getPeriod(periodIdx);\n    return findMaxBufferIndex(period, bufferType);\n  }\n  /**\n  * Returns the voPeriod object for a given id\n  * @param {String} id\n  * @returns {object|null}\n  */\n\n\n  function getPeriodById(id) {\n    if (!id || voPeriods.length === 0) {\n      return null;\n    }\n\n    var periods = voPeriods.filter(function (p) {\n      return p.id === id;\n    });\n\n    if (periods && periods.length > 0) {\n      return periods[0];\n    }\n\n    return null;\n  }\n\n  function getIsTypeOf(adaptation, type) {\n    return dashManifestModel.getIsTypeOf(adaptation, type);\n  }\n\n  function reset() {\n    voPeriods = [];\n    voAdaptations = {};\n    currentMediaInfo = {};\n  }\n  /**\n  * Checks if the supplied manifest is compatible for application of the supplied patch\n  * @param  {object}  manifest\n  * @param  {object}  patch\n  * @return {boolean}\n  */\n\n\n  function isPatchValid(manifest, patch) {\n    var manifestId = dashManifestModel.getId(manifest);\n    var patchManifestId = patchManifestModel.getMpdId(patch);\n    var manifestPublishTime = dashManifestModel.getPublishTime(manifest);\n    var patchPublishTime = patchManifestModel.getPublishTime(patch);\n    var originalManifestPublishTime = patchManifestModel.getOriginalPublishTime(patch); // Patches are considered compatible if the following are true\n    // - MPD@id == Patch@mpdId\n    // - MPD@publishTime == Patch@originalPublishTime\n    // - MPD@publishTime < Patch@publishTime\n    // - All values in comparison exist\n\n    return !!(manifestId && patchManifestId && manifestId == patchManifestId && manifestPublishTime && originalManifestPublishTime && manifestPublishTime.getTime() == originalManifestPublishTime.getTime() && patchPublishTime && manifestPublishTime.getTime() < patchPublishTime.getTime());\n  }\n  /**\n  * Takes a given patch and applies it to the provided manifest, assumes patch is valid for manifest\n  * @param  {object} manifest\n  * @param  {object} patch\n  */\n\n\n  function applyPatchToManifest(manifest, patch) {\n    // get all operations from the patch and apply them in document order\n    patchManifestModel.getPatchOperations(patch).forEach(function (operation) {\n      var result = operation.getMpdTarget(manifest); // operation supplies a path that doesn't match mpd, skip\n\n      if (result === null) {\n        return;\n      }\n\n      var name = result.name,\n          target = result.target,\n          leaf = result.leaf; // short circuit for attribute selectors\n\n      if (operation.xpath.findsAttribute()) {\n        switch (operation.action) {\n          case 'add':\n          case 'replace':\n            // add and replace are just setting the value\n            target[name] = operation.value;\n            break;\n\n          case 'remove':\n            // remove is deleting the value\n            delete target[name];\n            break;\n        }\n\n        return;\n      } // determine the relative insert position prior to possible removal\n\n\n      var relativePosition = (target[name + '_asArray'] || []).indexOf(leaf);\n      var insertBefore = operation.position === 'prepend' || operation.position === 'before'; // perform removal operation first, we have already capture the appropriate relative position\n\n      if (operation.action === 'remove' || operation.action === 'replace') {\n        // note that we ignore the 'ws' attribute of patch operations as it does not effect parsed mpd operations\n        // purge the directly named entity\n        delete target[name]; // if we did have a positional reference we need to purge from array set and restore X2JS proper semantics\n\n        if (relativePosition != -1) {\n          var targetArray = target[name + '_asArray'];\n          targetArray.splice(relativePosition, 1);\n\n          if (targetArray.length > 1) {\n            target[name] = targetArray;\n          } else if (targetArray.length == 1) {\n            // xml parsing semantics, singular asArray must be non-array in the unsuffixed key\n            target[name] = targetArray[0];\n          } else {\n            // all nodes of this type deleted, remove entry\n            delete target[name + '_asArray'];\n          }\n        }\n      } // Perform any add/replace operations now, technically RFC5261 only allows a single element to take the\n      // place of a replaced element while the add case allows an arbitrary number of children.\n      // Due to the both operations requiring the same insertion logic they have been combined here and we will\n      // not enforce single child operations for replace, assertions should be made at patch parse time if necessary\n\n\n      if (operation.action === 'add' || operation.action === 'replace') {\n        // value will be an object with element name keys pointing to arrays of objects\n        Object.keys(operation.value).forEach(function (insert) {\n          var insertNodes = operation.value[insert];\n          var updatedNodes = target[insert + '_asArray'] || [];\n\n          if (updatedNodes.length === 0 && target[insert]) {\n            updatedNodes.push(target[insert]);\n          }\n\n          if (updatedNodes.length === 0) {\n            // no original nodes for this element type\n            updatedNodes = insertNodes;\n          } else {\n            // compute the position we need to insert at, default to end of set\n            var position = updatedNodes.length;\n\n            if (insert == name && relativePosition != -1) {\n              // if the inserted element matches the operation target (not leaf) and there is a relative position we\n              // want the inserted position to be set such that our insertion is relative to original position\n              // since replace has modified the array length we reduce the insert point by 1\n              position = relativePosition + (insertBefore ? 0 : 1) + (operation.action == 'replace' ? -1 : 0);\n            } else {\n              // otherwise we are in an add append/prepend case or replace case that removed the target name completely\n              position = insertBefore ? 0 : updatedNodes.length;\n            } // we dont have to perform element removal for the replace case as that was done above\n\n\n            updatedNodes.splice.apply(updatedNodes, [position, 0].concat(insertNodes));\n          } // now we properly reset the element keys on the target to match parsing semantics\n\n\n          target[insert + '_asArray'] = updatedNodes;\n          target[insert] = updatedNodes.length == 1 ? updatedNodes[0] : updatedNodes;\n        });\n      }\n    });\n  } // #endregion PUBLIC FUNCTIONS\n  // #region PRIVATE FUNCTIONS\n  // --------------------------------------------------\n\n\n  function getManifest(externalManifest) {\n    return externalManifest ? externalManifest : voPeriods.length > 0 ? voPeriods[0].mpd.manifest : null;\n  }\n\n  function getAdaptationForMediaInfo(mediaInfo) {\n    if (!mediaInfo || !mediaInfo.streamInfo || mediaInfo.streamInfo.id === undefined || !voAdaptations[mediaInfo.streamInfo.id]) return null;\n    return voAdaptations[mediaInfo.streamInfo.id][mediaInfo.index];\n  }\n\n  function getPeriodForStreamInfo(streamInfo, voPeriodsArray) {\n    var ln = voPeriodsArray.length;\n\n    for (var i = 0; i < ln; i++) {\n      var voPeriod = voPeriodsArray[i];\n      if (streamInfo && streamInfo.id === voPeriod.id) return voPeriod;\n    }\n\n    return null;\n  }\n\n  function convertAdaptationToMediaInfo(adaptation) {\n    if (!adaptation) {\n      return null;\n    }\n\n    var mediaInfo = new _MediaInfo2.default();\n    var realAdaptation = adaptation.period.mpd.manifest.Period_asArray[adaptation.period.index].AdaptationSet_asArray[adaptation.index];\n    var viewpoint = void 0;\n    mediaInfo.id = adaptation.id;\n    mediaInfo.index = adaptation.index;\n    mediaInfo.type = adaptation.type;\n    mediaInfo.streamInfo = convertPeriodToStreamInfo(adaptation.period);\n    mediaInfo.representationCount = dashManifestModel.getRepresentationCount(realAdaptation);\n    mediaInfo.labels = dashManifestModel.getLabelsForAdaptation(realAdaptation);\n    mediaInfo.lang = dashManifestModel.getLanguageForAdaptation(realAdaptation);\n    viewpoint = dashManifestModel.getViewpointForAdaptation(realAdaptation);\n    mediaInfo.viewpoint = viewpoint ? viewpoint.value : undefined;\n    mediaInfo.accessibility = dashManifestModel.getAccessibilityForAdaptation(realAdaptation).map(function (accessibility) {\n      var accessibilityValue = accessibility.value;\n      var accessibilityData = accessibilityValue;\n\n      if (accessibility.schemeIdUri && accessibility.schemeIdUri.search('cea-608') >= 0 && typeof cea608parser !== 'undefined') {\n        if (accessibilityValue) {\n          accessibilityData = 'cea-608:' + accessibilityValue;\n        } else {\n          accessibilityData = 'cea-608';\n        }\n\n        mediaInfo.embeddedCaptions = true;\n      }\n\n      return accessibilityData;\n    });\n    mediaInfo.audioChannelConfiguration = dashManifestModel.getAudioChannelConfigurationForAdaptation(realAdaptation).map(function (audioChannelConfiguration) {\n      return audioChannelConfiguration.value;\n    });\n\n    if (mediaInfo.audioChannelConfiguration.length === 0 && Array.isArray(realAdaptation.Representation_asArray) && realAdaptation.Representation_asArray.length > 0) {\n      mediaInfo.audioChannelConfiguration = dashManifestModel.getAudioChannelConfigurationForRepresentation(realAdaptation.Representation_asArray[0]).map(function (audioChannelConfiguration) {\n        return audioChannelConfiguration.value;\n      });\n    }\n\n    mediaInfo.roles = dashManifestModel.getRolesForAdaptation(realAdaptation).map(function (role) {\n      return role.value;\n    });\n    mediaInfo.codec = dashManifestModel.getCodec(realAdaptation);\n    mediaInfo.mimeType = dashManifestModel.getMimeType(realAdaptation);\n    mediaInfo.contentProtection = dashManifestModel.getContentProtectionData(realAdaptation);\n    mediaInfo.bitrateList = dashManifestModel.getBitrateListForAdaptation(realAdaptation);\n\n    if (mediaInfo.contentProtection) {\n      mediaInfo.contentProtection.forEach(function (item) {\n        item.KID = dashManifestModel.getKID(item);\n      });\n    }\n\n    mediaInfo.isText = dashManifestModel.getIsTextTrack(mediaInfo.mimeType);\n    mediaInfo.supplementalProperties = dashManifestModel.getSupplementalPropperties(realAdaptation);\n    return mediaInfo;\n  }\n\n  function convertVideoInfoToEmbeddedTextInfo(mediaInfo, channel, lang) {\n    mediaInfo.id = channel; // CC1, CC2, CC3, or CC4\n\n    mediaInfo.index = 100 + parseInt(channel.substring(2, 3));\n    mediaInfo.type = constants.EMBEDDED_TEXT;\n    mediaInfo.codec = 'cea-608-in-SEI';\n    mediaInfo.isText = true;\n    mediaInfo.isEmbedded = true;\n    mediaInfo.lang = lang;\n    mediaInfo.roles = ['caption'];\n  }\n\n  function convertVideoInfoToThumbnailInfo(mediaInfo) {\n    mediaInfo.type = constants.IMAGE;\n  }\n\n  function convertPeriodToStreamInfo(period) {\n    var streamInfo = new _StreamInfo2.default();\n    var THRESHOLD = 1;\n    streamInfo.id = period.id;\n    streamInfo.index = period.index;\n    streamInfo.start = period.start;\n    streamInfo.duration = period.duration;\n    streamInfo.manifestInfo = convertMpdToManifestInfo(period.mpd);\n    streamInfo.isLast = period.mpd.manifest.Period_asArray.length === 1 || Math.abs(streamInfo.start + streamInfo.duration - streamInfo.manifestInfo.duration) < THRESHOLD;\n    return streamInfo;\n  }\n\n  function convertMpdToManifestInfo(mpd) {\n    var manifestInfo = new _ManifestInfo2.default();\n    manifestInfo.DVRWindowSize = mpd.timeShiftBufferDepth;\n    manifestInfo.loadedTime = mpd.manifest.loadedTime;\n    manifestInfo.availableFrom = mpd.availabilityStartTime;\n    manifestInfo.minBufferTime = mpd.manifest.minBufferTime;\n    manifestInfo.maxFragmentDuration = mpd.maxSegmentDuration;\n    manifestInfo.duration = dashManifestModel.getDuration(mpd.manifest);\n    manifestInfo.isDynamic = dashManifestModel.getIsDynamic(mpd.manifest);\n    manifestInfo.serviceDescriptions = dashManifestModel.getServiceDescriptions(mpd.manifest);\n    manifestInfo.protocol = mpd.manifest.protocol;\n    return manifestInfo;\n  }\n\n  function checkConfig() {\n    if (!constants) {\n      throw new Error('setConfig function has to be called previously');\n    }\n  }\n\n  function getPeriod(periodIdx) {\n    return voPeriods.length > 0 ? voPeriods[0].mpd.manifest.Period_asArray[periodIdx] : null;\n  }\n\n  function findRepresentationIndex(period, representationId) {\n    var index = findRepresentation(period, representationId, true);\n    return index !== null ? index : -1;\n  }\n\n  function findRepresentation(period, representationId, returnIndex) {\n    var adaptationSet = void 0,\n        adaptationSetArray = void 0,\n        representation = void 0,\n        representationArray = void 0,\n        adaptationSetArrayIndex = void 0,\n        representationArrayIndex = void 0;\n\n    if (period) {\n      adaptationSetArray = period.AdaptationSet_asArray;\n\n      for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n        adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n        representationArray = adaptationSet.Representation_asArray;\n\n        for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {\n          representation = representationArray[representationArrayIndex];\n\n          if (representationId === representation.id) {\n            if (returnIndex) {\n              return representationArrayIndex;\n            } else {\n              return representation;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  function findMaxBufferIndex(period, bufferType) {\n    var adaptationSet = void 0,\n        adaptationSetArray = void 0,\n        representationArray = void 0,\n        adaptationSetArrayIndex = void 0;\n    if (!period || !bufferType) return -1;\n    adaptationSetArray = period.AdaptationSet_asArray;\n\n    for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n      adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n      representationArray = adaptationSet.Representation_asArray;\n\n      if (dashManifestModel.getIsTypeOf(adaptationSet, bufferType)) {\n        return representationArray.length;\n      }\n    }\n\n    return -1;\n  } // #endregion PRIVATE FUNCTIONS\n\n\n  instance = {\n    getBandwidthForRepresentation: getBandwidthForRepresentation,\n    getIndexForRepresentation: getIndexForRepresentation,\n    getMaxIndexForBufferType: getMaxIndexForBufferType,\n    convertDataToRepresentationInfo: convertRepresentationToRepresentationInfo,\n    getDataForMedia: getAdaptationForMediaInfo,\n    getStreamsInfo: getStreamsInfo,\n    getMediaInfoForType: getMediaInfoForType,\n    getAllMediaInfoForType: getAllMediaInfoForType,\n    getAdaptationForType: getAdaptationForType,\n    getRealAdaptation: getRealAdaptation,\n    getRealPeriodByIndex: getRealPeriodByIndex,\n    getEssentialPropertiesForRepresentation: getEssentialPropertiesForRepresentation,\n    getVoRepresentations: getVoRepresentations,\n    getEventsFor: getEventsFor,\n    getEvent: getEvent,\n    getMpd: getMpd,\n    setConfig: setConfig,\n    updatePeriods: updatePeriods,\n    getIsTextTrack: getIsTextTrack,\n    getUTCTimingSources: getUTCTimingSources,\n    getSuggestedPresentationDelay: getSuggestedPresentationDelay,\n    getAvailabilityStartTime: getAvailabilityStartTime,\n    getIsTypeOf: getIsTypeOf,\n    getIsDynamic: getIsDynamic,\n    getDuration: getDuration,\n    getRegularPeriods: getRegularPeriods,\n    getLocation: getLocation,\n    getPatchLocation: getPatchLocation,\n    getManifestUpdatePeriod: getManifestUpdatePeriod,\n    getPublishTime: getPublishTime,\n    getIsDVB: getIsDVB,\n    getIsPatch: getIsPatch,\n    getBaseURLsFromElement: getBaseURLsFromElement,\n    getRepresentationSortFunction: getRepresentationSortFunction,\n    getCodec: getCodec,\n    getVoAdaptations: getVoAdaptations,\n    getVoPeriods: getVoPeriods,\n    getPeriodById: getPeriodById,\n    setCurrentMediaInfo: setCurrentMediaInfo,\n    isPatchValid: isPatchValid,\n    applyPatchToManifest: applyPatchToManifest,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nDashAdapter.__dashjs_factory_name = 'DashAdapter';\nexports.default = _FactoryMaker2.default.getSingletonFactory(DashAdapter);","map":{"version":3,"mappings":"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","names":["DashAdapter","instance","dashManifestModel","patchManifestModel","voPeriods","voAdaptations","currentMediaInfo","constants","cea608parser","context","PROFILE_DVB","setup","getInstance","reset","getVoAdaptations","getVoPeriods","setConfig","config","errHandler","BASE64","convertRepresentationToRepresentationInfo","voRepresentation","representationInfo","RepresentationInfo","realAdaptation","adaptation","period","mpd","manifest","Period_asArray","index","AdaptationSet_asArray","realRepresentation","getRepresentationFor","id","quality","bandwidth","getBandwidth","DVRWindow","segmentAvailabilityRange","fragmentDuration","segmentDuration","segments","length","duration","NaN","MSETimeOffset","mediaInfo","convertAdaptationToMediaInfo","getMediaInfoForType","streamInfo","type","selectedVoPeriod","getPeriodForStreamInfo","periodId","getAdaptationsForPeriod","getAdaptationForType","idx","getIndexForAdaptation","getIsMain","getRolesForAdaptation","filter","role","value","DashConstants","MAIN","periodIndex","adaptations","getAdaptationsForType","allMediaInfoForType","getAllMediaInfoForType","i","ln","areMediaInfosEqual","mInfoOne","mInfoTwo","sameId","sameViewpoint","viewpoint","sameLang","lang","sameRoles","roles","toString","sameAccessibility","accessibility","sameAudioChannelConfiguration","audioChannelConfiguration","externalManifest","voLocalPeriods","mediaArr","data","media","j","checkConfig","getRegularPeriods","adaptationsForType","EMBEDDED_TEXT","VIDEO","accessibilityLength","indexOf","substring","parts","split","call","convertVideoInfoToEmbeddedTextInfo","push","CC1","IMAGE","convertVideoInfoToThumbnailInfo","updatePeriods","newManifest","getStreamsInfo","maxStreamsInfo","streams","convertPeriodToStreamInfo","getRealAdaptation","getAdaptationForId","getAdaptationForIndex","getEssentialPropertiesForRepresentation","representation","e","getRealPeriodByIndex","getRealPeriodForIndex","getVoRepresentations","voReps","voAdaptation","getAdaptationForMediaInfo","getRepresentationsForAdaptation","getEvent","eventBox","eventStreams","mediaStartTime","isNaN","schemeIdUri","scheme_id_uri","event","Event","timescale","periodStart","start","eventStream","presentationTimeOffset","presentationTimeDelta","presentation_time_delta","calculatedPresentationTime","version","event_duration","messageData","message_data","getEventsFor","info","events","StreamInfo","getEventsForPeriod","MediaInfo","getEventStreamForAdaptationSet","getEventStreamForRepresentation","setCurrentMediaInfo","streamId","getIsTextTrack","getUTCTimingSources","getManifest","getSuggestedPresentationDelay","getAvailabilityStartTime","getMpd","getIsDynamic","getDuration","getLocation","getManifestUpdatePeriod","latencyOfLastUpdate","getPublishTime","getPatchLocation","patchLocation","publishTime","hasOwnProperty","ttl","parseFloat","getTime","Date","__text","getIsDVB","hasProfile","getIsPatch","getBaseURLsFromElement","node","getRepresentationSortFunction","getCodec","representationId","addResolutionInfo","getBandwidthForRepresentation","periodIdx","getPeriod","findRepresentation","getIndexForRepresentation","findRepresentationIndex","getMaxIndexForBufferType","bufferType","findMaxBufferIndex","getPeriodById","periods","p","getIsTypeOf","isPatchValid","patch","manifestId","getId","patchManifestId","getMpdId","manifestPublishTime","patchPublishTime","originalManifestPublishTime","getOriginalPublishTime","applyPatchToManifest","getPatchOperations","forEach","operation","result","getMpdTarget","name","target","leaf","xpath","findsAttribute","action","relativePosition","insertBefore","position","targetArray","splice","Object","keys","insert","insertNodes","updatedNodes","apply","concat","undefined","voPeriodsArray","voPeriod","representationCount","getRepresentationCount","labels","getLabelsForAdaptation","getLanguageForAdaptation","getViewpointForAdaptation","getAccessibilityForAdaptation","map","accessibilityValue","accessibilityData","search","embeddedCaptions","getAudioChannelConfigurationForAdaptation","Array","isArray","Representation_asArray","getAudioChannelConfigurationForRepresentation","codec","mimeType","getMimeType","contentProtection","getContentProtectionData","bitrateList","getBitrateListForAdaptation","item","KID","getKID","isText","supplementalProperties","getSupplementalPropperties","channel","parseInt","isEmbedded","THRESHOLD","manifestInfo","convertMpdToManifestInfo","isLast","Math","abs","ManifestInfo","DVRWindowSize","timeShiftBufferDepth","loadedTime","availableFrom","availabilityStartTime","minBufferTime","maxFragmentDuration","maxSegmentDuration","isDynamic","serviceDescriptions","getServiceDescriptions","protocol","Error","returnIndex","adaptationSet","adaptationSetArray","representationArray","adaptationSetArrayIndex","representationArrayIndex","convertDataToRepresentationInfo","getDataForMedia","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/dash/DashAdapter.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport DashConstants from './constants/DashConstants';\nimport RepresentationInfo from './vo/RepresentationInfo';\nimport MediaInfo from './vo/MediaInfo';\nimport StreamInfo from './vo/StreamInfo';\nimport ManifestInfo from './vo/ManifestInfo';\nimport Event from './vo/Event';\nimport FactoryMaker from '../core/FactoryMaker';\nimport DashManifestModel from './models/DashManifestModel';\nimport PatchManifestModel from './models/PatchManifestModel';\n\n/**\n * @module DashAdapter\n */\n\nfunction DashAdapter() {\n    let instance,\n        dashManifestModel,\n        patchManifestModel,\n        voPeriods,\n        voAdaptations,\n        currentMediaInfo,\n        constants,\n        cea608parser;\n\n    const context = this.context;\n\n    const PROFILE_DVB = 'urn:dvb:dash:profile:dvb-dash:2014';\n\n    function setup() {\n        dashManifestModel = DashManifestModel(context).getInstance();\n        patchManifestModel = PatchManifestModel(context).getInstance();\n        reset();\n    }\n\n    // #region PUBLIC FUNCTIONS\n    // --------------------------------------------------\n    function getVoAdaptations() {\n        return voAdaptations;\n    }\n\n    function getVoPeriods() {\n        return voPeriods;\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.constants) {\n            constants = config.constants;\n        }\n\n        if (config.cea608parser) {\n            cea608parser = config.cea608parser;\n        }\n\n        if (config.errHandler) {\n            dashManifestModel.setConfig({ errHandler: config.errHandler });\n        }\n\n        if (config.BASE64) {\n            dashManifestModel.setConfig({ BASE64: config.BASE64 });\n        }\n    }\n\n    /**\n     * Creates an instance of RepresentationInfo based on a representation value object\n     * @param {object} voRepresentation\n     * @returns {RepresentationInfo|null} representationInfo\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function convertRepresentationToRepresentationInfo(voRepresentation) {\n        if (voRepresentation) {\n            let representationInfo = new RepresentationInfo();\n            const realAdaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\n            const realRepresentation = dashManifestModel.getRepresentationFor(voRepresentation.index, realAdaptation);\n\n            representationInfo.id = voRepresentation.id;\n            representationInfo.quality = voRepresentation.index;\n            representationInfo.bandwidth = dashManifestModel.getBandwidth(realRepresentation);\n            representationInfo.DVRWindow = voRepresentation.segmentAvailabilityRange;\n            representationInfo.fragmentDuration = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length > 0 ? voRepresentation.segments[0].duration : NaN);\n            representationInfo.MSETimeOffset = voRepresentation.MSETimeOffset;\n            representationInfo.mediaInfo = convertAdaptationToMediaInfo(voRepresentation.adaptation);\n\n            return representationInfo;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns a MediaInfo object for a given media type.\n     * @param {object} streamInfo\n     * @param {MediaType }type\n     * @returns {null|MediaInfo} mediaInfo\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getMediaInfoForType(streamInfo, type) {\n        if (voPeriods.length === 0 || !streamInfo) {\n            return null;\n        }\n\n        let selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voPeriods);\n        if (!selectedVoPeriod) return null;\n\n        let periodId = selectedVoPeriod.id;\n        voAdaptations[periodId] = voAdaptations[periodId] || dashManifestModel.getAdaptationsForPeriod(selectedVoPeriod);\n\n        let realAdaptation = getAdaptationForType(streamInfo.index, type, streamInfo);\n        if (!realAdaptation) return null;\n        let idx = dashManifestModel.getIndexForAdaptation(realAdaptation, voPeriods[0].mpd.manifest, streamInfo.index);\n\n        return convertAdaptationToMediaInfo(voAdaptations[periodId][idx]);\n    }\n\n    /**\n     * Checks if the role of the specified AdaptationSet is set to main\n     * @param {object} adaptation\n     * @returns {boolean}\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getIsMain(adaptation) {\n        return dashManifestModel.getRolesForAdaptation(adaptation).filter(function (role) {\n            return role.value === DashConstants.MAIN;\n        })[0];\n    }\n\n    /**\n     * Returns the AdaptationSet for a given period and a given mediaType.\n     * @param {number} periodIndex\n     * @param {MediaType} type\n     * @param {object} streamInfo\n     * @returns {null|object} adaptation\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getAdaptationForType(periodIndex, type, streamInfo) {\n        const adaptations = dashManifestModel.getAdaptationsForType(voPeriods[0].mpd.manifest, periodIndex, type);\n\n        if (!adaptations || adaptations.length === 0) return null;\n\n        if (adaptations.length > 1 && streamInfo) {\n            const allMediaInfoForType = getAllMediaInfoForType(streamInfo, type);\n\n            if (currentMediaInfo[streamInfo.id] && currentMediaInfo[streamInfo.id][type]) {\n                for (let i = 0, ln = adaptations.length; i < ln; i++) {\n                    if (areMediaInfosEqual(currentMediaInfo[streamInfo.id][type], allMediaInfoForType[i])) {\n                        return adaptations[i];\n                    }\n                }\n            }\n\n            for (let i = 0, ln = adaptations.length; i < ln; i++) {\n                if (getIsMain(adaptations[i])) {\n                    return adaptations[i];\n                }\n            }\n        }\n\n        return adaptations[0];\n    }\n\n    /**\n     * Compares two mediaInfo objects\n     * @param {MediaInfo} mInfoOne\n     * @param {MediaInfo} mInfoTwo\n     * @returns {boolean}\n     */\n    function areMediaInfosEqual(mInfoOne, mInfoTwo) {\n        if (!mInfoOne || !mInfoTwo) {\n            return false;\n        }\n\n        const sameId = mInfoOne.id === mInfoTwo.id;\n        const sameViewpoint = mInfoOne.viewpoint === mInfoTwo.viewpoint;\n        const sameLang = mInfoOne.lang === mInfoTwo.lang;\n        const sameRoles = mInfoOne.roles.toString() === mInfoTwo.roles.toString();\n        const sameAccessibility = mInfoOne.accessibility.toString() === mInfoTwo.accessibility.toString();\n        const sameAudioChannelConfiguration = mInfoOne.audioChannelConfiguration.toString() === mInfoTwo.audioChannelConfiguration.toString();\n\n        return (sameId && sameViewpoint && sameLang && sameRoles && sameAccessibility && sameAudioChannelConfiguration);\n    }\n\n    /**\n     * Returns the mediaInfo for a given mediaType\n     * @param {object} streamInfo\n     * @param {MediaType} type\n     * @param {object} externalManifest Set to null or undefined if no external manifest is to be used\n     * @returns {Array} mediaArr\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getAllMediaInfoForType(streamInfo, type, externalManifest) {\n        let voLocalPeriods = voPeriods;\n        let manifest = externalManifest;\n        let mediaArr = [];\n        let data,\n            media,\n            idx,\n            i,\n            j,\n            ln,\n            periodId;\n\n        if (manifest) {\n            checkConfig();\n\n            voLocalPeriods = getRegularPeriods(manifest);\n        } else {\n            if (voPeriods.length > 0) {\n                manifest = voPeriods[0].mpd.manifest;\n            } else {\n                return mediaArr;\n            }\n        }\n\n        const selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voLocalPeriods);\n        if (selectedVoPeriod) {\n            periodId = selectedVoPeriod.id;\n        }\n        const adaptationsForType = dashManifestModel.getAdaptationsForType(manifest, streamInfo ? streamInfo.index : null, type !== constants.EMBEDDED_TEXT ? type : constants.VIDEO);\n\n        if (!adaptationsForType || adaptationsForType.length === 0) return mediaArr;\n\n        voAdaptations[periodId] = voAdaptations[periodId] || dashManifestModel.getAdaptationsForPeriod(selectedVoPeriod);\n\n        for (i = 0, ln = adaptationsForType.length; i < ln; i++) {\n            data = adaptationsForType[i];\n            idx = dashManifestModel.getIndexForAdaptation(data, manifest, streamInfo.index);\n            media = convertAdaptationToMediaInfo(voAdaptations[periodId][idx]);\n\n            if (type === constants.EMBEDDED_TEXT) {\n                let accessibilityLength = media.accessibility.length;\n                for (j = 0; j < accessibilityLength; j++) {\n                    if (!media) {\n                        continue;\n                    }\n                    let accessibility = media.accessibility[j];\n                    if (accessibility.indexOf('cea-608:') === 0) {\n                        let value = accessibility.substring(8);\n                        let parts = value.split(';');\n                        if (parts[0].substring(0, 2) === 'CC') {\n                            for (j = 0; j < parts.length; j++) {\n                                if (!media) {\n                                    media = convertAdaptationToMediaInfo.call(this, voAdaptations[periodId][idx]);\n                                }\n                                convertVideoInfoToEmbeddedTextInfo(media, parts[j].substring(0, 3), parts[j].substring(4));\n                                mediaArr.push(media);\n                                media = null;\n                            }\n                        } else {\n                            for (j = 0; j < parts.length; j++) { // Only languages for CC1, CC2, ...\n                                if (!media) {\n                                    media = convertAdaptationToMediaInfo.call(this, voAdaptations[periodId][idx]);\n                                }\n                                convertVideoInfoToEmbeddedTextInfo(media, 'CC' + (j + 1), parts[j]);\n                                mediaArr.push(media);\n                                media = null;\n                            }\n                        }\n                    } else if (accessibility.indexOf('cea-608') === 0) { // Nothing known. We interpret it as CC1=eng\n                        convertVideoInfoToEmbeddedTextInfo(media, constants.CC1, 'eng');\n                        mediaArr.push(media);\n                        media = null;\n                    }\n                }\n            } else if (type === constants.IMAGE) {\n                convertVideoInfoToThumbnailInfo(media);\n                mediaArr.push(media);\n                media = null;\n            } else if (media) {\n                mediaArr.push(media);\n            }\n        }\n\n        return mediaArr;\n    }\n\n    /**\n     * @param {object} newManifest\n     * @returns {*}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function updatePeriods(newManifest) {\n        if (!newManifest) return null;\n\n        checkConfig();\n\n        voPeriods = getRegularPeriods(newManifest);\n\n        voAdaptations = {};\n    }\n\n    /**\n     * @param {object} externalManifest\n     * @param {number} maxStreamsInfo\n     * @returns {Array} streams\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getStreamsInfo(externalManifest, maxStreamsInfo) {\n        const streams = [];\n        let voLocalPeriods = voPeriods;\n\n        //if manifest is defined, getStreamsInfo is for an outside manifest, not the current one\n        if (externalManifest) {\n            checkConfig();\n            voLocalPeriods = getRegularPeriods(externalManifest);\n        }\n\n        if (voLocalPeriods.length > 0) {\n            if (!maxStreamsInfo || maxStreamsInfo > voLocalPeriods.length) {\n                maxStreamsInfo = voLocalPeriods.length;\n            }\n            for (let i = 0; i < maxStreamsInfo; i++) {\n                streams.push(convertPeriodToStreamInfo(voLocalPeriods[i]));\n            }\n        }\n\n        return streams;\n    }\n\n    /**\n     *\n     * @param {object} streamInfo\n     * @param {object} mediaInfo\n     * @returns {object} realAdaptation\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getRealAdaptation(streamInfo, mediaInfo) {\n        let id,\n            realAdaptation;\n\n        const selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voPeriods);\n\n        id = mediaInfo ? mediaInfo.id : null;\n\n        if (voPeriods.length > 0 && selectedVoPeriod) {\n            realAdaptation = id ? dashManifestModel.getAdaptationForId(id, voPeriods[0].mpd.manifest, selectedVoPeriod.index) : dashManifestModel.getAdaptationForIndex(mediaInfo ? mediaInfo.index : null, voPeriods[0].mpd.manifest, selectedVoPeriod.index);\n        }\n\n        return realAdaptation;\n    }\n\n    /**\n     * Return all EssentialProperties of a Representation\n     * @param {object} representation\n     * @return {array}\n     */\n    function getEssentialPropertiesForRepresentation(representation) {\n        try {\n            return dashManifestModel.getEssentialPropertiesForRepresentation(representation);\n        } catch (e) {\n            return [];\n        }\n    }\n\n    /**\n     * Returns the period by index\n     * @param {number} index\n     * @return {object}\n     */\n    function getRealPeriodByIndex(index) {\n        return dashManifestModel.getRealPeriodForIndex(index, voPeriods[0].mpd.manifest);\n    }\n\n    /**\n     * Returns all voRepresentations for a given mediaInfo\n     * @param {object} mediaInfo\n     * @returns {Array} voReps\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getVoRepresentations(mediaInfo) {\n        let voReps;\n\n        const voAdaptation = getAdaptationForMediaInfo(mediaInfo);\n        voReps = dashManifestModel.getRepresentationsForAdaptation(voAdaptation);\n\n        return voReps;\n    }\n\n    /**\n     *\n     * @param {object} eventBox\n     * @param {object} eventStreams\n     * @param {number} mediaStartTime\n     * @param {object} voRepresentation\n     * @returns {null|Event}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getEvent(eventBox, eventStreams, mediaStartTime, voRepresentation) {\n        try {\n            if (!eventBox || !eventStreams || isNaN(mediaStartTime) || !voRepresentation) {\n                return null;\n            }\n\n            const schemeIdUri = eventBox.scheme_id_uri;\n            const value = eventBox.value;\n\n            if (!eventStreams[schemeIdUri + '/' + value]) {\n                return null;\n            }\n\n            const event = new Event();\n            const timescale = eventBox.timescale || 1;\n            const periodStart = voRepresentation.adaptation.period.start;\n            const eventStream = eventStreams[schemeIdUri + '/' + value];\n            const presentationTimeOffset = !isNaN(voRepresentation.presentationTimeOffset) ? voRepresentation.presentationTimeOffset : !isNaN(eventStream.presentationTimeOffset) ? eventStream.presentationTimeOffset : 0;\n            let presentationTimeDelta = eventBox.presentation_time_delta / timescale; // In case of version 1 events the presentation_time is parsed as presentation_time_delta\n            let calculatedPresentationTime;\n\n            if (eventBox.version === 0) {\n                calculatedPresentationTime = periodStart + mediaStartTime - presentationTimeOffset + presentationTimeDelta;\n            } else {\n                calculatedPresentationTime = periodStart - presentationTimeOffset + presentationTimeDelta;\n            }\n\n            const duration = eventBox.event_duration;\n            const id = eventBox.id;\n            const messageData = eventBox.message_data;\n\n            event.eventStream = eventStream;\n            event.eventStream.value = value;\n            event.eventStream.timescale = timescale;\n            event.duration = duration;\n            event.id = id;\n            event.calculatedPresentationTime = calculatedPresentationTime;\n            event.messageData = messageData;\n            event.presentationTimeDelta = presentationTimeDelta;\n\n            return event;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    /**\n     *\n     * @param {object} info\n     * @param {object} voRepresentation\n     * @returns {Array}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getEventsFor(info, voRepresentation) {\n        let events = [];\n\n        if (voPeriods.length > 0) {\n            const manifest = voPeriods[0].mpd.manifest;\n\n            if (info instanceof StreamInfo) {\n                events = dashManifestModel.getEventsForPeriod(getPeriodForStreamInfo(info, voPeriods));\n            } else if (info instanceof MediaInfo) {\n                events = dashManifestModel.getEventStreamForAdaptationSet(manifest, getAdaptationForMediaInfo(info));\n            } else if (info instanceof RepresentationInfo) {\n                events = dashManifestModel.getEventStreamForRepresentation(manifest, voRepresentation);\n            }\n        }\n\n        return events;\n    }\n\n    /**\n     *\n     * @param {number} streamId\n     * @param {MediaType} type\n     * @param {object} mediaInfo\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function setCurrentMediaInfo(streamId, type, mediaInfo) {\n        currentMediaInfo[streamId] = currentMediaInfo[streamId] || {};\n        currentMediaInfo[streamId][type] = currentMediaInfo[streamId][type] || {};\n        currentMediaInfo[streamId][type] = mediaInfo;\n    }\n\n    /**\n     *\n     * @param {String} type\n     * @returns {boolean}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getIsTextTrack(type) {\n        return dashManifestModel.getIsTextTrack(type);\n    }\n\n    /**\n     * Returns the UTC Timing Sources specified in the manifest\n     * @returns {Array} utcTimingSources\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getUTCTimingSources() {\n        const manifest = getManifest();\n        return dashManifestModel.getUTCTimingSources(manifest);\n    }\n\n    /**\n     * Returns the suggestedPresentationDelay as specified in the manifest\n     * @returns {String} suggestedPresentationDelay\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getSuggestedPresentationDelay() {\n        const mpd = voPeriods.length > 0 ? voPeriods[0].mpd : null;\n        return dashManifestModel.getSuggestedPresentationDelay(mpd);\n    }\n\n    /**\n     * Returns the availabilityStartTime as specified in the manifest\n     * @param {object} externalManifest Omit this value if no external manifest should be used\n     * @returns {string} availabilityStartTime\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getAvailabilityStartTime(externalManifest) {\n        const mpd = getMpd(externalManifest);\n        return dashManifestModel.getAvailabilityStartTime(mpd);\n    }\n\n    /**\n     * Returns a boolean indicating if the manifest is dynamic or not\n     * @param {object} externalManifest Omit this value if no external manifest should be used\n     * @returns {boolean}\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getIsDynamic(externalManifest) {\n        const manifest = getManifest(externalManifest);\n        return dashManifestModel.getIsDynamic(manifest);\n    }\n\n    /**\n     * Returns the duration of the MPD\n     * @param {object} externalManifest Omit this value if no external manifest should be used\n     * @returns {number} duration\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getDuration(externalManifest) {\n        const manifest = getManifest(externalManifest);\n        return dashManifestModel.getDuration(manifest);\n    }\n\n    /**\n     * Returns all periods of the MPD\n     * @param {object} externalManifest Omit this value if no external manifest should be used\n     * @returns {Array} periods\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getRegularPeriods(externalManifest) {\n        const mpd = getMpd(externalManifest);\n        return dashManifestModel.getRegularPeriods(mpd);\n    }\n\n    /**\n     * Returns an MPD object\n     * @param {object} externalManifest Omit this value if no external manifest should be used\n     * @returns {object} MPD\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getMpd(externalManifest) {\n        const manifest = getManifest(externalManifest);\n        return dashManifestModel.getMpd(manifest);\n    }\n\n    /**\n     * Returns the location element of the MPD\n     * @param {object} manifest\n     * @returns {String} location\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getLocation(manifest) {\n        return dashManifestModel.getLocation(manifest);\n    }\n\n    /**\n     * Returns the manifest update period used for dynamic manifests\n     * @param {object} manifest\n     * @param {number} latencyOfLastUpdate\n     * @returns {NaN|number} manifestUpdatePeriod\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getManifestUpdatePeriod(manifest, latencyOfLastUpdate = 0) {\n        return dashManifestModel.getManifestUpdatePeriod(manifest, latencyOfLastUpdate);\n    }\n\n    /**\n     * Returns the publish time from the manifest\n     * @param {object} manifest\n     * @returns {Date|null} publishTime\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getPublishTime(manifest) {\n        return dashManifestModel.getPublishTime(manifest);\n    }\n\n    /**\n     * Returns the patch location of the MPD if one exists and it is still valid\n     * @param {object} manifest\n     * @returns {(String|null)} patch location\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getPatchLocation(manifest) {\n        const patchLocation = dashManifestModel.getPatchLocation(manifest);\n        const publishTime = dashManifestModel.getPublishTime(manifest);\n\n        // short-circuit when no patch location or publish time exists\n        if (!patchLocation || !publishTime) {\n            return null;\n        }\n\n        // if a ttl is provided, ensure patch location has not expired\n        if (patchLocation.hasOwnProperty('ttl') && publishTime) {\n            // attribute describes number of seconds as a double\n            const ttl = parseFloat(patchLocation.ttl) * 1000;\n\n            // check if the patch location has expired, if so do not consider it\n            if (publishTime.getTime() + ttl <= new Date().getTime()) {\n                return null;\n            }\n        }\n\n        // the patch location exists and, if a ttl applies, has not expired\n        return patchLocation.__text;\n    }\n\n    /**\n     * Checks if the manifest has a DVB profile\n     * @param {object} manifest\n     * @returns {boolean}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getIsDVB(manifest) {\n        return dashManifestModel.hasProfile(manifest, PROFILE_DVB);\n    }\n\n    /**\n     * Checks if the manifest is actually just a patch manifest\n     * @param  {object} manifest\n     * @return {boolean}\n     */\n    function getIsPatch(manifest) {\n        return patchManifestModel.getIsPatch(manifest);\n    }\n\n    /**\n     *\n     * @param {object} node\n     * @returns {Array}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getBaseURLsFromElement(node) {\n        return dashManifestModel.getBaseURLsFromElement(node);\n    }\n\n    /**\n     *\n     * @returns {*}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getRepresentationSortFunction() {\n        return dashManifestModel.getRepresentationSortFunction();\n    }\n\n    /**\n     * Returns the codec for a given adaptation set and a given representation id.\n     * @param {object} adaptation\n     * @param {number} representationId\n     * @param {boolean} addResolutionInfo Defines whether to include resolution information in the output\n     * @returns {String} codec\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getCodec(adaptation, representationId, addResolutionInfo) {\n        return dashManifestModel.getCodec(adaptation, representationId, addResolutionInfo);\n    }\n\n    /**\n     * Returns the bandwidth for a given representation id\n     * @param {number} representationId\n     * @param {number} periodIdx\n     * @returns {number} bandwidth\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getBandwidthForRepresentation(representationId, periodIdx) {\n        let representation;\n        let period = getPeriod(periodIdx);\n\n        representation = findRepresentation(period, representationId);\n\n        return representation ? representation.bandwidth : null;\n    }\n\n    /**\n     * Returns the index for a given representation id\n     * @param {string} representationId\n     * @param {number} periodIdx\n     * @returns {number} index\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getIndexForRepresentation(representationId, periodIdx) {\n        let period = getPeriod(periodIdx);\n\n        return findRepresentationIndex(period, representationId);\n    }\n\n    /**\n     * This method returns the current max index based on what is defined in the MPD.\n     *\n     * @param {string} bufferType - String 'audio' or 'video',\n     * @param {number} periodIdx - Make sure this is the period index not id\n     * @return {number}\n     * @memberof module:DashAdapter\n     * @instance\n     */\n    function getMaxIndexForBufferType(bufferType, periodIdx) {\n        let period = getPeriod(periodIdx);\n\n        return findMaxBufferIndex(period, bufferType);\n    }\n\n    /**\n     * Returns the voPeriod object for a given id\n     * @param {String} id\n     * @returns {object|null}\n     */\n    function getPeriodById(id) {\n        if (!id || voPeriods.length === 0) {\n            return null;\n        }\n        const periods = voPeriods.filter((p) => {\n            return p.id === id;\n        });\n\n        if (periods && periods.length > 0) {\n            return periods[0];\n        }\n\n        return null;\n    }\n\n    function getIsTypeOf(adaptation, type) {\n        return dashManifestModel.getIsTypeOf(adaptation, type);\n    }\n\n    function reset() {\n        voPeriods = [];\n        voAdaptations = {};\n        currentMediaInfo = {};\n    }\n\n    /**\n     * Checks if the supplied manifest is compatible for application of the supplied patch\n     * @param  {object}  manifest\n     * @param  {object}  patch\n     * @return {boolean}\n     */\n    function isPatchValid(manifest, patch) {\n        let manifestId = dashManifestModel.getId(manifest);\n        let patchManifestId = patchManifestModel.getMpdId(patch);\n        let manifestPublishTime = dashManifestModel.getPublishTime(manifest);\n        let patchPublishTime = patchManifestModel.getPublishTime(patch);\n        let originalManifestPublishTime = patchManifestModel.getOriginalPublishTime(patch);\n\n        // Patches are considered compatible if the following are true\n        // - MPD@id == Patch@mpdId\n        // - MPD@publishTime == Patch@originalPublishTime\n        // - MPD@publishTime < Patch@publishTime\n        // - All values in comparison exist\n        return !!(manifestId && patchManifestId && (manifestId == patchManifestId) &&\n            manifestPublishTime && originalManifestPublishTime && (manifestPublishTime.getTime() == originalManifestPublishTime.getTime()) &&\n            patchPublishTime && (manifestPublishTime.getTime() < patchPublishTime.getTime()));\n    }\n\n    /**\n     * Takes a given patch and applies it to the provided manifest, assumes patch is valid for manifest\n     * @param  {object} manifest\n     * @param  {object} patch\n     */\n    function applyPatchToManifest(manifest, patch) {\n        // get all operations from the patch and apply them in document order\n        patchManifestModel.getPatchOperations(patch)\n            .forEach((operation) => {\n                let result = operation.getMpdTarget(manifest);\n\n                // operation supplies a path that doesn't match mpd, skip\n                if (result === null) {\n                    return;\n                }\n\n                let {name, target, leaf} = result;\n\n                // short circuit for attribute selectors\n                if (operation.xpath.findsAttribute()) {\n                    switch (operation.action) {\n                        case 'add':\n                        case 'replace':\n                            // add and replace are just setting the value\n                            target[name] = operation.value;\n                            break;\n                        case 'remove':\n                            // remove is deleting the value\n                            delete target[name];\n                            break;\n                    }\n                    return;\n                }\n\n                // determine the relative insert position prior to possible removal\n                let relativePosition = (target[name + '_asArray'] || []).indexOf(leaf);\n                let insertBefore = (operation.position === 'prepend' || operation.position === 'before');\n\n                // perform removal operation first, we have already capture the appropriate relative position\n                if (operation.action === 'remove' || operation.action === 'replace') {\n                    // note that we ignore the 'ws' attribute of patch operations as it does not effect parsed mpd operations\n\n                    // purge the directly named entity\n                    delete target[name];\n\n                    // if we did have a positional reference we need to purge from array set and restore X2JS proper semantics\n                    if (relativePosition != -1) {\n                        let targetArray = target[name + '_asArray'];\n                        targetArray.splice(relativePosition, 1);\n                        if (targetArray.length > 1) {\n                            target[name] = targetArray;\n                        } else if (targetArray.length == 1) {\n                            // xml parsing semantics, singular asArray must be non-array in the unsuffixed key\n                            target[name] = targetArray[0];\n                        } else {\n                            // all nodes of this type deleted, remove entry\n                            delete target[name + '_asArray'];\n                        }\n                    }\n                }\n\n                // Perform any add/replace operations now, technically RFC5261 only allows a single element to take the\n                // place of a replaced element while the add case allows an arbitrary number of children.\n                // Due to the both operations requiring the same insertion logic they have been combined here and we will\n                // not enforce single child operations for replace, assertions should be made at patch parse time if necessary\n                if (operation.action === 'add' || operation.action === 'replace') {\n                    // value will be an object with element name keys pointing to arrays of objects\n                    Object.keys(operation.value).forEach((insert) => {\n                        let insertNodes = operation.value[insert];\n\n                        let updatedNodes = target[insert + '_asArray'] || [];\n                        if (updatedNodes.length === 0 && target[insert]) {\n                            updatedNodes.push(target[insert]);\n                        }\n\n                        if (updatedNodes.length === 0) {\n                            // no original nodes for this element type\n                            updatedNodes = insertNodes;\n                        } else {\n                            // compute the position we need to insert at, default to end of set\n                            let position = updatedNodes.length;\n                            if (insert == name && relativePosition != -1) {\n                                // if the inserted element matches the operation target (not leaf) and there is a relative position we\n                                // want the inserted position to be set such that our insertion is relative to original position\n                                // since replace has modified the array length we reduce the insert point by 1\n                                position = relativePosition + (insertBefore ? 0 : 1) + (operation.action == 'replace' ? -1 : 0);\n                            } else {\n                                // otherwise we are in an add append/prepend case or replace case that removed the target name completely\n                                position = insertBefore ? 0 : updatedNodes.length;\n                            }\n\n                            // we dont have to perform element removal for the replace case as that was done above\n                            updatedNodes.splice.apply(updatedNodes, [position, 0].concat(insertNodes));\n                        }\n\n                        // now we properly reset the element keys on the target to match parsing semantics\n                        target[insert + '_asArray'] = updatedNodes;\n                        target[insert] = updatedNodes.length == 1 ? updatedNodes[0] : updatedNodes;\n                    });\n                }\n            });\n    }\n\n    // #endregion PUBLIC FUNCTIONS\n\n    // #region PRIVATE FUNCTIONS\n    // --------------------------------------------------\n    function getManifest(externalManifest) {\n        return externalManifest ? externalManifest : voPeriods.length > 0 ? voPeriods[0].mpd.manifest : null;\n    }\n\n    function getAdaptationForMediaInfo(mediaInfo) {\n        if (!mediaInfo || !mediaInfo.streamInfo || mediaInfo.streamInfo.id === undefined || !voAdaptations[mediaInfo.streamInfo.id]) return null;\n        return voAdaptations[mediaInfo.streamInfo.id][mediaInfo.index];\n    }\n\n    function getPeriodForStreamInfo(streamInfo, voPeriodsArray) {\n        const ln = voPeriodsArray.length;\n\n        for (let i = 0; i < ln; i++) {\n            let voPeriod = voPeriodsArray[i];\n\n            if (streamInfo && streamInfo.id === voPeriod.id) return voPeriod;\n        }\n\n        return null;\n    }\n\n    function convertAdaptationToMediaInfo(adaptation) {\n        if (!adaptation) {\n            return null;\n        }\n\n        let mediaInfo = new MediaInfo();\n        const realAdaptation = adaptation.period.mpd.manifest.Period_asArray[adaptation.period.index].AdaptationSet_asArray[adaptation.index];\n        let viewpoint;\n\n        mediaInfo.id = adaptation.id;\n        mediaInfo.index = adaptation.index;\n        mediaInfo.type = adaptation.type;\n        mediaInfo.streamInfo = convertPeriodToStreamInfo(adaptation.period);\n        mediaInfo.representationCount = dashManifestModel.getRepresentationCount(realAdaptation);\n        mediaInfo.labels = dashManifestModel.getLabelsForAdaptation(realAdaptation);\n        mediaInfo.lang = dashManifestModel.getLanguageForAdaptation(realAdaptation);\n        viewpoint = dashManifestModel.getViewpointForAdaptation(realAdaptation);\n        mediaInfo.viewpoint = viewpoint ? viewpoint.value : undefined;\n        mediaInfo.accessibility = dashManifestModel.getAccessibilityForAdaptation(realAdaptation).map(function (accessibility) {\n            let accessibilityValue = accessibility.value;\n            let accessibilityData = accessibilityValue;\n            if (accessibility.schemeIdUri && (accessibility.schemeIdUri.search('cea-608') >= 0) && typeof (cea608parser) !== 'undefined') {\n                if (accessibilityValue) {\n                    accessibilityData = 'cea-608:' + accessibilityValue;\n                } else {\n                    accessibilityData = 'cea-608';\n                }\n                mediaInfo.embeddedCaptions = true;\n            }\n            return accessibilityData;\n        });\n\n        mediaInfo.audioChannelConfiguration = dashManifestModel.getAudioChannelConfigurationForAdaptation(realAdaptation).map(function (audioChannelConfiguration) {\n            return audioChannelConfiguration.value;\n        });\n\n        if (mediaInfo.audioChannelConfiguration.length === 0 && Array.isArray(realAdaptation.Representation_asArray) && realAdaptation.Representation_asArray.length > 0) {\n            mediaInfo.audioChannelConfiguration = dashManifestModel.getAudioChannelConfigurationForRepresentation(realAdaptation.Representation_asArray[0]).map(function (audioChannelConfiguration) {\n                return audioChannelConfiguration.value;\n            });\n        }\n        mediaInfo.roles = dashManifestModel.getRolesForAdaptation(realAdaptation).map(function (role) {\n            return role.value;\n        });\n        mediaInfo.codec = dashManifestModel.getCodec(realAdaptation);\n        mediaInfo.mimeType = dashManifestModel.getMimeType(realAdaptation);\n        mediaInfo.contentProtection = dashManifestModel.getContentProtectionData(realAdaptation);\n        mediaInfo.bitrateList = dashManifestModel.getBitrateListForAdaptation(realAdaptation);\n\n        if (mediaInfo.contentProtection) {\n            mediaInfo.contentProtection.forEach(function (item) {\n                item.KID = dashManifestModel.getKID(item);\n            });\n        }\n\n        mediaInfo.isText = dashManifestModel.getIsTextTrack(mediaInfo.mimeType);\n        mediaInfo.supplementalProperties = dashManifestModel.getSupplementalPropperties(realAdaptation);\n\n        return mediaInfo;\n    }\n\n    function convertVideoInfoToEmbeddedTextInfo(mediaInfo, channel, lang) {\n        mediaInfo.id = channel; // CC1, CC2, CC3, or CC4\n        mediaInfo.index = 100 + parseInt(channel.substring(2, 3));\n        mediaInfo.type = constants.EMBEDDED_TEXT;\n        mediaInfo.codec = 'cea-608-in-SEI';\n        mediaInfo.isText = true;\n        mediaInfo.isEmbedded = true;\n        mediaInfo.lang = lang;\n        mediaInfo.roles = ['caption'];\n    }\n\n    function convertVideoInfoToThumbnailInfo(mediaInfo) {\n        mediaInfo.type = constants.IMAGE;\n    }\n\n    function convertPeriodToStreamInfo(period) {\n        let streamInfo = new StreamInfo();\n        const THRESHOLD = 1;\n\n        streamInfo.id = period.id;\n        streamInfo.index = period.index;\n        streamInfo.start = period.start;\n        streamInfo.duration = period.duration;\n        streamInfo.manifestInfo = convertMpdToManifestInfo(period.mpd);\n        streamInfo.isLast = period.mpd.manifest.Period_asArray.length === 1 || Math.abs((streamInfo.start + streamInfo.duration) - streamInfo.manifestInfo.duration) < THRESHOLD;\n\n        return streamInfo;\n    }\n\n    function convertMpdToManifestInfo(mpd) {\n        let manifestInfo = new ManifestInfo();\n\n        manifestInfo.DVRWindowSize = mpd.timeShiftBufferDepth;\n        manifestInfo.loadedTime = mpd.manifest.loadedTime;\n        manifestInfo.availableFrom = mpd.availabilityStartTime;\n        manifestInfo.minBufferTime = mpd.manifest.minBufferTime;\n        manifestInfo.maxFragmentDuration = mpd.maxSegmentDuration;\n        manifestInfo.duration = dashManifestModel.getDuration(mpd.manifest);\n        manifestInfo.isDynamic = dashManifestModel.getIsDynamic(mpd.manifest);\n        manifestInfo.serviceDescriptions = dashManifestModel.getServiceDescriptions(mpd.manifest);\n        manifestInfo.protocol = mpd.manifest.protocol;\n\n        return manifestInfo;\n    }\n\n    function checkConfig() {\n        if (!constants) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    function getPeriod(periodIdx) {\n        return voPeriods.length > 0 ? voPeriods[0].mpd.manifest.Period_asArray[periodIdx] : null;\n    }\n\n    function findRepresentationIndex(period, representationId) {\n        const index = findRepresentation(period, representationId, true);\n\n        return index !== null ? index : -1;\n    }\n\n    function findRepresentation(period, representationId, returnIndex) {\n        let adaptationSet,\n            adaptationSetArray,\n            representation,\n            representationArray,\n            adaptationSetArrayIndex,\n            representationArrayIndex;\n\n        if (period) {\n            adaptationSetArray = period.AdaptationSet_asArray;\n            for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n                adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n                representationArray = adaptationSet.Representation_asArray;\n                for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {\n                    representation = representationArray[representationArrayIndex];\n                    if (representationId === representation.id) {\n                        if (returnIndex) {\n                            return representationArrayIndex;\n                        } else {\n                            return representation;\n                        }\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    function findMaxBufferIndex(period, bufferType) {\n        let adaptationSet,\n            adaptationSetArray,\n            representationArray,\n            adaptationSetArrayIndex;\n\n        if (!period || !bufferType) return -1;\n\n        adaptationSetArray = period.AdaptationSet_asArray;\n        for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n            adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n            representationArray = adaptationSet.Representation_asArray;\n            if (dashManifestModel.getIsTypeOf(adaptationSet, bufferType)) {\n                return representationArray.length;\n            }\n        }\n\n        return -1;\n    }\n\n    // #endregion PRIVATE FUNCTIONS\n\n    instance = {\n        getBandwidthForRepresentation: getBandwidthForRepresentation,\n        getIndexForRepresentation: getIndexForRepresentation,\n        getMaxIndexForBufferType: getMaxIndexForBufferType,\n        convertDataToRepresentationInfo: convertRepresentationToRepresentationInfo,\n        getDataForMedia: getAdaptationForMediaInfo,\n        getStreamsInfo: getStreamsInfo,\n        getMediaInfoForType: getMediaInfoForType,\n        getAllMediaInfoForType: getAllMediaInfoForType,\n        getAdaptationForType: getAdaptationForType,\n        getRealAdaptation: getRealAdaptation,\n        getRealPeriodByIndex,\n        getEssentialPropertiesForRepresentation,\n        getVoRepresentations: getVoRepresentations,\n        getEventsFor: getEventsFor,\n        getEvent: getEvent,\n        getMpd,\n        setConfig: setConfig,\n        updatePeriods: updatePeriods,\n        getIsTextTrack: getIsTextTrack,\n        getUTCTimingSources: getUTCTimingSources,\n        getSuggestedPresentationDelay: getSuggestedPresentationDelay,\n        getAvailabilityStartTime: getAvailabilityStartTime,\n        getIsTypeOf,\n        getIsDynamic: getIsDynamic,\n        getDuration: getDuration,\n        getRegularPeriods: getRegularPeriods,\n        getLocation: getLocation,\n        getPatchLocation: getPatchLocation,\n        getManifestUpdatePeriod: getManifestUpdatePeriod,\n        getPublishTime,\n        getIsDVB: getIsDVB,\n        getIsPatch: getIsPatch,\n        getBaseURLsFromElement: getBaseURLsFromElement,\n        getRepresentationSortFunction: getRepresentationSortFunction,\n        getCodec: getCodec,\n        getVoAdaptations: getVoAdaptations,\n        getVoPeriods: getVoPeriods,\n        getPeriodById,\n        setCurrentMediaInfo: setCurrentMediaInfo,\n        isPatchValid: isPatchValid,\n        applyPatchToManifest: applyPatchToManifest,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nDashAdapter.__dashjs_factory_name = 'DashAdapter';\nexport default FactoryMaker.getSingletonFactory(DashAdapter);\n"]},"metadata":{},"sourceType":"script"}