{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Debug = require('../../../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _FactoryMaker = require('../../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _LearningAbrController = require('./LearningAbrController');\n\nvar _LearningAbrController2 = _interopRequireDefault(_LearningAbrController);\n\nvar _LoLpQoEEvaluator = require('./LoLpQoEEvaluator');\n\nvar _LoLpQoEEvaluator2 = _interopRequireDefault(_LoLpQoEEvaluator);\n\nvar _SwitchRequest = require('../../SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _MetricsConstants = require('../../../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _LoLpWeightSelector = require('./LoLpWeightSelector');\n\nvar _LoLpWeightSelector2 = _interopRequireDefault(_LoLpWeightSelector);\n\nvar _Constants = require('../../../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Authors:\n* Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n* Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n* May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n*/\n\n\nvar DWS_TARGET_LATENCY = 1.5;\nvar DWS_BUFFER_MIN = 0.3;\n\nfunction LoLPRule(config) {\n  config = config || {};\n  var dashMetrics = config.dashMetrics;\n  var context = this.context;\n  var logger = void 0,\n      instance = void 0,\n      learningController = void 0,\n      qoeEvaluator = void 0;\n\n  function _setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    learningController = (0, _LearningAbrController2.default)(context).create();\n    qoeEvaluator = (0, _LoLpQoEEvaluator2.default)(context).create();\n  }\n\n  function getMaxIndex(rulesContext) {\n    try {\n      var switchRequest = (0, _SwitchRequest2.default)(context).create();\n      var mediaType = rulesContext.getMediaInfo().type;\n      var abrController = rulesContext.getAbrController();\n      var streamInfo = rulesContext.getStreamInfo();\n      var currentQuality = abrController.getQualityFor(mediaType, streamInfo);\n      var mediaInfo = rulesContext.getMediaInfo();\n      var bufferStateVO = dashMetrics.getCurrentBufferState(mediaType);\n      var scheduleController = rulesContext.getScheduleController();\n      var currentBufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n      var isDynamic = streamInfo && streamInfo.manifestInfo ? streamInfo.manifestInfo.isDynamic : null;\n      var playbackController = scheduleController.getPlaybackController();\n      var latency = playbackController.getCurrentLiveLatency();\n\n      if (!rulesContext.useLoLPABR() || mediaType === _Constants2.default.AUDIO) {\n        return switchRequest;\n      }\n\n      if (!latency) {\n        latency = 0;\n      }\n\n      var playbackRate = playbackController.getPlaybackRate();\n      var throughputHistory = abrController.getThroughputHistory();\n      var throughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n      logger.debug('Throughput ' + Math.round(throughput) + ' kbps');\n\n      if (isNaN(throughput) || !bufferStateVO) {\n        return switchRequest;\n      }\n\n      if (abrController.getAbandonmentStateFor(mediaType) === _MetricsConstants2.default.ABANDON_LOAD) {\n        return switchRequest;\n      } // QoE parameters\n\n\n      var bitrateList = mediaInfo.bitrateList; // [{bandwidth: 200000, width: 640, height: 360}, ...]\n\n      var segmentDuration = rulesContext.getRepresentationInfo().fragmentDuration;\n      var minBitrateKbps = bitrateList[0].bandwidth / 1000.0; // min bitrate level\n\n      var maxBitrateKbps = bitrateList[bitrateList.length - 1].bandwidth / 1000.0; // max bitrate level\n\n      for (var i = 0; i < bitrateList.length; i++) {\n        // in case bitrateList is not sorted as expected\n        var b = bitrateList[i].bandwidth / 1000.0;\n        if (b > maxBitrateKbps) maxBitrateKbps = b;else if (b < minBitrateKbps) {\n          minBitrateKbps = b;\n        }\n      } // Learning rule pre-calculations\n\n\n      var currentBitrate = bitrateList[currentQuality].bandwidth;\n      var currentBitrateKbps = currentBitrate / 1000.0;\n      var httpRequest = dashMetrics.getCurrentHttpRequest(mediaType, true);\n      var lastFragmentDownloadTime = (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) / 1000;\n      var segmentRebufferTime = lastFragmentDownloadTime > segmentDuration ? lastFragmentDownloadTime - segmentDuration : 0;\n      qoeEvaluator.setupPerSegmentQoe(segmentDuration, maxBitrateKbps, minBitrateKbps);\n      qoeEvaluator.logSegmentMetrics(currentBitrateKbps, segmentRebufferTime, latency, playbackRate);\n      /*\n      * Dynamic Weights Selector (step 1/2: initialization)\n      */\n\n      var dynamicWeightsSelector = (0, _LoLpWeightSelector2.default)(context).create({\n        targetLatency: DWS_TARGET_LATENCY,\n        bufferMin: DWS_BUFFER_MIN,\n        segmentDuration: segmentDuration,\n        qoeEvaluator: qoeEvaluator\n      });\n      /*\n      * Select next quality\n      */\n\n      switchRequest.quality = learningController.getNextQuality(mediaInfo, throughput * 1000, latency, currentBufferLevel, playbackRate, currentQuality, dynamicWeightsSelector);\n      switchRequest.reason = {\n        throughput: throughput,\n        latency: latency\n      };\n      switchRequest.priority = _SwitchRequest2.default.PRIORITY.STRONG;\n      scheduleController.setTimeToLoadDelay(0);\n\n      if (switchRequest.quality !== currentQuality) {\n        console.log('[TgcLearningRule][' + mediaType + '] requesting switch to index: ', switchRequest.quality, 'Average throughput', Math.round(throughput), 'kbps');\n      }\n\n      return switchRequest;\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Reset objects to their initial state\n  * @private\n  */\n\n\n  function _resetInitialSettings() {\n    learningController.reset();\n    qoeEvaluator.reset();\n  }\n  /**\n  * Reset the rule\n  */\n\n\n  function reset() {\n    _resetInitialSettings();\n  }\n\n  instance = {\n    getMaxIndex: getMaxIndex,\n    reset: reset\n  };\n\n  _setup();\n\n  return instance;\n}\n\nLoLPRule.__dashjs_factory_name = 'LoLPRule';\nexports.default = _FactoryMaker2.default.getClassFactory(LoLPRule);","map":{"version":3,"mappings":"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","names":["DWS_TARGET_LATENCY","DWS_BUFFER_MIN","LoLPRule","config","dashMetrics","context","logger","instance","learningController","qoeEvaluator","_setup","getInstance","getLogger","create","getMaxIndex","rulesContext","switchRequest","mediaType","getMediaInfo","type","abrController","getAbrController","streamInfo","getStreamInfo","currentQuality","getQualityFor","mediaInfo","bufferStateVO","getCurrentBufferState","scheduleController","getScheduleController","currentBufferLevel","getCurrentBufferLevel","isDynamic","manifestInfo","playbackController","getPlaybackController","latency","getCurrentLiveLatency","useLoLPABR","Constants","AUDIO","playbackRate","getPlaybackRate","throughputHistory","getThroughputHistory","throughput","getSafeAverageThroughput","debug","Math","round","isNaN","getAbandonmentStateFor","MetricsConstants","ABANDON_LOAD","bitrateList","segmentDuration","getRepresentationInfo","fragmentDuration","minBitrateKbps","bandwidth","maxBitrateKbps","length","i","b","currentBitrate","currentBitrateKbps","httpRequest","getCurrentHttpRequest","lastFragmentDownloadTime","tresponse","getTime","trequest","segmentRebufferTime","setupPerSegmentQoe","logSegmentMetrics","dynamicWeightsSelector","targetLatency","bufferMin","quality","getNextQuality","reason","priority","SwitchRequest","PRIORITY","STRONG","setTimeToLoadDelay","console","log","e","_resetInitialSettings","reset","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/rules/abr/lolp/LoLpRule.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Authors:\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n */\n\nimport Debug from '../../../../core/Debug';\nimport FactoryMaker from '../../../../core/FactoryMaker';\nimport LearningAbrController from './LearningAbrController';\nimport LoLpQoeEvaluator from './LoLpQoEEvaluator';\nimport SwitchRequest from '../../SwitchRequest';\nimport MetricsConstants from '../../../constants/MetricsConstants';\nimport LoLpWeightSelector from './LoLpWeightSelector';\nimport Constants from '../../../constants/Constants';\n\nconst DWS_TARGET_LATENCY = 1.5;\nconst DWS_BUFFER_MIN = 0.3;\n\nfunction LoLPRule(config) {\n\n    config = config || {};\n\n    let dashMetrics = config.dashMetrics;\n    let context = this.context;\n\n    let logger,\n        instance,\n        learningController,\n        qoeEvaluator;\n\n    function _setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        learningController = LearningAbrController(context).create();\n        qoeEvaluator = LoLpQoeEvaluator(context).create();\n    }\n\n    function getMaxIndex(rulesContext) {\n        try {\n            let switchRequest = SwitchRequest(context).create();\n            let mediaType = rulesContext.getMediaInfo().type;\n            let abrController = rulesContext.getAbrController();\n            const streamInfo = rulesContext.getStreamInfo();\n            let currentQuality = abrController.getQualityFor(mediaType, streamInfo);\n            const mediaInfo = rulesContext.getMediaInfo();\n            const bufferStateVO = dashMetrics.getCurrentBufferState(mediaType);\n            const scheduleController = rulesContext.getScheduleController();\n            const currentBufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n            const isDynamic = streamInfo && streamInfo.manifestInfo ? streamInfo.manifestInfo.isDynamic : null;\n            const playbackController = scheduleController.getPlaybackController();\n            let latency = playbackController.getCurrentLiveLatency();\n\n            if (!rulesContext.useLoLPABR() || (mediaType === Constants.AUDIO)) {\n                return switchRequest;\n            }\n\n            if (!latency) {\n                latency = 0;\n            }\n\n            const playbackRate = playbackController.getPlaybackRate();\n            const throughputHistory = abrController.getThroughputHistory();\n            const throughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n            logger.debug(`Throughput ${Math.round(throughput)} kbps`);\n\n            if (isNaN(throughput) || !bufferStateVO) {\n                return switchRequest;\n            }\n\n            if (abrController.getAbandonmentStateFor(mediaType) === MetricsConstants.ABANDON_LOAD) {\n                return switchRequest;\n            }\n\n            // QoE parameters\n            let bitrateList = mediaInfo.bitrateList;  // [{bandwidth: 200000, width: 640, height: 360}, ...]\n            let segmentDuration = rulesContext.getRepresentationInfo().fragmentDuration;\n            let minBitrateKbps = bitrateList[0].bandwidth / 1000.0;                         // min bitrate level\n            let maxBitrateKbps = bitrateList[bitrateList.length - 1].bandwidth / 1000.0;    // max bitrate level\n            for (let i = 0; i < bitrateList.length; i++) {  // in case bitrateList is not sorted as expected\n                let b = bitrateList[i].bandwidth / 1000.0;\n                if (b > maxBitrateKbps)\n                    maxBitrateKbps = b;\n                else if (b < minBitrateKbps) {\n                    minBitrateKbps = b;\n                }\n            }\n\n            // Learning rule pre-calculations\n            let currentBitrate = bitrateList[currentQuality].bandwidth;\n            let currentBitrateKbps = currentBitrate / 1000.0;\n            let httpRequest = dashMetrics.getCurrentHttpRequest(mediaType, true);\n            let lastFragmentDownloadTime = (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) / 1000;\n            let segmentRebufferTime = lastFragmentDownloadTime > segmentDuration ? lastFragmentDownloadTime - segmentDuration : 0;\n            qoeEvaluator.setupPerSegmentQoe(segmentDuration, maxBitrateKbps, minBitrateKbps);\n            qoeEvaluator.logSegmentMetrics(currentBitrateKbps, segmentRebufferTime, latency, playbackRate);\n\n            /*\n            * Dynamic Weights Selector (step 1/2: initialization)\n            */\n            let dynamicWeightsSelector = LoLpWeightSelector(context).create({\n                targetLatency: DWS_TARGET_LATENCY,\n                bufferMin: DWS_BUFFER_MIN,\n                segmentDuration,\n                qoeEvaluator\n            });\n\n            /*\n             * Select next quality\n             */\n            switchRequest.quality = learningController.getNextQuality(mediaInfo, throughput * 1000, latency, currentBufferLevel, playbackRate, currentQuality, dynamicWeightsSelector);\n            switchRequest.reason = { throughput: throughput, latency: latency };\n            switchRequest.priority = SwitchRequest.PRIORITY.STRONG;\n\n            scheduleController.setTimeToLoadDelay(0);\n\n            if (switchRequest.quality !== currentQuality) {\n                console.log('[TgcLearningRule][' + mediaType + '] requesting switch to index: ', switchRequest.quality, 'Average throughput', Math.round(throughput), 'kbps');\n            }\n\n            return switchRequest;\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Reset objects to their initial state\n     * @private\n     */\n    function _resetInitialSettings() {\n        learningController.reset();\n        qoeEvaluator.reset();\n    }\n\n    /**\n     * Reset the rule\n     */\n    function reset() {\n        _resetInitialSettings();\n    }\n\n    instance = {\n        getMaxIndex,\n        reset\n    };\n\n    _setup();\n\n    return instance;\n}\n\nLoLPRule.__dashjs_factory_name = 'LoLPRule';\nexport default FactoryMaker.getClassFactory(LoLPRule);\n"]},"metadata":{},"sourceType":"script"}