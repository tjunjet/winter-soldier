{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _XHRLoader = require('./XHRLoader');\n\nvar _XHRLoader2 = _interopRequireDefault(_XHRLoader);\n\nvar _FetchLoader = require('./FetchLoader');\n\nvar _FetchLoader2 = _interopRequireDefault(_FetchLoader);\n\nvar _HTTPRequest = require('../vo/metrics/HTTPRequest');\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _DashJSError = require('../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _CmcdModel = require('../models/CmcdModel');\n\nvar _CmcdModel2 = _interopRequireDefault(_CmcdModel);\n\nvar _Utils = require('../../core/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Settings = require('../../core/Settings');\n\nvar _Settings2 = _interopRequireDefault(_Settings);\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* @module HTTPLoader\n* @ignore\n* @description Manages download of resources via HTTP.\n* @param {Object} cfg - dependancies from parent\n*/\n\n\nfunction HTTPLoader(cfg) {\n  cfg = cfg || {};\n  var context = this.context;\n  var errHandler = cfg.errHandler;\n  var dashMetrics = cfg.dashMetrics;\n  var mediaPlayerModel = cfg.mediaPlayerModel;\n  var requestModifier = cfg.requestModifier;\n  var boxParser = cfg.boxParser;\n  var useFetch = cfg.useFetch || false;\n  var errors = cfg.errors;\n  var requestTimeout = cfg.requestTimeout || 0;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var settings = (0, _Settings2.default)(context).getInstance();\n  var instance = void 0,\n      requests = void 0,\n      delayedRequests = void 0,\n      retryRequests = void 0,\n      downloadErrorToRequestTypeMap = void 0,\n      cmcdModel = void 0,\n      logger = void 0;\n\n  function setup() {\n    var _downloadErrorToReque;\n\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    requests = [];\n    delayedRequests = [];\n    retryRequests = [];\n    cmcdModel = (0, _CmcdModel2.default)(context).getInstance();\n    downloadErrorToRequestTypeMap = (_downloadErrorToReque = {}, _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.MPD_TYPE, errors.DOWNLOAD_ERROR_ID_MANIFEST_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.XLINK_EXPANSION_TYPE, errors.DOWNLOAD_ERROR_ID_XLINK_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.INIT_SEGMENT_TYPE, errors.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE, errors.DOWNLOAD_ERROR_ID_CONTENT_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.INDEX_SEGMENT_TYPE, errors.DOWNLOAD_ERROR_ID_CONTENT_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.BITSTREAM_SWITCHING_SEGMENT_TYPE, errors.DOWNLOAD_ERROR_ID_CONTENT_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.OTHER_TYPE, errors.DOWNLOAD_ERROR_ID_CONTENT_CODE), _downloadErrorToReque);\n  }\n\n  function internalLoad(config, remainingAttempts) {\n    var request = config.request;\n    var traces = [];\n    var firstProgress = true;\n    var needFailureReport = true;\n    var requestStartTime = new Date();\n    var lastTraceTime = requestStartTime;\n    var lastTraceReceivedCount = 0;\n    var httpRequest = void 0;\n\n    if (!requestModifier || !dashMetrics || !errHandler) {\n      throw new Error('config object is not correct or missing');\n    }\n\n    var handleLoaded = function handleLoaded(success) {\n      needFailureReport = false;\n      request.requestStartDate = requestStartTime;\n      request.requestEndDate = new Date();\n      request.firstByteDate = request.firstByteDate || requestStartTime;\n\n      if (!request.checkExistenceOnly) {\n        dashMetrics.addHttpRequest(request, httpRequest.response ? httpRequest.response.responseURL : null, httpRequest.response ? httpRequest.response.status : null, httpRequest.response && httpRequest.response.getAllResponseHeaders ? httpRequest.response.getAllResponseHeaders() : httpRequest.response ? httpRequest.response.responseHeaders : [], success ? traces : null);\n\n        if (request.type === _HTTPRequest.HTTPRequest.MPD_TYPE) {\n          dashMetrics.addManifestUpdate(request);\n        }\n      }\n    };\n\n    var onloadend = function onloadend() {\n      if (requests.indexOf(httpRequest) === -1) {\n        return;\n      } else {\n        requests.splice(requests.indexOf(httpRequest), 1);\n      }\n\n      if (needFailureReport) {\n        handleLoaded(false);\n\n        if (remainingAttempts > 0) {\n          // If we get a 404 to a media segment we should check the client clock again and perform a UTC sync in the background.\n          try {\n            if (settings.get().streaming.utcSynchronization.enableBackgroundSyncAfterSegmentDownloadError && request.type === _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE) {\n              // Only trigger a sync if the loading failed for the first time\n              var initialNumberOfAttempts = mediaPlayerModel.getRetryAttemptsForType(_HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE);\n\n              if (initialNumberOfAttempts === remainingAttempts) {\n                eventBus.trigger(_Events2.default.ATTEMPT_BACKGROUND_SYNC);\n              }\n            }\n          } catch (e) {}\n\n          remainingAttempts--;\n          var retryRequest = {\n            config: config\n          };\n          retryRequests.push(retryRequest);\n          retryRequest.timeout = setTimeout(function () {\n            if (retryRequests.indexOf(retryRequest) === -1) {\n              return;\n            } else {\n              retryRequests.splice(retryRequests.indexOf(retryRequest), 1);\n            }\n\n            internalLoad(config, remainingAttempts);\n          }, mediaPlayerModel.getRetryIntervalsForType(request.type));\n        } else {\n          if (request.type === _HTTPRequest.HTTPRequest.MSS_FRAGMENT_INFO_SEGMENT_TYPE) {\n            return;\n          }\n\n          errHandler.error(new _DashJSError2.default(downloadErrorToRequestTypeMap[request.type], request.url + ' is not available', {\n            request: request,\n            response: httpRequest.response\n          }));\n\n          if (config.error) {\n            config.error(request, 'error', httpRequest.response.statusText);\n          }\n\n          if (config.complete) {\n            config.complete(request, httpRequest.response.statusText);\n          }\n        }\n      }\n    };\n\n    var progress = function progress(event) {\n      var currentTime = new Date();\n\n      if (firstProgress) {\n        firstProgress = false;\n\n        if (!event.lengthComputable || event.lengthComputable && event.total !== event.loaded) {\n          request.firstByteDate = currentTime;\n        }\n      }\n\n      if (event.lengthComputable) {\n        request.bytesLoaded = event.loaded;\n        request.bytesTotal = event.total;\n      }\n\n      if (!event.noTrace) {\n        traces.push({\n          s: lastTraceTime,\n          d: event.time ? event.time : currentTime.getTime() - lastTraceTime.getTime(),\n          b: [event.loaded ? event.loaded - lastTraceReceivedCount : 0]\n        });\n        lastTraceTime = currentTime;\n        lastTraceReceivedCount = event.loaded;\n      }\n\n      if (config.progress && event) {\n        config.progress(event);\n      }\n    };\n\n    var onload = function onload() {\n      if (httpRequest.response.status >= 200 && httpRequest.response.status <= 299) {\n        handleLoaded(true);\n\n        if (config.success) {\n          config.success(httpRequest.response.response, httpRequest.response.statusText, httpRequest.response.responseURL);\n        }\n\n        if (config.complete) {\n          config.complete(request, httpRequest.response.statusText);\n        }\n      }\n    };\n\n    var onabort = function onabort() {\n      if (config.abort) {\n        config.abort(request);\n      }\n    };\n\n    var ontimeout = function ontimeout(event) {\n      var timeoutMessage = void 0;\n\n      if (event.lengthComputable) {\n        var percentageComplete = event.loaded / event.total * 100;\n        timeoutMessage = 'Request timeout: loaded: ' + event.loaded + ', out of: ' + event.total + ' : ' + percentageComplete.toFixed(3) + '% Completed';\n      } else {\n        timeoutMessage = 'Request timeout: non-computable download size';\n      }\n\n      logger.warn(timeoutMessage);\n    };\n\n    var loader = void 0;\n\n    if (useFetch && window.fetch && request.responseType === 'arraybuffer' && request.type === _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE) {\n      loader = (0, _FetchLoader2.default)(context).create({\n        requestModifier: requestModifier,\n        boxParser: boxParser\n      });\n    } else {\n      loader = (0, _XHRLoader2.default)(context).create({\n        requestModifier: requestModifier\n      });\n    }\n\n    var headers = null;\n    var modifiedUrl = requestModifier.modifyRequestURL(request.url);\n\n    if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n      var cmcdMode = settings.get().streaming.cmcd.mode;\n\n      if (cmcdMode === _Constants2.default.CMCD_MODE_QUERY) {\n        var additionalQueryParameter = _getAdditionalQueryParameter(request);\n\n        modifiedUrl = _Utils2.default.addAditionalQueryParameterToUrl(modifiedUrl, additionalQueryParameter);\n      } else if (cmcdMode === _Constants2.default.CMCD_MODE_HEADER) {\n        headers = cmcdModel.getHeaderParameters(request);\n      }\n    }\n\n    var verb = request.checkExistenceOnly ? _HTTPRequest.HTTPRequest.HEAD : _HTTPRequest.HTTPRequest.GET;\n    var withCredentials = mediaPlayerModel.getXHRWithCredentialsForType(request.type);\n    httpRequest = {\n      url: modifiedUrl,\n      method: verb,\n      withCredentials: withCredentials,\n      request: request,\n      onload: onload,\n      onend: onloadend,\n      onerror: onloadend,\n      progress: progress,\n      onabort: onabort,\n      ontimeout: ontimeout,\n      loader: loader,\n      timeout: requestTimeout,\n      headers: headers\n    }; // Adds the ability to delay single fragment loading time to control buffer.\n\n    var now = new Date().getTime();\n\n    if (isNaN(request.delayLoadingTime) || now >= request.delayLoadingTime) {\n      // no delay - just send\n      requests.push(httpRequest);\n      loader.load(httpRequest);\n    } else {\n      // delay\n      var delayedRequest = {\n        httpRequest: httpRequest\n      };\n      delayedRequests.push(delayedRequest);\n      delayedRequest.delayTimeout = setTimeout(function () {\n        if (delayedRequests.indexOf(delayedRequest) === -1) {\n          return;\n        } else {\n          delayedRequests.splice(delayedRequests.indexOf(delayedRequest), 1);\n        }\n\n        try {\n          requestStartTime = new Date();\n          lastTraceTime = requestStartTime;\n          requests.push(delayedRequest.httpRequest);\n          loader.load(delayedRequest.httpRequest);\n        } catch (e) {\n          delayedRequest.httpRequest.onerror();\n        }\n      }, request.delayLoadingTime - now);\n    }\n  }\n\n  function _getAdditionalQueryParameter(request) {\n    try {\n      var additionalQueryParameter = [];\n      var cmcdQueryParameter = cmcdModel.getQueryParameter(request);\n\n      if (cmcdQueryParameter) {\n        additionalQueryParameter.push(cmcdQueryParameter);\n      }\n\n      return additionalQueryParameter;\n    } catch (e) {\n      return [];\n    }\n  }\n  /**\n  * Initiates a download of the resource described by config.request\n  * @param {Object} config - contains request (FragmentRequest or derived type), and callbacks\n  * @memberof module:HTTPLoader\n  * @instance\n  */\n\n\n  function load(config) {\n    if (config.request) {\n      internalLoad(config, mediaPlayerModel.getRetryAttemptsForType(config.request.type));\n    } else {\n      if (config.error) {\n        config.error(config.request, 'error');\n      }\n    }\n  }\n  /**\n  * Aborts any inflight downloads\n  * @memberof module:HTTPLoader\n  * @instance\n  */\n\n\n  function abort() {\n    retryRequests.forEach(function (t) {\n      clearTimeout(t.timeout); // abort request in order to trigger LOADING_ABANDONED event\n\n      if (t.config.request && t.config.abort) {\n        t.config.abort(t.config.request);\n      }\n    });\n    retryRequests = [];\n    delayedRequests.forEach(function (x) {\n      return clearTimeout(x.delayTimeout);\n    });\n    delayedRequests = [];\n    requests.forEach(function (x) {\n      // MSS patch: ignore FragmentInfo requests\n      if (x.request.type === _HTTPRequest.HTTPRequest.MSS_FRAGMENT_INFO_SEGMENT_TYPE) {\n        return;\n      } // abort will trigger onloadend which we don't want\n      // when deliberately aborting inflight requests -\n      // set them to undefined so they are not called\n\n\n      x.onloadend = x.onerror = x.onprogress = undefined;\n      x.loader.abort(x);\n    });\n    requests = [];\n  }\n\n  instance = {\n    load: load,\n    abort: abort\n  };\n  setup();\n  return instance;\n}\n\nHTTPLoader.__dashjs_factory_name = 'HTTPLoader';\n\nvar factory = _FactoryMaker2.default.getClassFactory(HTTPLoader);\n\nexports.default = factory;","map":{"version":3,"mappings":"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","names":["HTTPLoader","cfg","context","errHandler","dashMetrics","mediaPlayerModel","requestModifier","boxParser","useFetch","errors","requestTimeout","eventBus","getInstance","settings","instance","requests","delayedRequests","retryRequests","downloadErrorToRequestTypeMap","cmcdModel","logger","setup","getLogger","HTTPRequest","MPD_TYPE","DOWNLOAD_ERROR_ID_MANIFEST_CODE","XLINK_EXPANSION_TYPE","DOWNLOAD_ERROR_ID_XLINK_CODE","INIT_SEGMENT_TYPE","DOWNLOAD_ERROR_ID_INITIALIZATION_CODE","MEDIA_SEGMENT_TYPE","DOWNLOAD_ERROR_ID_CONTENT_CODE","INDEX_SEGMENT_TYPE","BITSTREAM_SWITCHING_SEGMENT_TYPE","OTHER_TYPE","internalLoad","config","remainingAttempts","request","traces","firstProgress","needFailureReport","requestStartTime","Date","lastTraceTime","lastTraceReceivedCount","httpRequest","Error","handleLoaded","success","requestStartDate","requestEndDate","firstByteDate","checkExistenceOnly","addHttpRequest","response","responseURL","status","getAllResponseHeaders","responseHeaders","type","addManifestUpdate","onloadend","indexOf","splice","get","streaming","utcSynchronization","enableBackgroundSyncAfterSegmentDownloadError","initialNumberOfAttempts","getRetryAttemptsForType","trigger","Events","ATTEMPT_BACKGROUND_SYNC","e","retryRequest","push","timeout","setTimeout","getRetryIntervalsForType","MSS_FRAGMENT_INFO_SEGMENT_TYPE","error","DashJSError","url","statusText","complete","progress","event","currentTime","lengthComputable","total","loaded","bytesLoaded","bytesTotal","noTrace","s","d","time","getTime","b","onload","onabort","abort","ontimeout","timeoutMessage","percentageComplete","toFixed","warn","loader","window","fetch","responseType","create","headers","modifiedUrl","modifyRequestURL","cmcd","enabled","cmcdMode","mode","Constants","CMCD_MODE_QUERY","additionalQueryParameter","_getAdditionalQueryParameter","Utils","addAditionalQueryParameterToUrl","CMCD_MODE_HEADER","getHeaderParameters","verb","HEAD","GET","withCredentials","getXHRWithCredentialsForType","method","onend","onerror","now","isNaN","delayLoadingTime","load","delayedRequest","delayTimeout","cmcdQueryParameter","getQueryParameter","forEach","clearTimeout","t","x","onprogress","undefined","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/net/HTTPLoader.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport XHRLoader from './XHRLoader';\nimport FetchLoader from './FetchLoader';\nimport {HTTPRequest} from '../vo/metrics/HTTPRequest';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport DashJSError from '../vo/DashJSError';\nimport CmcdModel from '../models/CmcdModel';\nimport Utils from '../../core/Utils';\nimport Debug from '../../core/Debug';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport Settings from '../../core/Settings';\nimport Constants from '../constants/Constants';\n\n/**\n * @module HTTPLoader\n * @ignore\n * @description Manages download of resources via HTTP.\n * @param {Object} cfg - dependancies from parent\n */\nfunction HTTPLoader(cfg) {\n\n    cfg = cfg || {};\n\n    const context = this.context;\n    const errHandler = cfg.errHandler;\n    const dashMetrics = cfg.dashMetrics;\n    const mediaPlayerModel = cfg.mediaPlayerModel;\n    const requestModifier = cfg.requestModifier;\n    const boxParser = cfg.boxParser;\n    const useFetch = cfg.useFetch || false;\n    const errors = cfg.errors;\n    const requestTimeout = cfg.requestTimeout || 0;\n    const eventBus = EventBus(context).getInstance();\n    const settings = Settings(context).getInstance();\n\n    let instance,\n        requests,\n        delayedRequests,\n        retryRequests,\n        downloadErrorToRequestTypeMap,\n        cmcdModel,\n        logger;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        requests = [];\n        delayedRequests = [];\n        retryRequests = [];\n        cmcdModel = CmcdModel(context).getInstance();\n\n        downloadErrorToRequestTypeMap = {\n            [HTTPRequest.MPD_TYPE]: errors.DOWNLOAD_ERROR_ID_MANIFEST_CODE,\n            [HTTPRequest.XLINK_EXPANSION_TYPE]: errors.DOWNLOAD_ERROR_ID_XLINK_CODE,\n            [HTTPRequest.INIT_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE,\n            [HTTPRequest.MEDIA_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE,\n            [HTTPRequest.INDEX_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE,\n            [HTTPRequest.BITSTREAM_SWITCHING_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE,\n            [HTTPRequest.OTHER_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE\n        };\n    }\n\n    function internalLoad(config, remainingAttempts) {\n        const request = config.request;\n        const traces = [];\n        let firstProgress = true;\n        let needFailureReport = true;\n        let requestStartTime = new Date();\n        let lastTraceTime = requestStartTime;\n        let lastTraceReceivedCount = 0;\n        let httpRequest;\n\n        if (!requestModifier || !dashMetrics || !errHandler) {\n            throw new Error('config object is not correct or missing');\n        }\n\n        const handleLoaded = function (success) {\n            needFailureReport = false;\n\n            request.requestStartDate = requestStartTime;\n            request.requestEndDate = new Date();\n            request.firstByteDate = request.firstByteDate || requestStartTime;\n\n            if (!request.checkExistenceOnly) {\n                dashMetrics.addHttpRequest(request, httpRequest.response ? httpRequest.response.responseURL : null,\n                    httpRequest.response ? httpRequest.response.status : null,\n                    httpRequest.response && httpRequest.response.getAllResponseHeaders ? httpRequest.response.getAllResponseHeaders() :\n                        httpRequest.response ? httpRequest.response.responseHeaders : [],\n                    success ? traces : null);\n\n                if (request.type === HTTPRequest.MPD_TYPE) {\n                    dashMetrics.addManifestUpdate(request);\n                }\n            }\n        };\n\n        const onloadend = function () {\n            if (requests.indexOf(httpRequest) === -1) {\n                return;\n            } else {\n                requests.splice(requests.indexOf(httpRequest), 1);\n            }\n\n            if (needFailureReport) {\n                handleLoaded(false);\n\n                if (remainingAttempts > 0) {\n\n                    // If we get a 404 to a media segment we should check the client clock again and perform a UTC sync in the background.\n                    try {\n                        if (settings.get().streaming.utcSynchronization.enableBackgroundSyncAfterSegmentDownloadError && request.type === HTTPRequest.MEDIA_SEGMENT_TYPE) {\n                            // Only trigger a sync if the loading failed for the first time\n                            const initialNumberOfAttempts = mediaPlayerModel.getRetryAttemptsForType(HTTPRequest.MEDIA_SEGMENT_TYPE);\n                            if (initialNumberOfAttempts === remainingAttempts) {\n                                eventBus.trigger(Events.ATTEMPT_BACKGROUND_SYNC);\n                            }\n                        }\n                    } catch (e) {\n\n                    }\n\n                    remainingAttempts--;\n                    let retryRequest = { config: config };\n                    retryRequests.push(retryRequest);\n                    retryRequest.timeout = setTimeout(function () {\n                        if (retryRequests.indexOf(retryRequest) === -1) {\n                            return;\n                        } else {\n                            retryRequests.splice(retryRequests.indexOf(retryRequest), 1);\n                        }\n                        internalLoad(config, remainingAttempts);\n                    }, mediaPlayerModel.getRetryIntervalsForType(request.type));\n                } else {\n                    if (request.type === HTTPRequest.MSS_FRAGMENT_INFO_SEGMENT_TYPE) {\n                        return;\n                    }\n\n                    errHandler.error(new DashJSError(downloadErrorToRequestTypeMap[request.type], request.url + ' is not available', {\n                        request: request,\n                        response: httpRequest.response\n                    }));\n\n                    if (config.error) {\n                        config.error(request, 'error', httpRequest.response.statusText);\n                    }\n\n                    if (config.complete) {\n                        config.complete(request, httpRequest.response.statusText);\n                    }\n                }\n            }\n        };\n\n        const progress = function (event) {\n            const currentTime = new Date();\n\n            if (firstProgress) {\n                firstProgress = false;\n                if (!event.lengthComputable ||\n                    (event.lengthComputable && event.total !== event.loaded)) {\n                    request.firstByteDate = currentTime;\n                }\n            }\n\n            if (event.lengthComputable) {\n                request.bytesLoaded = event.loaded;\n                request.bytesTotal = event.total;\n            }\n\n            if (!event.noTrace) {\n                traces.push({\n                    s: lastTraceTime,\n                    d: event.time ? event.time : currentTime.getTime() - lastTraceTime.getTime(),\n                    b: [event.loaded ? event.loaded - lastTraceReceivedCount : 0]\n                });\n\n                lastTraceTime = currentTime;\n                lastTraceReceivedCount = event.loaded;\n            }\n\n            if (config.progress && event) {\n                config.progress(event);\n            }\n        };\n\n        const onload = function () {\n            if (httpRequest.response.status >= 200 && httpRequest.response.status <= 299) {\n                handleLoaded(true);\n\n                if (config.success) {\n                    config.success(httpRequest.response.response, httpRequest.response.statusText, httpRequest.response.responseURL);\n                }\n\n                if (config.complete) {\n                    config.complete(request, httpRequest.response.statusText);\n                }\n            }\n        };\n\n        const onabort = function () {\n            if (config.abort) {\n                config.abort(request);\n            }\n        };\n\n        const ontimeout = function (event) {\n            let timeoutMessage;\n            if (event.lengthComputable) {\n                let percentageComplete = (event.loaded / event.total) * 100;\n                timeoutMessage = 'Request timeout: loaded: ' + event.loaded + ', out of: ' + event.total + ' : ' + percentageComplete.toFixed(3) + '% Completed';\n            } else {\n                timeoutMessage = 'Request timeout: non-computable download size';\n            }\n            logger.warn(timeoutMessage);\n        };\n\n        let loader;\n        if (useFetch && window.fetch && request.responseType === 'arraybuffer' && request.type === HTTPRequest.MEDIA_SEGMENT_TYPE) {\n            loader = FetchLoader(context).create({\n                requestModifier: requestModifier,\n                boxParser: boxParser\n            });\n        } else {\n            loader = XHRLoader(context).create({\n                requestModifier: requestModifier\n            });\n        }\n\n        let headers = null;\n        let modifiedUrl = requestModifier.modifyRequestURL(request.url);\n        if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n            const cmcdMode = settings.get().streaming.cmcd.mode;\n            if (cmcdMode === Constants.CMCD_MODE_QUERY) {\n                const additionalQueryParameter = _getAdditionalQueryParameter(request);\n                modifiedUrl = Utils.addAditionalQueryParameterToUrl(modifiedUrl, additionalQueryParameter);\n            }\n            else if (cmcdMode === Constants.CMCD_MODE_HEADER) {\n                headers = cmcdModel.getHeaderParameters(request);\n            }\n        }\n        const verb = request.checkExistenceOnly ? HTTPRequest.HEAD : HTTPRequest.GET;\n        const withCredentials = mediaPlayerModel.getXHRWithCredentialsForType(request.type);\n\n\n        httpRequest = {\n            url: modifiedUrl,\n            method: verb,\n            withCredentials: withCredentials,\n            request: request,\n            onload: onload,\n            onend: onloadend,\n            onerror: onloadend,\n            progress: progress,\n            onabort: onabort,\n            ontimeout: ontimeout,\n            loader: loader,\n            timeout: requestTimeout,\n            headers: headers\n        };\n\n        // Adds the ability to delay single fragment loading time to control buffer.\n        let now = new Date().getTime();\n        if (isNaN(request.delayLoadingTime) || now >= request.delayLoadingTime) {\n            // no delay - just send\n            requests.push(httpRequest);\n            loader.load(httpRequest);\n        } else {\n            // delay\n            let delayedRequest = { httpRequest: httpRequest };\n            delayedRequests.push(delayedRequest);\n            delayedRequest.delayTimeout = setTimeout(function () {\n                if (delayedRequests.indexOf(delayedRequest) === -1) {\n                    return;\n                } else {\n                    delayedRequests.splice(delayedRequests.indexOf(delayedRequest), 1);\n                }\n                try {\n                    requestStartTime = new Date();\n                    lastTraceTime = requestStartTime;\n                    requests.push(delayedRequest.httpRequest);\n                    loader.load(delayedRequest.httpRequest);\n                } catch (e) {\n                    delayedRequest.httpRequest.onerror();\n                }\n            }, (request.delayLoadingTime - now));\n        }\n    }\n\n    function _getAdditionalQueryParameter(request) {\n        try {\n            const additionalQueryParameter = [];\n            const cmcdQueryParameter = cmcdModel.getQueryParameter(request);\n\n            if (cmcdQueryParameter) {\n                additionalQueryParameter.push(cmcdQueryParameter);\n            }\n\n            return additionalQueryParameter;\n        } catch (e) {\n            return [];\n        }\n    }\n\n    /**\n     * Initiates a download of the resource described by config.request\n     * @param {Object} config - contains request (FragmentRequest or derived type), and callbacks\n     * @memberof module:HTTPLoader\n     * @instance\n     */\n    function load(config) {\n        if (config.request) {\n            internalLoad(\n                config,\n                mediaPlayerModel.getRetryAttemptsForType(\n                    config.request.type\n                )\n            );\n        } else {\n            if (config.error) {\n                config.error(config.request, 'error');\n            }\n        }\n    }\n\n    /**\n     * Aborts any inflight downloads\n     * @memberof module:HTTPLoader\n     * @instance\n     */\n    function abort() {\n        retryRequests.forEach(t => {\n            clearTimeout(t.timeout);\n            // abort request in order to trigger LOADING_ABANDONED event\n            if (t.config.request && t.config.abort) {\n                t.config.abort(t.config.request);\n            }\n        });\n        retryRequests = [];\n\n        delayedRequests.forEach(x => clearTimeout(x.delayTimeout));\n        delayedRequests = [];\n\n        requests.forEach(x => {\n            // MSS patch: ignore FragmentInfo requests\n            if (x.request.type === HTTPRequest.MSS_FRAGMENT_INFO_SEGMENT_TYPE) {\n                return;\n            }\n\n            // abort will trigger onloadend which we don't want\n            // when deliberately aborting inflight requests -\n            // set them to undefined so they are not called\n            x.onloadend = x.onerror = x.onprogress = undefined;\n            x.loader.abort(x);\n        });\n        requests = [];\n    }\n\n    instance = {\n        load: load,\n        abort: abort\n    };\n\n    setup();\n\n    return instance;\n}\n\nHTTPLoader.__dashjs_factory_name = 'HTTPLoader';\n\nconst factory = FactoryMaker.getClassFactory(HTTPLoader);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}