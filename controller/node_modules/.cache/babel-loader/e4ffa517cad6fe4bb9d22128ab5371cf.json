{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _MetricsConstants = require('../../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _SwitchRequest = require('../SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _FactoryMaker = require('../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _HTTPRequest = require('../../vo/metrics/HTTPRequest');\n\nvar _EventBus = require('../../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Debug = require('../../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _Constants = require('../../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2020, Unified Streaming.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n// For a description of the Learn2Adapt-LowLatency (L2A-LL) bitrate adaptation algorithm, see https://github.com/unifiedstreaming/Learn2Adapt-LowLatency/blob/master/Online_learning_for_bitrate_adaptation_in_low_latency_live_streaming_CR.pdf\n\n\nvar L2A_STATE_ONE_BITRATE = 0; // If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n\nvar L2A_STATE_STARTUP = 1; // Set placeholder buffer such that we download fragments at most recently measured throughput.\n\nvar L2A_STATE_STEADY = 2; // Buffer primed, we switch to steady operation.\n\nfunction L2ARule(config) {\n  config = config || {};\n  var context = this.context;\n  var dashMetrics = config.dashMetrics;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      l2AStateDict = void 0,\n      l2AParameterDict = void 0,\n      logger = void 0;\n  /**\n  * Setup function to initialize L2ARule\n  */\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n\n    _resetInitialSettings();\n\n    eventBus.on(_Events2.default.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n    eventBus.on(_Events2.default.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n    eventBus.on(_Events2.default.METRIC_ADDED, _onMetricAdded, instance);\n    eventBus.on(_Events2.default.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n  }\n  /**\n  * Sets the initial state of the algorithm. Calls the initialize function for the paramteters.\n  * @param {object} rulesContext\n  * @return {object} initialState\n  * @private\n  */\n\n\n  function _getInitialL2AState(rulesContext) {\n    var initialState = {};\n    var mediaInfo = rulesContext.getMediaInfo();\n    var bitrates = mediaInfo.bitrateList.map(function (b) {\n      return b.bandwidth / 1000;\n    });\n    initialState.state = L2A_STATE_STARTUP;\n    initialState.bitrates = bitrates;\n    initialState.lastQuality = 0;\n\n    _initializeL2AParameters(mediaInfo);\n\n    _clearL2AStateOnSeek(initialState);\n\n    return initialState;\n  }\n  /**\n  * Initializes the parameters of the algorithm. This will be done once for each media type.\n  * @param {object} mediaInfo\n  * @private\n  */\n\n\n  function _initializeL2AParameters(mediaInfo) {\n    if (!mediaInfo || !mediaInfo.type) {\n      return;\n    }\n\n    l2AParameterDict[mediaInfo.type] = {};\n    l2AParameterDict[mediaInfo.type].w = []; //Vector of probabilities associated with bitrate decisions\n\n    l2AParameterDict[mediaInfo.type].prev_w = []; //Vector of probabilities associated with bitrate decisions calculated in the previous step\n\n    l2AParameterDict[mediaInfo.type].Q = 0; //Initialization of Lagrangian multiplier (This keeps track of the buffer displacement)\n\n    l2AParameterDict[mediaInfo.type].segment_request_start_s = 0;\n    l2AParameterDict[mediaInfo.type].segment_download_finish_s = 0;\n    l2AParameterDict[mediaInfo.type].B_target = 1.5; //Target buffer level\n  }\n  /**\n      * Clears the state object\n      * @param {object} l2AState\n      * @private\n      */\n\n\n  function _clearL2AStateOnSeek(l2AState) {\n    l2AState.placeholderBuffer = 0;\n    l2AState.mostAdvancedSegmentStart = NaN;\n    l2AState.lastSegmentWasReplacement = false;\n    l2AState.lastSegmentStart = NaN;\n    l2AState.lastSegmentDurationS = NaN;\n    l2AState.lastSegmentRequestTimeMs = NaN;\n    l2AState.lastSegmentFinishTimeMs = NaN;\n  }\n  /**\n  * Returns the state object for a fiven media type. If the state object is not yet defined _getInitialL2AState is called\n  * @param {object} rulesContext\n  * @return {object} l2AState\n  * @private\n  */\n\n\n  function _getL2AState(rulesContext) {\n    var mediaType = rulesContext.getMediaType();\n    var l2AState = l2AStateDict[mediaType];\n\n    if (!l2AState) {\n      l2AState = _getInitialL2AState(rulesContext);\n      l2AStateDict[mediaType] = l2AState;\n    }\n\n    return l2AState;\n  }\n  /**\n  * Event handler for the seeking event.\n  * @private\n  */\n\n\n  function _onPlaybackSeeking() {\n    for (var mediaType in l2AStateDict) {\n      if (l2AStateDict.hasOwnProperty(mediaType)) {\n        var l2aState = l2AStateDict[mediaType];\n\n        if (l2aState.state !== L2A_STATE_ONE_BITRATE) {\n          l2aState.state = L2A_STATE_STARTUP;\n\n          _clearL2AStateOnSeek(l2aState);\n        }\n      }\n    }\n  }\n  /**\n  * Event handler for the mediaFragmentLoaded event\n  * @param {object} e\n  * @private\n  */\n\n\n  function _onMediaFragmentLoaded(e) {\n    if (e && e.chunk && e.chunk.mediaInfo) {\n      var l2AState = l2AStateDict[e.chunk.mediaInfo.type];\n      var l2AParameters = l2AParameterDict[e.chunk.mediaInfo.type];\n\n      if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n        var start = e.chunk.start;\n\n        if (isNaN(l2AState.mostAdvancedSegmentStart) || start > l2AState.mostAdvancedSegmentStart) {\n          l2AState.mostAdvancedSegmentStart = start;\n          l2AState.lastSegmentWasReplacement = false;\n        } else {\n          l2AState.lastSegmentWasReplacement = true;\n        }\n\n        l2AState.lastSegmentStart = start;\n        l2AState.lastSegmentDurationS = e.chunk.duration;\n        l2AState.lastQuality = e.chunk.quality;\n\n        _checkNewSegment(l2AState, l2AParameters);\n      }\n    }\n  }\n  /**\n  * Event handler for the metricAdded event\n  * @param {object} e\n  * @private\n  */\n\n\n  function _onMetricAdded(e) {\n    if (e && e.metric === _MetricsConstants2.default.HTTP_REQUEST && e.value && e.value.type === _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n      var l2AState = l2AStateDict[e.mediaType];\n      var l2AParameters = l2AParameterDict[e.mediaType];\n\n      if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n        l2AState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n        l2AState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n\n        _checkNewSegment(l2AState, l2AParameters);\n      }\n    }\n  }\n  /**\n  * When a new metric has been added or a media fragment has been loaded the state is adjusted accordingly\n  * @param {object} L2AState\n  * @param {object} l2AParameters\n  * @private\n  */\n\n\n  function _checkNewSegment(L2AState, l2AParameters) {\n    if (!isNaN(L2AState.lastSegmentStart) && !isNaN(L2AState.lastSegmentRequestTimeMs)) {\n      l2AParameters.segment_request_start_s = 0.001 * L2AState.lastSegmentRequestTimeMs;\n      l2AParameters.segment_download_finish_s = 0.001 * L2AState.lastSegmentFinishTimeMs;\n      L2AState.lastSegmentStart = NaN;\n      L2AState.lastSegmentRequestTimeMs = NaN;\n    }\n  }\n  /**\n  * Event handler for the qualityChangeRequested event\n  * @param {object} e\n  * @private\n  */\n\n\n  function _onQualityChangeRequested(e) {\n    // Useful to store change requests when abandoning a download.\n    if (e && e.mediaType) {\n      var L2AState = l2AStateDict[e.mediaType];\n\n      if (L2AState && L2AState.state !== L2A_STATE_ONE_BITRATE) {\n        L2AState.abrQuality = e.newQuality;\n      }\n    }\n  }\n  /**\n  * Dot multiplication of two arrays\n  * @param {array} arr1\n  * @param {array} arr2\n  * @return {number} sumdot\n  * @private\n  */\n\n\n  function _dotmultiplication(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return -1;\n    }\n\n    var sumdot = 0;\n\n    for (var i = 0; i < arr1.length; i++) {\n      sumdot = sumdot + arr1[i] * arr2[i];\n    }\n\n    return sumdot;\n  }\n  /**\n  * Project an n-dim vector y to the simplex Dn\n  * Dn = { x : x n-dim, 1 >= x >= 0, sum(x) = 1}\n  * Algorithm is explained at http://arxiv.org/abs/1101.6081\n  * @param {array} arr\n  * @return {array}\n  */\n\n\n  function euclideanProjection(arr) {\n    var m = arr.length;\n    var bget = false;\n    var arr2 = [];\n\n    for (var ii = 0; ii < m; ++ii) {\n      arr2[ii] = arr[ii];\n    }\n\n    var s = arr.sort(function (a, b) {\n      return b - a;\n    });\n    var tmpsum = 0;\n    var tmax = 0;\n    var x = [];\n\n    for (var _ii = 0; _ii < m - 1; ++_ii) {\n      tmpsum = tmpsum + s[_ii];\n      tmax = (tmpsum - 1) / (_ii + 1);\n\n      if (tmax >= s[_ii + 1]) {\n        bget = true;\n        break;\n      }\n    }\n\n    if (!bget) {\n      tmax = (tmpsum + s[m - 1] - 1) / m;\n    }\n\n    for (var _ii2 = 0; _ii2 < m; ++_ii2) {\n      x[_ii2] = Math.max(arr2[_ii2] - tmax, 0);\n    }\n\n    return x;\n  }\n  /**\n  * Returns a switch request object indicating which quality is to be played\n  * @param {object} rulesContext\n  * @return {object}\n  */\n\n\n  function getMaxIndex(rulesContext) {\n    var switchRequest = (0, _SwitchRequest2.default)(context).create();\n    var horizon = 4; // Optimization horizon (The amount of steps required to achieve convergence)\n\n    var vl = Math.pow(horizon, 0.99); // Cautiousness parameter, used to control aggressiveness of the bitrate decision process.\n\n    var alpha = Math.max(Math.pow(horizon, 1), vl * Math.sqrt(horizon)); // Step size, used for gradient descent exploration granularity\n\n    var mediaInfo = rulesContext.getMediaInfo();\n    var mediaType = rulesContext.getMediaType();\n    var bitrates = mediaInfo.bitrateList.map(function (b) {\n      return b.bandwidth;\n    });\n    var bitrateCount = bitrates.length;\n    var scheduleController = rulesContext.getScheduleController();\n    var streamInfo = rulesContext.getStreamInfo();\n    var abrController = rulesContext.getAbrController();\n    var throughputHistory = abrController.getThroughputHistory();\n    var isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n    var useL2AABR = rulesContext.useL2AABR();\n    var bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n    var safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n    var throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic); // In kbits/s\n\n    var react = 2; // Reactiveness to volatility (abrupt throughput drops), used to re-calibrate Lagrangian multiplier Q\n\n    var latency = throughputHistory.getAverageLatency(mediaType);\n    var videoModel = rulesContext.getVideoModel();\n    var quality = void 0;\n    var currentPlaybackRate = videoModel.getPlaybackRate();\n\n    if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') || !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') || !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useL2AABR')) {\n      return switchRequest;\n    }\n\n    switchRequest.reason = switchRequest.reason || {};\n\n    if (!useL2AABR || mediaType === _Constants2.default.AUDIO) {\n      // L2A decides bitrate only for video. Audio to be included in decision process in a later stage\n      return switchRequest;\n    }\n\n    scheduleController.setTimeToLoadDelay(0);\n\n    var l2AState = _getL2AState(rulesContext);\n\n    if (l2AState.state === L2A_STATE_ONE_BITRATE) {\n      // shouldn't even have been called\n      return switchRequest;\n    }\n\n    var l2AParameter = l2AParameterDict[mediaType];\n\n    if (!l2AParameter) {\n      return switchRequest;\n    }\n\n    switchRequest.reason.state = l2AState.state;\n    switchRequest.reason.throughput = throughput;\n    switchRequest.reason.latency = latency;\n\n    if (isNaN(throughput)) {\n      // still starting up - not enough information\n      return switchRequest;\n    }\n\n    switch (l2AState.state) {\n      case L2A_STATE_STARTUP:\n        quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency); //During strat-up phase abr.controller is responsible for bitrate decisions.\n\n        switchRequest.quality = quality;\n        switchRequest.reason.throughput = safeThroughput;\n        l2AState.lastQuality = quality;\n\n        if (!isNaN(l2AState.lastSegmentDurationS) && bufferLevel >= l2AParameter.B_target) {\n          l2AState.state = L2A_STATE_STEADY;\n          l2AParameter.Q = vl; // Initialization of Q langrangian multiplier\n          // Update of probability vector w, to be used in main adaptation logic of L2A below (steady state)\n\n          for (var i = 0; i < bitrateCount; ++i) {\n            if (i === l2AState.lastQuality) {\n              l2AParameter.prev_w[i] = 1;\n            } else {\n              l2AParameter.prev_w[i] = 0;\n            }\n          }\n        }\n\n        break;\n      // L2A_STATE_STARTUP\n\n      case L2A_STATE_STEADY:\n        var diff1 = []; //Used to calculate the difference between consecutive decisions (w-w_prev)\n        // Manual calculation of latency and throughput during previous request\n\n        var throughputMeasureTime = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce(function (a, b) {\n          return a + b.d;\n        }, 0);\n        var downloadBytes = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce(function (a, b) {\n          return a + b.b[0];\n        }, 0);\n        var lastthroughput = Math.round(8 * downloadBytes / throughputMeasureTime); // bits/ms = kbits/s\n\n        if (lastthroughput < 1) {\n          lastthroughput = 1;\n        } //To avoid division with 0 (avoid infinity) in case of an absolute network outage\n\n\n        var V = l2AState.lastSegmentDurationS;\n        var sign = 1; //Main adaptation logic of L2A-LL\n\n        for (var _i = 0; _i < bitrateCount; ++_i) {\n          bitrates[_i] = bitrates[_i] / 1000; // Originally in bps, now in Kbps\n\n          if (currentPlaybackRate * bitrates[_i] > lastthroughput) {\n            // In this case buffer would deplete, leading to a stall, which increases latency and thus the particular probability of selsection of bitrate[i] should be decreased.\n            sign = -1;\n          } // The objective of L2A is to minimize the overall latency=request-response time + buffer length after download+ potential stalling (if buffer less than chunk downlad time)\n\n\n          l2AParameter.w[_i] = l2AParameter.prev_w[_i] + sign * (V / (2 * alpha)) * ((l2AParameter.Q + vl) * (currentPlaybackRate * bitrates[_i] / lastthroughput)); //Lagrangian descent\n        } // Apply euclidean projection on w to ensure w expresses a probability distribution\n\n\n        l2AParameter.w = euclideanProjection(l2AParameter.w);\n\n        for (var _i2 = 0; _i2 < bitrateCount; ++_i2) {\n          diff1[_i2] = l2AParameter.w[_i2] - l2AParameter.prev_w[_i2];\n          l2AParameter.prev_w[_i2] = l2AParameter.w[_i2];\n        } // Lagrangian multiplier Q calculation:\n\n\n        l2AParameter.Q = Math.max(0, l2AParameter.Q - V + V * currentPlaybackRate * ((_dotmultiplication(bitrates, l2AParameter.prev_w) + _dotmultiplication(bitrates, diff1)) / lastthroughput)); // Quality is calculated as argmin of the absolute difference between available bitrates (bitrates[i]) and bitrate estimation (dotmultiplication(w,bitrates)).\n\n        var temp = [];\n\n        for (var _i3 = 0; _i3 < bitrateCount; ++_i3) {\n          temp[_i3] = Math.abs(bitrates[_i3] - _dotmultiplication(l2AParameter.w, bitrates));\n        } // Quality is calculated based on the probability distribution w (the output of L2A)\n\n\n        quality = temp.indexOf(Math.min.apply(Math, temp)); // We employ a cautious -stepwise- ascent\n\n        if (quality > l2AState.lastQuality) {\n          if (bitrates[l2AState.lastQuality + 1] <= lastthroughput) {\n            quality = l2AState.lastQuality + 1;\n          }\n        } // Provision against bitrate over-estimation, by re-calibrating the Lagrangian multiplier Q, to be taken into account for the next chunk\n\n\n        if (bitrates[quality] >= lastthroughput) {\n          l2AParameter.Q = react * Math.max(vl, l2AParameter.Q);\n        }\n\n        switchRequest.quality = quality;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n        switchRequest.reason.bufferLevel = bufferLevel;\n        l2AState.lastQuality = switchRequest.quality;\n        break;\n\n      default:\n        // should not arrive here, try to recover\n        logger.debug('L2A ABR rule invoked in bad state.');\n        switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n        switchRequest.reason.state = l2AState.state;\n        switchRequest.reason.throughput = safeThroughput;\n        switchRequest.reason.latency = latency;\n        l2AState.state = L2A_STATE_STARTUP;\n\n        _clearL2AStateOnSeek(l2AState);\n\n    }\n\n    return switchRequest;\n  }\n  /**\n  * Reset objects to their initial state\n  * @private\n  */\n\n\n  function _resetInitialSettings() {\n    l2AStateDict = {};\n    l2AParameterDict = {};\n  }\n  /**\n  * Reset the rule\n  */\n\n\n  function reset() {\n    _resetInitialSettings();\n\n    eventBus.off(_Events2.default.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n    eventBus.off(_Events2.default.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n    eventBus.off(_Events2.default.METRIC_ADDED, _onMetricAdded, instance);\n    eventBus.off(_Events2.default.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n  }\n\n  instance = {\n    getMaxIndex: getMaxIndex,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nL2ARule.__dashjs_factory_name = 'L2ARule';\nexports.default = _FactoryMaker2.default.getClassFactory(L2ARule);","map":{"version":3,"mappings":"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","names":["L2A_STATE_ONE_BITRATE","L2A_STATE_STARTUP","L2A_STATE_STEADY","L2ARule","config","context","dashMetrics","eventBus","getInstance","instance","l2AStateDict","l2AParameterDict","logger","setup","getLogger","_resetInitialSettings","on","Events","PLAYBACK_SEEKING","_onPlaybackSeeking","MEDIA_FRAGMENT_LOADED","_onMediaFragmentLoaded","METRIC_ADDED","_onMetricAdded","QUALITY_CHANGE_REQUESTED","_onQualityChangeRequested","_getInitialL2AState","rulesContext","initialState","mediaInfo","getMediaInfo","bitrates","bitrateList","map","b","bandwidth","state","lastQuality","_initializeL2AParameters","_clearL2AStateOnSeek","type","w","prev_w","Q","segment_request_start_s","segment_download_finish_s","B_target","l2AState","placeholderBuffer","mostAdvancedSegmentStart","NaN","lastSegmentWasReplacement","lastSegmentStart","lastSegmentDurationS","lastSegmentRequestTimeMs","lastSegmentFinishTimeMs","_getL2AState","mediaType","getMediaType","hasOwnProperty","l2aState","e","chunk","l2AParameters","start","isNaN","duration","quality","_checkNewSegment","metric","MetricsConstants","HTTP_REQUEST","value","HTTPRequest","MEDIA_SEGMENT_TYPE","trace","length","trequest","getTime","_tfinish","L2AState","abrQuality","newQuality","_dotmultiplication","arr1","arr2","sumdot","i","euclideanProjection","arr","m","bget","ii","s","sort","a","tmpsum","tmax","x","Math","max","getMaxIndex","switchRequest","create","horizon","vl","pow","alpha","sqrt","bitrateCount","scheduleController","getScheduleController","streamInfo","getStreamInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","isDynamic","manifestInfo","useL2AABR","bufferLevel","getCurrentBufferLevel","safeThroughput","getSafeAverageThroughput","throughput","getAverageThroughput","react","latency","getAverageLatency","videoModel","getVideoModel","currentPlaybackRate","getPlaybackRate","reason","Constants","AUDIO","setTimeToLoadDelay","l2AParameter","getQualityForBitrate","diff1","throughputMeasureTime","getCurrentHttpRequest","reduce","d","downloadBytes","lastthroughput","round","V","sign","temp","abs","indexOf","min","debug","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/rules/abr/L2ARule.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2020, Unified Streaming.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the Learn2Adapt-LowLatency (L2A-LL) bitrate adaptation algorithm, see https://github.com/unifiedstreaming/Learn2Adapt-LowLatency/blob/master/Online_learning_for_bitrate_adaptation_in_low_latency_live_streaming_CR.pdf\n\nimport MetricsConstants from '../../constants/MetricsConstants';\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport {HTTPRequest} from '../../vo/metrics/HTTPRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\nimport Constants from '../../constants/Constants';\n\nconst L2A_STATE_ONE_BITRATE = 0; // If there is only one bitrate (or initialization failed), always return NO_CHANGE.\nconst L2A_STATE_STARTUP = 1; // Set placeholder buffer such that we download fragments at most recently measured throughput.\nconst L2A_STATE_STEADY = 2; // Buffer primed, we switch to steady operation.\n\n\nfunction L2ARule(config) {\n    config = config || {};\n    const context = this.context;\n\n    const dashMetrics = config.dashMetrics;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        l2AStateDict,\n        l2AParameterDict,\n        logger;\n\n    /**\n     * Setup function to initialize L2ARule\n     */\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n\n        eventBus.on(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n        eventBus.on(Events.METRIC_ADDED, _onMetricAdded, instance);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n    }\n\n    /**\n     * Sets the initial state of the algorithm. Calls the initialize function for the paramteters.\n     * @param {object} rulesContext\n     * @return {object} initialState\n     * @private\n     */\n    function _getInitialL2AState(rulesContext) {\n        const initialState = {};\n        const mediaInfo = rulesContext.getMediaInfo();\n        const bitrates = mediaInfo.bitrateList.map((b) => {\n            return b.bandwidth / 1000;\n        });\n\n        initialState.state = L2A_STATE_STARTUP;\n        initialState.bitrates = bitrates;\n        initialState.lastQuality = 0;\n\n        _initializeL2AParameters(mediaInfo);\n        _clearL2AStateOnSeek(initialState);\n\n        return initialState;\n    }\n\n    /**\n     * Initializes the parameters of the algorithm. This will be done once for each media type.\n     * @param {object} mediaInfo\n     * @private\n     */\n    function _initializeL2AParameters(mediaInfo) {\n\n        if (!mediaInfo || !mediaInfo.type) {\n            return;\n        }\n        l2AParameterDict[mediaInfo.type] = {};\n        l2AParameterDict[mediaInfo.type].w = []; //Vector of probabilities associated with bitrate decisions\n        l2AParameterDict[mediaInfo.type].prev_w = []; //Vector of probabilities associated with bitrate decisions calculated in the previous step\n        l2AParameterDict[mediaInfo.type].Q = 0; //Initialization of Lagrangian multiplier (This keeps track of the buffer displacement)\n        l2AParameterDict[mediaInfo.type].segment_request_start_s = 0;\n        l2AParameterDict[mediaInfo.type].segment_download_finish_s = 0;\n        l2AParameterDict[mediaInfo.type].B_target = 1.5; //Target buffer level\n    }\n\n\n    /**\n     * Clears the state object\n     * @param {object} l2AState\n     * @private\n     */\n    function _clearL2AStateOnSeek(l2AState) {\n        l2AState.placeholderBuffer = 0;\n        l2AState.mostAdvancedSegmentStart = NaN;\n        l2AState.lastSegmentWasReplacement = false;\n        l2AState.lastSegmentStart = NaN;\n        l2AState.lastSegmentDurationS = NaN;\n        l2AState.lastSegmentRequestTimeMs = NaN;\n        l2AState.lastSegmentFinishTimeMs = NaN;\n    }\n\n\n    /**\n     * Returns the state object for a fiven media type. If the state object is not yet defined _getInitialL2AState is called\n     * @param {object} rulesContext\n     * @return {object} l2AState\n     * @private\n     */\n    function _getL2AState(rulesContext) {\n        const mediaType = rulesContext.getMediaType();\n        let l2AState = l2AStateDict[mediaType];\n\n        if (!l2AState) {\n            l2AState = _getInitialL2AState(rulesContext);\n            l2AStateDict[mediaType] = l2AState;\n        }\n\n        return l2AState;\n    }\n\n    /**\n     * Event handler for the seeking event.\n     * @private\n     */\n    function _onPlaybackSeeking() {\n        for (const mediaType in l2AStateDict) {\n            if (l2AStateDict.hasOwnProperty(mediaType)) {\n                const l2aState = l2AStateDict[mediaType];\n                if (l2aState.state !== L2A_STATE_ONE_BITRATE) {\n                    l2aState.state = L2A_STATE_STARTUP;\n                    _clearL2AStateOnSeek(l2aState);\n                }\n            }\n        }\n    }\n\n    /**\n     * Event handler for the mediaFragmentLoaded event\n     * @param {object} e\n     * @private\n     */\n    function _onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            const l2AState = l2AStateDict[e.chunk.mediaInfo.type];\n            const l2AParameters = l2AParameterDict[e.chunk.mediaInfo.type];\n\n            if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n                const start = e.chunk.start;\n                if (isNaN(l2AState.mostAdvancedSegmentStart) || start > l2AState.mostAdvancedSegmentStart) {\n                    l2AState.mostAdvancedSegmentStart = start;\n                    l2AState.lastSegmentWasReplacement = false;\n                } else {\n                    l2AState.lastSegmentWasReplacement = true;\n                }\n\n                l2AState.lastSegmentStart = start;\n                l2AState.lastSegmentDurationS = e.chunk.duration;\n                l2AState.lastQuality = e.chunk.quality;\n\n                _checkNewSegment(l2AState, l2AParameters);\n            }\n        }\n    }\n\n    /**\n     * Event handler for the metricAdded event\n     * @param {object} e\n     * @private\n     */\n    function _onMetricAdded(e) {\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n            const l2AState = l2AStateDict[e.mediaType];\n            const l2AParameters = l2AParameterDict[e.mediaType];\n\n            if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n                l2AState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n                l2AState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n                _checkNewSegment(l2AState, l2AParameters);\n            }\n        }\n    }\n\n    /**\n     * When a new metric has been added or a media fragment has been loaded the state is adjusted accordingly\n     * @param {object} L2AState\n     * @param {object} l2AParameters\n     * @private\n     */\n    function _checkNewSegment(L2AState, l2AParameters) {\n        if (!isNaN(L2AState.lastSegmentStart) && !isNaN(L2AState.lastSegmentRequestTimeMs)) {\n            l2AParameters.segment_request_start_s = 0.001 * L2AState.lastSegmentRequestTimeMs;\n            l2AParameters.segment_download_finish_s = 0.001 * L2AState.lastSegmentFinishTimeMs;\n            L2AState.lastSegmentStart = NaN;\n            L2AState.lastSegmentRequestTimeMs = NaN;\n        }\n    }\n\n    /**\n     * Event handler for the qualityChangeRequested event\n     * @param {object} e\n     * @private\n     */\n    function _onQualityChangeRequested(e) {\n        // Useful to store change requests when abandoning a download.\n        if (e && e.mediaType) {\n            const L2AState = l2AStateDict[e.mediaType];\n            if (L2AState && L2AState.state !== L2A_STATE_ONE_BITRATE) {\n                L2AState.abrQuality = e.newQuality;\n            }\n        }\n    }\n\n    /**\n     * Dot multiplication of two arrays\n     * @param {array} arr1\n     * @param {array} arr2\n     * @return {number} sumdot\n     * @private\n     */\n\n    function _dotmultiplication(arr1, arr2) {\n        if (arr1.length !== arr2.length) {\n            return -1;\n        }\n        let sumdot = 0;\n        for (let i = 0; i < arr1.length; i++) {\n            sumdot = sumdot + arr1[i] * arr2[i];\n        }\n        return sumdot;\n    }\n\n    /**\n     * Project an n-dim vector y to the simplex Dn\n     * Dn = { x : x n-dim, 1 >= x >= 0, sum(x) = 1}\n     * Algorithm is explained at http://arxiv.org/abs/1101.6081\n     * @param {array} arr\n     * @return {array}\n     */\n    function euclideanProjection(arr) {\n        const m = arr.length;\n        let bget = false;\n        let arr2 = [];\n        for (let ii = 0; ii < m; ++ii) {\n            arr2[ii] = arr[ii];\n        }\n        let s = arr.sort(function (a, b) {\n            return b - a;\n        });\n        let tmpsum = 0;\n        let tmax = 0;\n        let x = [];\n        for (let ii = 0; ii < m - 1; ++ii) {\n            tmpsum = tmpsum + s[ii];\n            tmax = (tmpsum - 1) / (ii + 1);\n            if (tmax >= s[ii + 1]) {\n                bget = true;\n                break;\n            }\n        }\n        if (!bget) {\n            tmax = (tmpsum + s[m - 1] - 1) / m;\n        }\n        for (let ii = 0; ii < m; ++ii) {\n            x[ii] = Math.max(arr2[ii] - tmax, 0);\n        }\n        return x;\n    }\n\n    /**\n     * Returns a switch request object indicating which quality is to be played\n     * @param {object} rulesContext\n     * @return {object}\n     */\n    function getMaxIndex(rulesContext) {\n        const switchRequest = SwitchRequest(context).create();\n        const horizon = 4; // Optimization horizon (The amount of steps required to achieve convergence)\n        const vl = Math.pow(horizon, 0.99);// Cautiousness parameter, used to control aggressiveness of the bitrate decision process.\n        const alpha = Math.max(Math.pow(horizon, 1), vl * Math.sqrt(horizon));// Step size, used for gradient descent exploration granularity\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        const bitrateCount = bitrates.length;\n        const scheduleController = rulesContext.getScheduleController();\n        const streamInfo = rulesContext.getStreamInfo();\n        const abrController = rulesContext.getAbrController();\n        const throughputHistory = abrController.getThroughputHistory();\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n        const useL2AABR = rulesContext.useL2AABR();\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic); // In kbits/s\n        const react = 2; // Reactiveness to volatility (abrupt throughput drops), used to re-calibrate Lagrangian multiplier Q\n        const latency = throughputHistory.getAverageLatency(mediaType);\n        const videoModel = rulesContext.getVideoModel();\n        let quality;\n        let currentPlaybackRate = videoModel.getPlaybackRate();\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') ||\n            !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') ||\n            !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useL2AABR')) {\n            return switchRequest;\n        }\n\n        switchRequest.reason = switchRequest.reason || {};\n\n        if ((!useL2AABR) || (mediaType === Constants.AUDIO)) {// L2A decides bitrate only for video. Audio to be included in decision process in a later stage\n            return switchRequest;\n        }\n\n        scheduleController.setTimeToLoadDelay(0);\n\n        const l2AState = _getL2AState(rulesContext);\n\n        if (l2AState.state === L2A_STATE_ONE_BITRATE) {\n            // shouldn't even have been called\n            return switchRequest;\n        }\n\n        const l2AParameter = l2AParameterDict[mediaType];\n\n        if (!l2AParameter) {\n            return switchRequest;\n        }\n\n        switchRequest.reason.state = l2AState.state;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n\n        if (isNaN(throughput)) {\n            // still starting up - not enough information\n            return switchRequest;\n        }\n\n        switch (l2AState.state) {\n            case L2A_STATE_STARTUP:\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);//During strat-up phase abr.controller is responsible for bitrate decisions.\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = safeThroughput;\n                l2AState.lastQuality = quality;\n\n                if (!isNaN(l2AState.lastSegmentDurationS) && bufferLevel >= l2AParameter.B_target) {\n                    l2AState.state = L2A_STATE_STEADY;\n                    l2AParameter.Q = vl;// Initialization of Q langrangian multiplier\n                    // Update of probability vector w, to be used in main adaptation logic of L2A below (steady state)\n                    for (let i = 0; i < bitrateCount; ++i) {\n                        if (i === l2AState.lastQuality) {\n                            l2AParameter.prev_w[i] = 1;\n                        } else {\n                            l2AParameter.prev_w[i] = 0;\n                        }\n                    }\n                }\n\n                break; // L2A_STATE_STARTUP\n            case L2A_STATE_STEADY:\n                let diff1 = [];//Used to calculate the difference between consecutive decisions (w-w_prev)\n\n                // Manual calculation of latency and throughput during previous request\n                let throughputMeasureTime = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce((a, b) => a + b.d, 0);\n                const downloadBytes = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce((a, b) => a + b.b[0], 0);\n                let lastthroughput = Math.round((8 * downloadBytes) / throughputMeasureTime); // bits/ms = kbits/s\n\n                if (lastthroughput < 1) {\n                    lastthroughput = 1;\n                }//To avoid division with 0 (avoid infinity) in case of an absolute network outage\n\n                let V = l2AState.lastSegmentDurationS;\n                let sign = 1;\n\n                //Main adaptation logic of L2A-LL\n                for (let i = 0; i < bitrateCount; ++i) {\n                    bitrates[i] = bitrates[i] / 1000; // Originally in bps, now in Kbps\n                    if (currentPlaybackRate * bitrates[i] > lastthroughput) {// In this case buffer would deplete, leading to a stall, which increases latency and thus the particular probability of selsection of bitrate[i] should be decreased.\n                        sign = -1;\n                    }\n                    // The objective of L2A is to minimize the overall latency=request-response time + buffer length after download+ potential stalling (if buffer less than chunk downlad time)\n                    l2AParameter.w[i] = l2AParameter.prev_w[i] + sign * (V / (2 * alpha)) * ((l2AParameter.Q + vl) * (currentPlaybackRate * bitrates[i] / lastthroughput));//Lagrangian descent\n                }\n\n                // Apply euclidean projection on w to ensure w expresses a probability distribution\n                l2AParameter.w = euclideanProjection(l2AParameter.w);\n\n                for (let i = 0; i < bitrateCount; ++i) {\n                    diff1[i] = l2AParameter.w[i] - l2AParameter.prev_w[i];\n                    l2AParameter.prev_w[i] = l2AParameter.w[i];\n                }\n\n                // Lagrangian multiplier Q calculation:\n                l2AParameter.Q = Math.max(0, l2AParameter.Q - V + V * currentPlaybackRate * ((_dotmultiplication(bitrates, l2AParameter.prev_w) + _dotmultiplication(bitrates, diff1)) / lastthroughput));\n\n                // Quality is calculated as argmin of the absolute difference between available bitrates (bitrates[i]) and bitrate estimation (dotmultiplication(w,bitrates)).\n                let temp = [];\n                for (let i = 0; i < bitrateCount; ++i) {\n                    temp[i] = Math.abs(bitrates[i] - _dotmultiplication(l2AParameter.w, bitrates));\n                }\n\n                // Quality is calculated based on the probability distribution w (the output of L2A)\n                quality = temp.indexOf(Math.min(...temp));\n\n                // We employ a cautious -stepwise- ascent\n                if (quality > l2AState.lastQuality) {\n                    if (bitrates[l2AState.lastQuality + 1] <= lastthroughput) {\n                        quality = l2AState.lastQuality + 1;\n                    }\n                }\n\n                // Provision against bitrate over-estimation, by re-calibrating the Lagrangian multiplier Q, to be taken into account for the next chunk\n                if (bitrates[quality] >= lastthroughput) {\n                    l2AParameter.Q = react * Math.max(vl, l2AParameter.Q);\n                }\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = throughput;\n                switchRequest.reason.latency = latency;\n                switchRequest.reason.bufferLevel = bufferLevel;\n                l2AState.lastQuality = switchRequest.quality;\n                break;\n            default:\n                // should not arrive here, try to recover\n                logger.debug('L2A ABR rule invoked in bad state.');\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.reason.state = l2AState.state;\n                switchRequest.reason.throughput = safeThroughput;\n                switchRequest.reason.latency = latency;\n                l2AState.state = L2A_STATE_STARTUP;\n                _clearL2AStateOnSeek(l2AState);\n        }\n        return switchRequest;\n    }\n\n    /**\n     * Reset objects to their initial state\n     * @private\n     */\n    function _resetInitialSettings() {\n        l2AStateDict = {};\n        l2AParameterDict = {};\n    }\n\n    /**\n     * Reset the rule\n     */\n    function reset() {\n        _resetInitialSettings();\n        eventBus.off(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n        eventBus.off(Events.METRIC_ADDED, _onMetricAdded, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nL2ARule.__dashjs_factory_name = 'L2ARule';\nexport default FactoryMaker.getClassFactory(L2ARule);\n"]},"metadata":{},"sourceType":"script"}