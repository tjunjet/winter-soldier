{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Debug = require('../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* This is a sink that is used to temporarily hold onto media chunks before a video element is added.\n* The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer.\n*\n* @class PreBufferSink\n* @ignore\n* @implements FragmentSink\n*/\n\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction PreBufferSink(onAppendedCallback) {\n  var context = this.context;\n  var instance = void 0,\n      logger = void 0,\n      outstandingInit = void 0;\n  var chunks = [];\n  var onAppended = onAppendedCallback;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n  }\n\n  function reset() {\n    chunks = [];\n    outstandingInit = null;\n    onAppended = null;\n  }\n\n  function append(chunk) {\n    if (chunk.segmentType !== 'InitializationSegment') {\n      //Init segments are stored in the initCache.\n      chunks.push(chunk);\n      chunks.sort(function (a, b) {\n        return a.start - b.start;\n      });\n      outstandingInit = null;\n    } else {\n      //We need to hold an init chunk for when a corresponding media segment is being downloaded when the discharge happens.\n      outstandingInit = chunk;\n    }\n\n    logger.debug('PreBufferSink appended chunk s: ' + chunk.start + '; e: ' + chunk.end);\n\n    if (onAppended) {\n      onAppended({\n        chunk: chunk\n      });\n    }\n  }\n\n  function remove(start, end) {\n    chunks = chunks.filter(function (a) {\n      return !((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start));\n    }); //The opposite of the getChunks predicate.\n  } //Nothing async, nothing to abort.\n\n\n  function abort() {}\n\n  function getAllBufferRanges() {\n    var ranges = [];\n\n    for (var i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n\n      if (ranges.length === 0 || chunk.start > ranges[ranges.length - 1].end) {\n        ranges.push({\n          start: chunk.start,\n          end: chunk.end\n        });\n      } else {\n        ranges[ranges.length - 1].end = chunk.end;\n      }\n    } //Implements TimeRanges interface. So acts just like sourceBuffer.buffered.\n\n\n    var timeranges = {\n      start: function start(n) {\n        return ranges[n].start;\n      },\n      end: function end(n) {\n        return ranges[n].end;\n      }\n    };\n    Object.defineProperty(timeranges, 'length', {\n      get: function get() {\n        return ranges.length;\n      }\n    });\n    return timeranges;\n  }\n\n  function hasDiscontinuitiesAfter() {\n    return false;\n  }\n\n  function updateTimestampOffset() {// Nothing to do\n  }\n\n  function getBuffer() {\n    return this;\n  }\n  /**\n  * Return the all chunks in the buffer the lie between times start and end.\n  * Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range.\n  * Chunks are removed from the buffer when they are discharged.\n  * @function PreBufferSink#discharge\n  * @param {?Number} start The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n  * @param {?Number} end The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n  * @returns {Array} The set of chunks from the buffer within the time ranges.\n  */\n\n\n  function discharge(start, end) {\n    var result = getChunksAt(start, end);\n\n    if (outstandingInit) {\n      result.push(outstandingInit);\n      outstandingInit = null;\n    }\n\n    remove(start, end);\n    return result;\n  }\n\n  function getChunksAt(start, end) {\n    return chunks.filter(function (a) {\n      return (isNaN(end) || a.start < end) && (isNaN(start) || a.end > start);\n    });\n  }\n\n  function waitForUpdateEnd(callback) {\n    callback();\n  }\n\n  instance = {\n    getAllBufferRanges: getAllBufferRanges,\n    append: append,\n    remove: remove,\n    abort: abort,\n    discharge: discharge,\n    reset: reset,\n    updateTimestampOffset: updateTimestampOffset,\n    hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\n    waitForUpdateEnd: waitForUpdateEnd,\n    getBuffer: getBuffer\n  };\n  setup();\n  return instance;\n}\n\nPreBufferSink.__dashjs_factory_name = 'PreBufferSink';\n\nvar factory = _FactoryMaker2.default.getClassFactory(PreBufferSink);\n\nexports.default = factory;","map":{"version":3,"mappings":"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","names":["PreBufferSink","onAppendedCallback","context","instance","logger","outstandingInit","chunks","onAppended","setup","getInstance","getLogger","reset","append","chunk","segmentType","push","sort","a","b","start","debug","end","remove","filter","isNaN","abort","getAllBufferRanges","ranges","i","length","timeranges","n","Object","defineProperty","get","hasDiscontinuitiesAfter","updateTimestampOffset","getBuffer","discharge","result","getChunksAt","waitForUpdateEnd","callback","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/PreBufferSink.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport FactoryMaker from '../core/FactoryMaker';\n\n/**\n * This is a sink that is used to temporarily hold onto media chunks before a video element is added.\n * The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer.\n *\n * @class PreBufferSink\n * @ignore\n * @implements FragmentSink\n */\nfunction PreBufferSink(onAppendedCallback) {\n    const context = this.context;\n\n    let instance,\n        logger,\n        outstandingInit;\n    let chunks = [];\n    let onAppended = onAppendedCallback;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function reset() {\n        chunks = [];\n        outstandingInit = null;\n        onAppended = null;\n    }\n\n    function append(chunk) {\n        if (chunk.segmentType !== 'InitializationSegment') { //Init segments are stored in the initCache.\n            chunks.push(chunk);\n            chunks.sort(function (a, b) { return a.start - b.start; });\n            outstandingInit = null;\n        } else {//We need to hold an init chunk for when a corresponding media segment is being downloaded when the discharge happens.\n            outstandingInit = chunk;\n        }\n\n        logger.debug('PreBufferSink appended chunk s: ' + chunk.start + '; e: ' + chunk.end);\n        if (onAppended) {\n            onAppended({\n                chunk: chunk\n            });\n        }\n    }\n\n    function remove(start, end) {\n        chunks = chunks.filter( a => !((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start))); //The opposite of the getChunks predicate.\n    }\n\n    //Nothing async, nothing to abort.\n    function abort() {\n    }\n\n    function getAllBufferRanges() {\n        let ranges = [];\n\n        for (let i = 0; i < chunks.length; i++) {\n            let chunk = chunks[i];\n            if (ranges.length === 0 || chunk.start > ranges[ranges.length - 1].end) {\n                ranges.push({ start: chunk.start, end: chunk.end });\n            } else {\n                ranges[ranges.length - 1].end = chunk.end;\n            }\n        }\n\n        //Implements TimeRanges interface. So acts just like sourceBuffer.buffered.\n        const timeranges = {\n            start: function (n) {\n                return ranges[n].start;\n            },\n            end: function (n) {\n                return ranges[n].end;\n            }\n        };\n\n        Object.defineProperty(timeranges, 'length', {\n            get: function () {\n                return ranges.length;\n            }\n        });\n\n        return timeranges;\n    }\n\n    function hasDiscontinuitiesAfter() {\n        return false;\n    }\n\n    function updateTimestampOffset() {\n        // Nothing to do\n    }\n\n    function getBuffer() {\n        return this;\n    }\n\n    /**\n     * Return the all chunks in the buffer the lie between times start and end.\n     * Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range.\n     * Chunks are removed from the buffer when they are discharged.\n     * @function PreBufferSink#discharge\n     * @param {?Number} start The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n     * @param {?Number} end The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n     * @returns {Array} The set of chunks from the buffer within the time ranges.\n     */\n    function discharge(start, end) {\n        const result = getChunksAt(start, end);\n        if (outstandingInit) {\n            result.push(outstandingInit);\n            outstandingInit = null;\n        }\n\n        remove(start, end);\n\n        return result;\n    }\n\n    function getChunksAt(start, end) {\n        return chunks.filter( a => ((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start)) );\n    }\n\n    function waitForUpdateEnd(callback) {\n        callback();\n    }\n\n    instance = {\n        getAllBufferRanges: getAllBufferRanges,\n        append: append,\n        remove: remove,\n        abort: abort,\n        discharge: discharge,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset,\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\n        waitForUpdateEnd: waitForUpdateEnd,\n        getBuffer: getBuffer\n    };\n\n    setup();\n\n    return instance;\n}\n\nPreBufferSink.__dashjs_factory_name = 'PreBufferSink';\nconst factory = FactoryMaker.getClassFactory(PreBufferSink);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}