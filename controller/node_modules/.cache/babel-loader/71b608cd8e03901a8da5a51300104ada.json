{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _QoeInfo = require('./QoeInfo');\n\nvar _QoeInfo2 = _interopRequireDefault(_QoeInfo);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Authors:\n* Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n* Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n* May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n*/\n\n\nfunction LoLpQoeEvaluator() {\n  var instance = void 0,\n      voPerSegmentQoeInfo = void 0,\n      segmentDuration = void 0,\n      maxBitrateKbps = void 0,\n      minBitrateKbps = void 0;\n\n  function _setup() {\n    _resetInitialSettings();\n  }\n\n  function _resetInitialSettings() {\n    voPerSegmentQoeInfo = null;\n    segmentDuration = null;\n    maxBitrateKbps = null;\n    minBitrateKbps = null;\n  }\n\n  function setupPerSegmentQoe(sDuration, maxBrKbps, minBrKbps) {\n    // Set up Per Segment QoeInfo\n    voPerSegmentQoeInfo = _createQoeInfo('segment', sDuration, maxBrKbps, minBrKbps);\n    segmentDuration = sDuration;\n    maxBitrateKbps = maxBrKbps;\n    minBitrateKbps = minBrKbps;\n  }\n\n  function _createQoeInfo(fragmentType, fragmentDuration, maxBitrateKbps, minBitrateKbps) {\n    /*\n    * [Weights][Source: Abdelhak Bentaleb, 2020 (last updated: 30 Mar 2020)]\n    * bitrateReward:           segment duration, e.g. 0.5s\n    * bitrateSwitchPenalty:    0.02s or 1s if the bitrate switch is too important\n    * rebufferPenalty:         max encoding bitrate, e.g. 1000kbps\n    * latencyPenalty:          if L â‰¤ 1.1 seconds then = min encoding bitrate * 0.05, otherwise = max encoding bitrate * 0.1\n    * playbackSpeedPenalty:    min encoding bitrate, e.g. 200kbps\n    */\n    // Create new QoeInfo object\n    var qoeInfo = new _QoeInfo2.default();\n    qoeInfo.type = fragmentType; // Set weight: bitrateReward\n    // set some safe value, else consider throwing error\n\n    if (!fragmentDuration) {\n      qoeInfo.weights.bitrateReward = 1;\n    } else {\n      qoeInfo.weights.bitrateReward = fragmentDuration;\n    } // Set weight: bitrateSwitchPenalty\n    // qoeInfo.weights.bitrateSwitchPenalty = 0.02;\n\n\n    qoeInfo.weights.bitrateSwitchPenalty = 1; // Set weight: rebufferPenalty\n    // set some safe value, else consider throwing error\n\n    if (!maxBitrateKbps) {\n      qoeInfo.weights.rebufferPenalty = 1000;\n    } else {\n      qoeInfo.weights.rebufferPenalty = maxBitrateKbps;\n    } // Set weight: latencyPenalty\n\n\n    qoeInfo.weights.latencyPenalty = [];\n    qoeInfo.weights.latencyPenalty.push({\n      threshold: 1.1,\n      penalty: minBitrateKbps * 0.05\n    });\n    qoeInfo.weights.latencyPenalty.push({\n      threshold: 100000000,\n      penalty: maxBitrateKbps * 0.1\n    }); // Set weight: playbackSpeedPenalty\n\n    if (!minBitrateKbps) qoeInfo.weights.playbackSpeedPenalty = 200; // set some safe value, else consider throwing error\n    else qoeInfo.weights.playbackSpeedPenalty = minBitrateKbps;\n    return qoeInfo;\n  }\n\n  function logSegmentMetrics(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed) {\n    if (voPerSegmentQoeInfo) {\n      _logMetricsInQoeInfo(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed, voPerSegmentQoeInfo);\n    }\n  }\n\n  function _logMetricsInQoeInfo(bitrate, rebufferTime, latency, playbackSpeed, qoeInfo) {\n    // Update: bitrate Weighted Sum value\n    qoeInfo.bitrateWSum += qoeInfo.weights.bitrateReward * bitrate; // Update: bitrateSwitch Weighted Sum value\n\n    if (qoeInfo.lastBitrate) {\n      qoeInfo.bitrateSwitchWSum += qoeInfo.weights.bitrateSwitchPenalty * Math.abs(bitrate - qoeInfo.lastBitrate);\n    }\n\n    qoeInfo.lastBitrate = bitrate; // Update: rebuffer Weighted Sum value\n\n    qoeInfo.rebufferWSum += qoeInfo.weights.rebufferPenalty * rebufferTime; // Update: latency Weighted Sum value\n\n    for (var i = 0; i < qoeInfo.weights.latencyPenalty.length; i++) {\n      var latencyRange = qoeInfo.weights.latencyPenalty[i];\n\n      if (latency <= latencyRange.threshold) {\n        qoeInfo.latencyWSum += latencyRange.penalty * latency;\n        break;\n      }\n    } // Update: playbackSpeed Weighted Sum value\n\n\n    qoeInfo.playbackSpeedWSum += qoeInfo.weights.playbackSpeedPenalty * Math.abs(1 - playbackSpeed); // Update: Total Qoe value\n\n    qoeInfo.totalQoe = qoeInfo.bitrateWSum - qoeInfo.bitrateSwitchWSum - qoeInfo.rebufferWSum - qoeInfo.latencyWSum - qoeInfo.playbackSpeedWSum;\n  } // Returns current Per Segment QoeInfo\n\n\n  function getPerSegmentQoe() {\n    return voPerSegmentQoeInfo;\n  } // For one-time use only\n  // Returns totalQoe based on a single set of metrics.\n\n\n  function calculateSingleUseQoe(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed) {\n    var singleUseQoeInfo = null;\n\n    if (segmentDuration && maxBitrateKbps && minBitrateKbps) {\n      singleUseQoeInfo = _createQoeInfo('segment', segmentDuration, maxBitrateKbps, minBitrateKbps);\n    }\n\n    if (singleUseQoeInfo) {\n      _logMetricsInQoeInfo(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed, singleUseQoeInfo);\n\n      return singleUseQoeInfo.totalQoe;\n    } else {\n      // Something went wrong..\n      return 0;\n    }\n  }\n\n  function reset() {\n    _resetInitialSettings();\n  }\n\n  instance = {\n    setupPerSegmentQoe: setupPerSegmentQoe,\n    logSegmentMetrics: logSegmentMetrics,\n    getPerSegmentQoe: getPerSegmentQoe,\n    calculateSingleUseQoe: calculateSingleUseQoe,\n    reset: reset\n  };\n\n  _setup();\n\n  return instance;\n}\n\nLoLpQoeEvaluator.__dashjs_factory_name = 'LoLpQoeEvaluator';\nexports.default = _FactoryMaker2.default.getClassFactory(LoLpQoeEvaluator);","map":{"version":3,"mappings":"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","names":["LoLpQoeEvaluator","instance","voPerSegmentQoeInfo","segmentDuration","maxBitrateKbps","minBitrateKbps","_setup","_resetInitialSettings","setupPerSegmentQoe","sDuration","maxBrKbps","minBrKbps","_createQoeInfo","fragmentType","fragmentDuration","qoeInfo","QoeInfo","type","weights","bitrateReward","bitrateSwitchPenalty","rebufferPenalty","latencyPenalty","push","threshold","penalty","playbackSpeedPenalty","logSegmentMetrics","segmentBitrate","segmentRebufferTime","currentLatency","currentPlaybackSpeed","_logMetricsInQoeInfo","bitrate","rebufferTime","latency","playbackSpeed","bitrateWSum","lastBitrate","bitrateSwitchWSum","Math","abs","rebufferWSum","i","length","latencyRange","latencyWSum","playbackSpeedWSum","totalQoe","getPerSegmentQoe","calculateSingleUseQoe","singleUseQoeInfo","reset","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/rules/abr/lolp/LoLpQoEEvaluator.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Authors:\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n */\nimport FactoryMaker from '../../../../core/FactoryMaker';\nimport QoeInfo from './QoeInfo';\n\nfunction LoLpQoeEvaluator() {\n\n    let instance,\n        voPerSegmentQoeInfo,\n        segmentDuration,\n        maxBitrateKbps,\n        minBitrateKbps;\n\n    function _setup() {\n        _resetInitialSettings();\n    }\n\n    function _resetInitialSettings() {\n        voPerSegmentQoeInfo = null;\n        segmentDuration = null;\n        maxBitrateKbps = null;\n        minBitrateKbps = null;\n    }\n\n    function setupPerSegmentQoe(sDuration, maxBrKbps, minBrKbps) {\n        // Set up Per Segment QoeInfo\n        voPerSegmentQoeInfo = _createQoeInfo('segment', sDuration, maxBrKbps, minBrKbps);\n        segmentDuration = sDuration;\n        maxBitrateKbps = maxBrKbps;\n        minBitrateKbps = minBrKbps;\n    }\n\n    function _createQoeInfo(fragmentType, fragmentDuration, maxBitrateKbps, minBitrateKbps) {\n        /*\n         * [Weights][Source: Abdelhak Bentaleb, 2020 (last updated: 30 Mar 2020)]\n         * bitrateReward:           segment duration, e.g. 0.5s\n         * bitrateSwitchPenalty:    0.02s or 1s if the bitrate switch is too important\n         * rebufferPenalty:         max encoding bitrate, e.g. 1000kbps\n         * latencyPenalty:          if L â‰¤ 1.1 seconds then = min encoding bitrate * 0.05, otherwise = max encoding bitrate * 0.1\n         * playbackSpeedPenalty:    min encoding bitrate, e.g. 200kbps\n         */\n\n        // Create new QoeInfo object\n        let qoeInfo = new QoeInfo();\n        qoeInfo.type = fragmentType;\n\n        // Set weight: bitrateReward\n        // set some safe value, else consider throwing error\n        if (!fragmentDuration) {\n            qoeInfo.weights.bitrateReward = 1;\n        }\n        else {\n            qoeInfo.weights.bitrateReward = fragmentDuration;\n        }\n\n        // Set weight: bitrateSwitchPenalty\n        // qoeInfo.weights.bitrateSwitchPenalty = 0.02;\n        qoeInfo.weights.bitrateSwitchPenalty = 1;\n\n        // Set weight: rebufferPenalty\n        // set some safe value, else consider throwing error\n        if (!maxBitrateKbps) {\n            qoeInfo.weights.rebufferPenalty = 1000;\n        }\n        else {\n            qoeInfo.weights.rebufferPenalty = maxBitrateKbps;\n        }\n\n        // Set weight: latencyPenalty\n        qoeInfo.weights.latencyPenalty = [];\n        qoeInfo.weights.latencyPenalty.push({ threshold: 1.1, penalty: (minBitrateKbps * 0.05) });\n        qoeInfo.weights.latencyPenalty.push({ threshold: 100000000, penalty: (maxBitrateKbps * 0.1) });\n\n        // Set weight: playbackSpeedPenalty\n        if (!minBitrateKbps) qoeInfo.weights.playbackSpeedPenalty = 200;   // set some safe value, else consider throwing error\n        else qoeInfo.weights.playbackSpeedPenalty = minBitrateKbps;\n\n        return qoeInfo;\n    }\n\n    function logSegmentMetrics(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed) {\n        if (voPerSegmentQoeInfo) {\n            _logMetricsInQoeInfo(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed, voPerSegmentQoeInfo);\n        }\n    }\n\n    function _logMetricsInQoeInfo(bitrate, rebufferTime, latency, playbackSpeed, qoeInfo) {\n        // Update: bitrate Weighted Sum value\n        qoeInfo.bitrateWSum += (qoeInfo.weights.bitrateReward * bitrate);\n\n        // Update: bitrateSwitch Weighted Sum value\n        if (qoeInfo.lastBitrate) {\n            qoeInfo.bitrateSwitchWSum += (qoeInfo.weights.bitrateSwitchPenalty * Math.abs(bitrate - qoeInfo.lastBitrate));\n        }\n        qoeInfo.lastBitrate = bitrate;\n\n        // Update: rebuffer Weighted Sum value\n        qoeInfo.rebufferWSum += (qoeInfo.weights.rebufferPenalty * rebufferTime);\n\n        // Update: latency Weighted Sum value\n        for (let i = 0; i < qoeInfo.weights.latencyPenalty.length; i++) {\n            let latencyRange = qoeInfo.weights.latencyPenalty[i];\n            if (latency <= latencyRange.threshold) {\n                qoeInfo.latencyWSum += (latencyRange.penalty * latency);\n                break;\n            }\n        }\n\n        // Update: playbackSpeed Weighted Sum value\n        qoeInfo.playbackSpeedWSum += (qoeInfo.weights.playbackSpeedPenalty * Math.abs(1 - playbackSpeed));\n\n        // Update: Total Qoe value\n        qoeInfo.totalQoe = qoeInfo.bitrateWSum - qoeInfo.bitrateSwitchWSum - qoeInfo.rebufferWSum - qoeInfo.latencyWSum - qoeInfo.playbackSpeedWSum;\n    }\n\n    // Returns current Per Segment QoeInfo\n    function getPerSegmentQoe() {\n        return voPerSegmentQoeInfo;\n    }\n\n    // For one-time use only\n    // Returns totalQoe based on a single set of metrics.\n    function calculateSingleUseQoe(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed) {\n        let singleUseQoeInfo = null;\n\n        if (segmentDuration && maxBitrateKbps && minBitrateKbps) {\n            singleUseQoeInfo = _createQoeInfo('segment', segmentDuration, maxBitrateKbps, minBitrateKbps);\n        }\n\n        if (singleUseQoeInfo) {\n            _logMetricsInQoeInfo(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed, singleUseQoeInfo);\n            return singleUseQoeInfo.totalQoe;\n        } else {\n            // Something went wrong..\n            return 0;\n        }\n    }\n\n    function reset() {\n        _resetInitialSettings();\n    }\n\n    instance = {\n        setupPerSegmentQoe,\n        logSegmentMetrics,\n        getPerSegmentQoe,\n        calculateSingleUseQoe,\n        reset\n    };\n\n    _setup();\n\n    return instance;\n}\n\nLoLpQoeEvaluator.__dashjs_factory_name = 'LoLpQoeEvaluator';\nexport default FactoryMaker.getClassFactory(LoLpQoeEvaluator);\n\n"]},"metadata":{},"sourceType":"script"}