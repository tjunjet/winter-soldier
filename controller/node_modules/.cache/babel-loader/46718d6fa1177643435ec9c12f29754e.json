{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Authors:\n* Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n* Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n* May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n*/\n\n\nvar WEIGHT_SELECTION_MODES = {\n  MANUAL: 'manual_weight_selection',\n  RANDOM: 'random_weight_selection',\n  DYNAMIC: 'dynamic_weight_selection'\n};\n\nfunction LearningAbrController() {\n  var context = this.context;\n  var instance = void 0,\n      logger = void 0,\n      somBitrateNeurons = void 0,\n      bitrateNormalizationFactor = void 0,\n      latencyNormalizationFactor = void 0,\n      minBitrate = void 0,\n      minBitrateNeuron = void 0,\n      weights = void 0,\n      sortedCenters = void 0,\n      weightSelectionMode = void 0;\n  /**\n  * Setup the class\n  */\n\n  function _setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n\n    _resetInitialSettings();\n  }\n  /**\n  * Reset all values\n  */\n\n\n  function reset() {\n    _resetInitialSettings();\n  }\n  /**\n  * Reset to initial settings\n  * @private\n  */\n\n\n  function _resetInitialSettings() {\n    somBitrateNeurons = null;\n    bitrateNormalizationFactor = 1;\n    latencyNormalizationFactor = 100;\n    minBitrate = 0;\n    minBitrateNeuron = null;\n    weights = null;\n    sortedCenters = null;\n    weightSelectionMode = WEIGHT_SELECTION_MODES.DYNAMIC;\n  }\n  /**\n  * Returns the maximum throughput\n  * @return {number}\n  * @private\n  */\n\n\n  function _getMaxThroughput() {\n    var maxThroughput = 0;\n\n    if (somBitrateNeurons) {\n      for (var i = 0; i < somBitrateNeurons.length; i++) {\n        var neuron = somBitrateNeurons[i];\n\n        if (neuron.state.throughput > maxThroughput) {\n          maxThroughput = neuron.state.throughput;\n        }\n      }\n    }\n\n    return maxThroughput;\n  }\n  /**\n  *\n  * @param {array} w\n  * @return {number}\n  * @private\n  */\n\n\n  function _getMagnitude(w) {\n    var magnitude = w.map(function (x) {\n      return Math.pow(x, 2);\n    }).reduce(function (sum, now) {\n      return sum + now;\n    });\n    return Math.sqrt(magnitude);\n  }\n  /**\n  *\n  * @param {array} a\n  * @param {array} b\n  * @param {array} w\n  * @return {number}\n  * @private\n  */\n\n\n  function _getDistance(a, b, w) {\n    var sum = a.map(function (x, i) {\n      return w[i] * Math.pow(x - b[i], 2);\n    }) // square the difference*w\n    .reduce(function (sum, now) {\n      return sum + now;\n    }); // sum\n\n    var sign = sum < 0 ? -1 : 1;\n    return sign * Math.sqrt(Math.abs(sum));\n  }\n  /**\n  *\n  * @param {object} a\n  * @param {object} b\n  * @return {number}\n  * @private\n  */\n\n\n  function _getNeuronDistance(a, b) {\n    var aState = [a.state.throughput, a.state.latency, a.state.rebuffer, a.state.switch];\n    var bState = [b.state.throughput, b.state.latency, b.state.rebuffer, b.state.switch];\n    return _getDistance(aState, bState, [1, 1, 1, 1]);\n  }\n  /**\n  *\n  * @param {object} winnerNeuron\n  * @param {array} somElements\n  * @param {array} x\n  * @private\n  */\n\n\n  function _updateNeurons(winnerNeuron, somElements, x) {\n    for (var i = 0; i < somElements.length; i++) {\n      var somNeuron = somElements[i];\n      var sigma = 0.1;\n\n      var neuronDistance = _getNeuronDistance(somNeuron, winnerNeuron);\n\n      var neighbourHood = Math.exp(-1 * Math.pow(neuronDistance, 2) / (2 * Math.pow(sigma, 2)));\n\n      _updateNeuronState(somNeuron, x, neighbourHood);\n    }\n  }\n  /**\n  *\n  * @param {object} neuron\n  * @param {array} x\n  * @param {object} neighbourHood\n  * @private\n  */\n\n\n  function _updateNeuronState(neuron, x, neighbourHood) {\n    var state = neuron.state;\n    var w = [0.01, 0.01, 0.01, 0.01]; // learning rate\n\n    state.throughput = state.throughput + (x[0] - state.throughput) * w[0] * neighbourHood;\n    state.latency = state.latency + (x[1] - state.latency) * w[1] * neighbourHood;\n    state.rebuffer = state.rebuffer + (x[2] - state.rebuffer) * w[2] * neighbourHood;\n    state.switch = state.switch + (x[3] - state.switch) * w[3] * neighbourHood;\n  }\n  /**\n  *\n  * @param {object} currentNeuron\n  * @param {number} currentThroughput\n  * @return {object}\n  * @private\n  */\n\n\n  function _getDownShiftNeuron(currentNeuron, currentThroughput) {\n    var maxSuitableBitrate = 0;\n    var result = currentNeuron;\n\n    if (somBitrateNeurons) {\n      for (var i = 0; i < somBitrateNeurons.length; i++) {\n        var n = somBitrateNeurons[i];\n\n        if (n.bitrate < currentNeuron.bitrate && n.bitrate > maxSuitableBitrate && currentThroughput > n.bitrate) {\n          // possible downshiftable neuron\n          maxSuitableBitrate = n.bitrate;\n          result = n;\n        }\n      }\n    }\n\n    return result;\n  }\n  /**\n  *\n  * @param {object} mediaInfo\n  * @param {number} throughput\n  * @param {number} latency\n  * @param {number} bufferSize\n  * @param {number} playbackRate\n  * @param {number} currentQualityIndex\n  * @param {object} dynamicWeightsSelector\n  * @return {null|*}\n  */\n\n\n  function getNextQuality(mediaInfo, throughput, latency, bufferSize, playbackRate, currentQualityIndex, dynamicWeightsSelector) {\n    // For Dynamic Weights Selector\n    var currentLatency = latency;\n    var currentBuffer = bufferSize;\n    var currentThroughput = throughput;\n\n    var somElements = _getSomBitrateNeurons(mediaInfo); // normalize throughput\n\n\n    var throughputNormalized = throughput / bitrateNormalizationFactor; // saturate values higher than 1\n\n    if (throughputNormalized > 1) {\n      throughputNormalized = _getMaxThroughput();\n    } // normalize latency\n\n\n    latency = latency / latencyNormalizationFactor;\n    var targetLatency = 0;\n    var targetRebufferLevel = 0;\n    var targetSwitch = 0; // 10K + video encoding is the recommended throughput\n\n    var throughputDelta = 10000;\n    logger.debug('getNextQuality called throughput:' + throughputNormalized + ' latency:' + latency + ' bufferSize:' + bufferSize + ' currentQualityIndex:' + currentQualityIndex + ' playbackRate:' + playbackRate);\n    var currentNeuron = somElements[currentQualityIndex];\n    var downloadTime = currentNeuron.bitrate * dynamicWeightsSelector.getSegmentDuration() / currentThroughput;\n    var rebuffer = Math.max(0, downloadTime - currentBuffer); // check buffer for possible stall\n\n    if (currentBuffer - downloadTime < dynamicWeightsSelector.getMinBuffer()) {\n      logger.debug('Buffer is low for bitrate= ' + currentNeuron.bitrate + ' downloadTime=' + downloadTime + ' currentBuffer=' + currentBuffer + ' rebuffer=' + rebuffer);\n      return _getDownShiftNeuron(currentNeuron, currentThroughput).qualityIndex;\n    }\n\n    switch (weightSelectionMode) {\n      case WEIGHT_SELECTION_MODES.MANUAL:\n        _manualWeightSelection();\n\n        break;\n\n      case WEIGHT_SELECTION_MODES.RANDOM:\n        _randomWeightSelection(somElements);\n\n        break;\n\n      case WEIGHT_SELECTION_MODES.DYNAMIC:\n        _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n\n        break;\n\n      default:\n        _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n\n    }\n\n    var minDistance = null;\n    var minIndex = null;\n    var winnerNeuron = null;\n    var winnerWeights = null;\n\n    for (var i = 0; i < somElements.length; i++) {\n      var somNeuron = somElements[i];\n      var somNeuronState = somNeuron.state;\n      var somData = [somNeuronState.throughput, somNeuronState.latency, somNeuronState.rebuffer, somNeuronState.switch];\n      var distanceWeights = weights.slice();\n      var nextBuffer = dynamicWeightsSelector.getNextBufferWithBitrate(somNeuron.bitrate, currentBuffer, currentThroughput);\n      var isBufferLow = nextBuffer < dynamicWeightsSelector.getMinBuffer();\n\n      if (isBufferLow) {\n        logger.debug('Buffer is low for bitrate=' + somNeuron.bitrate + ' downloadTime=' + downloadTime + ' currentBuffer=' + currentBuffer + ' nextBuffer=' + nextBuffer);\n      } // special condition downshift immediately\n\n\n      if (somNeuron.bitrate > throughput - throughputDelta || isBufferLow) {\n        if (somNeuron.bitrate !== minBitrate) {\n          // encourage to pick smaller bitrates throughputWeight=100\n          distanceWeights[0] = 100;\n        }\n      } // calculate the distance with the target\n\n\n      var distance = _getDistance(somData, [throughputNormalized, targetLatency, targetRebufferLevel, targetSwitch], distanceWeights);\n\n      if (minDistance === null || distance < minDistance) {\n        minDistance = distance;\n        minIndex = somNeuron.qualityIndex;\n        winnerNeuron = somNeuron;\n        winnerWeights = distanceWeights;\n      }\n    } // update current neuron and the neighbourhood with the calculated QoE\n    // will punish current if it is not picked\n\n\n    var bitrateSwitch = Math.abs(currentNeuron.bitrate - winnerNeuron.bitrate) / bitrateNormalizationFactor;\n\n    _updateNeurons(currentNeuron, somElements, [throughputNormalized, latency, rebuffer, bitrateSwitch]); // update bmu and  neighbours with targetQoE=1, targetLatency=0\n\n\n    _updateNeurons(winnerNeuron, somElements, [throughputNormalized, targetLatency, targetRebufferLevel, bitrateSwitch]);\n\n    return minIndex;\n  }\n  /**\n  * Option 1: Manual weights\n  * @private\n  */\n\n\n  function _manualWeightSelection() {\n    var throughputWeight = 0.4;\n    var latencyWeight = 0.4;\n    var bufferWeight = 0.4;\n    var switchWeight = 0.4;\n    weights = [throughputWeight, latencyWeight, bufferWeight, switchWeight]; // throughput, latency, buffer, switch\n  }\n  /**\n      * Option 2: Random (Xavier) weights\n      * @param {array} somElements\n      * @private\n      */\n\n\n  function _randomWeightSelection(somElements) {\n    weights = _getXavierWeights(somElements.length, 4);\n  }\n  /**\n  * Dynamic Weight Selector weights\n  * @param {object} dynamicWeightsSelector\n  * @param {array} somElements\n  * @param {number} currentLatency\n  * @param {number} currentBuffer\n  * @param {number} rebuffer\n  * @param {number} currentThroughput\n  * @param {number} playbackRate\n  * @private\n  */\n\n\n  function _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate) {\n    if (!weights) {\n      weights = sortedCenters[sortedCenters.length - 1];\n    } // Dynamic Weights Selector (step 2/2: find weights)\n\n\n    var weightVector = dynamicWeightsSelector.findWeightVector(somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n\n    if (weightVector !== null && weightVector !== -1) {\n      // null: something went wrong, -1: constraints not met\n      weights = weightVector;\n    }\n  }\n  /**\n  *\n  * @param {number }neuronCount\n  * @param {number }weightCount\n  * @return {array}\n  * @private\n  */\n\n\n  function _getXavierWeights(neuronCount, weightCount) {\n    var W = [];\n    var upperBound = Math.sqrt(2 / neuronCount);\n\n    for (var i = 0; i < weightCount; i++) {\n      W.push(Math.random() * upperBound);\n    }\n\n    weights = W;\n    return weights;\n  }\n  /**\n  *\n  * @param {object} mediaInfo\n  * @return {array}\n  * @private\n  */\n\n\n  function _getSomBitrateNeurons(mediaInfo) {\n    if (!somBitrateNeurons) {\n      somBitrateNeurons = [];\n      var bitrateList = mediaInfo.bitrateList;\n      var bitrateVector = [];\n      minBitrate = bitrateList[0].bandwidth;\n      bitrateList.forEach(function (element) {\n        bitrateVector.push(element.bandwidth);\n\n        if (element.bandwidth < minBitrate) {\n          minBitrate = element.bandwidth;\n        }\n      });\n      bitrateNormalizationFactor = _getMagnitude(bitrateVector);\n\n      for (var i = 0; i < bitrateList.length; i++) {\n        var neuron = {\n          qualityIndex: i,\n          bitrate: bitrateList[i].bandwidth,\n          state: {\n            // normalize throughputs\n            throughput: bitrateList[i].bandwidth / bitrateNormalizationFactor,\n            latency: 0,\n            rebuffer: 0,\n            switch: 0\n          }\n        };\n        somBitrateNeurons.push(neuron);\n\n        if (neuron.bitrate === minBitrate) {\n          minBitrateNeuron = neuron;\n        }\n      }\n\n      sortedCenters = _getInitialKmeansPlusPlusCenters(somBitrateNeurons);\n    }\n\n    return somBitrateNeurons;\n  }\n  /**\n  *\n  * @param {number} size\n  * @return {array}\n  * @private\n  */\n\n\n  function _getRandomData(size) {\n    var dataArray = [];\n\n    for (var i = 0; i < size; i++) {\n      var data = [Math.random() * _getMaxThroughput(), //throughput\n      Math.random(), //latency\n      Math.random(), //buffersize\n      Math.random() //switch\n      ];\n      dataArray.push(data);\n    }\n\n    return dataArray;\n  }\n  /**\n  *\n  * @param {array} somElements\n  * @return {array}\n  * @private\n  */\n\n\n  function _getInitialKmeansPlusPlusCenters(somElements) {\n    var centers = [];\n\n    var randomDataSet = _getRandomData(Math.pow(somElements.length, 2));\n\n    centers.push(randomDataSet[0]);\n    var distanceWeights = [1, 1, 1, 1];\n\n    for (var k = 1; k < somElements.length; k++) {\n      var nextPoint = null;\n      var _maxDistance = null;\n\n      for (var i = 0; i < randomDataSet.length; i++) {\n        var currentPoint = randomDataSet[i];\n        var minDistance = null;\n\n        for (var j = 0; j < centers.length; j++) {\n          var distance = _getDistance(currentPoint, centers[j], distanceWeights);\n\n          if (minDistance === null || distance < minDistance) {\n            minDistance = distance;\n          }\n        }\n\n        if (_maxDistance === null || minDistance > _maxDistance) {\n          nextPoint = currentPoint;\n          _maxDistance = minDistance;\n        }\n      }\n\n      centers.push(nextPoint);\n    } // find the least similar center\n\n\n    var maxDistance = null;\n    var leastSimilarIndex = null;\n\n    for (var _i = 0; _i < centers.length; _i++) {\n      var _distance = 0;\n\n      for (var _j = 0; _j < centers.length; _j++) {\n        if (_i === _j) continue;\n        _distance += _getDistance(centers[_i], centers[_j], distanceWeights);\n      }\n\n      if (maxDistance === null || _distance > maxDistance) {\n        maxDistance = _distance;\n        leastSimilarIndex = _i;\n      }\n    } // move centers to sortedCenters\n\n\n    var sortedCenters = [];\n    sortedCenters.push(centers[leastSimilarIndex]);\n    centers.splice(leastSimilarIndex, 1);\n\n    while (centers.length > 0) {\n      var _minDistance = null;\n      var minIndex = null;\n\n      for (var _i2 = 0; _i2 < centers.length; _i2++) {\n        var _distance2 = _getDistance(sortedCenters[0], centers[_i2], distanceWeights);\n\n        if (_minDistance === null || _distance2 < _minDistance) {\n          _minDistance = _distance2;\n          minIndex = _i2;\n        }\n      }\n\n      sortedCenters.push(centers[minIndex]);\n      centers.splice(minIndex, 1);\n    }\n\n    return sortedCenters;\n  }\n\n  instance = {\n    getNextQuality: getNextQuality,\n    reset: reset\n  };\n\n  _setup();\n\n  return instance;\n}\n\nLearningAbrController.__dashjs_factory_name = 'LearningAbrController';\nexports.default = _FactoryMaker2.default.getClassFactory(LearningAbrController);","map":{"version":3,"mappings":"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","names":["WEIGHT_SELECTION_MODES","MANUAL","RANDOM","DYNAMIC","LearningAbrController","context","instance","logger","somBitrateNeurons","bitrateNormalizationFactor","latencyNormalizationFactor","minBitrate","minBitrateNeuron","weights","sortedCenters","weightSelectionMode","_setup","getInstance","getLogger","_resetInitialSettings","reset","_getMaxThroughput","maxThroughput","i","length","neuron","state","throughput","_getMagnitude","w","magnitude","map","x","Math","pow","reduce","sum","now","sqrt","_getDistance","a","b","sign","abs","_getNeuronDistance","aState","latency","rebuffer","switch","bState","_updateNeurons","winnerNeuron","somElements","somNeuron","sigma","neuronDistance","neighbourHood","exp","_updateNeuronState","_getDownShiftNeuron","currentNeuron","currentThroughput","maxSuitableBitrate","result","n","bitrate","getNextQuality","mediaInfo","bufferSize","playbackRate","currentQualityIndex","dynamicWeightsSelector","currentLatency","currentBuffer","_getSomBitrateNeurons","throughputNormalized","targetLatency","targetRebufferLevel","targetSwitch","throughputDelta","debug","downloadTime","getSegmentDuration","max","getMinBuffer","qualityIndex","_manualWeightSelection","_randomWeightSelection","_dynamicWeightSelection","minDistance","minIndex","winnerWeights","somNeuronState","somData","distanceWeights","slice","nextBuffer","getNextBufferWithBitrate","isBufferLow","distance","bitrateSwitch","throughputWeight","latencyWeight","bufferWeight","switchWeight","_getXavierWeights","weightVector","findWeightVector","neuronCount","weightCount","W","upperBound","push","random","bitrateList","bitrateVector","bandwidth","forEach","element","_getInitialKmeansPlusPlusCenters","_getRandomData","size","dataArray","data","centers","randomDataSet","k","nextPoint","maxDistance","currentPoint","j","leastSimilarIndex","splice","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/rules/abr/lolp/LearningAbrController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Authors:\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n */\n\nimport FactoryMaker from '../../../../core/FactoryMaker';\nimport Debug from '../../../../core/Debug';\n\nconst WEIGHT_SELECTION_MODES = {\n    MANUAL: 'manual_weight_selection',\n    RANDOM: 'random_weight_selection',\n    DYNAMIC: 'dynamic_weight_selection'\n};\n\nfunction LearningAbrController() {\n    const context = this.context;\n\n    let instance,\n        logger,\n        somBitrateNeurons,\n        bitrateNormalizationFactor,\n        latencyNormalizationFactor,\n        minBitrate,\n        minBitrateNeuron,\n        weights,\n        sortedCenters,\n        weightSelectionMode;\n\n    /**\n     * Setup the class\n     */\n    function _setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n    }\n\n    /**\n     * Reset all values\n     */\n    function reset() {\n        _resetInitialSettings();\n    }\n\n    /**\n     * Reset to initial settings\n     * @private\n     */\n    function _resetInitialSettings() {\n        somBitrateNeurons = null;\n        bitrateNormalizationFactor = 1;\n        latencyNormalizationFactor = 100;\n        minBitrate = 0;\n        minBitrateNeuron = null;\n        weights = null;\n        sortedCenters = null;\n        weightSelectionMode = WEIGHT_SELECTION_MODES.DYNAMIC;\n    }\n\n    /**\n     * Returns the maximum throughput\n     * @return {number}\n     * @private\n     */\n    function _getMaxThroughput() {\n        let maxThroughput = 0;\n\n        if (somBitrateNeurons) {\n            for (let i = 0; i < somBitrateNeurons.length; i++) {\n                let neuron = somBitrateNeurons[i];\n                if (neuron.state.throughput > maxThroughput) {\n                    maxThroughput = neuron.state.throughput;\n                }\n            }\n        }\n\n        return maxThroughput;\n    }\n\n    /**\n     *\n     * @param {array} w\n     * @return {number}\n     * @private\n     */\n    function _getMagnitude(w) {\n        const magnitude = w.map((x) => (Math.pow(x, 2))).reduce((sum, now) => sum + now);\n\n        return Math.sqrt(magnitude);\n    }\n\n    /**\n     *\n     * @param {array} a\n     * @param {array} b\n     * @param {array} w\n     * @return {number}\n     * @private\n     */\n    function _getDistance(a, b, w) {\n        let sum = a\n            .map((x, i) => (w[i] * (Math.pow(x - b[i], 2)))) // square the difference*w\n            .reduce((sum, now) => sum + now); // sum\n        let sign = (sum < 0) ? -1 : 1;\n\n        return sign * Math.sqrt(Math.abs(sum));\n    }\n\n    /**\n     *\n     * @param {object} a\n     * @param {object} b\n     * @return {number}\n     * @private\n     */\n    function _getNeuronDistance(a, b) {\n        let aState = [a.state.throughput, a.state.latency, a.state.rebuffer, a.state.switch];\n        let bState = [b.state.throughput, b.state.latency, b.state.rebuffer, b.state.switch];\n\n        return _getDistance(aState, bState, [1, 1, 1, 1]);\n    }\n\n    /**\n     *\n     * @param {object} winnerNeuron\n     * @param {array} somElements\n     * @param {array} x\n     * @private\n     */\n    function _updateNeurons(winnerNeuron, somElements, x) {\n        for (let i = 0; i < somElements.length; i++) {\n            let somNeuron = somElements[i];\n            let sigma = 0.1;\n            const neuronDistance = _getNeuronDistance(somNeuron, winnerNeuron);\n            let neighbourHood = Math.exp(-1 * Math.pow(neuronDistance, 2) / (2 * Math.pow(sigma, 2)));\n            _updateNeuronState(somNeuron, x, neighbourHood);\n        }\n    }\n\n    /**\n     *\n     * @param {object} neuron\n     * @param {array} x\n     * @param {object} neighbourHood\n     * @private\n     */\n    function _updateNeuronState(neuron, x, neighbourHood) {\n        let state = neuron.state;\n        let w = [0.01, 0.01, 0.01, 0.01]; // learning rate\n\n        state.throughput = state.throughput + (x[0] - state.throughput) * w[0] * neighbourHood;\n        state.latency = state.latency + (x[1] - state.latency) * w[1] * neighbourHood;\n        state.rebuffer = state.rebuffer + (x[2] - state.rebuffer) * w[2] * neighbourHood;\n        state.switch = state.switch + (x[3] - state.switch) * w[3] * neighbourHood;\n    }\n\n    /**\n     *\n     * @param {object} currentNeuron\n     * @param {number} currentThroughput\n     * @return {object}\n     * @private\n     */\n    function _getDownShiftNeuron(currentNeuron, currentThroughput) {\n        let maxSuitableBitrate = 0;\n        let result = currentNeuron;\n\n        if (somBitrateNeurons) {\n            for (let i = 0; i < somBitrateNeurons.length; i++) {\n                let n = somBitrateNeurons[i];\n                if (n.bitrate < currentNeuron.bitrate && n.bitrate > maxSuitableBitrate && currentThroughput > n.bitrate) {\n                    // possible downshiftable neuron\n                    maxSuitableBitrate = n.bitrate;\n                    result = n;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {object} mediaInfo\n     * @param {number} throughput\n     * @param {number} latency\n     * @param {number} bufferSize\n     * @param {number} playbackRate\n     * @param {number} currentQualityIndex\n     * @param {object} dynamicWeightsSelector\n     * @return {null|*}\n     */\n    function getNextQuality(mediaInfo, throughput, latency, bufferSize, playbackRate, currentQualityIndex, dynamicWeightsSelector) {\n        // For Dynamic Weights Selector\n        let currentLatency = latency;\n        let currentBuffer = bufferSize;\n        let currentThroughput = throughput;\n\n        let somElements = _getSomBitrateNeurons(mediaInfo);\n        // normalize throughput\n        let throughputNormalized = throughput / bitrateNormalizationFactor;\n        // saturate values higher than 1\n        if (throughputNormalized > 1) {\n            throughputNormalized = _getMaxThroughput();\n        }\n        // normalize latency\n        latency = latency / latencyNormalizationFactor;\n\n        const targetLatency = 0;\n        const targetRebufferLevel = 0;\n        const targetSwitch = 0;\n        // 10K + video encoding is the recommended throughput\n        const throughputDelta = 10000;\n\n        logger.debug(`getNextQuality called throughput:${throughputNormalized} latency:${latency} bufferSize:${bufferSize} currentQualityIndex:${currentQualityIndex} playbackRate:${playbackRate}`);\n\n        let currentNeuron = somElements[currentQualityIndex];\n        let downloadTime = (currentNeuron.bitrate * dynamicWeightsSelector.getSegmentDuration()) / currentThroughput;\n        let rebuffer = Math.max(0, (downloadTime - currentBuffer));\n\n        // check buffer for possible stall\n        if (currentBuffer - downloadTime < dynamicWeightsSelector.getMinBuffer()) {\n            logger.debug(`Buffer is low for bitrate= ${currentNeuron.bitrate} downloadTime=${downloadTime} currentBuffer=${currentBuffer} rebuffer=${rebuffer}`);\n            return _getDownShiftNeuron(currentNeuron, currentThroughput).qualityIndex;\n        }\n\n        switch (weightSelectionMode) {\n            case WEIGHT_SELECTION_MODES.MANUAL:\n                _manualWeightSelection();\n                break;\n            case WEIGHT_SELECTION_MODES.RANDOM:\n                _randomWeightSelection(somElements);\n                break;\n            case WEIGHT_SELECTION_MODES.DYNAMIC:\n                _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n                break;\n            default:\n                _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n\n        }\n\n        let minDistance = null;\n        let minIndex = null;\n        let winnerNeuron = null;\n        let winnerWeights = null;\n\n        for (let i = 0; i < somElements.length; i++) {\n            let somNeuron = somElements[i];\n            let somNeuronState = somNeuron.state;\n            let somData = [somNeuronState.throughput,\n                somNeuronState.latency,\n                somNeuronState.rebuffer,\n                somNeuronState.switch];\n\n            let distanceWeights = weights.slice();\n            let nextBuffer = dynamicWeightsSelector.getNextBufferWithBitrate(somNeuron.bitrate, currentBuffer, currentThroughput);\n            let isBufferLow = nextBuffer < dynamicWeightsSelector.getMinBuffer();\n            if (isBufferLow) {\n                logger.debug(`Buffer is low for bitrate=${somNeuron.bitrate} downloadTime=${downloadTime} currentBuffer=${currentBuffer} nextBuffer=${nextBuffer}`);\n            }\n            // special condition downshift immediately\n            if (somNeuron.bitrate > throughput - throughputDelta || isBufferLow) {\n                if (somNeuron.bitrate !== minBitrate) {\n                    // encourage to pick smaller bitrates throughputWeight=100\n                    distanceWeights[0] = 100;\n                }\n            }\n\n            // calculate the distance with the target\n            let distance = _getDistance(somData, [throughputNormalized, targetLatency, targetRebufferLevel, targetSwitch], distanceWeights);\n            if (minDistance === null || distance < minDistance) {\n                minDistance = distance;\n                minIndex = somNeuron.qualityIndex;\n                winnerNeuron = somNeuron;\n                winnerWeights = distanceWeights;\n            }\n        }\n\n        // update current neuron and the neighbourhood with the calculated QoE\n        // will punish current if it is not picked\n        let bitrateSwitch = Math.abs(currentNeuron.bitrate - winnerNeuron.bitrate) / bitrateNormalizationFactor;\n        _updateNeurons(currentNeuron, somElements, [throughputNormalized, latency, rebuffer, bitrateSwitch]);\n\n        // update bmu and  neighbours with targetQoE=1, targetLatency=0\n        _updateNeurons(winnerNeuron, somElements, [throughputNormalized, targetLatency, targetRebufferLevel, bitrateSwitch]);\n\n        return minIndex;\n    }\n\n    /**\n     * Option 1: Manual weights\n     * @private\n     */\n    function _manualWeightSelection() {\n        let throughputWeight = 0.4;\n        let latencyWeight = 0.4;\n        let bufferWeight = 0.4;\n        let switchWeight = 0.4;\n\n        weights = [throughputWeight, latencyWeight, bufferWeight, switchWeight]; // throughput, latency, buffer, switch\n    }\n\n    /**\n     * Option 2: Random (Xavier) weights\n     * @param {array} somElements\n     * @private\n     */\n    function _randomWeightSelection(somElements) {\n        weights = _getXavierWeights(somElements.length, 4);\n    }\n\n    /**\n     * Dynamic Weight Selector weights\n     * @param {object} dynamicWeightsSelector\n     * @param {array} somElements\n     * @param {number} currentLatency\n     * @param {number} currentBuffer\n     * @param {number} rebuffer\n     * @param {number} currentThroughput\n     * @param {number} playbackRate\n     * @private\n     */\n    function _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate) {\n        if (!weights) {\n            weights = sortedCenters[sortedCenters.length - 1];\n        }\n        // Dynamic Weights Selector (step 2/2: find weights)\n        let weightVector = dynamicWeightsSelector.findWeightVector(somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n        if (weightVector !== null && weightVector !== -1) {   // null: something went wrong, -1: constraints not met\n            weights = weightVector;\n        }\n    }\n\n    /**\n     *\n     * @param {number }neuronCount\n     * @param {number }weightCount\n     * @return {array}\n     * @private\n     */\n    function _getXavierWeights(neuronCount, weightCount) {\n        let W = [];\n        let upperBound = Math.sqrt((2 / neuronCount));\n\n        for (let i = 0; i < weightCount; i++) {\n            W.push(Math.random() * upperBound);\n        }\n\n        weights = W;\n\n        return weights;\n    }\n\n    /**\n     *\n     * @param {object} mediaInfo\n     * @return {array}\n     * @private\n     */\n    function _getSomBitrateNeurons(mediaInfo) {\n        if (!somBitrateNeurons) {\n            somBitrateNeurons = [];\n            const bitrateList = mediaInfo.bitrateList;\n            let bitrateVector = [];\n            minBitrate = bitrateList[0].bandwidth;\n\n            bitrateList.forEach(element => {\n                bitrateVector.push(element.bandwidth);\n                if (element.bandwidth < minBitrate) {\n                    minBitrate = element.bandwidth;\n                }\n            });\n            bitrateNormalizationFactor = _getMagnitude(bitrateVector);\n\n            for (let i = 0; i < bitrateList.length; i++) {\n                let neuron = {\n                    qualityIndex: i,\n                    bitrate: bitrateList[i].bandwidth,\n                    state: {\n                        // normalize throughputs\n                        throughput: bitrateList[i].bandwidth / bitrateNormalizationFactor,\n                        latency: 0,\n                        rebuffer: 0,\n                        switch: 0\n                    }\n                };\n                somBitrateNeurons.push(neuron);\n                if (neuron.bitrate === minBitrate) {\n                    minBitrateNeuron = neuron;\n                }\n            }\n\n            sortedCenters = _getInitialKmeansPlusPlusCenters(somBitrateNeurons);\n        }\n\n        return somBitrateNeurons;\n    }\n\n    /**\n     *\n     * @param {number} size\n     * @return {array}\n     * @private\n     */\n    function _getRandomData(size) {\n        let dataArray = [];\n\n        for (let i = 0; i < size; i++) {\n            let data = [\n                Math.random() * _getMaxThroughput(), //throughput\n                Math.random(), //latency\n                Math.random(), //buffersize\n                Math.random() //switch\n            ];\n            dataArray.push(data);\n        }\n\n        return dataArray;\n    }\n\n    /**\n     *\n     * @param {array} somElements\n     * @return {array}\n     * @private\n     */\n    function _getInitialKmeansPlusPlusCenters(somElements) {\n        let centers = [];\n        let randomDataSet = _getRandomData(Math.pow(somElements.length, 2));\n        centers.push(randomDataSet[0]);\n        let distanceWeights = [1, 1, 1, 1];\n\n        for (let k = 1; k < somElements.length; k++) {\n            let nextPoint = null;\n            let maxDistance = null;\n            for (let i = 0; i < randomDataSet.length; i++) {\n                let currentPoint = randomDataSet[i];\n                let minDistance = null;\n                for (let j = 0; j < centers.length; j++) {\n                    let distance = _getDistance(currentPoint, centers[j], distanceWeights);\n                    if (minDistance === null || distance < minDistance) {\n                        minDistance = distance;\n                    }\n                }\n                if (maxDistance === null || minDistance > maxDistance) {\n                    nextPoint = currentPoint;\n                    maxDistance = minDistance;\n                }\n            }\n            centers.push(nextPoint);\n        }\n\n        // find the least similar center\n        let maxDistance = null;\n        let leastSimilarIndex = null;\n        for (let i = 0; i < centers.length; i++) {\n            let distance = 0;\n            for (let j = 0; j < centers.length; j++) {\n                if (i === j) continue;\n                distance += _getDistance(centers[i], centers[j], distanceWeights);\n            }\n            if (maxDistance === null || distance > maxDistance) {\n                maxDistance = distance;\n                leastSimilarIndex = i;\n            }\n        }\n\n        // move centers to sortedCenters\n        let sortedCenters = [];\n        sortedCenters.push(centers[leastSimilarIndex]);\n        centers.splice(leastSimilarIndex, 1);\n        while (centers.length > 0) {\n            let minDistance = null;\n            let minIndex = null;\n            for (let i = 0; i < centers.length; i++) {\n                let distance = _getDistance(sortedCenters[0], centers[i], distanceWeights);\n                if (minDistance === null || distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = i;\n                }\n            }\n            sortedCenters.push(centers[minIndex]);\n            centers.splice(minIndex, 1);\n        }\n\n        return sortedCenters;\n    }\n\n    instance = {\n        getNextQuality,\n        reset\n    };\n\n    _setup();\n    return instance;\n}\n\nLearningAbrController.__dashjs_factory_name = 'LearningAbrController';\nexport default FactoryMaker.getClassFactory(LearningAbrController);\n"]},"metadata":{},"sourceType":"script"}