{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Constants = require('../../streaming/constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _SegmentsUtils = require('./SegmentsUtils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction TimelineSegmentsGetter(config, isDynamic) {\n  config = config || {};\n  var timelineConverter = config.timelineConverter;\n  var instance = void 0;\n\n  function checkConfig() {\n    if (!timelineConverter || !timelineConverter.hasOwnProperty('calcMediaTimeFromPresentationTime') || !timelineConverter.hasOwnProperty('calcSegmentAvailabilityRange')) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n\n  function iterateSegments(representation, iterFunc) {\n    var base = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate || representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList;\n    var timeline = base.SegmentTimeline;\n    var list = base.SegmentURL_asArray;\n    var time = 0;\n    var scaledTime = 0;\n    var availabilityIdx = -1;\n    var fragments = void 0,\n        frag = void 0,\n        i = void 0,\n        len = void 0,\n        j = void 0,\n        repeat = void 0,\n        repeatEndTime = void 0,\n        nextFrag = void 0,\n        fTimescale = void 0;\n    fTimescale = representation.timescale;\n    fragments = timeline.S_asArray;\n    var breakIterator = false;\n\n    for (i = 0, len = fragments.length; i < len && !breakIterator; i++) {\n      frag = fragments[i];\n      repeat = 0;\n\n      if (frag.hasOwnProperty('r')) {\n        repeat = frag.r;\n      } // For a repeated S element, t belongs only to the first segment\n\n\n      if (frag.hasOwnProperty('t')) {\n        time = frag.t;\n        scaledTime = time / fTimescale;\n      } // This is a special case: \"A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the\n      // next MPD update.\"\n\n\n      if (repeat < 0) {\n        nextFrag = fragments[i + 1];\n\n        if (nextFrag && nextFrag.hasOwnProperty('t')) {\n          repeatEndTime = nextFrag.t / fTimescale;\n        } else {\n          var availabilityEnd = representation.segmentAvailabilityRange ? representation.segmentAvailabilityRange.end : timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic).end;\n          repeatEndTime = timelineConverter.calcMediaTimeFromPresentationTime(availabilityEnd, representation);\n          representation.segmentDuration = frag.d / fTimescale;\n        }\n\n        repeat = Math.ceil((repeatEndTime - scaledTime) / (frag.d / fTimescale)) - 1;\n      }\n\n      for (j = 0; j <= repeat && !breakIterator; j++) {\n        availabilityIdx++;\n        breakIterator = iterFunc(time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i);\n\n        if (breakIterator) {\n          representation.segmentDuration = frag.d / fTimescale; // check if there is at least one more segment\n\n          if (j < repeat - 1 || i < len - 1) {\n            availabilityIdx++;\n          }\n        }\n\n        time += frag.d;\n        scaledTime = time / fTimescale;\n      }\n    }\n\n    representation.availableSegmentsNumber = availabilityIdx;\n  }\n\n  function getSegmentByIndex(representation, index, lastSegmentTime) {\n    checkConfig();\n\n    if (!representation) {\n      return null;\n    }\n\n    var segment = null;\n    var found = false;\n    iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\n      if (found || lastSegmentTime < 0) {\n        var media = base.media;\n        var mediaRange = frag.mediaRange;\n\n        if (list) {\n          media = list[i].media || '';\n          mediaRange = list[i].mediaRange;\n        }\n\n        segment = (0, _SegmentsUtils.getTimeBasedSegment)(timelineConverter, isDynamic, representation, time, frag.d, fTimescale, media, mediaRange, availabilityIdx, frag.tManifest);\n        return true;\n      } else if (scaledTime >= lastSegmentTime - frag.d * 0.5 / fTimescale) {\n        // same logic, if deviation is\n        // 50% of segment duration, segment is found if scaledTime is greater than or equal to (startTime of previous segment - half of the previous segment duration)\n        found = true;\n      }\n\n      return false;\n    });\n    return segment;\n  }\n\n  function getSegmentByTime(representation, requestedTime) {\n    checkConfig();\n\n    if (!representation) {\n      return null;\n    }\n\n    if (requestedTime === undefined) {\n      requestedTime = null;\n    }\n\n    var segment = null;\n    var requiredMediaTime = timelineConverter.calcMediaTimeFromPresentationTime(requestedTime, representation);\n    iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\n      // In some cases when requiredMediaTime = actual end time of the last segment\n      // it is possible that this time a bit exceeds the declared end time of the last segment.\n      // in this case we still need to include the last segment in the segment list.\n      if (requiredMediaTime < scaledTime + frag.d / fTimescale) {\n        var media = base.media;\n        var mediaRange = frag.mediaRange;\n\n        if (list) {\n          media = list[i].media || '';\n          mediaRange = list[i].mediaRange;\n        }\n\n        segment = (0, _SegmentsUtils.getTimeBasedSegment)(timelineConverter, isDynamic, representation, time, frag.d, fTimescale, media, mediaRange, availabilityIdx, frag.tManifest);\n        return true;\n      }\n\n      return false;\n    });\n    return segment;\n  }\n\n  instance = {\n    getSegmentByIndex: getSegmentByIndex,\n    getSegmentByTime: getSegmentByTime\n  };\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nTimelineSegmentsGetter.__dashjs_factory_name = 'TimelineSegmentsGetter';\n\nvar factory = _FactoryMaker2.default.getClassFactory(TimelineSegmentsGetter);\n\nexports.default = factory;","map":{"version":3,"mappings":"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","names":["TimelineSegmentsGetter","config","isDynamic","timelineConverter","instance","checkConfig","hasOwnProperty","Error","Constants","MISSING_CONFIG_ERROR","iterateSegments","representation","iterFunc","base","adaptation","period","mpd","manifest","Period_asArray","index","AdaptationSet_asArray","Representation_asArray","SegmentTemplate","SegmentList","timeline","SegmentTimeline","list","SegmentURL_asArray","time","scaledTime","availabilityIdx","fragments","frag","i","len","j","repeat","repeatEndTime","nextFrag","fTimescale","timescale","S_asArray","breakIterator","length","r","t","availabilityEnd","segmentAvailabilityRange","end","calcSegmentAvailabilityRange","calcMediaTimeFromPresentationTime","segmentDuration","d","Math","ceil","availableSegmentsNumber","getSegmentByIndex","lastSegmentTime","segment","found","media","mediaRange","tManifest","getSegmentByTime","requestedTime","undefined","requiredMediaTime","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/dash/utils/TimelineSegmentsGetter.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Constants from '../../streaming/constants/Constants';\n\nimport { getTimeBasedSegment } from './SegmentsUtils';\n\nfunction TimelineSegmentsGetter(config, isDynamic) {\n\n    config = config || {};\n    const timelineConverter = config.timelineConverter;\n\n    let instance;\n\n    function checkConfig() {\n        if (!timelineConverter || !timelineConverter.hasOwnProperty('calcMediaTimeFromPresentationTime') ||\n            !timelineConverter.hasOwnProperty('calcSegmentAvailabilityRange')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function iterateSegments(representation, iterFunc) {\n        const base = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate ||\n            representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n                AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList;\n        const timeline = base.SegmentTimeline;\n        const list = base.SegmentURL_asArray;\n\n        let time = 0;\n        let scaledTime = 0;\n        let availabilityIdx = -1;\n\n        let fragments,\n            frag,\n            i,\n            len,\n            j,\n            repeat,\n            repeatEndTime,\n            nextFrag,\n            fTimescale;\n\n        fTimescale = representation.timescale;\n        fragments = timeline.S_asArray;\n\n        let breakIterator = false;\n\n        for (i = 0, len = fragments.length; i < len && !breakIterator; i++) {\n            frag = fragments[i];\n            repeat = 0;\n            if (frag.hasOwnProperty('r')) {\n                repeat = frag.r;\n            }\n\n            // For a repeated S element, t belongs only to the first segment\n            if (frag.hasOwnProperty('t')) {\n                time = frag.t;\n                scaledTime = time / fTimescale;\n            }\n\n            // This is a special case: \"A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the\n            // next MPD update.\"\n            if (repeat < 0) {\n                nextFrag = fragments[i + 1];\n\n                if (nextFrag && nextFrag.hasOwnProperty('t')) {\n                    repeatEndTime = nextFrag.t / fTimescale;\n                } else {\n                    const availabilityEnd = representation.segmentAvailabilityRange ? representation.segmentAvailabilityRange.end : (timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic).end);\n                    repeatEndTime = timelineConverter.calcMediaTimeFromPresentationTime(availabilityEnd, representation);\n                    representation.segmentDuration = frag.d / fTimescale;\n                }\n\n                repeat = Math.ceil((repeatEndTime - scaledTime) / (frag.d / fTimescale)) - 1;\n            }\n\n            for (j = 0; j <= repeat && !breakIterator; j++) {\n                availabilityIdx++;\n\n                breakIterator = iterFunc(time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i);\n\n                if (breakIterator) {\n                    representation.segmentDuration = frag.d / fTimescale;\n\n                    // check if there is at least one more segment\n                    if (j < repeat - 1 || i < len - 1) {\n                        availabilityIdx++;\n                    }\n                }\n\n                time += frag.d;\n                scaledTime = time / fTimescale;\n            }\n        }\n\n        representation.availableSegmentsNumber = availabilityIdx;\n    }\n\n    function getSegmentByIndex(representation, index, lastSegmentTime) {\n        checkConfig();\n\n        if (!representation) {\n            return null;\n        }\n\n        let segment = null;\n        let found = false;\n\n        iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\n            if (found || lastSegmentTime < 0) {\n                let media = base.media;\n                let mediaRange = frag.mediaRange;\n\n                if (list) {\n                    media = list[i].media || '';\n                    mediaRange = list[i].mediaRange;\n                }\n\n                segment = getTimeBasedSegment(\n                    timelineConverter,\n                    isDynamic,\n                    representation,\n                    time,\n                    frag.d,\n                    fTimescale,\n                    media,\n                    mediaRange,\n                    availabilityIdx,\n                    frag.tManifest);\n\n                return true;\n            } else if (scaledTime >= lastSegmentTime - frag.d * 0.5 / fTimescale) { // same logic, if deviation is\n                // 50% of segment duration, segment is found if scaledTime is greater than or equal to (startTime of previous segment - half of the previous segment duration)\n                found = true;\n            }\n\n            return false;\n        });\n\n        return segment;\n    }\n\n    function getSegmentByTime(representation, requestedTime) {\n        checkConfig();\n\n        if (!representation) {\n            return null;\n        }\n\n        if (requestedTime === undefined) {\n            requestedTime = null;\n        }\n\n        let segment = null;\n        const requiredMediaTime = timelineConverter.calcMediaTimeFromPresentationTime(requestedTime, representation);\n\n        iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\n            // In some cases when requiredMediaTime = actual end time of the last segment\n            // it is possible that this time a bit exceeds the declared end time of the last segment.\n            // in this case we still need to include the last segment in the segment list.\n            if (requiredMediaTime < (scaledTime + (frag.d / fTimescale))) {\n                let media = base.media;\n                let mediaRange = frag.mediaRange;\n\n                if (list) {\n                    media = list[i].media || '';\n                    mediaRange = list[i].mediaRange;\n                }\n\n                segment = getTimeBasedSegment(\n                    timelineConverter,\n                    isDynamic,\n                    representation,\n                    time,\n                    frag.d,\n                    fTimescale,\n                    media,\n                    mediaRange,\n                    availabilityIdx,\n                    frag.tManifest);\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return segment;\n    }\n\n\n    instance = {\n        getSegmentByIndex: getSegmentByIndex,\n        getSegmentByTime: getSegmentByTime\n    };\n\n    return instance;\n}\n\nTimelineSegmentsGetter.__dashjs_factory_name = 'TimelineSegmentsGetter';\nconst factory = FactoryMaker.getClassFactory(TimelineSegmentsGetter);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}