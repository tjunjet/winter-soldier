{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _MetricsConstants = require('../../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _SwitchRequest = require('../SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _FactoryMaker = require('../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _HTTPRequest = require('../../vo/metrics/HTTPRequest');\n\nvar _EventBus = require('../../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Debug = require('../../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\n// TODO: add BOLA_STATE_SEEK and tune BOLA behavior on seeking\n\n\nvar BOLA_STATE_ONE_BITRATE = 0;\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2016, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\n\nvar BOLA_STATE_STARTUP = 1;\nvar BOLA_STATE_STEADY = 2;\nvar MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\n\nvar MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2; // E.g. if there are 5 bitrates, BOLA switches to top bitrate at buffer = 10 + 5 * 2 = 20s.\n// If Schedule Controller does not allow buffer to reach that level, it can be achieved through the placeholder buffer level.\n\nvar PLACEHOLDER_BUFFER_DECAY = 0.99; // Make sure placeholder buffer does not stick around too long.\n\nfunction BolaRule(config) {\n  config = config || {};\n  var context = this.context;\n  var dashMetrics = config.dashMetrics;\n  var mediaPlayerModel = config.mediaPlayerModel;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      bolaStateDict = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    resetInitialSettings();\n    eventBus.on(_Events2.default.BUFFER_EMPTY, onBufferEmpty, instance);\n    eventBus.on(_Events2.default.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    eventBus.on(_Events2.default.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n    eventBus.on(_Events2.default.METRIC_ADDED, onMetricAdded, instance);\n    eventBus.on(_Events2.default.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n    eventBus.on(_Events2.default.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n  }\n\n  function utilitiesFromBitrates(bitrates) {\n    return bitrates.map(function (b) {\n      return Math.log(b);\n    }); // no need to worry about offset, utilities will be offset (uniformly) anyway later\n  } // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\n\n\n  function calculateBolaParameters(stableBufferTime, bitrates, utilities) {\n    var highestUtilityIndex = utilities.reduce(function (highestIndex, u, uIndex) {\n      return u > utilities[highestIndex] ? uIndex : highestIndex;\n    }, 0);\n\n    if (highestUtilityIndex === 0) {\n      // if highestUtilityIndex === 0, then always use lowest bitrate\n      return null;\n    }\n\n    var bufferTime = Math.max(stableBufferTime, MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * bitrates.length); // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\n    // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.\n    // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\n    // Vp * (utilities[0] + gp - 1) === minimumBufferS and Vp * (utilities[max] + gp - 1) === bufferTarget\n    // giving:\n\n    var gp = (utilities[highestUtilityIndex] - 1) / (bufferTime / MINIMUM_BUFFER_S - 1);\n    var Vp = MINIMUM_BUFFER_S / gp; // note that expressions for gp and Vp assume utilities[0] === 1, which is true because of normalization\n\n    return {\n      gp: gp,\n      Vp: Vp\n    };\n  }\n\n  function getInitialBolaState(rulesContext) {\n    var initialState = {};\n    var mediaInfo = rulesContext.getMediaInfo();\n    var bitrates = mediaInfo.bitrateList.map(function (b) {\n      return b.bandwidth;\n    });\n    var utilities = utilitiesFromBitrates(bitrates);\n    utilities = utilities.map(function (u) {\n      return u - utilities[0] + 1;\n    }); // normalize\n\n    var stableBufferTime = mediaPlayerModel.getStableBufferTime();\n    var params = calculateBolaParameters(stableBufferTime, bitrates, utilities);\n\n    if (!params) {\n      // only happens when there is only one bitrate level\n      initialState.state = BOLA_STATE_ONE_BITRATE;\n    } else {\n      initialState.state = BOLA_STATE_STARTUP;\n      initialState.bitrates = bitrates;\n      initialState.utilities = utilities;\n      initialState.stableBufferTime = stableBufferTime;\n      initialState.Vp = params.Vp;\n      initialState.gp = params.gp;\n      initialState.lastQuality = 0;\n      clearBolaStateOnSeek(initialState);\n    }\n\n    return initialState;\n  }\n\n  function clearBolaStateOnSeek(bolaState) {\n    bolaState.placeholderBuffer = 0;\n    bolaState.mostAdvancedSegmentStart = NaN;\n    bolaState.lastSegmentWasReplacement = false;\n    bolaState.lastSegmentStart = NaN;\n    bolaState.lastSegmentDurationS = NaN;\n    bolaState.lastSegmentRequestTimeMs = NaN;\n    bolaState.lastSegmentFinishTimeMs = NaN;\n  } // If the buffer target is changed (can this happen mid-stream?), then adjust BOLA parameters accordingly.\n\n\n  function checkBolaStateStableBufferTime(bolaState, mediaType) {\n    var stableBufferTime = mediaPlayerModel.getStableBufferTime();\n\n    if (bolaState.stableBufferTime !== stableBufferTime) {\n      var params = calculateBolaParameters(stableBufferTime, bolaState.bitrates, bolaState.utilities);\n\n      if (params.Vp !== bolaState.Vp || params.gp !== bolaState.gp) {\n        // correct placeholder buffer using two criteria:\n        // 1. do not change effective buffer level at effectiveBufferLevel === MINIMUM_BUFFER_S ( === Vp * gp )\n        // 2. scale placeholder buffer by Vp subject to offset indicated in 1.\n        var bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n        var effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\n        effectiveBufferLevel -= MINIMUM_BUFFER_S;\n        effectiveBufferLevel *= params.Vp / bolaState.Vp;\n        effectiveBufferLevel += MINIMUM_BUFFER_S;\n        bolaState.stableBufferTime = stableBufferTime;\n        bolaState.Vp = params.Vp;\n        bolaState.gp = params.gp;\n        bolaState.placeholderBuffer = Math.max(0, effectiveBufferLevel - bufferLevel);\n      }\n    }\n  }\n\n  function getBolaState(rulesContext) {\n    var mediaType = rulesContext.getMediaType();\n    var bolaState = bolaStateDict[mediaType];\n\n    if (!bolaState) {\n      bolaState = getInitialBolaState(rulesContext);\n      bolaStateDict[mediaType] = bolaState;\n    } else if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n      checkBolaStateStableBufferTime(bolaState, mediaType);\n    }\n\n    return bolaState;\n  } // The core idea of BOLA.\n\n\n  function getQualityFromBufferLevel(bolaState, bufferLevel) {\n    var bitrateCount = bolaState.bitrates.length;\n    var quality = NaN;\n    var score = NaN;\n\n    for (var i = 0; i < bitrateCount; ++i) {\n      var s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\n\n      if (isNaN(score) || s >= score) {\n        score = s;\n        quality = i;\n      }\n    }\n\n    return quality;\n  } // maximum buffer level which prefers to download at quality rather than wait\n\n\n  function maxBufferLevelForQuality(bolaState, quality) {\n    return bolaState.Vp * (bolaState.utilities[quality] + bolaState.gp);\n  } // the minimum buffer level that would cause BOLA to choose quality rather than a lower bitrate\n\n\n  function minBufferLevelForQuality(bolaState, quality) {\n    var qBitrate = bolaState.bitrates[quality];\n    var qUtility = bolaState.utilities[quality];\n    var min = 0;\n\n    for (var i = quality - 1; i >= 0; --i) {\n      // for each bitrate less than bitrates[quality], BOLA should prefer quality (unless other bitrate has higher utility)\n      if (bolaState.utilities[i] < bolaState.utilities[quality]) {\n        var iBitrate = bolaState.bitrates[i];\n        var iUtility = bolaState.utilities[i];\n        var level = bolaState.Vp * (bolaState.gp + (qBitrate * iUtility - iBitrate * qUtility) / (qBitrate - iBitrate));\n        min = Math.max(min, level); // we want min to be small but at least level(i) for all i\n      }\n    }\n\n    return min;\n  }\n  /*\n  * The placeholder buffer increases the effective buffer that is used to calculate the bitrate.\n  * There are two main reasons we might want to increase the placeholder buffer:\n  *\n  * 1. When a segment finishes downloading, we would expect to get a call on getMaxIndex() regarding the quality for\n  *    the next segment. However, there might be a delay before the next call. E.g. when streaming live content, the\n  *    next segment might not be available yet. If the call to getMaxIndex() does happens after a delay, we don't\n  *    want the delay to change the BOLA decision - we only want to factor download time to decide on bitrate level.\n  *\n  * 2. It is possible to get a call to getMaxIndex() without having a segment download. The buffer target in dash.js\n  *    is different for top-quality segments and lower-quality segments. If getMaxIndex() returns a lower-than-top\n  *    quality, then the buffer controller might decide not to download a segment. When dash.js is ready for the next\n  *    segment, getMaxIndex() will be called again. We don't want this extra delay to factor in the bitrate decision.\n  */\n\n\n  function updatePlaceholderBuffer(bolaState, mediaType) {\n    var nowMs = Date.now();\n\n    if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n      // compensate for non-bandwidth-derived delays, e.g., live streaming availability, buffer controller\n      var delay = 0.001 * (nowMs - bolaState.lastSegmentFinishTimeMs);\n      bolaState.placeholderBuffer += Math.max(0, delay);\n    } else if (!isNaN(bolaState.lastCallTimeMs)) {\n      // no download after last call, compensate for delay between calls\n      var _delay = 0.001 * (nowMs - bolaState.lastCallTimeMs);\n\n      bolaState.placeholderBuffer += Math.max(0, _delay);\n    }\n\n    bolaState.lastCallTimeMs = nowMs;\n    bolaState.lastSegmentStart = NaN;\n    bolaState.lastSegmentRequestTimeMs = NaN;\n    bolaState.lastSegmentFinishTimeMs = NaN;\n    checkBolaStateStableBufferTime(bolaState, mediaType);\n  }\n\n  function onBufferEmpty() {\n    // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\n    for (var mediaType in bolaStateDict) {\n      if (bolaStateDict.hasOwnProperty(mediaType) && bolaStateDict[mediaType].state === BOLA_STATE_STEADY) {\n        bolaStateDict[mediaType].placeholderBuffer = 0;\n      }\n    }\n  }\n\n  function onPlaybackSeeking() {\n    // TODO: 1. Verify what happens if we seek mid-fragment.\n    // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\n    for (var mediaType in bolaStateDict) {\n      if (bolaStateDict.hasOwnProperty(mediaType)) {\n        var bolaState = bolaStateDict[mediaType];\n\n        if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n          bolaState.state = BOLA_STATE_STARTUP; // TODO: BOLA_STATE_SEEK?\n\n          clearBolaStateOnSeek(bolaState);\n        }\n      }\n    }\n  }\n\n  function onMediaFragmentLoaded(e) {\n    if (e && e.chunk && e.chunk.mediaInfo) {\n      var bolaState = bolaStateDict[e.chunk.mediaInfo.type];\n\n      if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n        var start = e.chunk.start;\n\n        if (isNaN(bolaState.mostAdvancedSegmentStart) || start > bolaState.mostAdvancedSegmentStart) {\n          bolaState.mostAdvancedSegmentStart = start;\n          bolaState.lastSegmentWasReplacement = false;\n        } else {\n          bolaState.lastSegmentWasReplacement = true;\n        }\n\n        bolaState.lastSegmentStart = start;\n        bolaState.lastSegmentDurationS = e.chunk.duration;\n        bolaState.lastQuality = e.chunk.quality;\n        checkNewSegment(bolaState, e.chunk.mediaInfo.type);\n      }\n    }\n  }\n\n  function onMetricAdded(e) {\n    if (e && e.metric === _MetricsConstants2.default.HTTP_REQUEST && e.value && e.value.type === _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n      var bolaState = bolaStateDict[e.mediaType];\n\n      if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n        bolaState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n        bolaState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n        checkNewSegment(bolaState, e.mediaType);\n      }\n    }\n  }\n  /*\n  * When a new segment is downloaded, we get two notifications: onMediaFragmentLoaded() and onMetricAdded(). It is\n  * possible that the quality for the downloaded segment was lower (not higher) than the quality indicated by BOLA.\n  * This might happen because of other rules such as the DroppedFramesRule. When this happens, we trim the\n  * placeholder buffer to make BOLA more stable. This mechanism also avoids inflating the buffer when BOLA itself\n  * decides not to increase the quality to avoid oscillations.\n  *\n  * We should also check for replacement segments (fast switching). In this case, a segment is downloaded but does\n  * not grow the actual buffer. Fast switching might cause the buffer to deplete, causing BOLA to drop the bitrate.\n  * We avoid this by growing the placeholder buffer.\n  */\n\n\n  function checkNewSegment(bolaState, mediaType) {\n    if (!isNaN(bolaState.lastSegmentStart) && !isNaN(bolaState.lastSegmentRequestTimeMs) && !isNaN(bolaState.placeholderBuffer)) {\n      bolaState.placeholderBuffer *= PLACEHOLDER_BUFFER_DECAY; // Find what maximum buffer corresponding to last segment was, and ensure placeholder is not relatively larger.\n\n      if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n        var bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n        var bufferAtLastSegmentRequest = bufferLevel + 0.001 * (bolaState.lastSegmentFinishTimeMs - bolaState.lastSegmentRequestTimeMs); // estimate\n\n        var maxEffectiveBufferForLastSegment = maxBufferLevelForQuality(bolaState, bolaState.lastQuality);\n        var maxPlaceholderBuffer = Math.max(0, maxEffectiveBufferForLastSegment - bufferAtLastSegmentRequest);\n        bolaState.placeholderBuffer = Math.min(maxPlaceholderBuffer, bolaState.placeholderBuffer);\n      } // then see if we should grow placeholder buffer\n\n\n      if (bolaState.lastSegmentWasReplacement && !isNaN(bolaState.lastSegmentDurationS)) {\n        // compensate for segments that were downloaded but did not grow the buffer\n        bolaState.placeholderBuffer += bolaState.lastSegmentDurationS;\n      }\n\n      bolaState.lastSegmentStart = NaN;\n      bolaState.lastSegmentRequestTimeMs = NaN;\n    }\n  }\n\n  function onQualityChangeRequested(e) {\n    // Useful to store change requests when abandoning a download.\n    if (e) {\n      var bolaState = bolaStateDict[e.mediaType];\n\n      if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n        bolaState.abrQuality = e.newQuality;\n      }\n    }\n  }\n\n  function onFragmentLoadingAbandoned(e) {\n    if (e) {\n      var bolaState = bolaStateDict[e.mediaType];\n\n      if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n        // deflate placeholderBuffer - note that we want to be conservative when abandoning\n        var bufferLevel = dashMetrics.getCurrentBufferLevel(e.mediaType);\n        var wantEffectiveBufferLevel = void 0;\n\n        if (bolaState.abrQuality > 0) {\n          // deflate to point where BOLA just chooses newQuality over newQuality-1\n          wantEffectiveBufferLevel = minBufferLevelForQuality(bolaState, bolaState.abrQuality);\n        } else {\n          wantEffectiveBufferLevel = MINIMUM_BUFFER_S;\n        }\n\n        var maxPlaceholderBuffer = Math.max(0, wantEffectiveBufferLevel - bufferLevel);\n        bolaState.placeholderBuffer = Math.min(bolaState.placeholderBuffer, maxPlaceholderBuffer);\n      }\n    }\n  }\n\n  function getMaxIndex(rulesContext) {\n    var switchRequest = (0, _SwitchRequest2.default)(context).create();\n\n    if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') || !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') || !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useBufferOccupancyABR')) {\n      return switchRequest;\n    }\n\n    var mediaInfo = rulesContext.getMediaInfo();\n    var mediaType = rulesContext.getMediaType();\n    var scheduleController = rulesContext.getScheduleController();\n    var streamInfo = rulesContext.getStreamInfo();\n    var abrController = rulesContext.getAbrController();\n    var throughputHistory = abrController.getThroughputHistory();\n    var streamId = streamInfo ? streamInfo.id : null;\n    var isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n    var useBufferOccupancyABR = rulesContext.useBufferOccupancyABR();\n    switchRequest.reason = switchRequest.reason || {};\n\n    if (!useBufferOccupancyABR) {\n      return switchRequest;\n    }\n\n    scheduleController.setTimeToLoadDelay(0);\n    var bolaState = getBolaState(rulesContext);\n\n    if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\n      // shouldn't even have been called\n      return switchRequest;\n    }\n\n    var bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n    var throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\n    var safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n    var latency = throughputHistory.getAverageLatency(mediaType);\n    var quality = void 0;\n    switchRequest.reason.state = bolaState.state;\n    switchRequest.reason.throughput = throughput;\n    switchRequest.reason.latency = latency;\n\n    if (isNaN(throughput)) {\n      // isNaN(throughput) === isNaN(safeThroughput) === isNaN(latency)\n      // still starting up - not enough information\n      return switchRequest;\n    }\n\n    switch (bolaState.state) {\n      case BOLA_STATE_STARTUP:\n        quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n        switchRequest.quality = quality;\n        switchRequest.reason.throughput = safeThroughput;\n        bolaState.placeholderBuffer = Math.max(0, minBufferLevelForQuality(bolaState, quality) - bufferLevel);\n        bolaState.lastQuality = quality;\n\n        if (!isNaN(bolaState.lastSegmentDurationS) && bufferLevel >= bolaState.lastSegmentDurationS) {\n          bolaState.state = BOLA_STATE_STEADY;\n        }\n\n        break;\n      // BOLA_STATE_STARTUP\n\n      case BOLA_STATE_STEADY:\n        // NB: The placeholder buffer is added to bufferLevel to come up with a bitrate.\n        //     This might lead BOLA to be too optimistic and to choose a bitrate that would lead to rebuffering -\n        //     if the real buffer bufferLevel runs out, the placeholder buffer cannot prevent rebuffering.\n        //     However, the InsufficientBufferRule takes care of this scenario.\n        updatePlaceholderBuffer(bolaState, mediaType);\n        quality = getQualityFromBufferLevel(bolaState, bufferLevel + bolaState.placeholderBuffer); // we want to avoid oscillations\n        // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\n\n        var qualityForThroughput = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n\n        if (quality > bolaState.lastQuality && quality > qualityForThroughput) {\n          // only intervene if we are trying to *increase* quality to an *unsustainable* level\n          // we are only avoid oscillations - do not drop below last quality\n          quality = Math.max(qualityForThroughput, bolaState.lastQuality);\n        } // We do not want to overfill buffer with low quality chunks.\n        // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\n\n\n        var delayS = Math.max(0, bufferLevel + bolaState.placeholderBuffer - maxBufferLevelForQuality(bolaState, quality)); // First reduce placeholder buffer, then tell schedule controller to pause.\n\n        if (delayS <= bolaState.placeholderBuffer) {\n          bolaState.placeholderBuffer -= delayS;\n          delayS = 0;\n        } else {\n          delayS -= bolaState.placeholderBuffer;\n          bolaState.placeholderBuffer = 0;\n\n          if (quality < abrController.getTopQualityIndexFor(mediaType, streamId)) {\n            // At top quality, allow schedule controller to decide how far to fill buffer.\n            scheduleController.setTimeToLoadDelay(1000 * delayS);\n          } else {\n            delayS = 0;\n          }\n        }\n\n        switchRequest.quality = quality;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n        switchRequest.reason.bufferLevel = bufferLevel;\n        switchRequest.reason.placeholderBuffer = bolaState.placeholderBuffer;\n        switchRequest.reason.delay = delayS;\n        bolaState.lastQuality = quality; // keep bolaState.state === BOLA_STATE_STEADY\n\n        break;\n      // BOLA_STATE_STEADY\n\n      default:\n        logger.debug('BOLA ABR rule invoked in bad state.'); // should not arrive here, try to recover\n\n        switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n        switchRequest.reason.state = bolaState.state;\n        switchRequest.reason.throughput = safeThroughput;\n        switchRequest.reason.latency = latency;\n        bolaState.state = BOLA_STATE_STARTUP;\n        clearBolaStateOnSeek(bolaState);\n    }\n\n    return switchRequest;\n  }\n\n  function resetInitialSettings() {\n    bolaStateDict = {};\n  }\n\n  function reset() {\n    resetInitialSettings();\n    eventBus.off(_Events2.default.BUFFER_EMPTY, onBufferEmpty, instance);\n    eventBus.off(_Events2.default.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    eventBus.off(_Events2.default.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n    eventBus.off(_Events2.default.METRIC_ADDED, onMetricAdded, instance);\n    eventBus.off(_Events2.default.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n    eventBus.off(_Events2.default.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n  }\n\n  instance = {\n    getMaxIndex: getMaxIndex,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nBolaRule.__dashjs_factory_name = 'BolaRule';\nexports.default = _FactoryMaker2.default.getClassFactory(BolaRule);","map":{"version":3,"mappings":"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","names":["BOLA_STATE_ONE_BITRATE","BOLA_STATE_STARTUP","BOLA_STATE_STEADY","MINIMUM_BUFFER_S","MINIMUM_BUFFER_PER_BITRATE_LEVEL_S","PLACEHOLDER_BUFFER_DECAY","BolaRule","config","context","dashMetrics","mediaPlayerModel","eventBus","getInstance","instance","logger","bolaStateDict","setup","getLogger","resetInitialSettings","on","Events","BUFFER_EMPTY","onBufferEmpty","PLAYBACK_SEEKING","onPlaybackSeeking","MEDIA_FRAGMENT_LOADED","onMediaFragmentLoaded","METRIC_ADDED","onMetricAdded","QUALITY_CHANGE_REQUESTED","onQualityChangeRequested","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","utilitiesFromBitrates","bitrates","map","Math","log","b","calculateBolaParameters","stableBufferTime","utilities","highestUtilityIndex","reduce","highestIndex","u","uIndex","bufferTime","max","length","gp","Vp","getInitialBolaState","rulesContext","initialState","mediaInfo","getMediaInfo","bitrateList","bandwidth","getStableBufferTime","params","state","lastQuality","clearBolaStateOnSeek","bolaState","placeholderBuffer","mostAdvancedSegmentStart","NaN","lastSegmentWasReplacement","lastSegmentStart","lastSegmentDurationS","lastSegmentRequestTimeMs","lastSegmentFinishTimeMs","checkBolaStateStableBufferTime","mediaType","bufferLevel","getCurrentBufferLevel","effectiveBufferLevel","getBolaState","getMediaType","getQualityFromBufferLevel","bitrateCount","quality","score","i","s","isNaN","maxBufferLevelForQuality","minBufferLevelForQuality","qBitrate","qUtility","min","iBitrate","iUtility","level","updatePlaceholderBuffer","nowMs","Date","now","delay","lastCallTimeMs","hasOwnProperty","e","chunk","type","start","duration","checkNewSegment","metric","MetricsConstants","HTTP_REQUEST","value","HTTPRequest","MEDIA_SEGMENT_TYPE","trace","trequest","getTime","_tfinish","bufferAtLastSegmentRequest","maxEffectiveBufferForLastSegment","maxPlaceholderBuffer","abrQuality","newQuality","wantEffectiveBufferLevel","getMaxIndex","switchRequest","create","scheduleController","getScheduleController","streamInfo","getStreamInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","streamId","id","isDynamic","manifestInfo","useBufferOccupancyABR","reason","setTimeToLoadDelay","throughput","getAverageThroughput","safeThroughput","getSafeAverageThroughput","latency","getAverageLatency","getQualityForBitrate","qualityForThroughput","delayS","getTopQualityIndexFor","debug","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/rules/abr/BolaRule.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2016, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\n\nimport MetricsConstants from '../../constants/MetricsConstants';\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport { HTTPRequest } from '../../vo/metrics/HTTPRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\n\n// BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\n// TODO: add BOLA_STATE_SEEK and tune BOLA behavior on seeking\nconst BOLA_STATE_ONE_BITRATE    = 0;\nconst BOLA_STATE_STARTUP        = 1;\nconst BOLA_STATE_STEADY         = 2;\n\nconst MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\nconst MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2;\n// E.g. if there are 5 bitrates, BOLA switches to top bitrate at buffer = 10 + 5 * 2 = 20s.\n// If Schedule Controller does not allow buffer to reach that level, it can be achieved through the placeholder buffer level.\n\nconst PLACEHOLDER_BUFFER_DECAY = 0.99; // Make sure placeholder buffer does not stick around too long.\n\nfunction BolaRule(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const dashMetrics = config.dashMetrics;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        bolaStateDict;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n\n        eventBus.on(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    function utilitiesFromBitrates(bitrates) {\n        return bitrates.map(b => Math.log(b));\n        // no need to worry about offset, utilities will be offset (uniformly) anyway later\n    }\n\n    // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\n    function calculateBolaParameters(stableBufferTime, bitrates, utilities) {\n        const highestUtilityIndex = utilities.reduce((highestIndex, u, uIndex) => (u > utilities[highestIndex] ? uIndex : highestIndex), 0);\n\n        if (highestUtilityIndex === 0) {\n            // if highestUtilityIndex === 0, then always use lowest bitrate\n            return null;\n        }\n\n        const bufferTime = Math.max(stableBufferTime, MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * bitrates.length);\n\n        // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\n        // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.\n        // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\n        // Vp * (utilities[0] + gp - 1) === minimumBufferS and Vp * (utilities[max] + gp - 1) === bufferTarget\n        // giving:\n        const gp = (utilities[highestUtilityIndex] - 1) / (bufferTime / MINIMUM_BUFFER_S - 1);\n        const Vp = MINIMUM_BUFFER_S / gp;\n        // note that expressions for gp and Vp assume utilities[0] === 1, which is true because of normalization\n\n        return {gp: gp, Vp: Vp};\n    }\n\n    function getInitialBolaState(rulesContext) {\n        const initialState = {};\n        const mediaInfo = rulesContext.getMediaInfo();\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        let utilities = utilitiesFromBitrates(bitrates);\n        utilities = utilities.map(u => u - utilities[0] + 1); // normalize\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        const params = calculateBolaParameters(stableBufferTime, bitrates, utilities);\n\n        if (!params) {\n            // only happens when there is only one bitrate level\n            initialState.state = BOLA_STATE_ONE_BITRATE;\n        } else {\n            initialState.state = BOLA_STATE_STARTUP;\n\n            initialState.bitrates = bitrates;\n            initialState.utilities = utilities;\n            initialState.stableBufferTime = stableBufferTime;\n            initialState.Vp = params.Vp;\n            initialState.gp = params.gp;\n\n            initialState.lastQuality = 0;\n            clearBolaStateOnSeek(initialState);\n        }\n\n        return initialState;\n    }\n\n    function clearBolaStateOnSeek(bolaState) {\n        bolaState.placeholderBuffer = 0;\n        bolaState.mostAdvancedSegmentStart = NaN;\n        bolaState.lastSegmentWasReplacement = false;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentDurationS = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n    }\n\n    // If the buffer target is changed (can this happen mid-stream?), then adjust BOLA parameters accordingly.\n    function checkBolaStateStableBufferTime(bolaState, mediaType) {\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        if (bolaState.stableBufferTime !== stableBufferTime) {\n            const params = calculateBolaParameters(stableBufferTime, bolaState.bitrates, bolaState.utilities);\n            if (params.Vp !== bolaState.Vp || params.gp !== bolaState.gp) {\n                // correct placeholder buffer using two criteria:\n                // 1. do not change effective buffer level at effectiveBufferLevel === MINIMUM_BUFFER_S ( === Vp * gp )\n                // 2. scale placeholder buffer by Vp subject to offset indicated in 1.\n\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n                let effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\n\n                effectiveBufferLevel -= MINIMUM_BUFFER_S;\n                effectiveBufferLevel *= params.Vp / bolaState.Vp;\n                effectiveBufferLevel += MINIMUM_BUFFER_S;\n\n                bolaState.stableBufferTime = stableBufferTime;\n                bolaState.Vp = params.Vp;\n                bolaState.gp = params.gp;\n                bolaState.placeholderBuffer = Math.max(0, effectiveBufferLevel - bufferLevel);\n            }\n        }\n    }\n\n    function getBolaState(rulesContext) {\n        const mediaType = rulesContext.getMediaType();\n        let bolaState = bolaStateDict[mediaType];\n        if (!bolaState) {\n            bolaState = getInitialBolaState(rulesContext);\n            bolaStateDict[mediaType] = bolaState;\n        } else if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n            checkBolaStateStableBufferTime(bolaState, mediaType);\n        }\n        return bolaState;\n    }\n\n    // The core idea of BOLA.\n    function getQualityFromBufferLevel(bolaState, bufferLevel) {\n        const bitrateCount = bolaState.bitrates.length;\n        let quality = NaN;\n        let score = NaN;\n        for (let i = 0; i < bitrateCount; ++i) {\n            let s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\n            if (isNaN(score) || s >= score) {\n                score = s;\n                quality = i;\n            }\n        }\n        return quality;\n    }\n\n    // maximum buffer level which prefers to download at quality rather than wait\n    function maxBufferLevelForQuality(bolaState, quality) {\n        return bolaState.Vp * (bolaState.utilities[quality] + bolaState.gp);\n    }\n\n    // the minimum buffer level that would cause BOLA to choose quality rather than a lower bitrate\n    function minBufferLevelForQuality(bolaState, quality) {\n        const qBitrate = bolaState.bitrates[quality];\n        const qUtility = bolaState.utilities[quality];\n\n        let min = 0;\n        for (let i = quality - 1; i >= 0; --i) {\n            // for each bitrate less than bitrates[quality], BOLA should prefer quality (unless other bitrate has higher utility)\n            if (bolaState.utilities[i] < bolaState.utilities[quality]) {\n                const iBitrate = bolaState.bitrates[i];\n                const iUtility = bolaState.utilities[i];\n\n                const level = bolaState.Vp * (bolaState.gp + (qBitrate * iUtility - iBitrate * qUtility) / (qBitrate - iBitrate));\n                min = Math.max(min, level); // we want min to be small but at least level(i) for all i\n            }\n        }\n        return min;\n    }\n\n    /*\n     * The placeholder buffer increases the effective buffer that is used to calculate the bitrate.\n     * There are two main reasons we might want to increase the placeholder buffer:\n     *\n     * 1. When a segment finishes downloading, we would expect to get a call on getMaxIndex() regarding the quality for\n     *    the next segment. However, there might be a delay before the next call. E.g. when streaming live content, the\n     *    next segment might not be available yet. If the call to getMaxIndex() does happens after a delay, we don't\n     *    want the delay to change the BOLA decision - we only want to factor download time to decide on bitrate level.\n     *\n     * 2. It is possible to get a call to getMaxIndex() without having a segment download. The buffer target in dash.js\n     *    is different for top-quality segments and lower-quality segments. If getMaxIndex() returns a lower-than-top\n     *    quality, then the buffer controller might decide not to download a segment. When dash.js is ready for the next\n     *    segment, getMaxIndex() will be called again. We don't want this extra delay to factor in the bitrate decision.\n     */\n    function updatePlaceholderBuffer(bolaState, mediaType) {\n        const nowMs = Date.now();\n\n        if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n            // compensate for non-bandwidth-derived delays, e.g., live streaming availability, buffer controller\n            const delay = 0.001 * (nowMs - bolaState.lastSegmentFinishTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        } else if (!isNaN(bolaState.lastCallTimeMs)) {\n            // no download after last call, compensate for delay between calls\n            const delay = 0.001 * (nowMs - bolaState.lastCallTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        }\n\n        bolaState.lastCallTimeMs = nowMs;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n\n        checkBolaStateStableBufferTime(bolaState, mediaType);\n    }\n\n    function onBufferEmpty() {\n        // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\n        for (const mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType) && bolaStateDict[mediaType].state === BOLA_STATE_STEADY) {\n                bolaStateDict[mediaType].placeholderBuffer = 0;\n            }\n        }\n    }\n\n    function onPlaybackSeeking() {\n        // TODO: 1. Verify what happens if we seek mid-fragment.\n        // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\n        for (const mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType)) {\n                const bolaState = bolaStateDict[mediaType];\n                if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                    bolaState.state = BOLA_STATE_STARTUP; // TODO: BOLA_STATE_SEEK?\n                    clearBolaStateOnSeek(bolaState);\n                }\n            }\n        }\n    }\n\n    function onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            const bolaState = bolaStateDict[e.chunk.mediaInfo.type];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                const start = e.chunk.start;\n                if (isNaN(bolaState.mostAdvancedSegmentStart) || start > bolaState.mostAdvancedSegmentStart) {\n                    bolaState.mostAdvancedSegmentStart = start;\n                    bolaState.lastSegmentWasReplacement = false;\n                } else {\n                    bolaState.lastSegmentWasReplacement = true;\n                }\n\n                bolaState.lastSegmentStart = start;\n                bolaState.lastSegmentDurationS = e.chunk.duration;\n                bolaState.lastQuality = e.chunk.quality;\n\n                checkNewSegment(bolaState, e.chunk.mediaInfo.type);\n            }\n        }\n    }\n\n    function onMetricAdded(e) {\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n                bolaState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n\n                checkNewSegment(bolaState, e.mediaType);\n            }\n        }\n    }\n\n    /*\n     * When a new segment is downloaded, we get two notifications: onMediaFragmentLoaded() and onMetricAdded(). It is\n     * possible that the quality for the downloaded segment was lower (not higher) than the quality indicated by BOLA.\n     * This might happen because of other rules such as the DroppedFramesRule. When this happens, we trim the\n     * placeholder buffer to make BOLA more stable. This mechanism also avoids inflating the buffer when BOLA itself\n     * decides not to increase the quality to avoid oscillations.\n     *\n     * We should also check for replacement segments (fast switching). In this case, a segment is downloaded but does\n     * not grow the actual buffer. Fast switching might cause the buffer to deplete, causing BOLA to drop the bitrate.\n     * We avoid this by growing the placeholder buffer.\n     */\n    function checkNewSegment(bolaState, mediaType) {\n        if (!isNaN(bolaState.lastSegmentStart) && !isNaN(bolaState.lastSegmentRequestTimeMs) && !isNaN(bolaState.placeholderBuffer)) {\n            bolaState.placeholderBuffer *= PLACEHOLDER_BUFFER_DECAY;\n\n            // Find what maximum buffer corresponding to last segment was, and ensure placeholder is not relatively larger.\n            if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n                const bufferAtLastSegmentRequest = bufferLevel + 0.001 * (bolaState.lastSegmentFinishTimeMs - bolaState.lastSegmentRequestTimeMs); // estimate\n                const maxEffectiveBufferForLastSegment = maxBufferLevelForQuality(bolaState, bolaState.lastQuality);\n                const maxPlaceholderBuffer = Math.max(0, maxEffectiveBufferForLastSegment - bufferAtLastSegmentRequest);\n                bolaState.placeholderBuffer = Math.min(maxPlaceholderBuffer, bolaState.placeholderBuffer);\n            }\n\n            // then see if we should grow placeholder buffer\n\n            if (bolaState.lastSegmentWasReplacement && !isNaN(bolaState.lastSegmentDurationS)) {\n                // compensate for segments that were downloaded but did not grow the buffer\n                bolaState.placeholderBuffer += bolaState.lastSegmentDurationS;\n            }\n\n            bolaState.lastSegmentStart = NaN;\n            bolaState.lastSegmentRequestTimeMs = NaN;\n        }\n    }\n\n    function onQualityChangeRequested(e) {\n        // Useful to store change requests when abandoning a download.\n        if (e) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.abrQuality = e.newQuality;\n            }\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        if (e) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                // deflate placeholderBuffer - note that we want to be conservative when abandoning\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(e.mediaType);\n                let wantEffectiveBufferLevel;\n                if (bolaState.abrQuality > 0) {\n                    // deflate to point where BOLA just chooses newQuality over newQuality-1\n                    wantEffectiveBufferLevel = minBufferLevelForQuality(bolaState, bolaState.abrQuality);\n                } else {\n                    wantEffectiveBufferLevel = MINIMUM_BUFFER_S;\n                }\n                const maxPlaceholderBuffer = Math.max(0, wantEffectiveBufferLevel - bufferLevel);\n                bolaState.placeholderBuffer = Math.min(bolaState.placeholderBuffer, maxPlaceholderBuffer);\n            }\n        }\n    }\n\n    function getMaxIndex(rulesContext) {\n        const switchRequest = SwitchRequest(context).create();\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') ||\n            !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') ||\n            !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useBufferOccupancyABR')) {\n            return switchRequest;\n        }\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const scheduleController = rulesContext.getScheduleController();\n        const streamInfo = rulesContext.getStreamInfo();\n        const abrController = rulesContext.getAbrController();\n        const throughputHistory = abrController.getThroughputHistory();\n        const streamId = streamInfo ? streamInfo.id : null;\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n        const useBufferOccupancyABR = rulesContext.useBufferOccupancyABR();\n        switchRequest.reason = switchRequest.reason || {};\n\n        if (!useBufferOccupancyABR) {\n            return switchRequest;\n        }\n\n        scheduleController.setTimeToLoadDelay(0);\n\n        const bolaState = getBolaState(rulesContext);\n\n        if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\n            // shouldn't even have been called\n            return switchRequest;\n        }\n\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n        const latency = throughputHistory.getAverageLatency(mediaType);\n        let quality;\n\n        switchRequest.reason.state = bolaState.state;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n\n        if (isNaN(throughput)) { // isNaN(throughput) === isNaN(safeThroughput) === isNaN(latency)\n            // still starting up - not enough information\n            return switchRequest;\n        }\n\n        switch (bolaState.state) {\n            case BOLA_STATE_STARTUP:\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = safeThroughput;\n\n                bolaState.placeholderBuffer = Math.max(0, minBufferLevelForQuality(bolaState, quality) - bufferLevel);\n                bolaState.lastQuality = quality;\n\n                if (!isNaN(bolaState.lastSegmentDurationS) && bufferLevel >= bolaState.lastSegmentDurationS) {\n                    bolaState.state = BOLA_STATE_STEADY;\n                }\n\n                break; // BOLA_STATE_STARTUP\n\n            case BOLA_STATE_STEADY:\n\n                // NB: The placeholder buffer is added to bufferLevel to come up with a bitrate.\n                //     This might lead BOLA to be too optimistic and to choose a bitrate that would lead to rebuffering -\n                //     if the real buffer bufferLevel runs out, the placeholder buffer cannot prevent rebuffering.\n                //     However, the InsufficientBufferRule takes care of this scenario.\n\n                updatePlaceholderBuffer(bolaState, mediaType);\n\n                quality = getQualityFromBufferLevel(bolaState, bufferLevel + bolaState.placeholderBuffer);\n\n                // we want to avoid oscillations\n                // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\n                const qualityForThroughput = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                if (quality > bolaState.lastQuality && quality > qualityForThroughput) {\n                    // only intervene if we are trying to *increase* quality to an *unsustainable* level\n                    // we are only avoid oscillations - do not drop below last quality\n\n                    quality = Math.max(qualityForThroughput, bolaState.lastQuality);\n                }\n\n                // We do not want to overfill buffer with low quality chunks.\n                // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\n                let delayS = Math.max(0, bufferLevel + bolaState.placeholderBuffer - maxBufferLevelForQuality(bolaState, quality));\n\n                // First reduce placeholder buffer, then tell schedule controller to pause.\n                if (delayS <= bolaState.placeholderBuffer) {\n                    bolaState.placeholderBuffer -= delayS;\n                    delayS = 0;\n                } else {\n                    delayS -= bolaState.placeholderBuffer;\n                    bolaState.placeholderBuffer = 0;\n\n                    if (quality < abrController.getTopQualityIndexFor(mediaType, streamId)) {\n                        // At top quality, allow schedule controller to decide how far to fill buffer.\n                        scheduleController.setTimeToLoadDelay(1000 * delayS);\n                    } else {\n                        delayS = 0;\n                    }\n                }\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = throughput;\n                switchRequest.reason.latency = latency;\n                switchRequest.reason.bufferLevel = bufferLevel;\n                switchRequest.reason.placeholderBuffer = bolaState.placeholderBuffer;\n                switchRequest.reason.delay = delayS;\n\n                bolaState.lastQuality = quality;\n                // keep bolaState.state === BOLA_STATE_STEADY\n\n                break; // BOLA_STATE_STEADY\n\n            default:\n                logger.debug('BOLA ABR rule invoked in bad state.');\n                // should not arrive here, try to recover\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.reason.state = bolaState.state;\n                switchRequest.reason.throughput = safeThroughput;\n                switchRequest.reason.latency = latency;\n                bolaState.state = BOLA_STATE_STARTUP;\n                clearBolaStateOnSeek(bolaState);\n        }\n\n        return switchRequest;\n    }\n\n    function resetInitialSettings() {\n        bolaStateDict = {};\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nBolaRule.__dashjs_factory_name = 'BolaRule';\nexport default FactoryMaker.getClassFactory(BolaRule);\n"]},"metadata":{},"sourceType":"script"}