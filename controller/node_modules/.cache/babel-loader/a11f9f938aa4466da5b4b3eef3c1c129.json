{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EventBus = require('../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _Errors = require('../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _DashConstants = require('../dash/constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _URLUtils = require('./utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ManifestUpdater() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      refreshDelay = void 0,\n      refreshTimer = void 0,\n      isPaused = void 0,\n      isStopped = void 0,\n      isUpdating = void 0,\n      manifestLoader = void 0,\n      manifestModel = void 0,\n      adapter = void 0,\n      errHandler = void 0,\n      settings = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.manifestModel) {\n      manifestModel = config.manifestModel;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n\n    if (config.manifestLoader) {\n      manifestLoader = config.manifestLoader;\n    }\n\n    if (config.errHandler) {\n      errHandler = config.errHandler;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n  }\n\n  function initialize() {\n    resetInitialSettings();\n    eventBus.on(_Events2.default.STREAMS_COMPOSED, onStreamsComposed, this);\n    eventBus.on(_Events2.default.PLAYBACK_STARTED, onPlaybackStarted, this);\n    eventBus.on(_Events2.default.PLAYBACK_PAUSED, onPlaybackPaused, this);\n    eventBus.on(_Events2.default.INTERNAL_MANIFEST_LOADED, onManifestLoaded, this);\n  }\n\n  function setManifest(manifest) {\n    update(manifest);\n  }\n\n  function resetInitialSettings() {\n    refreshDelay = NaN;\n    isUpdating = false;\n    isPaused = true;\n    isStopped = false;\n    stopManifestRefreshTimer();\n  }\n\n  function reset() {\n    eventBus.off(_Events2.default.PLAYBACK_STARTED, onPlaybackStarted, this);\n    eventBus.off(_Events2.default.PLAYBACK_PAUSED, onPlaybackPaused, this);\n    eventBus.off(_Events2.default.STREAMS_COMPOSED, onStreamsComposed, this);\n    eventBus.off(_Events2.default.INTERNAL_MANIFEST_LOADED, onManifestLoaded, this);\n    resetInitialSettings();\n  }\n\n  function stopManifestRefreshTimer() {\n    if (refreshTimer !== null) {\n      clearTimeout(refreshTimer);\n      refreshTimer = null;\n    }\n  }\n\n  function startManifestRefreshTimer(delay) {\n    stopManifestRefreshTimer();\n\n    if (isStopped) {\n      return;\n    }\n\n    if (isNaN(delay) && !isNaN(refreshDelay)) {\n      delay = refreshDelay * 1000;\n    }\n\n    if (!isNaN(delay)) {\n      logger.debug('Refresh manifest in ' + delay + ' milliseconds.');\n      refreshTimer = setTimeout(onRefreshTimer, delay);\n    }\n  }\n\n  function refreshManifest() {\n    var ignorePatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    isUpdating = true;\n    var manifest = manifestModel.getValue(); // default to the original url in the manifest\n\n    var url = manifest.url; // Check for PatchLocation and Location alternatives\n\n    var patchLocation = adapter.getPatchLocation(manifest);\n    var location = adapter.getLocation(manifest);\n\n    if (patchLocation && !ignorePatch) {\n      url = patchLocation;\n    } else if (location) {\n      url = location;\n    } // if one of the alternatives was relative, convert to absolute\n\n\n    if (urlUtils.isRelative(url)) {\n      url = urlUtils.resolve(url, manifest.url);\n    }\n\n    manifestLoader.load(url);\n  }\n\n  function update(manifest) {\n    if (!manifest) {\n      // successful update with no content implies existing manifest remains valid\n      manifest = manifestModel.getValue(); // override load time to avoid invalid latency tracking and ensure update cadence\n\n      manifest.loadedTime = new Date();\n    } else if (adapter.getIsPatch(manifest)) {\n      // with patches the in-memory manifest is our base\n      var patch = manifest;\n      manifest = manifestModel.getValue(); // check for patch validity\n\n      var isPatchValid = adapter.isPatchValid(manifest, patch);\n      var patchSuccessful = isPatchValid;\n\n      if (isPatchValid) {\n        // grab publish time before update\n        var publishTime = adapter.getPublishTime(manifest); // apply validated patch to manifest\n\n        patchSuccessful = adapter.applyPatchToManifest(manifest, patch); // get the updated publish time\n\n        var updatedPublishTime = adapter.getPublishTime(manifest); // ensure the patch properly updated the in-memory publish time\n\n        patchSuccessful = publishTime.getTime() != updatedPublishTime.getTime();\n      } // if the patch failed to apply, force a full manifest refresh\n\n\n      if (!patchSuccessful) {\n        logger.debug('Patch provided is invalid, performing full manifest refresh');\n        refreshManifest(true);\n        return;\n      } // override load time to avoid invalid latency tracking and ensure update cadence\n\n\n      manifest.loadedTime = new Date();\n    } // See DASH-IF IOP v4.3 section 4.6.4 \"Transition Phase between Live and On-Demand\"\n    // Stop manifest update, ignore static manifest and signal end of dynamic stream to detect end of stream\n\n\n    if (manifestModel.getValue() && manifestModel.getValue().type === _DashConstants2.default.DYNAMIC && manifest.type === _DashConstants2.default.STATIC) {\n      eventBus.trigger(_Events2.default.DYNAMIC_TO_STATIC);\n      isUpdating = false;\n      isStopped = true;\n      return;\n    }\n\n    manifestModel.setValue(manifest);\n    var date = new Date();\n    var latencyOfLastUpdate = (date.getTime() - manifest.loadedTime.getTime()) / 1000;\n    refreshDelay = adapter.getManifestUpdatePeriod(manifest, latencyOfLastUpdate); // setTimeout uses a 32 bit number to store the delay. Any number greater than it\n    // will cause event associated with setTimeout to trigger immediately\n\n    if (refreshDelay * 1000 > 0x7FFFFFFF) {\n      refreshDelay = 0x7FFFFFFF / 1000;\n    }\n\n    eventBus.trigger(_Events2.default.MANIFEST_UPDATED, {\n      manifest: manifest\n    });\n    logger.info('Manifest has been refreshed at ' + date + '[' + date.getTime() / 1000 + '] ');\n\n    if (!isPaused) {\n      startManifestRefreshTimer();\n    }\n  }\n\n  function onRefreshTimer() {\n    if (isPaused) {\n      return;\n    }\n\n    if (isUpdating) {\n      startManifestRefreshTimer(settings.get().streaming.manifestUpdateRetryInterval);\n      return;\n    }\n\n    refreshManifest();\n  }\n\n  function onManifestLoaded(e) {\n    if (!e.error) {\n      update(e.manifest);\n    } else if (e.error.code === _Errors2.default.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE) {\n      errHandler.error(e.error);\n    }\n  }\n\n  function onPlaybackStarted()\n  /*e*/\n  {\n    isPaused = false;\n    startManifestRefreshTimer();\n  }\n\n  function onPlaybackPaused()\n  /*e*/\n  {\n    isPaused = !settings.get().streaming.scheduleWhilePaused;\n\n    if (isPaused) {\n      stopManifestRefreshTimer();\n    }\n  }\n\n  function onStreamsComposed()\n  /*e*/\n  {\n    // When streams are ready we can consider manifest update completed. Resolve the update promise.\n    isUpdating = false;\n  }\n\n  instance = {\n    initialize: initialize,\n    setManifest: setManifest,\n    refreshManifest: refreshManifest,\n    setConfig: setConfig,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nManifestUpdater.__dashjs_factory_name = 'ManifestUpdater';\nexports.default = _FactoryMaker2.default.getClassFactory(ManifestUpdater);","map":{"version":3,"mappings":"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","names":["ManifestUpdater","context","eventBus","getInstance","urlUtils","instance","logger","refreshDelay","refreshTimer","isPaused","isStopped","isUpdating","manifestLoader","manifestModel","adapter","errHandler","settings","setup","getLogger","setConfig","config","initialize","resetInitialSettings","on","Events","STREAMS_COMPOSED","onStreamsComposed","PLAYBACK_STARTED","onPlaybackStarted","PLAYBACK_PAUSED","onPlaybackPaused","INTERNAL_MANIFEST_LOADED","onManifestLoaded","setManifest","manifest","update","NaN","stopManifestRefreshTimer","reset","off","clearTimeout","startManifestRefreshTimer","delay","isNaN","debug","setTimeout","onRefreshTimer","refreshManifest","ignorePatch","getValue","url","patchLocation","getPatchLocation","location","getLocation","isRelative","resolve","load","loadedTime","Date","getIsPatch","patch","isPatchValid","patchSuccessful","publishTime","getPublishTime","applyPatchToManifest","updatedPublishTime","getTime","type","DashConstants","DYNAMIC","STATIC","trigger","DYNAMIC_TO_STATIC","setValue","date","latencyOfLastUpdate","getManifestUpdatePeriod","MANIFEST_UPDATED","info","get","streaming","manifestUpdateRetryInterval","e","error","code","Errors","MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE","scheduleWhilePaused","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/ManifestUpdater.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport FactoryMaker from '../core/FactoryMaker';\nimport Debug from '../core/Debug';\nimport Errors from '../core/errors/Errors';\nimport DashConstants from '../dash/constants/DashConstants';\nimport URLUtils from './utils/URLUtils';\n\nfunction ManifestUpdater() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        logger,\n        refreshDelay,\n        refreshTimer,\n        isPaused,\n        isStopped,\n        isUpdating,\n        manifestLoader,\n        manifestModel,\n        adapter,\n        errHandler,\n        settings;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.manifestLoader) {\n            manifestLoader = config.manifestLoader;\n        }\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function initialize() {\n        resetInitialSettings();\n\n        eventBus.on(Events.STREAMS_COMPOSED, onStreamsComposed, this);\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.on(Events.PLAYBACK_PAUSED, onPlaybackPaused, this);\n        eventBus.on(Events.INTERNAL_MANIFEST_LOADED, onManifestLoaded, this);\n    }\n\n    function setManifest(manifest) {\n        update(manifest);\n    }\n\n    function resetInitialSettings() {\n        refreshDelay = NaN;\n        isUpdating = false;\n        isPaused = true;\n        isStopped = false;\n        stopManifestRefreshTimer();\n    }\n\n    function reset() {\n\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.off(Events.PLAYBACK_PAUSED, onPlaybackPaused, this);\n        eventBus.off(Events.STREAMS_COMPOSED, onStreamsComposed, this);\n        eventBus.off(Events.INTERNAL_MANIFEST_LOADED, onManifestLoaded, this);\n\n        resetInitialSettings();\n    }\n\n    function stopManifestRefreshTimer() {\n        if (refreshTimer !== null) {\n            clearTimeout(refreshTimer);\n            refreshTimer = null;\n        }\n    }\n\n    function startManifestRefreshTimer(delay) {\n        stopManifestRefreshTimer();\n\n        if (isStopped) {\n            return;\n        }\n\n        if (isNaN(delay) && !isNaN(refreshDelay)) {\n            delay = refreshDelay * 1000;\n        }\n\n        if (!isNaN(delay)) {\n            logger.debug('Refresh manifest in ' + delay + ' milliseconds.');\n            refreshTimer = setTimeout(onRefreshTimer, delay);\n        }\n    }\n\n    function refreshManifest(ignorePatch = false) {\n        isUpdating = true;\n        const manifest = manifestModel.getValue();\n\n        // default to the original url in the manifest\n        let url = manifest.url;\n\n        // Check for PatchLocation and Location alternatives\n        const patchLocation = adapter.getPatchLocation(manifest);\n        const location = adapter.getLocation(manifest);\n        if (patchLocation && !ignorePatch) {\n            url = patchLocation;\n        } else if (location) {\n            url = location;\n        }\n\n        // if one of the alternatives was relative, convert to absolute\n        if (urlUtils.isRelative(url)) {\n            url = urlUtils.resolve(url, manifest.url);\n        }\n\n        manifestLoader.load(url);\n    }\n\n    function update(manifest) {\n        if (!manifest) {\n            // successful update with no content implies existing manifest remains valid\n            manifest = manifestModel.getValue();\n\n            // override load time to avoid invalid latency tracking and ensure update cadence\n            manifest.loadedTime = new Date();\n        } else if (adapter.getIsPatch(manifest)) {\n            // with patches the in-memory manifest is our base\n            let patch = manifest;\n            manifest = manifestModel.getValue();\n\n            // check for patch validity\n            let isPatchValid = adapter.isPatchValid(manifest, patch);\n            let patchSuccessful = isPatchValid;\n\n            if (isPatchValid) {\n                // grab publish time before update\n                let publishTime = adapter.getPublishTime(manifest);\n\n                // apply validated patch to manifest\n                patchSuccessful = adapter.applyPatchToManifest(manifest, patch);\n\n                // get the updated publish time\n                let updatedPublishTime = adapter.getPublishTime(manifest);\n\n                // ensure the patch properly updated the in-memory publish time\n                patchSuccessful = publishTime.getTime() != updatedPublishTime.getTime();\n            }\n\n            // if the patch failed to apply, force a full manifest refresh\n            if (!patchSuccessful) {\n                logger.debug('Patch provided is invalid, performing full manifest refresh');\n                refreshManifest(true);\n                return;\n            }\n\n            // override load time to avoid invalid latency tracking and ensure update cadence\n            manifest.loadedTime = new Date();\n        }\n\n        // See DASH-IF IOP v4.3 section 4.6.4 \"Transition Phase between Live and On-Demand\"\n        // Stop manifest update, ignore static manifest and signal end of dynamic stream to detect end of stream\n        if (manifestModel.getValue() && manifestModel.getValue().type === DashConstants.DYNAMIC && manifest.type === DashConstants.STATIC) {\n            eventBus.trigger(Events.DYNAMIC_TO_STATIC);\n            isUpdating = false;\n            isStopped = true;\n            return;\n        }\n\n        manifestModel.setValue(manifest);\n\n        const date = new Date();\n        const latencyOfLastUpdate = (date.getTime() - manifest.loadedTime.getTime()) / 1000;\n        refreshDelay = adapter.getManifestUpdatePeriod(manifest, latencyOfLastUpdate);\n        // setTimeout uses a 32 bit number to store the delay. Any number greater than it\n        // will cause event associated with setTimeout to trigger immediately\n        if (refreshDelay * 1000 > 0x7FFFFFFF) {\n            refreshDelay = 0x7FFFFFFF / 1000;\n        }\n        eventBus.trigger(Events.MANIFEST_UPDATED, { manifest: manifest });\n        logger.info('Manifest has been refreshed at ' + date + '[' + date.getTime() / 1000 + '] ');\n\n        if (!isPaused) {\n            startManifestRefreshTimer();\n        }\n    }\n\n    function onRefreshTimer() {\n        if (isPaused) {\n            return;\n        }\n        if (isUpdating) {\n            startManifestRefreshTimer(settings.get().streaming.manifestUpdateRetryInterval);\n            return;\n        }\n        refreshManifest();\n    }\n\n    function onManifestLoaded(e) {\n        if (!e.error) {\n            update(e.manifest);\n        } else if (e.error.code === Errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE) {\n            errHandler.error(e.error);\n        }\n    }\n\n    function onPlaybackStarted (/*e*/) {\n        isPaused = false;\n        startManifestRefreshTimer();\n    }\n\n    function onPlaybackPaused(/*e*/) {\n        isPaused = !settings.get().streaming.scheduleWhilePaused;\n\n        if (isPaused) {\n            stopManifestRefreshTimer();\n        }\n    }\n\n    function onStreamsComposed(/*e*/) {\n        // When streams are ready we can consider manifest update completed. Resolve the update promise.\n        isUpdating = false;\n    }\n\n    instance = {\n        initialize: initialize,\n        setManifest: setManifest,\n        refreshManifest: refreshManifest,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\nManifestUpdater.__dashjs_factory_name = 'ManifestUpdater';\nexport default FactoryMaker.getClassFactory(ManifestUpdater);\n"]},"metadata":{},"sourceType":"script"}