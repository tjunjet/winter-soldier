{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _BufferController = require('./../controllers/BufferController');\n\nvar _BufferController2 = _interopRequireDefault(_BufferController);\n\nvar _NotFragmentedTextBufferController = require('./NotFragmentedTextBufferController');\n\nvar _NotFragmentedTextBufferController2 = _interopRequireDefault(_NotFragmentedTextBufferController);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction TextBufferController(config) {\n  config = config || {};\n  var context = this.context;\n\n  var _BufferControllerImpl = void 0,\n      instance = void 0;\n\n  function setup() {\n    // according to text type, we create corresponding buffer controller\n    if (config.type === _Constants2.default.FRAGMENTED_TEXT) {\n      // in this case, internal buffer ocntroller is a classical BufferController object\n      _BufferControllerImpl = (0, _BufferController2.default)(context).create({\n        streamInfo: config.streamInfo,\n        type: config.type,\n        mediaPlayerModel: config.mediaPlayerModel,\n        manifestModel: config.manifestModel,\n        fragmentModel: config.fragmentModel,\n        errHandler: config.errHandler,\n        mediaController: config.mediaController,\n        representationController: config.representationController,\n        adapter: config.adapter,\n        textController: config.textController,\n        abrController: config.abrController,\n        playbackController: config.playbackController,\n        settings: config.settings\n      });\n    } else {\n      // in this case, internal buffer controller is a not fragmented text controller object\n      _BufferControllerImpl = (0, _NotFragmentedTextBufferController2.default)(context).create({\n        streamInfo: config.streamInfo,\n        type: config.type,\n        mimeType: config.mimeType,\n        fragmentModel: config.fragmentModel,\n        errHandler: config.errHandler\n      });\n    }\n  }\n\n  function getBufferControllerType() {\n    return _BufferControllerImpl.getBufferControllerType();\n  }\n\n  function initialize(source, StreamProcessor) {\n    return _BufferControllerImpl.initialize(source, StreamProcessor);\n  }\n\n  function createBuffer(mediaInfoArr, previousBuffers) {\n    return _BufferControllerImpl.createBuffer(mediaInfoArr, previousBuffers);\n  }\n\n  function getType() {\n    return _BufferControllerImpl.getType();\n  }\n\n  function getBuffer() {\n    return _BufferControllerImpl.getBuffer();\n  }\n\n  function setBuffer(value) {\n    _BufferControllerImpl.setBuffer(value);\n  }\n\n  function getMediaSource() {\n    return _BufferControllerImpl.getMediaSource();\n  }\n\n  function setMediaSource(value) {\n    _BufferControllerImpl.setMediaSource(value);\n  }\n\n  function getBufferLevel() {\n    return _BufferControllerImpl.getBufferLevel();\n  }\n\n  function reset(errored) {\n    _BufferControllerImpl.reset(errored);\n  }\n\n  function getIsBufferingCompleted() {\n    return _BufferControllerImpl.getIsBufferingCompleted();\n  }\n\n  function appendInitSegment(representationId) {\n    _BufferControllerImpl.appendInitSegment(representationId);\n  }\n\n  function getIsPruningInProgress() {\n    return _BufferControllerImpl.getIsPruningInProgress();\n  }\n\n  function dischargePreBuffer() {\n    return _BufferControllerImpl.dischargePreBuffer();\n  }\n\n  function getRangeAt(time) {\n    return _BufferControllerImpl.getRangeAt(time);\n  }\n\n  function updateTimestampOffset(MSETimeOffset) {\n    var buffer = getBuffer();\n\n    if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n      buffer.timestampOffset = MSETimeOffset;\n    }\n  }\n\n  function updateAppendWindow() {\n    _BufferControllerImpl.updateAppendWindow();\n  }\n\n  function getRepresentationInfo(quality) {\n    return _BufferControllerImpl.getRepresentationInfo(quality);\n  }\n\n  instance = {\n    getBufferControllerType: getBufferControllerType,\n    initialize: initialize,\n    createBuffer: createBuffer,\n    getType: getType,\n    getBuffer: getBuffer,\n    setBuffer: setBuffer,\n    getBufferLevel: getBufferLevel,\n    setMediaSource: setMediaSource,\n    getMediaSource: getMediaSource,\n    getIsBufferingCompleted: getIsBufferingCompleted,\n    getIsPruningInProgress: getIsPruningInProgress,\n    dischargePreBuffer: dischargePreBuffer,\n    appendInitSegment: appendInitSegment,\n    getRangeAt: getRangeAt,\n    reset: reset,\n    updateTimestampOffset: updateTimestampOffset,\n    updateAppendWindow: updateAppendWindow,\n    getRepresentationInfo: getRepresentationInfo\n  };\n  setup();\n  return instance;\n}\n\nTextBufferController.__dashjs_factory_name = 'TextBufferController';\nexports.default = _FactoryMaker2.default.getClassFactory(TextBufferController);","map":{"version":3,"mappings":";;;;;;AA8BA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AAjCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,SAASA,oBAAT,CAA8BC,MAA9B,EAAsC;EAElCA,SAASA,UAAU,EAAnBA;EACA,IAAIC,UAAU,KAAKA,OAAnB;;EAEA,IAAIC,8BAAJ;EAAA,IACIC,iBADJ;;EAGA,SAASC,KAAT,GAAiB;IAEb;IACA,IAAIJ,OAAOK,IAAPL,KAAgBM,oBAAUC,eAA9B,EAA+C;MAE3C;MACAL,wBAAwB,gCAAiBD,OAAjB,EAA0BO,MAA1B,CAAiC;QACrDC,YAAYT,OAAOS,UADkC;QAErDJ,MAAML,OAAOK,IAFwC;QAGrDK,kBAAkBV,OAAOU,gBAH4B;QAIrDC,eAAeX,OAAOW,aAJ+B;QAKrDC,eAAeZ,OAAOY,aAL+B;QAMrDC,YAAYb,OAAOa,UANkC;QAOrDC,iBAAiBd,OAAOc,eAP6B;QAQrDC,0BAA0Bf,OAAOe,wBARoB;QASrDC,SAAShB,OAAOgB,OATqC;QAUrDC,gBAAgBjB,OAAOiB,cAV8B;QAWrDC,eAAelB,OAAOkB,aAX+B;QAYrDC,oBAAoBnB,OAAOmB,kBAZ0B;QAarDC,UAAUpB,OAAOoB;MAboC,CAAjC,CAAxBlB;IAHJ,OAkBO;MAEH;MACAA,wBAAwB,iDAAkCD,OAAlC,EAA2CO,MAA3C,CAAkD;QACtEC,YAAYT,OAAOS,UADmD;QAEtEJ,MAAML,OAAOK,IAFyD;QAGtEgB,UAAUrB,OAAOqB,QAHqD;QAItET,eAAeZ,OAAOY,aAJgD;QAKtEC,YAAYb,OAAOa;MALmD,CAAlD,CAAxBX;IAQP;EAED;;EAAA,SAASoB,uBAAT,GAAmC;IAC/B,OAAOpB,sBAAsBoB,uBAAtBpB,EAAP;EAGJ;;EAAA,SAASqB,UAAT,CAAoBC,MAApB,EAA4BC,eAA5B,EAA6C;IACzC,OAAOvB,sBAAsBqB,UAAtBrB,CAAiCsB,MAAjCtB,EAAyCuB,eAAzCvB,CAAP;EAGJ;;EAAA,SAASwB,YAAT,CAAsBC,YAAtB,EAAoCC,eAApC,EAAqD;IACjD,OAAO1B,sBAAsBwB,YAAtBxB,CAAmCyB,YAAnCzB,EAAiD0B,eAAjD1B,CAAP;EAGJ;;EAAA,SAAS2B,OAAT,GAAmB;IACf,OAAO3B,sBAAsB2B,OAAtB3B,EAAP;EAGJ;;EAAA,SAAS4B,SAAT,GAAqB;IACjB,OAAO5B,sBAAsB4B,SAAtB5B,EAAP;EAGJ;;EAAA,SAAS6B,SAAT,CAAmBC,KAAnB,EAA0B;IACtB9B,sBAAsB6B,SAAtB7B,CAAgC8B,KAAhC9B;EAGJ;;EAAA,SAAS+B,cAAT,GAA0B;IACtB,OAAO/B,sBAAsB+B,cAAtB/B,EAAP;EAGJ;;EAAA,SAASgC,cAAT,CAAwBF,KAAxB,EAA+B;IAC3B9B,sBAAsBgC,cAAtBhC,CAAqC8B,KAArC9B;EAGJ;;EAAA,SAASiC,cAAT,GAA0B;IACtB,OAAOjC,sBAAsBiC,cAAtBjC,EAAP;EAGJ;;EAAA,SAASkC,KAAT,CAAeC,OAAf,EAAwB;IACpBnC,sBAAsBkC,KAAtBlC,CAA4BmC,OAA5BnC;EAGJ;;EAAA,SAASoC,uBAAT,GAAmC;IAC/B,OAAOpC,sBAAsBoC,uBAAtBpC,EAAP;EAGJ;;EAAA,SAASqC,iBAAT,CAA2BC,gBAA3B,EAA6C;IACzCtC,sBAAsBqC,iBAAtBrC,CAAwCsC,gBAAxCtC;EAGJ;;EAAA,SAASuC,sBAAT,GAAkC;IAC9B,OAAOvC,sBAAsBuC,sBAAtBvC,EAAP;EAGJ;;EAAA,SAASwC,kBAAT,GAA8B;IAC1B,OAAOxC,sBAAsBwC,kBAAtBxC,EAAP;EAGJ;;EAAA,SAASyC,UAAT,CAAoBC,IAApB,EAA0B;IACtB,OAAO1C,sBAAsByC,UAAtBzC,CAAiC0C,IAAjC1C,CAAP;EAGJ;;EAAA,SAAS2C,qBAAT,CAA+BC,aAA/B,EAA8C;IAC1C,IAAMC,SAASjB,WAAf;;IACA,IAAIiB,OAAOC,eAAPD,KAA2BD,aAA3BC,IAA4C,CAACE,MAAMH,aAANG,CAAjD,EAAuE;MACnEF,OAAOC,eAAPD,GAAyBD,aAAzBC;IAEP;EAED;;EAAA,SAASG,kBAAT,GAA8B;IAC1BhD,sBAAsBgD,kBAAtBhD;EAGJ;;EAAA,SAASiD,qBAAT,CAA+BC,OAA/B,EAAwC;IACpC,OAAOlD,sBAAsBiD,qBAAtBjD,CAA4CkD,OAA5ClD,CAAP;EAGJC;;EAAAA,WAAW;IACPmB,yBAAyBA,uBADlB;IAEPC,YAAYA,UAFL;IAGPG,cAAcA,YAHP;IAIPG,SAASA,OAJF;IAKPC,WAAWA,SALJ;IAMPC,WAAWA,SANJ;IAOPI,gBAAgBA,cAPT;IAQPD,gBAAgBA,cART;IASPD,gBAAgBA,cATT;IAUPK,yBAAyBA,uBAVlB;IAWPG,wBAAwBA,sBAXjB;IAYPC,oBAAoBA,kBAZb;IAaPH,mBAAmBA,iBAbZ;IAcPI,YAAYA,UAdL;IAePP,OAAOA,KAfA;IAgBPS,uBAAuBA,qBAhBhB;IAiBPK,sCAjBO;IAkBPC;EAlBO,CAAXhD;EAqBAC;EAEA,OAAOD,QAAP;AAGJJ;;AAAAA,qBAAqBsD,qBAArBtD,GAA6C,sBAA7CA;kBACeuD,uBAAaC,eAAbD,CAA6BvD,oBAA7BuD,C","names":["TextBufferController","config","context","_BufferControllerImpl","instance","setup","type","Constants","FRAGMENTED_TEXT","create","streamInfo","mediaPlayerModel","manifestModel","fragmentModel","errHandler","mediaController","representationController","adapter","textController","abrController","playbackController","settings","mimeType","getBufferControllerType","initialize","source","StreamProcessor","createBuffer","mediaInfoArr","previousBuffers","getType","getBuffer","setBuffer","value","getMediaSource","setMediaSource","getBufferLevel","reset","errored","getIsBufferingCompleted","appendInitSegment","representationId","getIsPruningInProgress","dischargePreBuffer","getRangeAt","time","updateTimestampOffset","MSETimeOffset","buffer","timestampOffset","isNaN","updateAppendWindow","getRepresentationInfo","quality","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/text/TextBufferController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport BufferController from './../controllers/BufferController';\nimport NotFragmentedTextBufferController from './NotFragmentedTextBufferController';\n\nfunction TextBufferController(config) {\n\n    config = config || {};\n    let context = this.context;\n\n    let _BufferControllerImpl,\n        instance;\n\n    function setup() {\n\n        // according to text type, we create corresponding buffer controller\n        if (config.type === Constants.FRAGMENTED_TEXT) {\n\n            // in this case, internal buffer ocntroller is a classical BufferController object\n            _BufferControllerImpl = BufferController(context).create({\n                streamInfo: config.streamInfo,\n                type: config.type,\n                mediaPlayerModel: config.mediaPlayerModel,\n                manifestModel: config.manifestModel,\n                fragmentModel: config.fragmentModel,\n                errHandler: config.errHandler,\n                mediaController: config.mediaController,\n                representationController: config.representationController,\n                adapter: config.adapter,\n                textController: config.textController,\n                abrController: config.abrController,\n                playbackController: config.playbackController,\n                settings: config.settings\n            });\n        } else {\n\n            // in this case, internal buffer controller is a not fragmented text controller object\n            _BufferControllerImpl = NotFragmentedTextBufferController(context).create({\n                streamInfo: config.streamInfo,\n                type: config.type,\n                mimeType: config.mimeType,\n                fragmentModel: config.fragmentModel,\n                errHandler: config.errHandler\n            });\n        }\n    }\n\n    function getBufferControllerType() {\n        return _BufferControllerImpl.getBufferControllerType();\n    }\n\n    function initialize(source, StreamProcessor) {\n        return _BufferControllerImpl.initialize(source, StreamProcessor);\n    }\n\n    function createBuffer(mediaInfoArr, previousBuffers) {\n        return _BufferControllerImpl.createBuffer(mediaInfoArr, previousBuffers);\n    }\n\n    function getType() {\n        return _BufferControllerImpl.getType();\n    }\n\n    function getBuffer() {\n        return _BufferControllerImpl.getBuffer();\n    }\n\n    function setBuffer(value) {\n        _BufferControllerImpl.setBuffer(value);\n    }\n\n    function getMediaSource() {\n        return _BufferControllerImpl.getMediaSource();\n    }\n\n    function setMediaSource(value) {\n        _BufferControllerImpl.setMediaSource(value);\n    }\n\n    function getBufferLevel() {\n        return _BufferControllerImpl.getBufferLevel();\n    }\n\n    function reset(errored) {\n        _BufferControllerImpl.reset(errored);\n    }\n\n    function getIsBufferingCompleted() {\n        return _BufferControllerImpl.getIsBufferingCompleted();\n    }\n\n    function appendInitSegment(representationId) {\n        _BufferControllerImpl.appendInitSegment(representationId);\n    }\n\n    function getIsPruningInProgress() {\n        return _BufferControllerImpl.getIsPruningInProgress();\n    }\n\n    function dischargePreBuffer() {\n        return _BufferControllerImpl.dischargePreBuffer();\n    }\n\n    function getRangeAt(time) {\n        return _BufferControllerImpl.getRangeAt(time);\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        const buffer = getBuffer();\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            buffer.timestampOffset = MSETimeOffset;\n        }\n    }\n\n    function updateAppendWindow() {\n        _BufferControllerImpl.updateAppendWindow();\n    }\n\n    function getRepresentationInfo(quality) {\n        return _BufferControllerImpl.getRepresentationInfo(quality);\n    }\n\n    instance = {\n        getBufferControllerType: getBufferControllerType,\n        initialize: initialize,\n        createBuffer: createBuffer,\n        getType: getType,\n        getBuffer: getBuffer,\n        setBuffer: setBuffer,\n        getBufferLevel: getBufferLevel,\n        setMediaSource: setMediaSource,\n        getMediaSource: getMediaSource,\n        getIsBufferingCompleted: getIsBufferingCompleted,\n        getIsPruningInProgress: getIsPruningInProgress,\n        dischargePreBuffer: dischargePreBuffer,\n        appendInitSegment: appendInitSegment,\n        getRangeAt: getRangeAt,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset,\n        updateAppendWindow,\n        getRepresentationInfo\n    };\n\n    setup();\n\n    return instance;\n}\n\nTextBufferController.__dashjs_factory_name = 'TextBufferController';\nexport default FactoryMaker.getClassFactory(TextBufferController);\n"]},"metadata":{},"sourceType":"script"}