{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../../streaming/constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _DashConstants = require('../constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _Representation = require('../vo/Representation');\n\nvar _Representation2 = _interopRequireDefault(_Representation);\n\nvar _AdaptationSet = require('../vo/AdaptationSet');\n\nvar _AdaptationSet2 = _interopRequireDefault(_AdaptationSet);\n\nvar _Period = require('../vo/Period');\n\nvar _Period2 = _interopRequireDefault(_Period);\n\nvar _Mpd = require('../vo/Mpd');\n\nvar _Mpd2 = _interopRequireDefault(_Mpd);\n\nvar _UTCTiming = require('../vo/UTCTiming');\n\nvar _UTCTiming2 = _interopRequireDefault(_UTCTiming);\n\nvar _Event = require('../vo/Event');\n\nvar _Event2 = _interopRequireDefault(_Event);\n\nvar _BaseURL = require('../vo/BaseURL');\n\nvar _BaseURL2 = _interopRequireDefault(_BaseURL);\n\nvar _EventStream = require('../vo/EventStream');\n\nvar _EventStream2 = _interopRequireDefault(_EventStream);\n\nvar _ObjectUtils = require('../../streaming/utils/ObjectUtils');\n\nvar _ObjectUtils2 = _interopRequireDefault(_ObjectUtils);\n\nvar _URLUtils = require('../../streaming/utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _DashJSError = require('../../streaming/vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _Errors = require('../../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _ThumbnailTracks = require('../../streaming/thumbnail/ThumbnailTracks');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction DashManifestModel() {\n  var instance = void 0,\n      logger = void 0,\n      errHandler = void 0,\n      BASE64 = void 0;\n  var context = this.context;\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n\n  var isInteger = Number.isInteger || function (value) {\n    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n  };\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n  }\n\n  function getIsTypeOf(adaptation, type) {\n    var i = void 0,\n        len = void 0,\n        representation = void 0,\n        col = void 0,\n        mimeTypeRegEx = void 0,\n        codecs = void 0;\n    var result = false;\n    var found = false;\n\n    if (!adaptation) {\n      throw new Error('adaptation is not defined');\n    }\n\n    if (!type) {\n      throw new Error('type is not defined');\n    }\n\n    if (adaptation.hasOwnProperty('ContentComponent_asArray')) {\n      col = adaptation.ContentComponent_asArray;\n    }\n\n    mimeTypeRegEx = type !== _Constants2.default.TEXT ? new RegExp(type) : new RegExp('(vtt|ttml)');\n\n    if (adaptation.Representation_asArray && adaptation.Representation_asArray.length && adaptation.Representation_asArray.length > 0) {\n      var essentialProperties = getEssentialPropertiesForRepresentation(adaptation.Representation_asArray[0]);\n\n      if (essentialProperties && essentialProperties.length > 0 && _ThumbnailTracks.THUMBNAILS_SCHEME_ID_URIS.indexOf(essentialProperties[0].schemeIdUri) >= 0) {\n        return type === _Constants2.default.IMAGE;\n      }\n\n      if (adaptation.Representation_asArray[0].hasOwnProperty(_DashConstants2.default.CODECS)) {\n        // Just check the start of the codecs string\n        codecs = adaptation.Representation_asArray[0].codecs;\n\n        if (codecs.search(_Constants2.default.STPP) === 0 || codecs.search(_Constants2.default.WVTT) === 0) {\n          return type === _Constants2.default.FRAGMENTED_TEXT;\n        }\n      }\n    }\n\n    if (col) {\n      if (col.length > 1) {\n        return type === _Constants2.default.MUXED;\n      } else if (col[0] && col[0].contentType === type) {\n        result = true;\n        found = true;\n      }\n    }\n\n    if (adaptation.hasOwnProperty(_DashConstants2.default.MIME_TYPE)) {\n      result = mimeTypeRegEx.test(adaptation.mimeType);\n      found = true;\n    } // couldn't find on adaptationset, so check a representation\n\n\n    if (!found) {\n      i = 0;\n      len = adaptation.Representation_asArray && adaptation.Representation_asArray.length ? adaptation.Representation_asArray.length : 0;\n\n      while (!found && i < len) {\n        representation = adaptation.Representation_asArray[i];\n\n        if (representation.hasOwnProperty(_DashConstants2.default.MIME_TYPE)) {\n          result = mimeTypeRegEx.test(representation.mimeType);\n          found = true;\n        }\n\n        i++;\n      }\n    }\n\n    return result;\n  }\n\n  function getIsAudio(adaptation) {\n    return getIsTypeOf(adaptation, _Constants2.default.AUDIO);\n  }\n\n  function getIsVideo(adaptation) {\n    return getIsTypeOf(adaptation, _Constants2.default.VIDEO);\n  }\n\n  function getIsFragmentedText(adaptation) {\n    return getIsTypeOf(adaptation, _Constants2.default.FRAGMENTED_TEXT);\n  }\n\n  function getIsMuxed(adaptation) {\n    return getIsTypeOf(adaptation, _Constants2.default.MUXED);\n  }\n\n  function getIsImage(adaptation) {\n    return getIsTypeOf(adaptation, _Constants2.default.IMAGE);\n  }\n\n  function getIsTextTrack(type) {\n    return type === 'text/vtt' || type === 'application/ttml+xml';\n  }\n\n  function getLanguageForAdaptation(adaptation) {\n    var lang = '';\n\n    if (adaptation && adaptation.hasOwnProperty(_DashConstants2.default.LANG)) {\n      //Filter out any other characters not allowed according to RFC5646\n      lang = adaptation.lang.replace(/[^A-Za-z0-9-]/g, '');\n    }\n\n    return lang;\n  }\n\n  function getViewpointForAdaptation(adaptation) {\n    return adaptation && adaptation.hasOwnProperty(_DashConstants2.default.VIEWPOINT) ? adaptation.Viewpoint : null;\n  }\n\n  function getRolesForAdaptation(adaptation) {\n    return adaptation && adaptation.hasOwnProperty(_DashConstants2.default.ROLE_ASARRAY) ? adaptation.Role_asArray : [];\n  }\n\n  function getAccessibilityForAdaptation(adaptation) {\n    return adaptation && adaptation.hasOwnProperty(_DashConstants2.default.ACCESSIBILITY_ASARRAY) ? adaptation.Accessibility_asArray : [];\n  }\n\n  function getAudioChannelConfigurationForAdaptation(adaptation) {\n    return adaptation && adaptation.hasOwnProperty(_DashConstants2.default.AUDIOCHANNELCONFIGURATION_ASARRAY) ? adaptation.AudioChannelConfiguration_asArray : [];\n  }\n\n  function getAudioChannelConfigurationForRepresentation(representation) {\n    return representation && representation.hasOwnProperty(_DashConstants2.default.AUDIOCHANNELCONFIGURATION_ASARRAY) ? representation.AudioChannelConfiguration_asArray : [];\n  }\n\n  function getRepresentationSortFunction() {\n    return function (a, b) {\n      return a.bandwidth - b.bandwidth;\n    };\n  }\n\n  function processAdaptation(realAdaptation) {\n    if (realAdaptation && Array.isArray(realAdaptation.Representation_asArray)) {\n      realAdaptation.Representation_asArray.sort(getRepresentationSortFunction());\n    }\n\n    return realAdaptation;\n  }\n\n  function getRealAdaptations(manifest, periodIndex) {\n    return manifest && manifest.Period_asArray && isInteger(periodIndex) ? manifest.Period_asArray[periodIndex] ? manifest.Period_asArray[periodIndex].AdaptationSet_asArray : [] : [];\n  }\n\n  function getRealPeriods(manifest) {\n    return manifest && manifest.Period_asArray ? manifest.Period_asArray : [];\n  }\n\n  function getRealPeriodForIndex(index, manifest) {\n    var realPeriods = getRealPeriods(manifest);\n\n    if (realPeriods.length > 0 && isInteger(index)) {\n      return realPeriods[index];\n    } else {\n      return null;\n    }\n  }\n\n  function getAdaptationForId(id, manifest, periodIndex) {\n    var realAdaptations = getRealAdaptations(manifest, periodIndex);\n    var i = void 0,\n        len = void 0;\n\n    for (i = 0, len = realAdaptations.length; i < len; i++) {\n      if (realAdaptations[i].hasOwnProperty(_DashConstants2.default.ID) && realAdaptations[i].id === id) {\n        return realAdaptations[i];\n      }\n    }\n\n    return null;\n  }\n\n  function getAdaptationForIndex(index, manifest, periodIndex) {\n    var realAdaptations = getRealAdaptations(manifest, periodIndex);\n\n    if (realAdaptations.length > 0 && isInteger(index)) {\n      return realAdaptations[index];\n    } else {\n      return null;\n    }\n  }\n\n  function getIndexForAdaptation(realAdaptation, manifest, periodIndex) {\n    if (!realAdaptation) {\n      return -1;\n    }\n\n    var realAdaptations = getRealAdaptations(manifest, periodIndex);\n\n    for (var i = 0; i < realAdaptations.length; i++) {\n      var objectUtils = (0, _ObjectUtils2.default)(context).getInstance();\n\n      if (objectUtils.areEqual(realAdaptations[i], realAdaptation)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function getAdaptationsForType(manifest, periodIndex, type) {\n    var realAdaptations = getRealAdaptations(manifest, periodIndex);\n    var i = void 0,\n        len = void 0;\n    var adaptations = [];\n\n    for (i = 0, len = realAdaptations.length; i < len; i++) {\n      if (getIsTypeOf(realAdaptations[i], type)) {\n        adaptations.push(processAdaptation(realAdaptations[i]));\n      }\n    }\n\n    return adaptations;\n  }\n\n  function getCodec(adaptation, representationId, addResolutionInfo) {\n    var codec = null;\n\n    if (adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0) {\n      var representation = isInteger(representationId) && representationId >= 0 && representationId < adaptation.Representation_asArray.length ? adaptation.Representation_asArray[representationId] : adaptation.Representation_asArray[0];\n\n      if (representation) {\n        codec = representation.mimeType + ';codecs=\"' + representation.codecs + '\"';\n\n        if (addResolutionInfo && representation.width !== undefined) {\n          codec += ';width=\"' + representation.width + '\";height=\"' + representation.height + '\"';\n        }\n      }\n    } // If the codec contains a profiles parameter we remove it. Otherwise it will cause problems when checking for codec capabilities of the platform\n\n\n    if (codec) {\n      codec = codec.replace(/\\sprofiles=[^;]*/g, '');\n    }\n\n    return codec;\n  }\n\n  function getMimeType(adaptation) {\n    return adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0 ? adaptation.Representation_asArray[0].mimeType : null;\n  }\n\n  function getKID(adaptation) {\n    if (!adaptation || !adaptation.hasOwnProperty(_DashConstants2.default.CENC_DEFAULT_KID)) {\n      return null;\n    }\n\n    return adaptation[_DashConstants2.default.CENC_DEFAULT_KID];\n  }\n\n  function getLabelsForAdaptation(adaptation) {\n    if (!adaptation || !Array.isArray(adaptation.Label_asArray)) {\n      return [];\n    }\n\n    var labelArray = [];\n\n    for (var i = 0; i < adaptation.Label_asArray.length; i++) {\n      labelArray.push({\n        lang: adaptation.Label_asArray[i].lang,\n        text: adaptation.Label_asArray[i].__text || adaptation.Label_asArray[i]\n      });\n    }\n\n    return labelArray;\n  }\n\n  function getContentProtectionData(adaptation) {\n    if (!adaptation || !adaptation.hasOwnProperty(_DashConstants2.default.CONTENTPROTECTION_ASARRAY) || adaptation.ContentProtection_asArray.length === 0) {\n      return null;\n    }\n\n    return adaptation.ContentProtection_asArray;\n  }\n\n  function getIsDynamic(manifest) {\n    var isDynamic = false;\n\n    if (manifest && manifest.hasOwnProperty('type')) {\n      isDynamic = manifest.type === _DashConstants2.default.DYNAMIC;\n    }\n\n    return isDynamic;\n  }\n\n  function getId(manifest) {\n    return manifest && manifest[_DashConstants2.default.ID] || null;\n  }\n\n  function hasProfile(manifest, profile) {\n    var has = false;\n\n    if (manifest && manifest.profiles && manifest.profiles.length > 0) {\n      has = manifest.profiles.indexOf(profile) !== -1;\n    }\n\n    return has;\n  }\n\n  function getDuration(manifest) {\n    var mpdDuration = void 0; //@mediaPresentationDuration specifies the duration of the entire Media Presentation.\n    //If the attribute is not present, the duration of the Media Presentation is unknown.\n\n    if (manifest && manifest.hasOwnProperty(_DashConstants2.default.MEDIA_PRESENTATION_DURATION)) {\n      mpdDuration = manifest.mediaPresentationDuration;\n    } else if (manifest && manifest.type == 'dynamic') {\n      mpdDuration = Number.POSITIVE_INFINITY;\n    } else {\n      mpdDuration = Number.MAX_SAFE_INTEGER || Number.MAX_VALUE;\n    }\n\n    return mpdDuration;\n  }\n\n  function getBandwidth(representation) {\n    return representation && representation.bandwidth ? representation.bandwidth : NaN;\n  }\n\n  function getManifestUpdatePeriod(manifest) {\n    var latencyOfLastUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var delay = NaN;\n\n    if (manifest && manifest.hasOwnProperty(_DashConstants2.default.MINIMUM_UPDATE_PERIOD)) {\n      delay = manifest.minimumUpdatePeriod;\n    }\n\n    return isNaN(delay) ? delay : Math.max(delay - latencyOfLastUpdate, 1);\n  }\n\n  function getPublishTime(manifest) {\n    return manifest && manifest.hasOwnProperty(_DashConstants2.default.PUBLISH_TIME) ? new Date(manifest[_DashConstants2.default.PUBLISH_TIME]) : null;\n  }\n\n  function getRepresentationCount(adaptation) {\n    return adaptation && Array.isArray(adaptation.Representation_asArray) ? adaptation.Representation_asArray.length : 0;\n  }\n\n  function getBitrateListForAdaptation(realAdaptation) {\n    var processedRealAdaptation = processAdaptation(realAdaptation);\n    var realRepresentations = processedRealAdaptation && Array.isArray(processedRealAdaptation.Representation_asArray) ? processedRealAdaptation.Representation_asArray : [];\n    return realRepresentations.map(function (realRepresentation) {\n      return {\n        bandwidth: realRepresentation.bandwidth,\n        width: realRepresentation.width || 0,\n        height: realRepresentation.height || 0,\n        scanType: realRepresentation.scanType || null,\n        id: realRepresentation.id || null\n      };\n    });\n  }\n\n  function getEssentialPropertiesForRepresentation(realRepresentation) {\n    if (!realRepresentation || !realRepresentation.EssentialProperty_asArray || !realRepresentation.EssentialProperty_asArray.length) return null;\n    return realRepresentation.EssentialProperty_asArray.map(function (prop) {\n      return {\n        schemeIdUri: prop.schemeIdUri,\n        value: prop.value\n      };\n    });\n  }\n\n  function getRepresentationFor(index, adaptation) {\n    return adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0 && isInteger(index) ? adaptation.Representation_asArray[index] : null;\n  }\n\n  function getRealAdaptationFor(voAdaptation) {\n    if (voAdaptation && voAdaptation.period && isInteger(voAdaptation.period.index)) {\n      var periodArray = voAdaptation.period.mpd.manifest.Period_asArray[voAdaptation.period.index];\n\n      if (periodArray && periodArray.AdaptationSet_asArray && isInteger(voAdaptation.index)) {\n        return processAdaptation(periodArray.AdaptationSet_asArray[voAdaptation.index]);\n      }\n    }\n  }\n\n  function getRepresentationsForAdaptation(voAdaptation) {\n    var voRepresentations = [];\n    var processedRealAdaptation = getRealAdaptationFor(voAdaptation);\n    var segmentInfo = void 0,\n        baseUrl = void 0;\n\n    if (processedRealAdaptation && processedRealAdaptation.Representation_asArray) {\n      // TODO: TO BE REMOVED. We should get just the baseUrl elements that affects to the representations\n      // that we are processing. Making it works properly will require much further changes and given\n      // parsing base Urls parameters is needed for our ultra low latency examples, we will\n      // keep this \"tricky\" code until the real (and good) solution comes\n      if (voAdaptation && voAdaptation.period && isInteger(voAdaptation.period.index)) {\n        var baseUrls = getBaseURLsFromElement(voAdaptation.period.mpd.manifest);\n\n        if (baseUrls) {\n          baseUrl = baseUrls[0];\n        }\n      }\n\n      for (var i = 0, len = processedRealAdaptation.Representation_asArray.length; i < len; ++i) {\n        var realRepresentation = processedRealAdaptation.Representation_asArray[i];\n        var voRepresentation = new _Representation2.default();\n        voRepresentation.index = i;\n        voRepresentation.adaptation = voAdaptation;\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.ID)) {\n          voRepresentation.id = realRepresentation.id;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.CODECS)) {\n          voRepresentation.codecs = realRepresentation.codecs;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.CODEC_PRIVATE_DATA)) {\n          voRepresentation.codecPrivateData = realRepresentation.codecPrivateData;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.BANDWITH)) {\n          voRepresentation.bandwidth = realRepresentation.bandwidth;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.WIDTH)) {\n          voRepresentation.width = realRepresentation.width;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.HEIGHT)) {\n          voRepresentation.height = realRepresentation.height;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.SCAN_TYPE)) {\n          voRepresentation.scanType = realRepresentation.scanType;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.MAX_PLAYOUT_RATE)) {\n          voRepresentation.maxPlayoutRate = realRepresentation.maxPlayoutRate;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.SEGMENT_BASE)) {\n          segmentInfo = realRepresentation.SegmentBase;\n          voRepresentation.segmentInfoType = _DashConstants2.default.SEGMENT_BASE;\n        } else if (realRepresentation.hasOwnProperty(_DashConstants2.default.SEGMENT_LIST)) {\n          segmentInfo = realRepresentation.SegmentList;\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.SEGMENT_TIMELINE)) {\n            voRepresentation.segmentInfoType = _DashConstants2.default.SEGMENT_TIMELINE;\n          } else {\n            voRepresentation.segmentInfoType = _DashConstants2.default.SEGMENT_LIST;\n          }\n        } else if (realRepresentation.hasOwnProperty(_DashConstants2.default.SEGMENT_TEMPLATE)) {\n          segmentInfo = realRepresentation.SegmentTemplate;\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.SEGMENT_TIMELINE)) {\n            voRepresentation.segmentInfoType = _DashConstants2.default.SEGMENT_TIMELINE;\n          } else {\n            voRepresentation.segmentInfoType = _DashConstants2.default.SEGMENT_TEMPLATE;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.INITIALIZATION_MINUS)) {\n            voRepresentation.initialization = segmentInfo.initialization.split('$Bandwidth$').join(realRepresentation.bandwidth).split('$RepresentationID$').join(realRepresentation.id);\n          }\n        } else {\n          voRepresentation.segmentInfoType = _DashConstants2.default.BASE_URL;\n        }\n\n        voRepresentation.essentialProperties = getEssentialPropertiesForRepresentation(realRepresentation);\n\n        if (segmentInfo) {\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.INITIALIZATION)) {\n            var initialization = segmentInfo.Initialization;\n\n            if (initialization.hasOwnProperty(_DashConstants2.default.SOURCE_URL)) {\n              voRepresentation.initialization = initialization.sourceURL;\n            }\n\n            if (initialization.hasOwnProperty(_DashConstants2.default.RANGE)) {\n              voRepresentation.range = initialization.range; // initialization source url will be determined from\n              // BaseURL when resolved at load time.\n            }\n          } else if (realRepresentation.hasOwnProperty(_DashConstants2.default.MIME_TYPE) && getIsTextTrack(realRepresentation.mimeType)) {\n            voRepresentation.range = 0;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.TIMESCALE)) {\n            voRepresentation.timescale = segmentInfo.timescale;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.DURATION)) {\n            // TODO according to the spec @maxSegmentDuration specifies the maximum duration of any Segment in any Representation in the Media Presentation\n            // It is also said that for a SegmentTimeline any @d value shall not exceed the value of MPD@maxSegmentDuration, but nothing is said about\n            // SegmentTemplate @duration attribute. We need to find out if @maxSegmentDuration should be used instead of calculated duration if the the duration\n            // exceeds @maxSegmentDuration\n            voRepresentation.segmentDuration = segmentInfo.duration / voRepresentation.timescale;\n          } else if (realRepresentation.hasOwnProperty(_DashConstants2.default.SEGMENT_TEMPLATE)) {\n            segmentInfo = realRepresentation.SegmentTemplate;\n\n            if (segmentInfo.hasOwnProperty(_DashConstants2.default.SEGMENT_TIMELINE)) {\n              voRepresentation.segmentDuration = calcSegmentDuration(segmentInfo.SegmentTimeline) / voRepresentation.timescale;\n            }\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.MEDIA)) {\n            voRepresentation.media = segmentInfo.media;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.START_NUMBER)) {\n            voRepresentation.startNumber = segmentInfo.startNumber;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.INDEX_RANGE)) {\n            voRepresentation.indexRange = segmentInfo.indexRange;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.PRESENTATION_TIME_OFFSET)) {\n            voRepresentation.presentationTimeOffset = segmentInfo.presentationTimeOffset / voRepresentation.timescale;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.AVAILABILITY_TIME_OFFSET)) {\n            voRepresentation.availabilityTimeOffset = segmentInfo.availabilityTimeOffset;\n          } else if (baseUrl && baseUrl.availabilityTimeOffset !== undefined) {\n            voRepresentation.availabilityTimeOffset = baseUrl.availabilityTimeOffset;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.AVAILABILITY_TIME_COMPLETE)) {\n            voRepresentation.availabilityTimeComplete = segmentInfo.availabilityTimeComplete !== 'false';\n          } else if (baseUrl && baseUrl.availabilityTimeComplete !== undefined) {\n            voRepresentation.availabilityTimeComplete = baseUrl.availabilityTimeComplete;\n          }\n        }\n\n        voRepresentation.MSETimeOffset = calcMSETimeOffset(voRepresentation);\n        voRepresentation.path = [voAdaptation.period.index, voAdaptation.index, i];\n        voRepresentations.push(voRepresentation);\n      }\n    }\n\n    return voRepresentations;\n  }\n\n  function calcSegmentDuration(segmentTimeline) {\n    var s0 = segmentTimeline.S_asArray[0];\n    var s1 = segmentTimeline.S_asArray[1];\n    return s0.hasOwnProperty('d') ? s0.d : s1.t - s0.t;\n  }\n\n  function calcMSETimeOffset(representation) {\n    // The MSEOffset is offset from AST for media. It is Period@start - presentationTimeOffset\n    var presentationOffset = representation.presentationTimeOffset;\n    var periodStart = representation.adaptation.period.start;\n    return periodStart - presentationOffset;\n  }\n\n  function getAdaptationsForPeriod(voPeriod) {\n    var realPeriod = voPeriod && isInteger(voPeriod.index) ? voPeriod.mpd.manifest.Period_asArray[voPeriod.index] : null;\n    var voAdaptations = [];\n    var voAdaptationSet = void 0,\n        realAdaptationSet = void 0,\n        i = void 0;\n\n    if (realPeriod && realPeriod.AdaptationSet_asArray) {\n      for (i = 0; i < realPeriod.AdaptationSet_asArray.length; i++) {\n        realAdaptationSet = realPeriod.AdaptationSet_asArray[i];\n        voAdaptationSet = new _AdaptationSet2.default();\n\n        if (realAdaptationSet.hasOwnProperty(_DashConstants2.default.ID)) {\n          voAdaptationSet.id = realAdaptationSet.id;\n        }\n\n        voAdaptationSet.index = i;\n        voAdaptationSet.period = voPeriod;\n\n        if (getIsMuxed(realAdaptationSet)) {\n          voAdaptationSet.type = _Constants2.default.MUXED;\n        } else if (getIsAudio(realAdaptationSet)) {\n          voAdaptationSet.type = _Constants2.default.AUDIO;\n        } else if (getIsVideo(realAdaptationSet)) {\n          voAdaptationSet.type = _Constants2.default.VIDEO;\n        } else if (getIsFragmentedText(realAdaptationSet)) {\n          voAdaptationSet.type = _Constants2.default.FRAGMENTED_TEXT;\n        } else if (getIsImage(realAdaptationSet)) {\n          voAdaptationSet.type = _Constants2.default.IMAGE;\n        } else {\n          voAdaptationSet.type = _Constants2.default.TEXT;\n        }\n\n        voAdaptations.push(voAdaptationSet);\n      }\n    }\n\n    return voAdaptations;\n  }\n\n  function getRegularPeriods(mpd) {\n    var isDynamic = mpd ? getIsDynamic(mpd.manifest) : false;\n    var voPeriods = [];\n    var realPreviousPeriod = null;\n    var realPeriod = null;\n    var voPreviousPeriod = null;\n    var voPeriod = null;\n    var len = void 0,\n        i = void 0;\n\n    for (i = 0, len = mpd && mpd.manifest && mpd.manifest.Period_asArray ? mpd.manifest.Period_asArray.length : 0; i < len; i++) {\n      realPeriod = mpd.manifest.Period_asArray[i]; // If the attribute @start is present in the Period, then the\n      // Period is a regular Period and the PeriodStart is equal\n      // to the value of this attribute.\n\n      if (realPeriod.hasOwnProperty(_DashConstants2.default.START)) {\n        voPeriod = new _Period2.default();\n        voPeriod.start = realPeriod.start;\n      } // If the @start attribute is absent, but the previous Period\n      // element contains a @duration attribute then then this new\n      // Period is also a regular Period. The start time of the new\n      // Period PeriodStart is the sum of the start time of the previous\n      // Period PeriodStart and the value of the attribute @duration\n      // of the previous Period.\n      else if (realPreviousPeriod !== null && realPreviousPeriod.hasOwnProperty(_DashConstants2.default.DURATION) && voPreviousPeriod !== null) {\n        voPeriod = new _Period2.default();\n        voPeriod.start = parseFloat((voPreviousPeriod.start + voPreviousPeriod.duration).toFixed(5));\n      } // If (i) @start attribute is absent, and (ii) the Period element\n      // is the first in the MPD, and (iii) the MPD@type is 'static',\n      // then the PeriodStart time shall be set to zero.\n      else if (i === 0 && !isDynamic) {\n        voPeriod = new _Period2.default();\n        voPeriod.start = 0;\n      } // The Period extends until the PeriodStart of the next Period.\n      // The difference between the PeriodStart time of a Period and\n      // the PeriodStart time of the following Period.\n\n\n      if (voPreviousPeriod !== null && isNaN(voPreviousPeriod.duration)) {\n        if (voPeriod !== null) {\n          voPreviousPeriod.duration = parseFloat((voPeriod.start - voPreviousPeriod.start).toFixed(5));\n        } else {\n          logger.warn('First period duration could not be calculated because lack of start and duration period properties. This will cause timing issues during playback');\n        }\n      }\n\n      if (voPeriod !== null) {\n        voPeriod.id = getPeriodId(realPeriod, i);\n        voPeriod.index = i;\n        voPeriod.mpd = mpd;\n\n        if (realPeriod.hasOwnProperty(_DashConstants2.default.DURATION)) {\n          voPeriod.duration = realPeriod.duration;\n        }\n\n        voPeriods.push(voPeriod);\n        realPreviousPeriod = realPeriod;\n        voPreviousPeriod = voPeriod;\n      }\n\n      realPeriod = null;\n      voPeriod = null;\n    }\n\n    if (voPeriods.length === 0) {\n      return voPeriods;\n    } // The last Period extends until the end of the Media Presentation.\n    // The difference between the PeriodStart time of the last Period\n    // and the mpd duration\n\n\n    if (voPreviousPeriod !== null && isNaN(voPreviousPeriod.duration)) {\n      voPreviousPeriod.duration = parseFloat((getEndTimeForLastPeriod(voPreviousPeriod) - voPreviousPeriod.start).toFixed(5));\n    }\n\n    return voPeriods;\n  }\n\n  function getPeriodId(realPeriod, i) {\n    if (!realPeriod) {\n      throw new Error('Period cannot be null or undefined');\n    }\n\n    var id = _Period2.default.DEFAULT_ID + '_' + i;\n\n    if (realPeriod.hasOwnProperty(_DashConstants2.default.ID) && realPeriod.id.length > 0 && realPeriod.id !== '__proto__') {\n      id = realPeriod.id;\n    }\n\n    return id;\n  }\n\n  function getMpd(manifest) {\n    var mpd = new _Mpd2.default();\n\n    if (manifest) {\n      mpd.manifest = manifest;\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.AVAILABILITY_START_TIME)) {\n        mpd.availabilityStartTime = new Date(manifest.availabilityStartTime.getTime());\n      } else {\n        if (manifest.loadedTime) {\n          mpd.availabilityStartTime = new Date(manifest.loadedTime.getTime());\n        }\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.AVAILABILITY_END_TIME)) {\n        mpd.availabilityEndTime = new Date(manifest.availabilityEndTime.getTime());\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.MINIMUM_UPDATE_PERIOD)) {\n        mpd.minimumUpdatePeriod = manifest.minimumUpdatePeriod;\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.MEDIA_PRESENTATION_DURATION)) {\n        mpd.mediaPresentationDuration = manifest.mediaPresentationDuration;\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.SUGGESTED_PRESENTATION_DELAY)) {\n        mpd.suggestedPresentationDelay = manifest.suggestedPresentationDelay;\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.TIMESHIFT_BUFFER_DEPTH)) {\n        mpd.timeShiftBufferDepth = manifest.timeShiftBufferDepth;\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.MAX_SEGMENT_DURATION)) {\n        mpd.maxSegmentDuration = manifest.maxSegmentDuration;\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.PUBLISH_TIME)) {\n        mpd.publishTime = new Date(manifest.publishTime);\n      }\n    }\n\n    return mpd;\n  }\n\n  function checkConfig() {\n    if (!errHandler || !errHandler.hasOwnProperty('error')) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n\n  function getEndTimeForLastPeriod(voPeriod) {\n    checkConfig();\n    var isDynamic = getIsDynamic(voPeriod.mpd.manifest);\n    var periodEnd = void 0;\n\n    if (voPeriod.mpd.manifest.mediaPresentationDuration) {\n      periodEnd = voPeriod.mpd.manifest.mediaPresentationDuration;\n    } else if (voPeriod.duration) {\n      periodEnd = voPeriod.duration;\n    } else if (isDynamic) {\n      periodEnd = Number.POSITIVE_INFINITY;\n    } else {\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MANIFEST_ERROR_ID_PARSE_CODE, 'Must have @mediaPresentationDuration on MPD or an explicit @duration on the last period.', voPeriod));\n    }\n\n    return periodEnd;\n  }\n\n  function getEventsForPeriod(period) {\n    var manifest = period && period.mpd && period.mpd.manifest ? period.mpd.manifest : null;\n    var periodArray = manifest ? manifest.Period_asArray : null;\n    var eventStreams = periodArray && period && isInteger(period.index) ? periodArray[period.index].EventStream_asArray : null;\n    var events = [];\n    var i = void 0,\n        j = void 0;\n\n    if (eventStreams) {\n      for (i = 0; i < eventStreams.length; i++) {\n        var eventStream = new _EventStream2.default();\n        eventStream.period = period;\n        eventStream.timescale = 1;\n\n        if (eventStreams[i].hasOwnProperty(_Constants2.default.SCHEME_ID_URI)) {\n          eventStream.schemeIdUri = eventStreams[i][_Constants2.default.SCHEME_ID_URI];\n        } else {\n          throw new Error('Invalid EventStream. SchemeIdUri has to be set');\n        }\n\n        if (eventStreams[i].hasOwnProperty(_DashConstants2.default.TIMESCALE)) {\n          eventStream.timescale = eventStreams[i][_DashConstants2.default.TIMESCALE];\n        }\n\n        if (eventStreams[i].hasOwnProperty(_DashConstants2.default.VALUE)) {\n          eventStream.value = eventStreams[i][_DashConstants2.default.VALUE];\n        }\n\n        if (eventStreams[i].hasOwnProperty(_DashConstants2.default.PRESENTATION_TIME_OFFSET)) {\n          eventStream.presentationTimeOffset = eventStreams[i][_DashConstants2.default.PRESENTATION_TIME_OFFSET];\n        }\n\n        for (j = 0; eventStreams[i].Event_asArray && j < eventStreams[i].Event_asArray.length; j++) {\n          var currentMpdEvent = eventStreams[i].Event_asArray[j];\n          var event = new _Event2.default();\n          event.presentationTime = 0;\n          event.eventStream = eventStream;\n\n          if (currentMpdEvent.hasOwnProperty(_DashConstants2.default.PRESENTATION_TIME)) {\n            event.presentationTime = currentMpdEvent.presentationTime;\n            var presentationTimeOffset = eventStream.presentationTimeOffset ? eventStream.presentationTimeOffset / eventStream.timescale : 0;\n            event.calculatedPresentationTime = event.presentationTime / eventStream.timescale + period.start - presentationTimeOffset;\n          }\n\n          if (currentMpdEvent.hasOwnProperty(_DashConstants2.default.DURATION)) {\n            event.duration = currentMpdEvent.duration / eventStream.timescale;\n          }\n\n          if (currentMpdEvent.hasOwnProperty(_DashConstants2.default.ID)) {\n            event.id = currentMpdEvent.id;\n          }\n\n          if (currentMpdEvent.Signal && currentMpdEvent.Signal.Binary) {\n            // toString is used to manage both regular and namespaced tags\n            event.messageData = BASE64.decodeArray(currentMpdEvent.Signal.Binary.toString());\n          } else {\n            // From Cor.1: 'NOTE: this attribute is an alternative\n            // to specifying a complete XML element(s) in the Event.\n            // It is useful when an event leans itself to a compact\n            // string representation'.\n            event.messageData = currentMpdEvent.messageData || currentMpdEvent.__text;\n          }\n\n          events.push(event);\n        }\n      }\n    }\n\n    return events;\n  }\n\n  function getEventStreams(inbandStreams, representation) {\n    var eventStreams = [];\n    var i = void 0;\n    if (!inbandStreams) return eventStreams;\n\n    for (i = 0; i < inbandStreams.length; i++) {\n      var eventStream = new _EventStream2.default();\n      eventStream.timescale = 1;\n      eventStream.representation = representation;\n\n      if (inbandStreams[i].hasOwnProperty(_Constants2.default.SCHEME_ID_URI)) {\n        eventStream.schemeIdUri = inbandStreams[i].schemeIdUri;\n      } else {\n        throw new Error('Invalid EventStream. SchemeIdUri has to be set');\n      }\n\n      if (inbandStreams[i].hasOwnProperty(_DashConstants2.default.TIMESCALE)) {\n        eventStream.timescale = inbandStreams[i].timescale;\n      }\n\n      if (inbandStreams[i].hasOwnProperty(_DashConstants2.default.VALUE)) {\n        eventStream.value = inbandStreams[i].value;\n      }\n\n      eventStreams.push(eventStream);\n    }\n\n    return eventStreams;\n  }\n\n  function getEventStreamForAdaptationSet(manifest, adaptation) {\n    var inbandStreams = void 0,\n        periodArray = void 0,\n        adaptationArray = void 0;\n\n    if (manifest && manifest.Period_asArray && adaptation && adaptation.period && isInteger(adaptation.period.index)) {\n      periodArray = manifest.Period_asArray[adaptation.period.index];\n\n      if (periodArray && periodArray.AdaptationSet_asArray && isInteger(adaptation.index)) {\n        adaptationArray = periodArray.AdaptationSet_asArray[adaptation.index];\n\n        if (adaptationArray) {\n          inbandStreams = adaptationArray.InbandEventStream_asArray;\n        }\n      }\n    }\n\n    return getEventStreams(inbandStreams, null);\n  }\n\n  function getEventStreamForRepresentation(manifest, representation) {\n    var inbandStreams = void 0,\n        periodArray = void 0,\n        adaptationArray = void 0,\n        representationArray = void 0;\n\n    if (manifest && manifest.Period_asArray && representation && representation.adaptation && representation.adaptation.period && isInteger(representation.adaptation.period.index)) {\n      periodArray = manifest.Period_asArray[representation.adaptation.period.index];\n\n      if (periodArray && periodArray.AdaptationSet_asArray && isInteger(representation.adaptation.index)) {\n        adaptationArray = periodArray.AdaptationSet_asArray[representation.adaptation.index];\n\n        if (adaptationArray && adaptationArray.Representation_asArray && isInteger(representation.index)) {\n          representationArray = adaptationArray.Representation_asArray[representation.index];\n\n          if (representationArray) {\n            inbandStreams = representationArray.InbandEventStream_asArray;\n          }\n        }\n      }\n    }\n\n    return getEventStreams(inbandStreams, representation);\n  }\n\n  function getUTCTimingSources(manifest) {\n    var isDynamic = getIsDynamic(manifest);\n    var hasAST = manifest ? manifest.hasOwnProperty(_DashConstants2.default.AVAILABILITY_START_TIME) : false;\n    var utcTimingsArray = manifest ? manifest.UTCTiming_asArray : null;\n    var utcTimingEntries = []; // do not bother synchronizing the clock unless MPD is live,\n    // or it is static and has availabilityStartTime attribute\n\n    if (isDynamic || hasAST) {\n      if (utcTimingsArray) {\n        // the order is important here - 23009-1 states that the order\n        // in the manifest \"indicates relative preference, first having\n        // the highest, and the last the lowest priority\".\n        utcTimingsArray.forEach(function (utcTiming) {\n          var entry = new _UTCTiming2.default();\n\n          if (utcTiming.hasOwnProperty(_Constants2.default.SCHEME_ID_URI)) {\n            entry.schemeIdUri = utcTiming.schemeIdUri;\n          } else {\n            // entries of type DescriptorType with no schemeIdUri\n            // are meaningless. let's just ignore this entry and\n            // move on.\n            return;\n          } // this is (incorrectly) interpreted as a number - schema\n          // defines it as a string\n\n\n          if (utcTiming.hasOwnProperty(_DashConstants2.default.VALUE)) {\n            entry.value = utcTiming.value.toString();\n          } else {\n            // without a value, there's not a lot we can do with\n            // this entry. let's just ignore this one and move on\n            return;\n          } // we're not interested in the optional id or any other\n          // attributes which might be attached to the entry\n\n\n          utcTimingEntries.push(entry);\n        });\n      }\n    }\n\n    return utcTimingEntries;\n  }\n\n  function getBaseURLsFromElement(node) {\n    var baseUrls = []; // if node.BaseURL_asArray and node.baseUri are undefined entries\n    // will be [undefined] which entries.some will just skip\n\n    var entries = node.BaseURL_asArray || [node.baseUri];\n    var earlyReturn = false;\n    entries.some(function (entry) {\n      if (entry) {\n        var baseUrl = new _BaseURL2.default();\n        var text = entry.__text || entry;\n\n        if (urlUtils.isRelative(text)) {\n          // it doesn't really make sense to have relative and\n          // absolute URLs at the same level, or multiple\n          // relative URLs at the same level, so assume we are\n          // done from this level of the MPD\n          earlyReturn = true; // deal with the specific case where the MPD@BaseURL\n          // is specified and is relative. when no MPD@BaseURL\n          // entries exist, that case is handled by the\n          // [node.baseUri] in the entries definition.\n\n          if (node.baseUri) {\n            text = urlUtils.resolve(text, node.baseUri);\n          }\n        }\n\n        baseUrl.url = text; // serviceLocation is optional, but we need it in order\n        // to blacklist correctly. if it's not available, use\n        // anything unique since there's no relationship to any\n        // other BaseURL and, in theory, the url should be\n        // unique so use this instead.\n\n        if (entry.hasOwnProperty(_DashConstants2.default.SERVICE_LOCATION) && entry.serviceLocation.length) {\n          baseUrl.serviceLocation = entry.serviceLocation;\n        } else {\n          baseUrl.serviceLocation = text;\n        }\n\n        if (entry.hasOwnProperty(_DashConstants2.default.DVB_PRIORITY)) {\n          baseUrl.dvb_priority = entry[_DashConstants2.default.DVB_PRIORITY];\n        }\n\n        if (entry.hasOwnProperty(_DashConstants2.default.DVB_WEIGHT)) {\n          baseUrl.dvb_weight = entry[_DashConstants2.default.DVB_WEIGHT];\n        }\n\n        if (entry.hasOwnProperty(_DashConstants2.default.AVAILABILITY_TIME_OFFSET)) {\n          baseUrl.availabilityTimeOffset = entry[_DashConstants2.default.AVAILABILITY_TIME_OFFSET];\n        }\n\n        if (entry.hasOwnProperty(_DashConstants2.default.AVAILABILITY_TIME_COMPLETE)) {\n          baseUrl.availabilityTimeComplete = entry[_DashConstants2.default.AVAILABILITY_TIME_COMPLETE] !== 'false';\n        }\n        /* NOTE: byteRange currently unused\n        */\n\n\n        baseUrls.push(baseUrl);\n        return earlyReturn;\n      }\n    });\n    return baseUrls;\n  }\n\n  function getLocation(manifest) {\n    if (manifest && manifest.hasOwnProperty(_Constants2.default.LOCATION)) {\n      // for now, do not support multiple Locations -\n      // just set Location to the first Location.\n      manifest.Location = manifest.Location_asArray[0];\n      return manifest.Location;\n    } // may well be undefined\n\n\n    return undefined;\n  }\n\n  function getPatchLocation(manifest) {\n    if (manifest && manifest.hasOwnProperty(_DashConstants2.default.PATCH_LOCATION)) {\n      // only include support for single patch location currently\n      manifest.PatchLocation = manifest.PatchLocation_asArray[0];\n      return manifest.PatchLocation;\n    } // no patch location provided\n\n\n    return undefined;\n  }\n\n  function getSuggestedPresentationDelay(mpd) {\n    return mpd && mpd.hasOwnProperty(_DashConstants2.default.SUGGESTED_PRESENTATION_DELAY) ? mpd.suggestedPresentationDelay : null;\n  }\n\n  function getAvailabilityStartTime(mpd) {\n    return mpd && mpd.hasOwnProperty(_DashConstants2.default.AVAILABILITY_START_TIME) && mpd.availabilityStartTime !== null ? mpd.availabilityStartTime.getTime() : null;\n  }\n\n  function getServiceDescriptions(manifest) {\n    var serviceDescriptions = [];\n\n    if (manifest && manifest.hasOwnProperty(_DashConstants2.default.SERVICE_DESCRIPTION)) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = manifest.ServiceDescription_asArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var sd = _step.value; // Convert each of the properties defined in\n\n          var id = void 0,\n              schemeIdUri = void 0,\n              latency = void 0,\n              playbackRate = void 0;\n\n          for (var prop in sd) {\n            if (sd.hasOwnProperty(prop)) {\n              if (prop === _DashConstants2.default.ID) {\n                id = sd[prop];\n              } else if (prop === _DashConstants2.default.SERVICE_DESCRIPTION_SCOPE) {\n                schemeIdUri = sd[prop].schemeIdUri;\n              } else if (prop === _DashConstants2.default.SERVICE_DESCRIPTION_LATENCY) {\n                latency = {\n                  target: sd[prop].target,\n                  max: sd[prop].max,\n                  min: sd[prop].min\n                };\n              } else if (prop === _DashConstants2.default.SERVICE_DESCRIPTION_PLAYBACK_RATE) {\n                playbackRate = {\n                  max: sd[prop].max,\n                  min: sd[prop].min\n                };\n              }\n            }\n          } // we have a ServiceDescription for low latency. Add it if it really has parameters defined\n\n\n          if (schemeIdUri === _Constants2.default.SERVICE_DESCRIPTION_LL_SCHEME && (latency || playbackRate)) {\n            serviceDescriptions.push({\n              id: id,\n              schemeIdUri: schemeIdUri,\n              latency: latency,\n              playbackRate: playbackRate\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    return serviceDescriptions;\n  }\n\n  function getSupplementalPropperties(adaptation) {\n    var supplementalProperties = {};\n\n    if (adaptation && adaptation.hasOwnProperty(_DashConstants2.default.SUPPLEMENTAL_PROPERTY)) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = adaptation.SupplementalProperty_asArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var sp = _step2.value;\n\n          if (sp.hasOwnProperty(_Constants2.default.SCHEME_ID_URI) && sp.hasOwnProperty(_DashConstants2.default.VALUE)) {\n            supplementalProperties[sp[_Constants2.default.SCHEME_ID_URI]] = sp[_DashConstants2.default.VALUE];\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    return supplementalProperties;\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.errHandler) {\n      errHandler = config.errHandler;\n    }\n\n    if (config.BASE64) {\n      BASE64 = config.BASE64;\n    }\n  }\n\n  instance = {\n    getIsTypeOf: getIsTypeOf,\n    getIsTextTrack: getIsTextTrack,\n    getLanguageForAdaptation: getLanguageForAdaptation,\n    getViewpointForAdaptation: getViewpointForAdaptation,\n    getRolesForAdaptation: getRolesForAdaptation,\n    getAccessibilityForAdaptation: getAccessibilityForAdaptation,\n    getAudioChannelConfigurationForAdaptation: getAudioChannelConfigurationForAdaptation,\n    getAudioChannelConfigurationForRepresentation: getAudioChannelConfigurationForRepresentation,\n    getAdaptationForIndex: getAdaptationForIndex,\n    getIndexForAdaptation: getIndexForAdaptation,\n    getAdaptationForId: getAdaptationForId,\n    getAdaptationsForType: getAdaptationsForType,\n    getRealPeriods: getRealPeriods,\n    getRealPeriodForIndex: getRealPeriodForIndex,\n    getCodec: getCodec,\n    getMimeType: getMimeType,\n    getKID: getKID,\n    getLabelsForAdaptation: getLabelsForAdaptation,\n    getContentProtectionData: getContentProtectionData,\n    getIsDynamic: getIsDynamic,\n    getId: getId,\n    hasProfile: hasProfile,\n    getDuration: getDuration,\n    getBandwidth: getBandwidth,\n    getManifestUpdatePeriod: getManifestUpdatePeriod,\n    getPublishTime: getPublishTime,\n    getRepresentationCount: getRepresentationCount,\n    getBitrateListForAdaptation: getBitrateListForAdaptation,\n    getRepresentationFor: getRepresentationFor,\n    getRepresentationsForAdaptation: getRepresentationsForAdaptation,\n    getAdaptationsForPeriod: getAdaptationsForPeriod,\n    getRegularPeriods: getRegularPeriods,\n    getMpd: getMpd,\n    getEventsForPeriod: getEventsForPeriod,\n    getEssentialPropertiesForRepresentation: getEssentialPropertiesForRepresentation,\n    getEventStreamForAdaptationSet: getEventStreamForAdaptationSet,\n    getEventStreamForRepresentation: getEventStreamForRepresentation,\n    getUTCTimingSources: getUTCTimingSources,\n    getBaseURLsFromElement: getBaseURLsFromElement,\n    getRepresentationSortFunction: getRepresentationSortFunction,\n    getLocation: getLocation,\n    getPatchLocation: getPatchLocation,\n    getSuggestedPresentationDelay: getSuggestedPresentationDelay,\n    getAvailabilityStartTime: getAvailabilityStartTime,\n    getServiceDescriptions: getServiceDescriptions,\n    getSupplementalPropperties: getSupplementalPropperties,\n    setConfig: setConfig\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nDashManifestModel.__dashjs_factory_name = 'DashManifestModel';\nexports.default = _FactoryMaker2.default.getSingletonFactory(DashManifestModel);","map":{"version":3,"mappings":"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","names":["DashManifestModel","instance","logger","errHandler","BASE64","context","urlUtils","getInstance","isInteger","Number","value","isFinite","Math","floor","setup","getLogger","getIsTypeOf","adaptation","type","i","len","representation","col","mimeTypeRegEx","codecs","result","found","Error","hasOwnProperty","ContentComponent_asArray","Constants","TEXT","RegExp","Representation_asArray","length","essentialProperties","getEssentialPropertiesForRepresentation","THUMBNAILS_SCHEME_ID_URIS","indexOf","schemeIdUri","IMAGE","DashConstants","CODECS","search","STPP","WVTT","FRAGMENTED_TEXT","MUXED","contentType","MIME_TYPE","test","mimeType","getIsAudio","AUDIO","getIsVideo","VIDEO","getIsFragmentedText","getIsMuxed","getIsImage","getIsTextTrack","getLanguageForAdaptation","lang","LANG","replace","getViewpointForAdaptation","VIEWPOINT","Viewpoint","getRolesForAdaptation","ROLE_ASARRAY","Role_asArray","getAccessibilityForAdaptation","ACCESSIBILITY_ASARRAY","Accessibility_asArray","getAudioChannelConfigurationForAdaptation","AUDIOCHANNELCONFIGURATION_ASARRAY","AudioChannelConfiguration_asArray","getAudioChannelConfigurationForRepresentation","getRepresentationSortFunction","a","b","bandwidth","processAdaptation","realAdaptation","Array","isArray","sort","getRealAdaptations","manifest","periodIndex","Period_asArray","AdaptationSet_asArray","getRealPeriods","getRealPeriodForIndex","index","realPeriods","getAdaptationForId","id","realAdaptations","ID","getAdaptationForIndex","getIndexForAdaptation","objectUtils","areEqual","getAdaptationsForType","adaptations","push","getCodec","representationId","addResolutionInfo","codec","width","undefined","height","getMimeType","getKID","CENC_DEFAULT_KID","getLabelsForAdaptation","Label_asArray","labelArray","text","__text","getContentProtectionData","CONTENTPROTECTION_ASARRAY","ContentProtection_asArray","getIsDynamic","isDynamic","DYNAMIC","getId","hasProfile","profile","has","profiles","getDuration","mpdDuration","MEDIA_PRESENTATION_DURATION","mediaPresentationDuration","POSITIVE_INFINITY","MAX_SAFE_INTEGER","MAX_VALUE","getBandwidth","NaN","getManifestUpdatePeriod","latencyOfLastUpdate","delay","MINIMUM_UPDATE_PERIOD","minimumUpdatePeriod","isNaN","max","getPublishTime","PUBLISH_TIME","Date","getRepresentationCount","getBitrateListForAdaptation","processedRealAdaptation","realRepresentations","map","realRepresentation","scanType","EssentialProperty_asArray","prop","getRepresentationFor","getRealAdaptationFor","voAdaptation","period","periodArray","mpd","getRepresentationsForAdaptation","voRepresentations","segmentInfo","baseUrl","baseUrls","getBaseURLsFromElement","voRepresentation","Representation","CODEC_PRIVATE_DATA","codecPrivateData","BANDWITH","WIDTH","HEIGHT","SCAN_TYPE","MAX_PLAYOUT_RATE","maxPlayoutRate","SEGMENT_BASE","SegmentBase","segmentInfoType","SEGMENT_LIST","SegmentList","SEGMENT_TIMELINE","SEGMENT_TEMPLATE","SegmentTemplate","INITIALIZATION_MINUS","initialization","split","join","BASE_URL","INITIALIZATION","Initialization","SOURCE_URL","sourceURL","RANGE","range","TIMESCALE","timescale","DURATION","segmentDuration","duration","calcSegmentDuration","SegmentTimeline","MEDIA","media","START_NUMBER","startNumber","INDEX_RANGE","indexRange","PRESENTATION_TIME_OFFSET","presentationTimeOffset","AVAILABILITY_TIME_OFFSET","availabilityTimeOffset","AVAILABILITY_TIME_COMPLETE","availabilityTimeComplete","MSETimeOffset","calcMSETimeOffset","path","segmentTimeline","s0","S_asArray","s1","d","t","presentationOffset","periodStart","start","getAdaptationsForPeriod","voPeriod","realPeriod","voAdaptations","voAdaptationSet","realAdaptationSet","AdaptationSet","getRegularPeriods","voPeriods","realPreviousPeriod","voPreviousPeriod","START","Period","parseFloat","toFixed","warn","getPeriodId","getEndTimeForLastPeriod","DEFAULT_ID","getMpd","Mpd","AVAILABILITY_START_TIME","availabilityStartTime","getTime","loadedTime","AVAILABILITY_END_TIME","availabilityEndTime","SUGGESTED_PRESENTATION_DELAY","suggestedPresentationDelay","TIMESHIFT_BUFFER_DEPTH","timeShiftBufferDepth","MAX_SEGMENT_DURATION","maxSegmentDuration","publishTime","checkConfig","MISSING_CONFIG_ERROR","periodEnd","error","DashJSError","Errors","MANIFEST_ERROR_ID_PARSE_CODE","getEventsForPeriod","eventStreams","EventStream_asArray","events","j","eventStream","EventStream","SCHEME_ID_URI","VALUE","Event_asArray","currentMpdEvent","event","Event","presentationTime","PRESENTATION_TIME","calculatedPresentationTime","Signal","Binary","messageData","decodeArray","toString","getEventStreams","inbandStreams","getEventStreamForAdaptationSet","adaptationArray","InbandEventStream_asArray","getEventStreamForRepresentation","representationArray","getUTCTimingSources","hasAST","utcTimingsArray","UTCTiming_asArray","utcTimingEntries","forEach","utcTiming","entry","UTCTiming","node","entries","BaseURL_asArray","baseUri","earlyReturn","some","BaseURL","isRelative","resolve","url","SERVICE_LOCATION","serviceLocation","DVB_PRIORITY","dvb_priority","DVB_WEIGHT","dvb_weight","getLocation","LOCATION","Location","Location_asArray","getPatchLocation","PATCH_LOCATION","PatchLocation","PatchLocation_asArray","getSuggestedPresentationDelay","getAvailabilityStartTime","getServiceDescriptions","serviceDescriptions","SERVICE_DESCRIPTION","ServiceDescription_asArray","Symbol","sd","latency","playbackRate","SERVICE_DESCRIPTION_SCOPE","SERVICE_DESCRIPTION_LATENCY","target","min","SERVICE_DESCRIPTION_PLAYBACK_RATE","SERVICE_DESCRIPTION_LL_SCHEME","_didIteratorError","_iteratorError","_iterator","getSupplementalPropperties","supplementalProperties","SUPPLEMENTAL_PROPERTY","SupplementalProperty_asArray","sp","_didIteratorError2","_iteratorError2","_iterator2","setConfig","config","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/dash/models/DashManifestModel.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../../streaming/constants/Constants';\nimport DashConstants from '../constants/DashConstants';\nimport Representation from '../vo/Representation';\nimport AdaptationSet from '../vo/AdaptationSet';\nimport Period from '../vo/Period';\nimport Mpd from '../vo/Mpd';\nimport UTCTiming from '../vo/UTCTiming';\nimport Event from '../vo/Event';\nimport BaseURL from '../vo/BaseURL';\nimport EventStream from '../vo/EventStream';\nimport ObjectUtils from '../../streaming/utils/ObjectUtils';\nimport URLUtils from '../../streaming/utils/URLUtils';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport DashJSError from '../../streaming/vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\nimport {THUMBNAILS_SCHEME_ID_URIS} from '../../streaming/thumbnail/ThumbnailTracks';\n\nfunction DashManifestModel() {\n    let instance,\n        logger,\n        errHandler,\n        BASE64;\n\n    const context = this.context;\n    const urlUtils = URLUtils(context).getInstance();\n\n    const isInteger = Number.isInteger || function (value) {\n        return typeof value === 'number' &&\n            isFinite(value) &&\n            Math.floor(value) === value;\n    };\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function getIsTypeOf(adaptation, type) {\n\n        let i,\n            len,\n            representation,\n            col,\n            mimeTypeRegEx,\n            codecs;\n        let result = false;\n        let found = false;\n\n        if (!adaptation) {\n            throw new Error('adaptation is not defined');\n        }\n\n        if (!type) {\n            throw new Error('type is not defined');\n        }\n\n        if (adaptation.hasOwnProperty('ContentComponent_asArray')) {\n            col = adaptation.ContentComponent_asArray;\n        }\n\n        mimeTypeRegEx = (type !== Constants.TEXT) ? new RegExp(type) : new RegExp('(vtt|ttml)');\n\n        if (adaptation.Representation_asArray && adaptation.Representation_asArray.length && adaptation.Representation_asArray.length > 0) {\n            let essentialProperties = getEssentialPropertiesForRepresentation(adaptation.Representation_asArray[0]);\n            if (essentialProperties && essentialProperties.length > 0 && THUMBNAILS_SCHEME_ID_URIS.indexOf(essentialProperties[0].schemeIdUri) >= 0) {\n                return type === Constants.IMAGE;\n            }\n            if (adaptation.Representation_asArray[0].hasOwnProperty(DashConstants.CODECS)) {\n                // Just check the start of the codecs string\n                codecs = adaptation.Representation_asArray[0].codecs;\n                if (codecs.search(Constants.STPP) === 0 || codecs.search(Constants.WVTT) === 0) {\n                    return type === Constants.FRAGMENTED_TEXT;\n                }\n            }\n        }\n\n        if (col) {\n            if (col.length > 1) {\n                return (type === Constants.MUXED);\n            } else if (col[0] && col[0].contentType === type) {\n                result = true;\n                found = true;\n            }\n        }\n\n        if (adaptation.hasOwnProperty(DashConstants.MIME_TYPE)) {\n            result = mimeTypeRegEx.test(adaptation.mimeType);\n            found = true;\n        }\n\n        // couldn't find on adaptationset, so check a representation\n        if (!found) {\n            i = 0;\n            len = adaptation.Representation_asArray && adaptation.Representation_asArray.length ? adaptation.Representation_asArray.length : 0;\n            while (!found && i < len) {\n                representation = adaptation.Representation_asArray[i];\n\n                if (representation.hasOwnProperty(DashConstants.MIME_TYPE)) {\n                    result = mimeTypeRegEx.test(representation.mimeType);\n                    found = true;\n                }\n\n                i++;\n            }\n        }\n\n        return result;\n    }\n\n    function getIsAudio(adaptation) {\n        return getIsTypeOf(adaptation, Constants.AUDIO);\n    }\n\n    function getIsVideo(adaptation) {\n        return getIsTypeOf(adaptation, Constants.VIDEO);\n    }\n\n    function getIsFragmentedText(adaptation) {\n        return getIsTypeOf(adaptation, Constants.FRAGMENTED_TEXT);\n    }\n\n    function getIsMuxed(adaptation) {\n        return getIsTypeOf(adaptation, Constants.MUXED);\n    }\n\n    function getIsImage(adaptation) {\n        return getIsTypeOf(adaptation, Constants.IMAGE);\n    }\n\n    function getIsTextTrack(type) {\n        return (type === 'text/vtt' || type === 'application/ttml+xml');\n    }\n\n    function getLanguageForAdaptation(adaptation) {\n        let lang = '';\n\n        if (adaptation && adaptation.hasOwnProperty(DashConstants.LANG)) {\n            //Filter out any other characters not allowed according to RFC5646\n            lang = adaptation.lang.replace(/[^A-Za-z0-9-]/g, '');\n        }\n\n        return lang;\n    }\n\n    function getViewpointForAdaptation(adaptation) {\n        return adaptation && adaptation.hasOwnProperty(DashConstants.VIEWPOINT) ? adaptation.Viewpoint : null;\n    }\n\n    function getRolesForAdaptation(adaptation) {\n        return adaptation && adaptation.hasOwnProperty(DashConstants.ROLE_ASARRAY) ? adaptation.Role_asArray : [];\n    }\n\n    function getAccessibilityForAdaptation(adaptation) {\n        return adaptation && adaptation.hasOwnProperty(DashConstants.ACCESSIBILITY_ASARRAY) ? adaptation.Accessibility_asArray : [];\n    }\n\n    function getAudioChannelConfigurationForAdaptation(adaptation) {\n        return adaptation && adaptation.hasOwnProperty(DashConstants.AUDIOCHANNELCONFIGURATION_ASARRAY) ? adaptation.AudioChannelConfiguration_asArray : [];\n    }\n\n    function getAudioChannelConfigurationForRepresentation(representation) {\n        return representation && representation.hasOwnProperty(DashConstants.AUDIOCHANNELCONFIGURATION_ASARRAY) ? representation.AudioChannelConfiguration_asArray : [];\n    }\n\n    function getRepresentationSortFunction() {\n        return (a, b) => a.bandwidth - b.bandwidth;\n    }\n\n    function processAdaptation(realAdaptation) {\n        if (realAdaptation && Array.isArray(realAdaptation.Representation_asArray)) {\n            realAdaptation.Representation_asArray.sort(getRepresentationSortFunction());\n        }\n\n        return realAdaptation;\n    }\n\n    function getRealAdaptations(manifest, periodIndex) {\n        return manifest && manifest.Period_asArray && isInteger(periodIndex) ? manifest.Period_asArray[periodIndex] ? manifest.Period_asArray[periodIndex].AdaptationSet_asArray : [] : [];\n    }\n\n    function getRealPeriods(manifest) {\n        return manifest && manifest.Period_asArray ? manifest.Period_asArray : [];\n    }\n\n    function getRealPeriodForIndex(index, manifest) {\n        const realPeriods = getRealPeriods(manifest);\n        if (realPeriods.length > 0 && isInteger(index)) {\n            return realPeriods[index];\n        } else {\n            return null;\n        }\n    }\n\n    function getAdaptationForId(id, manifest, periodIndex) {\n        const realAdaptations = getRealAdaptations(manifest, periodIndex);\n        let i,\n            len;\n\n        for (i = 0, len = realAdaptations.length; i < len; i++) {\n            if (realAdaptations[i].hasOwnProperty(DashConstants.ID) && realAdaptations[i].id === id) {\n                return realAdaptations[i];\n            }\n        }\n\n        return null;\n    }\n\n    function getAdaptationForIndex(index, manifest, periodIndex) {\n        const realAdaptations = getRealAdaptations(manifest, periodIndex);\n        if (realAdaptations.length > 0 && isInteger(index)) {\n            return realAdaptations[index];\n        } else {\n            return null;\n        }\n    }\n\n    function getIndexForAdaptation(realAdaptation, manifest, periodIndex) {\n        if (!realAdaptation) {\n            return -1;\n        }\n\n        const realAdaptations = getRealAdaptations(manifest, periodIndex);\n\n        for (let i = 0; i < realAdaptations.length; i++) {\n            let objectUtils = ObjectUtils(context).getInstance();\n            if (objectUtils.areEqual(realAdaptations[i], realAdaptation)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    function getAdaptationsForType(manifest, periodIndex, type) {\n        const realAdaptations = getRealAdaptations(manifest, periodIndex);\n        let i,\n            len;\n        const adaptations = [];\n\n        for (i = 0, len = realAdaptations.length; i < len; i++) {\n            if (getIsTypeOf(realAdaptations[i], type)) {\n                adaptations.push(processAdaptation(realAdaptations[i]));\n            }\n        }\n\n        return adaptations;\n    }\n\n    function getCodec(adaptation, representationId, addResolutionInfo) {\n        let codec = null;\n\n        if (adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0) {\n            const representation = isInteger(representationId) && representationId >= 0 && representationId < adaptation.Representation_asArray.length ?\n                adaptation.Representation_asArray[representationId] : adaptation.Representation_asArray[0];\n            if (representation) {\n                codec = representation.mimeType + ';codecs=\"' + representation.codecs + '\"';\n                if (addResolutionInfo && representation.width !== undefined) {\n                    codec += ';width=\"' + representation.width + '\";height=\"' + representation.height + '\"';\n                }\n            }\n        }\n\n        // If the codec contains a profiles parameter we remove it. Otherwise it will cause problems when checking for codec capabilities of the platform\n        if (codec) {\n            codec = codec.replace(/\\sprofiles=[^;]*/g, '');\n        }\n\n        return codec;\n    }\n\n    function getMimeType(adaptation) {\n        return adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0 ? adaptation.Representation_asArray[0].mimeType : null;\n    }\n\n    function getKID(adaptation) {\n        if (!adaptation || !adaptation.hasOwnProperty(DashConstants.CENC_DEFAULT_KID)) {\n            return null;\n        }\n        return adaptation[DashConstants.CENC_DEFAULT_KID];\n    }\n\n    function getLabelsForAdaptation(adaptation) {\n        if (!adaptation || !Array.isArray(adaptation.Label_asArray)) {\n            return [];\n        }\n\n        const labelArray = [];\n\n        for (let i = 0; i < adaptation.Label_asArray.length; i++) {\n            labelArray.push({\n                lang: adaptation.Label_asArray[i].lang,\n                text: adaptation.Label_asArray[i].__text || adaptation.Label_asArray[i]\n            });\n        }\n\n        return labelArray;\n    }\n\n    function getContentProtectionData(adaptation) {\n        if (!adaptation || !adaptation.hasOwnProperty(DashConstants.CONTENTPROTECTION_ASARRAY) || adaptation.ContentProtection_asArray.length === 0) {\n            return null;\n        }\n        return adaptation.ContentProtection_asArray;\n    }\n\n    function getIsDynamic(manifest) {\n        let isDynamic = false;\n        if (manifest && manifest.hasOwnProperty('type')) {\n            isDynamic = (manifest.type === DashConstants.DYNAMIC);\n        }\n        return isDynamic;\n    }\n\n    function getId(manifest) {\n        return (manifest && manifest[DashConstants.ID]) || null;\n    }\n\n    function hasProfile(manifest, profile) {\n        let has = false;\n\n        if (manifest && manifest.profiles && manifest.profiles.length > 0) {\n            has = (manifest.profiles.indexOf(profile) !== -1);\n        }\n\n        return has;\n    }\n\n    function getDuration(manifest) {\n        let mpdDuration;\n        //@mediaPresentationDuration specifies the duration of the entire Media Presentation.\n        //If the attribute is not present, the duration of the Media Presentation is unknown.\n        if (manifest && manifest.hasOwnProperty(DashConstants.MEDIA_PRESENTATION_DURATION)) {\n            mpdDuration = manifest.mediaPresentationDuration;\n        } else if (manifest && manifest.type == 'dynamic') {\n            mpdDuration = Number.POSITIVE_INFINITY;\n        } else {\n            mpdDuration = Number.MAX_SAFE_INTEGER || Number.MAX_VALUE;\n        }\n\n        return mpdDuration;\n    }\n\n    function getBandwidth(representation) {\n        return representation && representation.bandwidth ? representation.bandwidth : NaN;\n    }\n\n    function getManifestUpdatePeriod(manifest, latencyOfLastUpdate = 0) {\n        let delay = NaN;\n        if (manifest && manifest.hasOwnProperty(DashConstants.MINIMUM_UPDATE_PERIOD)) {\n            delay = manifest.minimumUpdatePeriod;\n        }\n        return isNaN(delay) ? delay : Math.max(delay - latencyOfLastUpdate, 1);\n    }\n\n    function getPublishTime(manifest) {\n        return manifest && manifest.hasOwnProperty(DashConstants.PUBLISH_TIME) ? new Date(manifest[DashConstants.PUBLISH_TIME]) : null;\n    }\n\n    function getRepresentationCount(adaptation) {\n        return adaptation && Array.isArray(adaptation.Representation_asArray) ? adaptation.Representation_asArray.length : 0;\n    }\n\n    function getBitrateListForAdaptation(realAdaptation) {\n        const processedRealAdaptation = processAdaptation(realAdaptation);\n        const realRepresentations = processedRealAdaptation && Array.isArray(processedRealAdaptation.Representation_asArray) ? processedRealAdaptation.Representation_asArray : [];\n\n        return realRepresentations.map((realRepresentation) => {\n            return {\n                bandwidth: realRepresentation.bandwidth,\n                width: realRepresentation.width || 0,\n                height: realRepresentation.height || 0,\n                scanType: realRepresentation.scanType || null,\n                id: realRepresentation.id || null\n            };\n        });\n    }\n\n    function getEssentialPropertiesForRepresentation(realRepresentation) {\n        if (!realRepresentation || !realRepresentation.EssentialProperty_asArray || !realRepresentation.EssentialProperty_asArray.length) return null;\n\n        return realRepresentation.EssentialProperty_asArray.map((prop) => {\n            return {\n                schemeIdUri: prop.schemeIdUri,\n                value: prop.value\n            };\n        });\n    }\n\n    function getRepresentationFor(index, adaptation) {\n        return adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0 &&\n        isInteger(index) ? adaptation.Representation_asArray[index] : null;\n    }\n\n    function getRealAdaptationFor(voAdaptation) {\n        if (voAdaptation && voAdaptation.period && isInteger(voAdaptation.period.index)) {\n            const periodArray = voAdaptation.period.mpd.manifest.Period_asArray[voAdaptation.period.index];\n            if (periodArray && periodArray.AdaptationSet_asArray && isInteger(voAdaptation.index)) {\n                return processAdaptation(periodArray.AdaptationSet_asArray[voAdaptation.index]);\n            }\n        }\n    }\n\n    function getRepresentationsForAdaptation(voAdaptation) {\n        const voRepresentations = [];\n        const processedRealAdaptation = getRealAdaptationFor(voAdaptation);\n        let segmentInfo,\n            baseUrl;\n\n        if (processedRealAdaptation && processedRealAdaptation.Representation_asArray) {\n            // TODO: TO BE REMOVED. We should get just the baseUrl elements that affects to the representations\n            // that we are processing. Making it works properly will require much further changes and given\n            // parsing base Urls parameters is needed for our ultra low latency examples, we will\n            // keep this \"tricky\" code until the real (and good) solution comes\n            if (voAdaptation && voAdaptation.period && isInteger(voAdaptation.period.index)) {\n                const baseUrls = getBaseURLsFromElement(voAdaptation.period.mpd.manifest);\n                if (baseUrls) {\n                    baseUrl = baseUrls[0];\n                }\n            }\n            for (let i = 0, len = processedRealAdaptation.Representation_asArray.length; i < len; ++i) {\n                const realRepresentation = processedRealAdaptation.Representation_asArray[i];\n                const voRepresentation = new Representation();\n                voRepresentation.index = i;\n                voRepresentation.adaptation = voAdaptation;\n\n                if (realRepresentation.hasOwnProperty(DashConstants.ID)) {\n                    voRepresentation.id = realRepresentation.id;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.CODECS)) {\n                    voRepresentation.codecs = realRepresentation.codecs;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.CODEC_PRIVATE_DATA)) {\n                    voRepresentation.codecPrivateData = realRepresentation.codecPrivateData;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.BANDWITH)) {\n                    voRepresentation.bandwidth = realRepresentation.bandwidth;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.WIDTH)) {\n                    voRepresentation.width = realRepresentation.width;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.HEIGHT)) {\n                    voRepresentation.height = realRepresentation.height;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.SCAN_TYPE)) {\n                    voRepresentation.scanType = realRepresentation.scanType;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.MAX_PLAYOUT_RATE)) {\n                    voRepresentation.maxPlayoutRate = realRepresentation.maxPlayoutRate;\n                }\n\n                if (realRepresentation.hasOwnProperty(DashConstants.SEGMENT_BASE)) {\n                    segmentInfo = realRepresentation.SegmentBase;\n                    voRepresentation.segmentInfoType = DashConstants.SEGMENT_BASE;\n                } else if (realRepresentation.hasOwnProperty(DashConstants.SEGMENT_LIST)) {\n                    segmentInfo = realRepresentation.SegmentList;\n\n                    if (segmentInfo.hasOwnProperty(DashConstants.SEGMENT_TIMELINE)) {\n                        voRepresentation.segmentInfoType = DashConstants.SEGMENT_TIMELINE;\n                    } else {\n                        voRepresentation.segmentInfoType = DashConstants.SEGMENT_LIST;\n                    }\n                } else if (realRepresentation.hasOwnProperty(DashConstants.SEGMENT_TEMPLATE)) {\n                    segmentInfo = realRepresentation.SegmentTemplate;\n\n                    if (segmentInfo.hasOwnProperty(DashConstants.SEGMENT_TIMELINE)) {\n                        voRepresentation.segmentInfoType = DashConstants.SEGMENT_TIMELINE;\n                    } else {\n                        voRepresentation.segmentInfoType = DashConstants.SEGMENT_TEMPLATE;\n                    }\n\n                    if (segmentInfo.hasOwnProperty(DashConstants.INITIALIZATION_MINUS)) {\n                        voRepresentation.initialization = segmentInfo.initialization.split('$Bandwidth$')\n                            .join(realRepresentation.bandwidth).split('$RepresentationID$').join(realRepresentation.id);\n                    }\n                } else {\n                    voRepresentation.segmentInfoType = DashConstants.BASE_URL;\n                }\n\n                voRepresentation.essentialProperties = getEssentialPropertiesForRepresentation(realRepresentation);\n\n                if (segmentInfo) {\n                    if (segmentInfo.hasOwnProperty(DashConstants.INITIALIZATION)) {\n                        const initialization = segmentInfo.Initialization;\n\n                        if (initialization.hasOwnProperty(DashConstants.SOURCE_URL)) {\n                            voRepresentation.initialization = initialization.sourceURL;\n                        }\n\n                        if (initialization.hasOwnProperty(DashConstants.RANGE)) {\n                            voRepresentation.range = initialization.range;\n                            // initialization source url will be determined from\n                            // BaseURL when resolved at load time.\n                        }\n                    } else if (realRepresentation.hasOwnProperty(DashConstants.MIME_TYPE) && getIsTextTrack(realRepresentation.mimeType)) {\n                        voRepresentation.range = 0;\n                    }\n\n                    if (segmentInfo.hasOwnProperty(DashConstants.TIMESCALE)) {\n                        voRepresentation.timescale = segmentInfo.timescale;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.DURATION)) {\n                        // TODO according to the spec @maxSegmentDuration specifies the maximum duration of any Segment in any Representation in the Media Presentation\n                        // It is also said that for a SegmentTimeline any @d value shall not exceed the value of MPD@maxSegmentDuration, but nothing is said about\n                        // SegmentTemplate @duration attribute. We need to find out if @maxSegmentDuration should be used instead of calculated duration if the the duration\n                        // exceeds @maxSegmentDuration\n                        voRepresentation.segmentDuration = segmentInfo.duration / voRepresentation.timescale;\n                    } else if (realRepresentation.hasOwnProperty(DashConstants.SEGMENT_TEMPLATE)) {\n                        segmentInfo = realRepresentation.SegmentTemplate;\n\n                        if (segmentInfo.hasOwnProperty(DashConstants.SEGMENT_TIMELINE)) {\n                            voRepresentation.segmentDuration = calcSegmentDuration(segmentInfo.SegmentTimeline) / voRepresentation.timescale;\n                        }\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.MEDIA)) {\n                        voRepresentation.media = segmentInfo.media;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.START_NUMBER)) {\n                        voRepresentation.startNumber = segmentInfo.startNumber;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.INDEX_RANGE)) {\n                        voRepresentation.indexRange = segmentInfo.indexRange;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.PRESENTATION_TIME_OFFSET)) {\n                        voRepresentation.presentationTimeOffset = segmentInfo.presentationTimeOffset / voRepresentation.timescale;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.AVAILABILITY_TIME_OFFSET)) {\n                        voRepresentation.availabilityTimeOffset = segmentInfo.availabilityTimeOffset;\n                    } else if (baseUrl && baseUrl.availabilityTimeOffset !== undefined) {\n                        voRepresentation.availabilityTimeOffset = baseUrl.availabilityTimeOffset;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.AVAILABILITY_TIME_COMPLETE)) {\n                        voRepresentation.availabilityTimeComplete = segmentInfo.availabilityTimeComplete !== 'false';\n                    } else if (baseUrl && baseUrl.availabilityTimeComplete !== undefined) {\n                        voRepresentation.availabilityTimeComplete = baseUrl.availabilityTimeComplete;\n                    }\n                }\n\n                voRepresentation.MSETimeOffset = calcMSETimeOffset(voRepresentation);\n                voRepresentation.path = [voAdaptation.period.index, voAdaptation.index, i];\n                voRepresentations.push(voRepresentation);\n            }\n        }\n\n        return voRepresentations;\n    }\n\n    function calcSegmentDuration(segmentTimeline) {\n        let s0 = segmentTimeline.S_asArray[0];\n        let s1 = segmentTimeline.S_asArray[1];\n        return s0.hasOwnProperty('d') ? s0.d : (s1.t - s0.t);\n    }\n\n    function calcMSETimeOffset(representation) {\n        // The MSEOffset is offset from AST for media. It is Period@start - presentationTimeOffset\n        const presentationOffset = representation.presentationTimeOffset;\n        const periodStart = representation.adaptation.period.start;\n        return (periodStart - presentationOffset);\n    }\n\n    function getAdaptationsForPeriod(voPeriod) {\n        const realPeriod = voPeriod && isInteger(voPeriod.index) ? voPeriod.mpd.manifest.Period_asArray[voPeriod.index] : null;\n        const voAdaptations = [];\n        let voAdaptationSet,\n            realAdaptationSet,\n            i;\n\n        if (realPeriod && realPeriod.AdaptationSet_asArray) {\n            for (i = 0; i < realPeriod.AdaptationSet_asArray.length; i++) {\n                realAdaptationSet = realPeriod.AdaptationSet_asArray[i];\n                voAdaptationSet = new AdaptationSet();\n                if (realAdaptationSet.hasOwnProperty(DashConstants.ID)) {\n                    voAdaptationSet.id = realAdaptationSet.id;\n                }\n                voAdaptationSet.index = i;\n                voAdaptationSet.period = voPeriod;\n\n                if (getIsMuxed(realAdaptationSet)) {\n                    voAdaptationSet.type = Constants.MUXED;\n                } else if (getIsAudio(realAdaptationSet)) {\n                    voAdaptationSet.type = Constants.AUDIO;\n                } else if (getIsVideo(realAdaptationSet)) {\n                    voAdaptationSet.type = Constants.VIDEO;\n                } else if (getIsFragmentedText(realAdaptationSet)) {\n                    voAdaptationSet.type = Constants.FRAGMENTED_TEXT;\n                } else if (getIsImage(realAdaptationSet)) {\n                    voAdaptationSet.type = Constants.IMAGE;\n                } else {\n                    voAdaptationSet.type = Constants.TEXT;\n                }\n                voAdaptations.push(voAdaptationSet);\n            }\n        }\n\n        return voAdaptations;\n    }\n\n    function getRegularPeriods(mpd) {\n        const isDynamic = mpd ? getIsDynamic(mpd.manifest) : false;\n        const voPeriods = [];\n        let realPreviousPeriod = null;\n        let realPeriod = null;\n        let voPreviousPeriod = null;\n        let voPeriod = null;\n        let len,\n            i;\n\n        for (i = 0, len = mpd && mpd.manifest && mpd.manifest.Period_asArray ? mpd.manifest.Period_asArray.length : 0; i < len; i++) {\n            realPeriod = mpd.manifest.Period_asArray[i];\n\n            // If the attribute @start is present in the Period, then the\n            // Period is a regular Period and the PeriodStart is equal\n            // to the value of this attribute.\n            if (realPeriod.hasOwnProperty(DashConstants.START)) {\n                voPeriod = new Period();\n                voPeriod.start = realPeriod.start;\n            }\n            // If the @start attribute is absent, but the previous Period\n            // element contains a @duration attribute then then this new\n            // Period is also a regular Period. The start time of the new\n            // Period PeriodStart is the sum of the start time of the previous\n            // Period PeriodStart and the value of the attribute @duration\n            // of the previous Period.\n            else if (realPreviousPeriod !== null && realPreviousPeriod.hasOwnProperty(DashConstants.DURATION) && voPreviousPeriod !== null) {\n                voPeriod = new Period();\n                voPeriod.start = parseFloat((voPreviousPeriod.start + voPreviousPeriod.duration).toFixed(5));\n            }\n            // If (i) @start attribute is absent, and (ii) the Period element\n            // is the first in the MPD, and (iii) the MPD@type is 'static',\n            // then the PeriodStart time shall be set to zero.\n            else if (i === 0 && !isDynamic) {\n                voPeriod = new Period();\n                voPeriod.start = 0;\n            }\n\n            // The Period extends until the PeriodStart of the next Period.\n            // The difference between the PeriodStart time of a Period and\n            // the PeriodStart time of the following Period.\n            if (voPreviousPeriod !== null && isNaN(voPreviousPeriod.duration)) {\n                if (voPeriod !== null) {\n                    voPreviousPeriod.duration = parseFloat((voPeriod.start - voPreviousPeriod.start).toFixed(5));\n                } else {\n                    logger.warn('First period duration could not be calculated because lack of start and duration period properties. This will cause timing issues during playback');\n                }\n            }\n\n            if (voPeriod !== null) {\n                voPeriod.id = getPeriodId(realPeriod, i);\n                voPeriod.index = i;\n                voPeriod.mpd = mpd;\n\n                if (realPeriod.hasOwnProperty(DashConstants.DURATION)) {\n                    voPeriod.duration = realPeriod.duration;\n                }\n\n                voPeriods.push(voPeriod);\n                realPreviousPeriod = realPeriod;\n                voPreviousPeriod = voPeriod;\n            }\n\n            realPeriod = null;\n            voPeriod = null;\n        }\n\n        if (voPeriods.length === 0) {\n            return voPeriods;\n        }\n\n        // The last Period extends until the end of the Media Presentation.\n        // The difference between the PeriodStart time of the last Period\n        // and the mpd duration\n        if (voPreviousPeriod !== null && isNaN(voPreviousPeriod.duration)) {\n            voPreviousPeriod.duration = parseFloat((getEndTimeForLastPeriod(voPreviousPeriod) - voPreviousPeriod.start).toFixed(5));\n        }\n\n        return voPeriods;\n    }\n\n    function getPeriodId(realPeriod, i) {\n        if (!realPeriod) {\n            throw new Error('Period cannot be null or undefined');\n        }\n\n        let id = Period.DEFAULT_ID + '_' + i;\n\n        if (realPeriod.hasOwnProperty(DashConstants.ID) && realPeriod.id.length > 0 && realPeriod.id !== '__proto__') {\n            id = realPeriod.id;\n        }\n\n        return id;\n    }\n\n    function getMpd(manifest) {\n        const mpd = new Mpd();\n\n        if (manifest) {\n            mpd.manifest = manifest;\n\n            if (manifest.hasOwnProperty(DashConstants.AVAILABILITY_START_TIME)) {\n                mpd.availabilityStartTime = new Date(manifest.availabilityStartTime.getTime());\n            } else {\n                if (manifest.loadedTime) {\n                    mpd.availabilityStartTime = new Date(manifest.loadedTime.getTime());\n                }\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.AVAILABILITY_END_TIME)) {\n                mpd.availabilityEndTime = new Date(manifest.availabilityEndTime.getTime());\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.MINIMUM_UPDATE_PERIOD)) {\n                mpd.minimumUpdatePeriod = manifest.minimumUpdatePeriod;\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.MEDIA_PRESENTATION_DURATION)) {\n                mpd.mediaPresentationDuration = manifest.mediaPresentationDuration;\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.SUGGESTED_PRESENTATION_DELAY)) {\n                mpd.suggestedPresentationDelay = manifest.suggestedPresentationDelay;\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.TIMESHIFT_BUFFER_DEPTH)) {\n                mpd.timeShiftBufferDepth = manifest.timeShiftBufferDepth;\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.MAX_SEGMENT_DURATION)) {\n                mpd.maxSegmentDuration = manifest.maxSegmentDuration;\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.PUBLISH_TIME)) {\n                mpd.publishTime = new Date(manifest.publishTime);\n            }\n        }\n\n        return mpd;\n    }\n\n    function checkConfig() {\n        if (!errHandler || !errHandler.hasOwnProperty('error')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function getEndTimeForLastPeriod(voPeriod) {\n        checkConfig();\n        const isDynamic = getIsDynamic(voPeriod.mpd.manifest);\n\n        let periodEnd;\n        if (voPeriod.mpd.manifest.mediaPresentationDuration) {\n            periodEnd = voPeriod.mpd.manifest.mediaPresentationDuration;\n        } else if (voPeriod.duration) {\n            periodEnd = voPeriod.duration;\n        } else if (isDynamic) {\n            periodEnd = Number.POSITIVE_INFINITY;\n        } else {\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_PARSE_CODE, 'Must have @mediaPresentationDuration on MPD or an explicit @duration on the last period.', voPeriod));\n        }\n\n        return periodEnd;\n    }\n\n    function getEventsForPeriod(period) {\n        const manifest = period && period.mpd && period.mpd.manifest ? period.mpd.manifest : null;\n        const periodArray = manifest ? manifest.Period_asArray : null;\n        const eventStreams = periodArray && period && isInteger(period.index) ? periodArray[period.index].EventStream_asArray : null;\n        const events = [];\n        let i,\n            j;\n\n        if (eventStreams) {\n            for (i = 0; i < eventStreams.length; i++) {\n                const eventStream = new EventStream();\n                eventStream.period = period;\n                eventStream.timescale = 1;\n\n                if (eventStreams[i].hasOwnProperty(Constants.SCHEME_ID_URI)) {\n                    eventStream.schemeIdUri = eventStreams[i][Constants.SCHEME_ID_URI];\n                } else {\n                    throw new Error('Invalid EventStream. SchemeIdUri has to be set');\n                }\n                if (eventStreams[i].hasOwnProperty(DashConstants.TIMESCALE)) {\n                    eventStream.timescale = eventStreams[i][DashConstants.TIMESCALE];\n                }\n                if (eventStreams[i].hasOwnProperty(DashConstants.VALUE)) {\n                    eventStream.value = eventStreams[i][DashConstants.VALUE];\n                }\n                if (eventStreams[i].hasOwnProperty(DashConstants.PRESENTATION_TIME_OFFSET)) {\n                    eventStream.presentationTimeOffset = eventStreams[i][DashConstants.PRESENTATION_TIME_OFFSET];\n                }\n                for (j = 0; eventStreams[i].Event_asArray && j < eventStreams[i].Event_asArray.length; j++) {\n                    const currentMpdEvent = eventStreams[i].Event_asArray[j];\n                    const event = new Event();\n                    event.presentationTime = 0;\n                    event.eventStream = eventStream;\n\n                    if (currentMpdEvent.hasOwnProperty(DashConstants.PRESENTATION_TIME)) {\n                        event.presentationTime = currentMpdEvent.presentationTime;\n                        const presentationTimeOffset = eventStream.presentationTimeOffset ? eventStream.presentationTimeOffset / eventStream.timescale : 0;\n                        event.calculatedPresentationTime = event.presentationTime / eventStream.timescale + period.start - presentationTimeOffset;\n                    }\n                    if (currentMpdEvent.hasOwnProperty(DashConstants.DURATION)) {\n                        event.duration = currentMpdEvent.duration / eventStream.timescale;\n                    }\n                    if (currentMpdEvent.hasOwnProperty(DashConstants.ID)) {\n                        event.id = currentMpdEvent.id;\n                    }\n\n                    if (currentMpdEvent.Signal && currentMpdEvent.Signal.Binary) {\n                        // toString is used to manage both regular and namespaced tags\n                        event.messageData = BASE64.decodeArray(currentMpdEvent.Signal.Binary.toString());\n                    } else {\n                        // From Cor.1: 'NOTE: this attribute is an alternative\n                        // to specifying a complete XML element(s) in the Event.\n                        // It is useful when an event leans itself to a compact\n                        // string representation'.\n                        event.messageData =\n                            currentMpdEvent.messageData ||\n                            currentMpdEvent.__text;\n                    }\n\n                    events.push(event);\n                }\n            }\n        }\n\n        return events;\n    }\n\n    function getEventStreams(inbandStreams, representation) {\n        const eventStreams = [];\n        let i;\n\n        if (!inbandStreams) return eventStreams;\n\n        for (i = 0; i < inbandStreams.length; i++) {\n            const eventStream = new EventStream();\n            eventStream.timescale = 1;\n            eventStream.representation = representation;\n\n            if (inbandStreams[i].hasOwnProperty(Constants.SCHEME_ID_URI)) {\n                eventStream.schemeIdUri = inbandStreams[i].schemeIdUri;\n            } else {\n                throw new Error('Invalid EventStream. SchemeIdUri has to be set');\n            }\n            if (inbandStreams[i].hasOwnProperty(DashConstants.TIMESCALE)) {\n                eventStream.timescale = inbandStreams[i].timescale;\n            }\n            if (inbandStreams[i].hasOwnProperty(DashConstants.VALUE)) {\n                eventStream.value = inbandStreams[i].value;\n            }\n            eventStreams.push(eventStream);\n        }\n\n        return eventStreams;\n    }\n\n    function getEventStreamForAdaptationSet(manifest, adaptation) {\n        let inbandStreams,\n            periodArray,\n            adaptationArray;\n\n        if (manifest && manifest.Period_asArray && adaptation && adaptation.period && isInteger(adaptation.period.index)) {\n            periodArray = manifest.Period_asArray[adaptation.period.index];\n            if (periodArray && periodArray.AdaptationSet_asArray && isInteger(adaptation.index)) {\n                adaptationArray = periodArray.AdaptationSet_asArray[adaptation.index];\n                if (adaptationArray) {\n                    inbandStreams = adaptationArray.InbandEventStream_asArray;\n                }\n            }\n        }\n\n        return getEventStreams(inbandStreams, null);\n    }\n\n    function getEventStreamForRepresentation(manifest, representation) {\n        let inbandStreams,\n            periodArray,\n            adaptationArray,\n            representationArray;\n\n        if (manifest && manifest.Period_asArray && representation && representation.adaptation && representation.adaptation.period && isInteger(representation.adaptation.period.index)) {\n            periodArray = manifest.Period_asArray[representation.adaptation.period.index];\n            if (periodArray && periodArray.AdaptationSet_asArray && isInteger(representation.adaptation.index)) {\n                adaptationArray = periodArray.AdaptationSet_asArray[representation.adaptation.index];\n                if (adaptationArray && adaptationArray.Representation_asArray && isInteger(representation.index)) {\n                    representationArray = adaptationArray.Representation_asArray[representation.index];\n                    if (representationArray) {\n                        inbandStreams = representationArray.InbandEventStream_asArray;\n                    }\n                }\n            }\n        }\n\n        return getEventStreams(inbandStreams, representation);\n    }\n\n    function getUTCTimingSources(manifest) {\n        const isDynamic = getIsDynamic(manifest);\n        const hasAST = manifest ? manifest.hasOwnProperty(DashConstants.AVAILABILITY_START_TIME) : false;\n        const utcTimingsArray = manifest ? manifest.UTCTiming_asArray : null;\n        const utcTimingEntries = [];\n\n        // do not bother synchronizing the clock unless MPD is live,\n        // or it is static and has availabilityStartTime attribute\n        if ((isDynamic || hasAST)) {\n            if (utcTimingsArray) {\n                // the order is important here - 23009-1 states that the order\n                // in the manifest \"indicates relative preference, first having\n                // the highest, and the last the lowest priority\".\n                utcTimingsArray.forEach(function (utcTiming) {\n                    const entry = new UTCTiming();\n\n                    if (utcTiming.hasOwnProperty(Constants.SCHEME_ID_URI)) {\n                        entry.schemeIdUri = utcTiming.schemeIdUri;\n                    } else {\n                        // entries of type DescriptorType with no schemeIdUri\n                        // are meaningless. let's just ignore this entry and\n                        // move on.\n                        return;\n                    }\n\n                    // this is (incorrectly) interpreted as a number - schema\n                    // defines it as a string\n                    if (utcTiming.hasOwnProperty(DashConstants.VALUE)) {\n                        entry.value = utcTiming.value.toString();\n                    } else {\n                        // without a value, there's not a lot we can do with\n                        // this entry. let's just ignore this one and move on\n                        return;\n                    }\n\n                    // we're not interested in the optional id or any other\n                    // attributes which might be attached to the entry\n\n                    utcTimingEntries.push(entry);\n                });\n            }\n        }\n\n        return utcTimingEntries;\n    }\n\n    function getBaseURLsFromElement(node) {\n        const baseUrls = [];\n        // if node.BaseURL_asArray and node.baseUri are undefined entries\n        // will be [undefined] which entries.some will just skip\n        const entries = node.BaseURL_asArray || [node.baseUri];\n        let earlyReturn = false;\n\n        entries.some(entry => {\n            if (entry) {\n                const baseUrl = new BaseURL();\n                let text = entry.__text || entry;\n\n                if (urlUtils.isRelative(text)) {\n                    // it doesn't really make sense to have relative and\n                    // absolute URLs at the same level, or multiple\n                    // relative URLs at the same level, so assume we are\n                    // done from this level of the MPD\n                    earlyReturn = true;\n\n                    // deal with the specific case where the MPD@BaseURL\n                    // is specified and is relative. when no MPD@BaseURL\n                    // entries exist, that case is handled by the\n                    // [node.baseUri] in the entries definition.\n                    if (node.baseUri) {\n                        text = urlUtils.resolve(text, node.baseUri);\n                    }\n                }\n\n                baseUrl.url = text;\n\n                // serviceLocation is optional, but we need it in order\n                // to blacklist correctly. if it's not available, use\n                // anything unique since there's no relationship to any\n                // other BaseURL and, in theory, the url should be\n                // unique so use this instead.\n                if (entry.hasOwnProperty(DashConstants.SERVICE_LOCATION) &&\n                    entry.serviceLocation.length) {\n                    baseUrl.serviceLocation = entry.serviceLocation;\n                } else {\n                    baseUrl.serviceLocation = text;\n                }\n\n                if (entry.hasOwnProperty(DashConstants.DVB_PRIORITY)) {\n                    baseUrl.dvb_priority = entry[DashConstants.DVB_PRIORITY];\n                }\n\n                if (entry.hasOwnProperty(DashConstants.DVB_WEIGHT)) {\n                    baseUrl.dvb_weight = entry[DashConstants.DVB_WEIGHT];\n                }\n\n                if (entry.hasOwnProperty(DashConstants.AVAILABILITY_TIME_OFFSET)) {\n                    baseUrl.availabilityTimeOffset = entry[DashConstants.AVAILABILITY_TIME_OFFSET];\n                }\n\n                if (entry.hasOwnProperty(DashConstants.AVAILABILITY_TIME_COMPLETE)) {\n                    baseUrl.availabilityTimeComplete = entry[DashConstants.AVAILABILITY_TIME_COMPLETE] !== 'false';\n                }\n                /* NOTE: byteRange currently unused\n                 */\n\n                baseUrls.push(baseUrl);\n\n                return earlyReturn;\n            }\n        });\n\n        return baseUrls;\n    }\n\n    function getLocation(manifest) {\n        if (manifest && manifest.hasOwnProperty(Constants.LOCATION)) {\n            // for now, do not support multiple Locations -\n            // just set Location to the first Location.\n            manifest.Location = manifest.Location_asArray[0];\n\n            return manifest.Location;\n        }\n\n        // may well be undefined\n        return undefined;\n    }\n\n    function getPatchLocation(manifest) {\n        if (manifest && manifest.hasOwnProperty(DashConstants.PATCH_LOCATION)) {\n            // only include support for single patch location currently\n            manifest.PatchLocation = manifest.PatchLocation_asArray[0];\n\n            return manifest.PatchLocation;\n        }\n\n        // no patch location provided\n        return undefined;\n    }\n\n    function getSuggestedPresentationDelay(mpd) {\n        return mpd && mpd.hasOwnProperty(DashConstants.SUGGESTED_PRESENTATION_DELAY) ? mpd.suggestedPresentationDelay : null;\n    }\n\n    function getAvailabilityStartTime(mpd) {\n        return mpd && mpd.hasOwnProperty(DashConstants.AVAILABILITY_START_TIME) && mpd.availabilityStartTime !== null ? mpd.availabilityStartTime.getTime() : null;\n    }\n\n    function getServiceDescriptions(manifest) {\n        const serviceDescriptions = [];\n        if (manifest && manifest.hasOwnProperty(DashConstants.SERVICE_DESCRIPTION)) {\n            for (const sd of manifest.ServiceDescription_asArray) {\n                // Convert each of the properties defined in\n                let id, schemeIdUri, latency, playbackRate;\n                for (const prop in sd) {\n                    if (sd.hasOwnProperty(prop)) {\n                        if (prop === DashConstants.ID) {\n                            id = sd[prop];\n                        } else if (prop === DashConstants.SERVICE_DESCRIPTION_SCOPE) {\n                            schemeIdUri = sd[prop].schemeIdUri;\n                        } else if (prop === DashConstants.SERVICE_DESCRIPTION_LATENCY) {\n                            latency = {\n                                target: sd[prop].target,\n                                max: sd[prop].max,\n                                min: sd[prop].min\n                            };\n                        } else if (prop === DashConstants.SERVICE_DESCRIPTION_PLAYBACK_RATE) {\n                            playbackRate = {\n                                max: sd[prop].max,\n                                min: sd[prop].min\n                            };\n                        }\n                    }\n                }\n                // we have a ServiceDescription for low latency. Add it if it really has parameters defined\n                if (schemeIdUri === Constants.SERVICE_DESCRIPTION_LL_SCHEME && (latency || playbackRate)) {\n                    serviceDescriptions.push({\n                        id,\n                        schemeIdUri,\n                        latency,\n                        playbackRate\n                    });\n                }\n            }\n        }\n\n        return serviceDescriptions;\n    }\n\n    function getSupplementalPropperties(adaptation) {\n        const supplementalProperties = {};\n\n        if (adaptation && adaptation.hasOwnProperty(DashConstants.SUPPLEMENTAL_PROPERTY)) {\n            for (const sp of adaptation.SupplementalProperty_asArray) {\n                if (sp.hasOwnProperty(Constants.SCHEME_ID_URI) && sp.hasOwnProperty(DashConstants.VALUE)) {\n                    supplementalProperties[sp[Constants.SCHEME_ID_URI]] = sp[DashConstants.VALUE];\n                }\n            }\n        }\n        return supplementalProperties;\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n\n        if (config.BASE64) {\n            BASE64 = config.BASE64;\n        }\n    }\n\n    instance = {\n        getIsTypeOf: getIsTypeOf,\n        getIsTextTrack: getIsTextTrack,\n        getLanguageForAdaptation: getLanguageForAdaptation,\n        getViewpointForAdaptation: getViewpointForAdaptation,\n        getRolesForAdaptation: getRolesForAdaptation,\n        getAccessibilityForAdaptation: getAccessibilityForAdaptation,\n        getAudioChannelConfigurationForAdaptation: getAudioChannelConfigurationForAdaptation,\n        getAudioChannelConfigurationForRepresentation: getAudioChannelConfigurationForRepresentation,\n        getAdaptationForIndex: getAdaptationForIndex,\n        getIndexForAdaptation: getIndexForAdaptation,\n        getAdaptationForId: getAdaptationForId,\n        getAdaptationsForType: getAdaptationsForType,\n        getRealPeriods,\n        getRealPeriodForIndex,\n        getCodec: getCodec,\n        getMimeType: getMimeType,\n        getKID: getKID,\n        getLabelsForAdaptation: getLabelsForAdaptation,\n        getContentProtectionData: getContentProtectionData,\n        getIsDynamic: getIsDynamic,\n        getId: getId,\n        hasProfile: hasProfile,\n        getDuration: getDuration,\n        getBandwidth: getBandwidth,\n        getManifestUpdatePeriod: getManifestUpdatePeriod,\n        getPublishTime: getPublishTime,\n        getRepresentationCount: getRepresentationCount,\n        getBitrateListForAdaptation: getBitrateListForAdaptation,\n        getRepresentationFor: getRepresentationFor,\n        getRepresentationsForAdaptation: getRepresentationsForAdaptation,\n        getAdaptationsForPeriod: getAdaptationsForPeriod,\n        getRegularPeriods: getRegularPeriods,\n        getMpd: getMpd,\n        getEventsForPeriod: getEventsForPeriod,\n        getEssentialPropertiesForRepresentation,\n        getEventStreamForAdaptationSet: getEventStreamForAdaptationSet,\n        getEventStreamForRepresentation: getEventStreamForRepresentation,\n        getUTCTimingSources: getUTCTimingSources,\n        getBaseURLsFromElement: getBaseURLsFromElement,\n        getRepresentationSortFunction: getRepresentationSortFunction,\n        getLocation: getLocation,\n        getPatchLocation: getPatchLocation,\n        getSuggestedPresentationDelay: getSuggestedPresentationDelay,\n        getAvailabilityStartTime: getAvailabilityStartTime,\n        getServiceDescriptions: getServiceDescriptions,\n        getSupplementalPropperties: getSupplementalPropperties,\n        setConfig: setConfig\n    };\n\n    setup();\n\n    return instance;\n}\n\nDashManifestModel.__dashjs_factory_name = 'DashManifestModel';\nexport default FactoryMaker.getSingletonFactory(DashManifestModel);\n"]},"metadata":{},"sourceType":"script"}