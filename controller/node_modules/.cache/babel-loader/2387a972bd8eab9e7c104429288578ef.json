{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _MetricsConstants = require('../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _MetricsList = require('../vo/MetricsList');\n\nvar _MetricsList2 = _interopRequireDefault(_MetricsList);\n\nvar _HTTPRequest = require('../vo/metrics/HTTPRequest');\n\nvar _RepresentationSwitch = require('../vo/metrics/RepresentationSwitch');\n\nvar _RepresentationSwitch2 = _interopRequireDefault(_RepresentationSwitch);\n\nvar _BufferLevel = require('../vo/metrics/BufferLevel');\n\nvar _BufferLevel2 = _interopRequireDefault(_BufferLevel);\n\nvar _BufferState = require('../vo/metrics/BufferState');\n\nvar _BufferState2 = _interopRequireDefault(_BufferState);\n\nvar _DVRInfo = require('../vo/metrics/DVRInfo');\n\nvar _DVRInfo2 = _interopRequireDefault(_DVRInfo);\n\nvar _DroppedFrames = require('../vo/metrics/DroppedFrames');\n\nvar _DroppedFrames2 = _interopRequireDefault(_DroppedFrames);\n\nvar _ManifestUpdate = require('../vo/metrics/ManifestUpdate');\n\nvar _SchedulingInfo = require('../vo/metrics/SchedulingInfo');\n\nvar _SchedulingInfo2 = _interopRequireDefault(_SchedulingInfo);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _RequestsQueue = require('../vo/metrics/RequestsQueue');\n\nvar _RequestsQueue2 = _interopRequireDefault(_RequestsQueue);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction MetricsModel(config) {\n  config = config || {};\n  var settings = config.settings;\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      streamMetrics = void 0;\n\n  function setup() {\n    streamMetrics = {};\n  }\n\n  function metricsChanged() {\n    eventBus.trigger(_Events2.default.METRICS_CHANGED);\n  }\n\n  function metricChanged(mediaType) {\n    eventBus.trigger(_Events2.default.METRIC_CHANGED, {\n      mediaType: mediaType\n    });\n    metricsChanged();\n  }\n\n  function metricUpdated(mediaType, metricType, vo) {\n    eventBus.trigger(_Events2.default.METRIC_UPDATED, {\n      mediaType: mediaType,\n      metric: metricType,\n      value: vo\n    });\n    metricChanged(mediaType);\n  }\n\n  function metricAdded(mediaType, metricType, vo) {\n    eventBus.trigger(_Events2.default.METRIC_ADDED, {\n      mediaType: mediaType,\n      metric: metricType,\n      value: vo\n    });\n    metricChanged(mediaType);\n  }\n\n  function clearCurrentMetricsForType(type) {\n    delete streamMetrics[type];\n    metricChanged(type);\n  }\n\n  function clearAllCurrentMetrics() {\n    streamMetrics = {};\n    metricsChanged();\n  }\n\n  function getMetricsFor(type, readOnly) {\n    var metrics = null;\n\n    if (!type) {\n      return metrics;\n    }\n\n    if (streamMetrics.hasOwnProperty(type)) {\n      metrics = streamMetrics[type];\n    } else if (!readOnly) {\n      metrics = new _MetricsList2.default();\n      streamMetrics[type] = metrics;\n    }\n\n    return metrics;\n  }\n\n  function pushMetrics(type, list, value) {\n    var metrics = getMetricsFor(type);\n\n    if (metrics !== null) {\n      metrics[list].push(value);\n\n      if (metrics[list].length > settings.get().streaming.metricsMaxListDepth) {\n        metrics[list].shift();\n      }\n    }\n  }\n\n  function appendHttpTrace(httpRequest, s, d, b) {\n    var vo = new _HTTPRequest.HTTPRequestTrace();\n    vo.s = s;\n    vo.d = d;\n    vo.b = b;\n    httpRequest.trace.push(vo);\n\n    if (!httpRequest.interval) {\n      httpRequest.interval = 0;\n    }\n\n    httpRequest.interval += d;\n    return vo;\n  }\n\n  function addHttpRequest(mediaType, tcpid, type, url, quality, actualurl, serviceLocation, range, trequest, tresponse, tfinish, responsecode, mediaduration, responseHeaders, traces) {\n    var vo = new _HTTPRequest.HTTPRequest(); // ISO 23009-1 D.4.3 NOTE 2:\n    // All entries for a given object will have the same URL and range\n    // and so can easily be correlated. If there were redirects or\n    // failures there will be one entry for each redirect/failure.\n    // The redirect-to URL or alternative url (where multiple have been\n    // provided in the MPD) will appear as the actualurl of the next\n    // entry with the same url value.\n\n    if (actualurl && actualurl !== url) {\n      // given the above, add an entry for the original request\n      addHttpRequest(mediaType, null, type, url, quality, null, null, range, trequest, null, // unknown\n      null, // unknown\n      null, // unknown, probably a 302\n      mediaduration, null, null);\n      vo.actualurl = actualurl;\n    }\n\n    vo.tcpid = tcpid;\n    vo.type = type;\n    vo.url = url;\n    vo.range = range;\n    vo.trequest = trequest;\n    vo.tresponse = tresponse;\n    vo.responsecode = responsecode;\n    vo._tfinish = tfinish;\n    vo._stream = mediaType;\n    vo._mediaduration = mediaduration;\n    vo._quality = quality;\n    vo._responseHeaders = responseHeaders;\n    vo._serviceLocation = serviceLocation;\n\n    if (traces) {\n      traces.forEach(function (trace) {\n        appendHttpTrace(vo, trace.s, trace.d, trace.b);\n      });\n    } else {\n      // The interval and trace shall be absent for redirect and failure records.\n      delete vo.interval;\n      delete vo.trace;\n    }\n\n    pushAndNotify(mediaType, _MetricsConstants2.default.HTTP_REQUEST, vo);\n  }\n\n  function addRepresentationSwitch(mediaType, t, mt, to, lto) {\n    var vo = new _RepresentationSwitch2.default();\n    vo.t = t;\n    vo.mt = mt;\n    vo.to = to;\n\n    if (lto) {\n      vo.lto = lto;\n    } else {\n      delete vo.lto;\n    }\n\n    pushAndNotify(mediaType, _MetricsConstants2.default.TRACK_SWITCH, vo);\n  }\n\n  function pushAndNotify(mediaType, metricType, metricObject) {\n    pushMetrics(mediaType, metricType, metricObject);\n    metricAdded(mediaType, metricType, metricObject);\n  }\n\n  function addBufferLevel(mediaType, t, level) {\n    var vo = new _BufferLevel2.default();\n    vo.t = t;\n    vo.level = level;\n    pushAndNotify(mediaType, _MetricsConstants2.default.BUFFER_LEVEL, vo);\n  }\n\n  function addBufferState(mediaType, state, target) {\n    var vo = new _BufferState2.default();\n    vo.target = target;\n    vo.state = state;\n    pushAndNotify(mediaType, _MetricsConstants2.default.BUFFER_STATE, vo);\n  }\n\n  function addDVRInfo(mediaType, currentTime, mpd, range) {\n    var vo = new _DVRInfo2.default();\n    vo.time = currentTime;\n    vo.range = range;\n    vo.manifestInfo = mpd;\n    pushAndNotify(mediaType, _MetricsConstants2.default.DVR_INFO, vo);\n  }\n\n  function addDroppedFrames(mediaType, quality) {\n    var vo = new _DroppedFrames2.default();\n    var list = getMetricsFor(mediaType).DroppedFrames;\n\n    if (!quality) {\n      return;\n    }\n\n    vo.time = quality.creationTime;\n    vo.droppedFrames = quality.droppedVideoFrames;\n\n    if (list.length > 0 && list[list.length - 1] == vo) {\n      return;\n    }\n\n    pushAndNotify(mediaType, _MetricsConstants2.default.DROPPED_FRAMES, vo);\n  }\n\n  function addSchedulingInfo(mediaType, t, type, startTime, availabilityStartTime, duration, quality, range, state) {\n    var vo = new _SchedulingInfo2.default();\n    vo.mediaType = mediaType;\n    vo.t = t;\n    vo.type = type;\n    vo.startTime = startTime;\n    vo.availabilityStartTime = availabilityStartTime;\n    vo.duration = duration;\n    vo.quality = quality;\n    vo.range = range;\n    vo.state = state;\n    pushAndNotify(mediaType, _MetricsConstants2.default.SCHEDULING_INFO, vo);\n  }\n\n  function addRequestsQueue(mediaType, loadingRequests, executedRequests) {\n    var vo = new _RequestsQueue2.default();\n    vo.loadingRequests = loadingRequests;\n    vo.executedRequests = executedRequests;\n    getMetricsFor(mediaType).RequestsQueue = vo;\n    metricAdded(mediaType, _MetricsConstants2.default.REQUESTS_QUEUE, vo);\n  }\n\n  function addManifestUpdate(mediaType, type, requestTime, fetchTime, availabilityStartTime, presentationStartTime, clientTimeOffset, currentTime, buffered, latency) {\n    var vo = new _ManifestUpdate.ManifestUpdate();\n    vo.mediaType = mediaType;\n    vo.type = type;\n    vo.requestTime = requestTime; // when this manifest update was requested\n\n    vo.fetchTime = fetchTime; // when this manifest update was received\n\n    vo.availabilityStartTime = availabilityStartTime;\n    vo.presentationStartTime = presentationStartTime; // the seek point (liveEdge for dynamic, Stream[0].startTime for static)\n\n    vo.clientTimeOffset = clientTimeOffset; // the calculated difference between the server and client wall clock time\n\n    vo.currentTime = currentTime; // actual element.currentTime\n\n    vo.buffered = buffered; // actual element.ranges\n\n    vo.latency = latency; // (static is fixed value of zero. dynamic should be ((Now-@availabilityStartTime) - currentTime)\n\n    pushMetrics(_Constants2.default.STREAM, _MetricsConstants2.default.MANIFEST_UPDATE, vo);\n    metricAdded(mediaType, _MetricsConstants2.default.MANIFEST_UPDATE, vo);\n  }\n\n  function updateManifestUpdateInfo(manifestUpdate, updatedFields) {\n    if (manifestUpdate) {\n      for (var field in updatedFields) {\n        manifestUpdate[field] = updatedFields[field];\n      }\n\n      metricUpdated(manifestUpdate.mediaType, _MetricsConstants2.default.MANIFEST_UPDATE, manifestUpdate);\n    }\n  }\n\n  function addManifestUpdateStreamInfo(manifestUpdate, id, index, start, duration) {\n    if (manifestUpdate) {\n      var vo = new _ManifestUpdate.ManifestUpdateStreamInfo();\n      vo.id = id;\n      vo.index = index;\n      vo.start = start;\n      vo.duration = duration;\n      manifestUpdate.streamInfo.push(vo);\n      metricUpdated(manifestUpdate.mediaType, _MetricsConstants2.default.MANIFEST_UPDATE_STREAM_INFO, manifestUpdate);\n    }\n  }\n\n  function addManifestUpdateRepresentationInfo(manifestUpdate, id, index, streamIndex, mediaType, presentationTimeOffset, startNumber, fragmentInfoType) {\n    if (manifestUpdate && manifestUpdate.representationInfo) {\n      var vo = new _ManifestUpdate.ManifestUpdateRepresentationInfo();\n      vo.id = id;\n      vo.index = index;\n      vo.streamIndex = streamIndex;\n      vo.mediaType = mediaType;\n      vo.startNumber = startNumber;\n      vo.fragmentInfoType = fragmentInfoType;\n      vo.presentationTimeOffset = presentationTimeOffset;\n      manifestUpdate.representationInfo.push(vo);\n      metricUpdated(manifestUpdate.mediaType, _MetricsConstants2.default.MANIFEST_UPDATE_TRACK_INFO, manifestUpdate);\n    }\n  }\n\n  function addPlayList(vo) {\n    if (vo.trace && Array.isArray(vo.trace)) {\n      vo.trace.forEach(function (trace) {\n        if (trace.hasOwnProperty('subreplevel') && !trace.subreplevel) {\n          delete trace.subreplevel;\n        }\n      });\n    } else {\n      delete vo.trace;\n    }\n\n    pushAndNotify(_Constants2.default.STREAM, _MetricsConstants2.default.PLAY_LIST, vo);\n  }\n\n  function addDVBErrors(vo) {\n    pushAndNotify(_Constants2.default.STREAM, _MetricsConstants2.default.DVB_ERRORS, vo);\n  }\n\n  instance = {\n    clearCurrentMetricsForType: clearCurrentMetricsForType,\n    clearAllCurrentMetrics: clearAllCurrentMetrics,\n    getMetricsFor: getMetricsFor,\n    addHttpRequest: addHttpRequest,\n    addRepresentationSwitch: addRepresentationSwitch,\n    addBufferLevel: addBufferLevel,\n    addBufferState: addBufferState,\n    addDVRInfo: addDVRInfo,\n    addDroppedFrames: addDroppedFrames,\n    addSchedulingInfo: addSchedulingInfo,\n    addRequestsQueue: addRequestsQueue,\n    addManifestUpdate: addManifestUpdate,\n    updateManifestUpdateInfo: updateManifestUpdateInfo,\n    addManifestUpdateStreamInfo: addManifestUpdateStreamInfo,\n    addManifestUpdateRepresentationInfo: addManifestUpdateRepresentationInfo,\n    addPlayList: addPlayList,\n    addDVBErrors: addDVBErrors\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nMetricsModel.__dashjs_factory_name = 'MetricsModel';\nexports.default = _FactoryMaker2.default.getSingletonFactory(MetricsModel);","map":{"version":3,"mappings":"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","names":["MetricsModel","config","settings","context","eventBus","getInstance","instance","streamMetrics","setup","metricsChanged","trigger","Events","METRICS_CHANGED","metricChanged","mediaType","METRIC_CHANGED","metricUpdated","metricType","vo","METRIC_UPDATED","metric","value","metricAdded","METRIC_ADDED","clearCurrentMetricsForType","type","clearAllCurrentMetrics","getMetricsFor","readOnly","metrics","hasOwnProperty","MetricsList","pushMetrics","list","push","length","get","streaming","metricsMaxListDepth","shift","appendHttpTrace","httpRequest","s","d","b","HTTPRequestTrace","trace","interval","addHttpRequest","tcpid","url","quality","actualurl","serviceLocation","range","trequest","tresponse","tfinish","responsecode","mediaduration","responseHeaders","traces","HTTPRequest","_tfinish","_stream","_mediaduration","_quality","_responseHeaders","_serviceLocation","forEach","pushAndNotify","MetricsConstants","HTTP_REQUEST","addRepresentationSwitch","t","mt","to","lto","TrackSwitch","TRACK_SWITCH","metricObject","addBufferLevel","level","BufferLevel","BUFFER_LEVEL","addBufferState","state","target","BufferState","BUFFER_STATE","addDVRInfo","currentTime","mpd","DVRInfo","time","manifestInfo","DVR_INFO","addDroppedFrames","DroppedFrames","creationTime","droppedFrames","droppedVideoFrames","DROPPED_FRAMES","addSchedulingInfo","startTime","availabilityStartTime","duration","SchedulingInfo","SCHEDULING_INFO","addRequestsQueue","loadingRequests","executedRequests","RequestsQueue","REQUESTS_QUEUE","addManifestUpdate","requestTime","fetchTime","presentationStartTime","clientTimeOffset","buffered","latency","ManifestUpdate","Constants","STREAM","MANIFEST_UPDATE","updateManifestUpdateInfo","manifestUpdate","updatedFields","field","addManifestUpdateStreamInfo","id","index","start","ManifestUpdateStreamInfo","streamInfo","MANIFEST_UPDATE_STREAM_INFO","addManifestUpdateRepresentationInfo","streamIndex","presentationTimeOffset","startNumber","fragmentInfoType","representationInfo","ManifestUpdateRepresentationInfo","MANIFEST_UPDATE_TRACK_INFO","addPlayList","Array","isArray","subreplevel","PLAY_LIST","addDVBErrors","DVB_ERRORS","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/models/MetricsModel.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport MetricsList from '../vo/MetricsList';\nimport { HTTPRequest, HTTPRequestTrace } from '../vo/metrics/HTTPRequest';\nimport TrackSwitch from '../vo/metrics/RepresentationSwitch';\nimport BufferLevel from '../vo/metrics/BufferLevel';\nimport BufferState from '../vo/metrics/BufferState';\nimport DVRInfo from '../vo/metrics/DVRInfo';\nimport DroppedFrames from '../vo/metrics/DroppedFrames';\nimport { ManifestUpdate, ManifestUpdateStreamInfo, ManifestUpdateRepresentationInfo } from '../vo/metrics/ManifestUpdate';\nimport SchedulingInfo from '../vo/metrics/SchedulingInfo';\nimport EventBus from '../../core/EventBus';\nimport RequestsQueue from '../vo/metrics/RequestsQueue';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\n\nfunction MetricsModel(config) {\n\n    config = config || {};\n\n    const settings = config.settings;\n\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let instance,\n        streamMetrics;\n\n    function setup() {\n        streamMetrics = {};\n    }\n\n    function metricsChanged() {\n        eventBus.trigger(Events.METRICS_CHANGED);\n    }\n\n    function metricChanged(mediaType) {\n        eventBus.trigger(Events.METRIC_CHANGED, { mediaType: mediaType });\n        metricsChanged();\n    }\n\n    function metricUpdated(mediaType, metricType, vo) {\n        eventBus.trigger(Events.METRIC_UPDATED, { mediaType: mediaType, metric: metricType, value: vo });\n        metricChanged(mediaType);\n    }\n\n    function metricAdded(mediaType, metricType, vo) {\n        eventBus.trigger(Events.METRIC_ADDED, { mediaType: mediaType, metric: metricType, value: vo });\n        metricChanged(mediaType);\n    }\n\n    function clearCurrentMetricsForType(type) {\n        delete streamMetrics[type];\n        metricChanged(type);\n    }\n\n    function clearAllCurrentMetrics() {\n        streamMetrics = {};\n        metricsChanged();\n    }\n\n    function getMetricsFor(type, readOnly) {\n        let metrics = null;\n\n        if (!type) {\n            return metrics;\n        }\n\n        if (streamMetrics.hasOwnProperty(type)) {\n            metrics = streamMetrics[type];\n        } else if (!readOnly) {\n            metrics = new MetricsList();\n            streamMetrics[type] = metrics;\n        }\n\n        return metrics;\n    }\n\n    function pushMetrics(type, list, value) {\n        let metrics = getMetricsFor(type);\n        if (metrics !== null) {\n            metrics[list].push(value);\n            if ( metrics[list].length > settings.get().streaming.metricsMaxListDepth ) {\n                metrics[list].shift();\n            }\n        }\n    }\n\n    function appendHttpTrace(httpRequest, s, d, b) {\n        let vo = new HTTPRequestTrace();\n\n        vo.s = s;\n        vo.d = d;\n        vo.b = b;\n\n        httpRequest.trace.push(vo);\n\n        if (!httpRequest.interval) {\n            httpRequest.interval = 0;\n        }\n\n        httpRequest.interval += d;\n\n        return vo;\n    }\n\n    function addHttpRequest(mediaType, tcpid, type, url, quality, actualurl, serviceLocation, range, trequest, tresponse, tfinish, responsecode, mediaduration, responseHeaders, traces) {\n        let vo = new HTTPRequest();\n\n        // ISO 23009-1 D.4.3 NOTE 2:\n        // All entries for a given object will have the same URL and range\n        // and so can easily be correlated. If there were redirects or\n        // failures there will be one entry for each redirect/failure.\n        // The redirect-to URL or alternative url (where multiple have been\n        // provided in the MPD) will appear as the actualurl of the next\n        // entry with the same url value.\n        if (actualurl && (actualurl !== url)) {\n\n            // given the above, add an entry for the original request\n            addHttpRequest(\n                mediaType,\n                null,\n                type,\n                url,\n                quality,\n                null,\n                null,\n                range,\n                trequest,\n                null, // unknown\n                null, // unknown\n                null, // unknown, probably a 302\n                mediaduration,\n                null,\n                null\n            );\n\n            vo.actualurl = actualurl;\n        }\n\n        vo.tcpid = tcpid;\n        vo.type = type;\n        vo.url = url;\n        vo.range = range;\n        vo.trequest = trequest;\n        vo.tresponse = tresponse;\n        vo.responsecode = responsecode;\n\n        vo._tfinish = tfinish;\n        vo._stream = mediaType;\n        vo._mediaduration = mediaduration;\n        vo._quality = quality;\n        vo._responseHeaders = responseHeaders;\n        vo._serviceLocation = serviceLocation;\n\n        if (traces) {\n            traces.forEach(trace => {\n                appendHttpTrace(vo, trace.s, trace.d, trace.b);\n            });\n        } else {\n            // The interval and trace shall be absent for redirect and failure records.\n            delete vo.interval;\n            delete vo.trace;\n        }\n\n        pushAndNotify(mediaType, MetricsConstants.HTTP_REQUEST, vo);\n    }\n\n    function addRepresentationSwitch(mediaType, t, mt, to, lto) {\n        let vo = new TrackSwitch();\n\n        vo.t = t;\n        vo.mt = mt;\n        vo.to = to;\n\n        if (lto) {\n            vo.lto = lto;\n        } else {\n            delete vo.lto;\n        }\n\n        pushAndNotify(mediaType, MetricsConstants.TRACK_SWITCH, vo);\n    }\n\n    function pushAndNotify(mediaType, metricType, metricObject) {\n        pushMetrics(mediaType, metricType, metricObject);\n        metricAdded(mediaType, metricType, metricObject);\n    }\n\n    function addBufferLevel(mediaType, t, level) {\n        let vo = new BufferLevel();\n        vo.t = t;\n        vo.level = level;\n\n        pushAndNotify(mediaType, MetricsConstants.BUFFER_LEVEL, vo);\n    }\n\n    function addBufferState(mediaType, state, target) {\n        let vo = new BufferState();\n        vo.target = target;\n        vo.state = state;\n\n        pushAndNotify(mediaType, MetricsConstants.BUFFER_STATE, vo);\n    }\n\n    function addDVRInfo(mediaType, currentTime, mpd, range) {\n        let vo = new DVRInfo();\n        vo.time = currentTime ;\n        vo.range = range;\n        vo.manifestInfo = mpd;\n\n        pushAndNotify(mediaType, MetricsConstants.DVR_INFO, vo);\n    }\n\n    function addDroppedFrames(mediaType, quality) {\n        let vo = new DroppedFrames();\n        let list = getMetricsFor(mediaType).DroppedFrames;\n\n        if (!quality) {\n            return;\n        }\n\n        vo.time = quality.creationTime;\n        vo.droppedFrames = quality.droppedVideoFrames;\n\n        if (list.length > 0 && list[list.length - 1] == vo) {\n            return;\n        }\n\n        pushAndNotify(mediaType, MetricsConstants.DROPPED_FRAMES, vo);\n    }\n\n    function addSchedulingInfo(mediaType, t, type, startTime, availabilityStartTime, duration, quality, range, state) {\n        let vo = new SchedulingInfo();\n\n        vo.mediaType = mediaType;\n        vo.t = t;\n\n        vo.type = type;\n        vo.startTime = startTime;\n        vo.availabilityStartTime = availabilityStartTime;\n        vo.duration = duration;\n        vo.quality = quality;\n        vo.range = range;\n\n        vo.state = state;\n\n        pushAndNotify(mediaType, MetricsConstants.SCHEDULING_INFO, vo);\n    }\n\n    function addRequestsQueue(mediaType, loadingRequests, executedRequests) {\n        let vo = new RequestsQueue();\n\n        vo.loadingRequests = loadingRequests;\n        vo.executedRequests = executedRequests;\n\n        getMetricsFor(mediaType).RequestsQueue = vo;\n        metricAdded(mediaType, MetricsConstants.REQUESTS_QUEUE, vo);\n    }\n\n    function addManifestUpdate(mediaType, type, requestTime, fetchTime, availabilityStartTime, presentationStartTime, clientTimeOffset, currentTime, buffered, latency) {\n        let vo = new ManifestUpdate();\n\n        vo.mediaType = mediaType;\n        vo.type = type;\n        vo.requestTime = requestTime; // when this manifest update was requested\n        vo.fetchTime = fetchTime; // when this manifest update was received\n        vo.availabilityStartTime = availabilityStartTime;\n        vo.presentationStartTime = presentationStartTime; // the seek point (liveEdge for dynamic, Stream[0].startTime for static)\n        vo.clientTimeOffset = clientTimeOffset; // the calculated difference between the server and client wall clock time\n        vo.currentTime = currentTime; // actual element.currentTime\n        vo.buffered = buffered; // actual element.ranges\n        vo.latency = latency; // (static is fixed value of zero. dynamic should be ((Now-@availabilityStartTime) - currentTime)\n\n        pushMetrics(Constants.STREAM, MetricsConstants.MANIFEST_UPDATE, vo);\n        metricAdded(mediaType, MetricsConstants.MANIFEST_UPDATE, vo);\n    }\n\n    function updateManifestUpdateInfo(manifestUpdate, updatedFields) {\n        if (manifestUpdate) {\n            for (let field in updatedFields) {\n                manifestUpdate[field] = updatedFields[field];\n            }\n\n            metricUpdated(manifestUpdate.mediaType, MetricsConstants.MANIFEST_UPDATE, manifestUpdate);\n        }\n    }\n\n    function addManifestUpdateStreamInfo(manifestUpdate, id, index, start, duration) {\n        if (manifestUpdate) {\n            let vo = new ManifestUpdateStreamInfo();\n\n            vo.id = id;\n            vo.index = index;\n            vo.start = start;\n            vo.duration = duration;\n\n            manifestUpdate.streamInfo.push(vo);\n            metricUpdated(manifestUpdate.mediaType, MetricsConstants.MANIFEST_UPDATE_STREAM_INFO, manifestUpdate);\n        }\n    }\n\n    function addManifestUpdateRepresentationInfo(manifestUpdate, id, index, streamIndex, mediaType, presentationTimeOffset, startNumber, fragmentInfoType) {\n        if (manifestUpdate && manifestUpdate.representationInfo) {\n\n            const vo = new ManifestUpdateRepresentationInfo();\n            vo.id = id;\n            vo.index = index;\n            vo.streamIndex = streamIndex;\n            vo.mediaType = mediaType;\n            vo.startNumber = startNumber;\n            vo.fragmentInfoType = fragmentInfoType;\n            vo.presentationTimeOffset = presentationTimeOffset;\n\n            manifestUpdate.representationInfo.push(vo);\n            metricUpdated(manifestUpdate.mediaType, MetricsConstants.MANIFEST_UPDATE_TRACK_INFO, manifestUpdate);\n        }\n    }\n\n    function addPlayList(vo) {\n        if (vo.trace && Array.isArray(vo.trace)) {\n            vo.trace.forEach(trace => {\n                if (trace.hasOwnProperty('subreplevel') && !trace.subreplevel) {\n                    delete trace.subreplevel;\n                }\n            });\n        } else {\n            delete vo.trace;\n        }\n\n        pushAndNotify(Constants.STREAM, MetricsConstants.PLAY_LIST, vo);\n    }\n\n    function addDVBErrors(vo) {\n        pushAndNotify(Constants.STREAM, MetricsConstants.DVB_ERRORS, vo);\n    }\n\n    instance = {\n        clearCurrentMetricsForType: clearCurrentMetricsForType,\n        clearAllCurrentMetrics: clearAllCurrentMetrics,\n        getMetricsFor: getMetricsFor,\n        addHttpRequest: addHttpRequest,\n        addRepresentationSwitch: addRepresentationSwitch,\n        addBufferLevel: addBufferLevel,\n        addBufferState: addBufferState,\n        addDVRInfo: addDVRInfo,\n        addDroppedFrames: addDroppedFrames,\n        addSchedulingInfo: addSchedulingInfo,\n        addRequestsQueue: addRequestsQueue,\n        addManifestUpdate: addManifestUpdate,\n        updateManifestUpdateInfo: updateManifestUpdateInfo,\n        addManifestUpdateStreamInfo: addManifestUpdateStreamInfo,\n        addManifestUpdateRepresentationInfo: addManifestUpdateRepresentationInfo,\n        addPlayList: addPlayList,\n        addDVBErrors: addDVBErrors\n    };\n\n    setup();\n    return instance;\n}\n\nMetricsModel.__dashjs_factory_name = 'MetricsModel';\nexport default FactoryMaker.getSingletonFactory(MetricsModel);\n"]},"metadata":{},"sourceType":"script"}