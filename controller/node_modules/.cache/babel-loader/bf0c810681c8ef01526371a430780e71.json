{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ThroughputRule = require('./ThroughputRule');\n\nvar _ThroughputRule2 = _interopRequireDefault(_ThroughputRule);\n\nvar _InsufficientBufferRule = require('./InsufficientBufferRule');\n\nvar _InsufficientBufferRule2 = _interopRequireDefault(_InsufficientBufferRule);\n\nvar _AbandonRequestsRule = require('./AbandonRequestsRule');\n\nvar _AbandonRequestsRule2 = _interopRequireDefault(_AbandonRequestsRule);\n\nvar _DroppedFramesRule = require('./DroppedFramesRule');\n\nvar _DroppedFramesRule2 = _interopRequireDefault(_DroppedFramesRule);\n\nvar _SwitchHistoryRule = require('./SwitchHistoryRule');\n\nvar _SwitchHistoryRule2 = _interopRequireDefault(_SwitchHistoryRule);\n\nvar _BolaRule = require('./BolaRule');\n\nvar _BolaRule2 = _interopRequireDefault(_BolaRule);\n\nvar _L2ARule = require('./L2ARule.js');\n\nvar _L2ARule2 = _interopRequireDefault(_L2ARule);\n\nvar _LoLpRule = require('./lolp/LoLpRule.js');\n\nvar _LoLpRule2 = _interopRequireDefault(_LoLpRule);\n\nvar _FactoryMaker = require('../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _SwitchRequest = require('../SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _Constants = require('../../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar QUALITY_SWITCH_RULES = 'qualitySwitchRules';\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\nvar ABANDON_FRAGMENT_RULES = 'abandonFragmentRules';\n\nfunction ABRRulesCollection(config) {\n  config = config || {};\n  var context = this.context;\n  var mediaPlayerModel = config.mediaPlayerModel;\n  var dashMetrics = config.dashMetrics;\n  var settings = config.settings;\n  var instance = void 0,\n      qualitySwitchRules = void 0,\n      abandonFragmentRules = void 0;\n\n  function initialize() {\n    qualitySwitchRules = [];\n    abandonFragmentRules = [];\n\n    if (settings.get().streaming.abr.useDefaultABRRules) {\n      // If L2A is used we only need this one rule\n      if (settings.get().streaming.abr.ABRStrategy === _Constants2.default.ABR_STRATEGY_L2A) {\n        qualitySwitchRules.push((0, _L2ARule2.default)(context).create({\n          dashMetrics: dashMetrics,\n          mediaPlayerModel: mediaPlayerModel,\n          settings: settings\n        }));\n      } // If LoLP is used we only need this one rule\n      else if (settings.get().streaming.abr.ABRStrategy === _Constants2.default.ABR_STRATEGY_LoLP) {\n        qualitySwitchRules.push((0, _LoLpRule2.default)(context).create({\n          dashMetrics: dashMetrics\n        }));\n      } else {\n        // Only one of BolaRule and ThroughputRule will give a switchRequest.quality !== SwitchRequest.NO_CHANGE.\n        // This is controlled by useBufferOccupancyABR mechanism in AbrController.\n        qualitySwitchRules.push((0, _BolaRule2.default)(context).create({\n          dashMetrics: dashMetrics,\n          mediaPlayerModel: mediaPlayerModel,\n          settings: settings\n        }));\n        qualitySwitchRules.push((0, _ThroughputRule2.default)(context).create({\n          dashMetrics: dashMetrics\n        }));\n        qualitySwitchRules.push((0, _InsufficientBufferRule2.default)(context).create({\n          dashMetrics: dashMetrics\n        }));\n        qualitySwitchRules.push((0, _SwitchHistoryRule2.default)(context).create());\n        qualitySwitchRules.push((0, _DroppedFramesRule2.default)(context).create());\n        abandonFragmentRules.push((0, _AbandonRequestsRule2.default)(context).create({\n          dashMetrics: dashMetrics,\n          mediaPlayerModel: mediaPlayerModel,\n          settings: settings\n        }));\n      }\n    } // add custom ABR rules if any\n\n\n    var customRules = mediaPlayerModel.getABRCustomRules();\n    customRules.forEach(function (rule) {\n      if (rule.type === QUALITY_SWITCH_RULES) {\n        qualitySwitchRules.push(rule.rule(context).create());\n      }\n\n      if (rule.type === ABANDON_FRAGMENT_RULES) {\n        abandonFragmentRules.push(rule.rule(context).create());\n      }\n    });\n  }\n\n  function getActiveRules(srArray) {\n    return srArray.filter(function (sr) {\n      return sr.quality > _SwitchRequest2.default.NO_CHANGE;\n    });\n  }\n  /**\n  *\n  * @param {array} srArray\n  * @return {object} SwitchRequest\n  */\n\n\n  function getMinSwitchRequest(srArray) {\n    var values = {};\n    var newSwitchReq = null;\n    var i = void 0,\n        len = void 0,\n        req = void 0,\n        quality = void 0,\n        reason = void 0;\n\n    if (srArray.length === 0) {\n      return;\n    }\n\n    values[_SwitchRequest2.default.PRIORITY.STRONG] = {\n      quality: _SwitchRequest2.default.NO_CHANGE,\n      reason: null\n    };\n    values[_SwitchRequest2.default.PRIORITY.WEAK] = {\n      quality: _SwitchRequest2.default.NO_CHANGE,\n      reason: null\n    };\n    values[_SwitchRequest2.default.PRIORITY.DEFAULT] = {\n      quality: _SwitchRequest2.default.NO_CHANGE,\n      reason: null\n    };\n\n    for (i = 0, len = srArray.length; i < len; i += 1) {\n      req = srArray[i];\n\n      if (req.quality !== _SwitchRequest2.default.NO_CHANGE) {\n        // We only use the new quality in case it is lower than the already saved one or if no new quality has been selected for the respective priority\n        if (values[req.priority].quality === _SwitchRequest2.default.NO_CHANGE || values[req.priority].quality > req.quality) {\n          values[req.priority].quality = req.quality;\n          values[req.priority].reason = req.reason || null;\n        }\n      }\n    }\n\n    if (values[_SwitchRequest2.default.PRIORITY.WEAK].quality !== _SwitchRequest2.default.NO_CHANGE) {\n      newSwitchReq = values[_SwitchRequest2.default.PRIORITY.WEAK];\n    }\n\n    if (values[_SwitchRequest2.default.PRIORITY.DEFAULT].quality !== _SwitchRequest2.default.NO_CHANGE) {\n      newSwitchReq = values[_SwitchRequest2.default.PRIORITY.DEFAULT];\n    }\n\n    if (values[_SwitchRequest2.default.PRIORITY.STRONG].quality !== _SwitchRequest2.default.NO_CHANGE) {\n      newSwitchReq = values[_SwitchRequest2.default.PRIORITY.STRONG];\n    }\n\n    if (newSwitchReq) {\n      quality = newSwitchReq.quality;\n      reason = newSwitchReq.reason;\n    }\n\n    return (0, _SwitchRequest2.default)(context).create(quality, reason);\n  }\n\n  function getMaxQuality(rulesContext) {\n    var switchRequestArray = qualitySwitchRules.map(function (rule) {\n      return rule.getMaxIndex(rulesContext);\n    });\n    var activeRules = getActiveRules(switchRequestArray);\n    var maxQuality = getMinSwitchRequest(activeRules);\n    return maxQuality || (0, _SwitchRequest2.default)(context).create();\n  }\n\n  function shouldAbandonFragment(rulesContext) {\n    var abandonRequestArray = abandonFragmentRules.map(function (rule) {\n      return rule.shouldAbandon(rulesContext);\n    });\n    var activeRules = getActiveRules(abandonRequestArray);\n    var shouldAbandon = getMinSwitchRequest(activeRules);\n    return shouldAbandon || (0, _SwitchRequest2.default)(context).create();\n  }\n\n  function reset() {\n    [qualitySwitchRules, abandonFragmentRules].forEach(function (rules) {\n      if (rules && rules.length) {\n        rules.forEach(function (rule) {\n          return rule.reset && rule.reset();\n        });\n      }\n    });\n    qualitySwitchRules = [];\n    abandonFragmentRules = [];\n  }\n\n  function getQualitySwitchRules() {\n    return qualitySwitchRules;\n  }\n\n  instance = {\n    initialize: initialize,\n    reset: reset,\n    getMaxQuality: getMaxQuality,\n    getMinSwitchRequest: getMinSwitchRequest,\n    shouldAbandonFragment: shouldAbandonFragment,\n    getQualitySwitchRules: getQualitySwitchRules\n  };\n  return instance;\n}\n\nABRRulesCollection.__dashjs_factory_name = 'ABRRulesCollection';\n\nvar factory = _FactoryMaker2.default.getClassFactory(ABRRulesCollection);\n\nfactory.QUALITY_SWITCH_RULES = QUALITY_SWITCH_RULES;\nfactory.ABANDON_FRAGMENT_RULES = ABANDON_FRAGMENT_RULES;\n\n_FactoryMaker2.default.updateSingletonFactory(ABRRulesCollection.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"mappings":"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","names":["QUALITY_SWITCH_RULES","ABANDON_FRAGMENT_RULES","ABRRulesCollection","config","context","mediaPlayerModel","dashMetrics","settings","instance","qualitySwitchRules","abandonFragmentRules","initialize","get","streaming","abr","useDefaultABRRules","ABRStrategy","Constants","ABR_STRATEGY_L2A","push","create","ABR_STRATEGY_LoLP","customRules","getABRCustomRules","forEach","rule","type","getActiveRules","srArray","filter","sr","quality","SwitchRequest","NO_CHANGE","getMinSwitchRequest","values","newSwitchReq","i","len","req","reason","length","PRIORITY","STRONG","WEAK","DEFAULT","priority","getMaxQuality","rulesContext","switchRequestArray","map","getMaxIndex","activeRules","maxQuality","shouldAbandonFragment","abandonRequestArray","shouldAbandon","reset","rules","getQualitySwitchRules","__dashjs_factory_name","factory","FactoryMaker","getClassFactory","updateSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/rules/abr/ABRRulesCollection.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport ThroughputRule from './ThroughputRule';\nimport InsufficientBufferRule from './InsufficientBufferRule';\nimport AbandonRequestsRule from './AbandonRequestsRule';\nimport DroppedFramesRule from './DroppedFramesRule';\nimport SwitchHistoryRule from './SwitchHistoryRule';\nimport BolaRule from './BolaRule';\nimport L2ARule from './L2ARule.js';\nimport LoLPRule from './lolp/LoLpRule.js';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport SwitchRequest from '../SwitchRequest';\nimport Constants from '../../constants/Constants';\n\nconst QUALITY_SWITCH_RULES = 'qualitySwitchRules';\nconst ABANDON_FRAGMENT_RULES = 'abandonFragmentRules';\n\n\nfunction ABRRulesCollection(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const dashMetrics = config.dashMetrics;\n    const settings = config.settings;\n\n    let instance,\n        qualitySwitchRules,\n        abandonFragmentRules;\n\n    function initialize() {\n        qualitySwitchRules = [];\n        abandonFragmentRules = [];\n\n        if (settings.get().streaming.abr.useDefaultABRRules) {\n\n            // If L2A is used we only need this one rule\n            if (settings.get().streaming.abr.ABRStrategy === Constants.ABR_STRATEGY_L2A) {\n                qualitySwitchRules.push(\n                    L2ARule(context).create({\n                        dashMetrics: dashMetrics,\n                        mediaPlayerModel: mediaPlayerModel,\n                        settings: settings\n                    })\n                );\n            }\n            // If LoLP is used we only need this one rule\n            else if (settings.get().streaming.abr.ABRStrategy === Constants.ABR_STRATEGY_LoLP) {\n                qualitySwitchRules.push(\n                    LoLPRule(context).create({\n                        dashMetrics: dashMetrics\n                    })\n                );\n            } else {\n                // Only one of BolaRule and ThroughputRule will give a switchRequest.quality !== SwitchRequest.NO_CHANGE.\n                // This is controlled by useBufferOccupancyABR mechanism in AbrController.\n                qualitySwitchRules.push(\n                    BolaRule(context).create({\n                        dashMetrics: dashMetrics,\n                        mediaPlayerModel: mediaPlayerModel,\n                        settings: settings\n                    })\n                );\n\n                qualitySwitchRules.push(\n                    ThroughputRule(context).create({\n                        dashMetrics: dashMetrics\n                    })\n                );\n                qualitySwitchRules.push(\n                    InsufficientBufferRule(context).create({\n                        dashMetrics: dashMetrics\n                    })\n                );\n                qualitySwitchRules.push(\n                    SwitchHistoryRule(context).create()\n                );\n                qualitySwitchRules.push(\n                    DroppedFramesRule(context).create()\n                );\n\n                abandonFragmentRules.push(\n                    AbandonRequestsRule(context).create({\n                        dashMetrics: dashMetrics,\n                        mediaPlayerModel: mediaPlayerModel,\n                        settings: settings\n                    })\n                );\n            }\n        }\n\n        // add custom ABR rules if any\n        const customRules = mediaPlayerModel.getABRCustomRules();\n        customRules.forEach(function (rule) {\n            if (rule.type === QUALITY_SWITCH_RULES) {\n                qualitySwitchRules.push(rule.rule(context).create());\n            }\n\n            if (rule.type === ABANDON_FRAGMENT_RULES) {\n                abandonFragmentRules.push(rule.rule(context).create());\n            }\n        });\n    }\n\n    function getActiveRules(srArray) {\n        return srArray.filter(sr => sr.quality > SwitchRequest.NO_CHANGE);\n    }\n\n    /**\n     *\n     * @param {array} srArray\n     * @return {object} SwitchRequest\n     */\n    function getMinSwitchRequest(srArray) {\n        const values = {};\n        let newSwitchReq = null;\n        let i,\n            len,\n            req,\n            quality,\n            reason;\n\n        if (srArray.length === 0) {\n            return;\n        }\n\n        values[SwitchRequest.PRIORITY.STRONG] = { quality: SwitchRequest.NO_CHANGE, reason: null };\n        values[SwitchRequest.PRIORITY.WEAK] = { quality: SwitchRequest.NO_CHANGE, reason: null };\n        values[SwitchRequest.PRIORITY.DEFAULT] = { quality: SwitchRequest.NO_CHANGE, reason: null };\n\n        for (i = 0, len = srArray.length; i < len; i += 1) {\n            req = srArray[i];\n            if (req.quality !== SwitchRequest.NO_CHANGE) {\n                // We only use the new quality in case it is lower than the already saved one or if no new quality has been selected for the respective priority\n                if (values[req.priority].quality === SwitchRequest.NO_CHANGE || values[req.priority].quality > req.quality) {\n                    values[req.priority].quality = req.quality;\n                    values[req.priority].reason = req.reason || null;\n                }\n            }\n        }\n\n        if (values[SwitchRequest.PRIORITY.WEAK].quality !== SwitchRequest.NO_CHANGE) {\n            newSwitchReq = values[SwitchRequest.PRIORITY.WEAK];\n        }\n\n        if (values[SwitchRequest.PRIORITY.DEFAULT].quality !== SwitchRequest.NO_CHANGE) {\n            newSwitchReq = values[SwitchRequest.PRIORITY.DEFAULT];\n        }\n\n        if (values[SwitchRequest.PRIORITY.STRONG].quality !== SwitchRequest.NO_CHANGE) {\n            newSwitchReq = values[SwitchRequest.PRIORITY.STRONG];\n        }\n\n        if (newSwitchReq) {\n            quality = newSwitchReq.quality;\n            reason = newSwitchReq.reason;\n        }\n\n        return SwitchRequest(context).create(quality, reason);\n    }\n\n    function getMaxQuality(rulesContext) {\n        const switchRequestArray = qualitySwitchRules.map(rule => rule.getMaxIndex(rulesContext));\n        const activeRules = getActiveRules(switchRequestArray);\n        const maxQuality = getMinSwitchRequest(activeRules);\n\n        return maxQuality || SwitchRequest(context).create();\n    }\n\n    function shouldAbandonFragment(rulesContext) {\n        const abandonRequestArray = abandonFragmentRules.map(rule => rule.shouldAbandon(rulesContext));\n        const activeRules = getActiveRules(abandonRequestArray);\n        const shouldAbandon = getMinSwitchRequest(activeRules);\n\n        return shouldAbandon || SwitchRequest(context).create();\n    }\n\n    function reset() {\n        [qualitySwitchRules, abandonFragmentRules].forEach(rules => {\n            if (rules && rules.length) {\n                rules.forEach(rule => rule.reset && rule.reset());\n            }\n        });\n        qualitySwitchRules = [];\n        abandonFragmentRules = [];\n    }\n\n    function getQualitySwitchRules() {\n        return qualitySwitchRules;\n    }\n\n    instance = {\n        initialize,\n        reset,\n        getMaxQuality,\n        getMinSwitchRequest,\n        shouldAbandonFragment,\n        getQualitySwitchRules\n    };\n\n    return instance;\n}\n\nABRRulesCollection.__dashjs_factory_name = 'ABRRulesCollection';\nconst factory = FactoryMaker.getClassFactory(ABRRulesCollection);\nfactory.QUALITY_SWITCH_RULES = QUALITY_SWITCH_RULES;\nfactory.ABANDON_FRAGMENT_RULES = ABANDON_FRAGMENT_RULES;\nFactoryMaker.updateSingletonFactory(ABRRulesCollection.__dashjs_factory_name, factory);\n\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}