{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar WEBVTT = 'WEBVTT';\n\nfunction VTTParser() {\n  var context = this.context;\n  var instance = void 0,\n      logger = void 0,\n      regExNewLine = void 0,\n      regExToken = void 0,\n      regExWhiteSpace = void 0,\n      regExWhiteSpaceWordBoundary = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    regExNewLine = /(?:\\r\\n|\\r|\\n)/gm;\n    regExToken = /-->/;\n    regExWhiteSpace = /(^[\\s]+|[\\s]+$)/g;\n    regExWhiteSpaceWordBoundary = /\\s\\b/g;\n  }\n\n  function parse(data) {\n    var captionArray = [];\n    var len = void 0,\n        lastStartTime = void 0;\n\n    if (!data) {\n      return captionArray;\n    }\n\n    data = data.split(regExNewLine);\n    len = data.length;\n    lastStartTime = -1;\n\n    for (var i = 0; i < len; i++) {\n      var item = data[i];\n\n      if (item.length > 0 && item !== WEBVTT) {\n        if (item.match(regExToken)) {\n          var attributes = parseItemAttributes(item);\n          var cuePoints = attributes.cuePoints;\n          var styles = attributes.styles;\n          var text = getSublines(data, i + 1);\n          var startTime = convertCuePointTimes(cuePoints[0].replace(regExWhiteSpace, ''));\n          var endTime = convertCuePointTimes(cuePoints[1].replace(regExWhiteSpace, ''));\n\n          if (!isNaN(startTime) && !isNaN(endTime) && startTime >= lastStartTime && endTime > startTime) {\n            if (text !== '') {\n              lastStartTime = startTime; //TODO Make VO external so other parsers can use.\n\n              captionArray.push({\n                start: startTime,\n                end: endTime,\n                data: text,\n                styles: styles\n              });\n            } else {\n              logger.error('Skipping cue due to empty/malformed cue text');\n            }\n          } else {\n            logger.error('Skipping cue due to incorrect cue timing');\n          }\n        }\n      }\n    }\n\n    return captionArray;\n  }\n\n  function convertCuePointTimes(time) {\n    var timeArray = time.split(':');\n    var len = timeArray.length - 1;\n    time = parseInt(timeArray[len - 1], 10) * 60 + parseFloat(timeArray[len]);\n\n    if (len === 2) {\n      time += parseInt(timeArray[0], 10) * 3600;\n    }\n\n    return time;\n  }\n\n  function parseItemAttributes(data) {\n    var vttCuePoints = data.split(regExToken);\n    var arr = vttCuePoints[1].split(regExWhiteSpaceWordBoundary);\n    arr.shift(); //remove first array index it is empty...\n\n    vttCuePoints[1] = arr[0];\n    arr.shift();\n    return {\n      cuePoints: vttCuePoints,\n      styles: getCaptionStyles(arr)\n    };\n  }\n\n  function getCaptionStyles(arr) {\n    var styleObject = {};\n    arr.forEach(function (element) {\n      if (element.split(/:/).length > 1) {\n        var val = element.split(/:/)[1];\n\n        if (val && val.search(/%/) != -1) {\n          val = parseInt(val.replace(/%/, ''), 10);\n        }\n\n        if (element.match(/align/) || element.match(/A/)) {\n          styleObject.align = val;\n        }\n\n        if (element.match(/line/) || element.match(/L/)) {\n          styleObject.line = val;\n        }\n\n        if (element.match(/position/) || element.match(/P/)) {\n          styleObject.position = val;\n        }\n\n        if (element.match(/size/) || element.match(/S/)) {\n          styleObject.size = val;\n        }\n      }\n    });\n    return styleObject;\n  }\n  /*\n  * VTT can have multiple lines to display per cuepoint.\n  */\n\n\n  function getSublines(data, idx) {\n    var i = idx;\n    var subline = '';\n    var lineData = '';\n    var lineCount = void 0;\n\n    while (data[i] !== '' && i < data.length) {\n      i++;\n    }\n\n    lineCount = i - idx;\n\n    if (lineCount > 1) {\n      for (var j = 0; j < lineCount; j++) {\n        lineData = data[idx + j];\n\n        if (!lineData.match(regExToken)) {\n          subline += lineData;\n\n          if (j !== lineCount - 1) {\n            subline += '\\n';\n          }\n        } else {\n          // caption text should not have '-->' in it\n          subline = '';\n          break;\n        }\n      }\n    } else {\n      lineData = data[idx];\n      if (!lineData.match(regExToken)) subline = lineData;\n    }\n\n    return subline;\n  }\n\n  instance = {\n    parse: parse\n  };\n  setup();\n  return instance;\n}\n\nVTTParser.__dashjs_factory_name = 'VTTParser';\nexports.default = _FactoryMaker2.default.getSingletonFactory(VTTParser);","map":{"version":3,"mappings":"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","names":["WEBVTT","VTTParser","context","instance","logger","regExNewLine","regExToken","regExWhiteSpace","regExWhiteSpaceWordBoundary","setup","getInstance","getLogger","parse","data","captionArray","len","lastStartTime","split","length","i","item","match","attributes","parseItemAttributes","cuePoints","styles","text","getSublines","startTime","convertCuePointTimes","replace","endTime","isNaN","push","start","end","error","time","timeArray","parseInt","parseFloat","vttCuePoints","arr","shift","getCaptionStyles","styleObject","forEach","element","val","search","align","line","position","size","idx","subline","lineData","lineCount","j","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/utils/VTTParser.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nconst WEBVTT = 'WEBVTT';\n\nfunction VTTParser() {\n    const context = this.context;\n\n    let instance,\n        logger,\n        regExNewLine,\n        regExToken,\n        regExWhiteSpace,\n        regExWhiteSpaceWordBoundary;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        regExNewLine = /(?:\\r\\n|\\r|\\n)/gm;\n        regExToken = /-->/;\n        regExWhiteSpace = /(^[\\s]+|[\\s]+$)/g;\n        regExWhiteSpaceWordBoundary = /\\s\\b/g;\n    }\n\n    function parse(data) {\n        const captionArray = [];\n        let len,\n            lastStartTime;\n\n        if (!data) {\n            return captionArray;\n        }\n\n        data = data.split( regExNewLine );\n        len = data.length;\n        lastStartTime = -1;\n\n        for (let i = 0 ; i < len; i++) {\n            let item = data[i];\n\n            if (item.length > 0 && item !== WEBVTT) {\n                if (item.match(regExToken)) {\n                    const attributes = parseItemAttributes(item);\n                    const cuePoints = attributes.cuePoints;\n                    const styles = attributes.styles;\n                    const text = getSublines(data, i + 1);\n                    const startTime = convertCuePointTimes(cuePoints[0].replace(regExWhiteSpace, ''));\n                    const endTime = convertCuePointTimes(cuePoints[1].replace(regExWhiteSpace, ''));\n\n                    if ((!isNaN(startTime) && !isNaN(endTime)) && startTime >= lastStartTime && endTime > startTime) {\n                        if (text !== '') {\n                            lastStartTime = startTime;\n                            //TODO Make VO external so other parsers can use.\n                            captionArray.push({\n                                start: startTime,\n                                end: endTime,\n                                data: text,\n                                styles: styles\n                            });\n                        }\n                        else {\n                            logger.error('Skipping cue due to empty/malformed cue text');\n                        }\n                    }\n                    else {\n                        logger.error('Skipping cue due to incorrect cue timing');\n                    }\n                }\n            }\n        }\n\n        return captionArray;\n    }\n\n    function convertCuePointTimes(time) {\n        const timeArray = time.split(':');\n        const len = timeArray.length - 1;\n\n        time = parseInt( timeArray[len - 1], 10 ) * 60 + parseFloat( timeArray[len]);\n\n        if ( len === 2 ) {\n            time += parseInt( timeArray[0], 10 ) * 3600;\n        }\n\n        return time;\n    }\n\n    function parseItemAttributes(data) {\n        const vttCuePoints = data.split(regExToken);\n        const arr = vttCuePoints[1].split(regExWhiteSpaceWordBoundary);\n        arr.shift(); //remove first array index it is empty...\n        vttCuePoints[1] = arr[0];\n        arr.shift();\n        return {cuePoints: vttCuePoints, styles: getCaptionStyles(arr)};\n    }\n\n    function getCaptionStyles(arr) {\n        const styleObject = {};\n        arr.forEach(function (element) {\n            if (element.split(/:/).length > 1) {\n                let val = element.split(/:/)[1];\n                if (val && val.search(/%/) != -1) {\n                    val = parseInt(val.replace(/%/, ''), 10);\n                }\n                if (element.match(/align/) || element.match(/A/)) {\n                    styleObject.align = val;\n                }\n                if (element.match(/line/) || element.match(/L/) ) {\n                    styleObject.line = val;\n                }\n                if (element.match(/position/) || element.match(/P/) ) {\n                    styleObject.position = val;\n                }\n                if (element.match(/size/) || element.match(/S/)) {\n                    styleObject.size = val;\n                }\n            }\n        });\n\n        return styleObject;\n    }\n\n    /*\n    * VTT can have multiple lines to display per cuepoint.\n    */\n    function getSublines(data, idx) {\n        let i = idx;\n\n        let subline = '';\n        let lineData = '';\n        let lineCount;\n\n        while (data[i] !== '' && i < data.length) {\n            i++;\n        }\n\n        lineCount = i - idx;\n        if (lineCount > 1) {\n            for (let j = 0; j < lineCount; j++) {\n                lineData = data[(idx + j)];\n                if (!lineData.match(regExToken)) {\n                    subline += lineData;\n                    if (j !== lineCount - 1) {\n                        subline += '\\n';\n                    }\n                }\n                else {\n                    // caption text should not have '-->' in it\n                    subline = '';\n                    break;\n                }\n            }\n        } else {\n            lineData = data[idx];\n            if (!lineData.match(regExToken))\n                subline = lineData;\n        }\n        return subline;\n    }\n\n    instance = {\n        parse: parse\n    };\n\n    setup();\n    return instance;\n}\nVTTParser.__dashjs_factory_name = 'VTTParser';\nexport default FactoryMaker.getSingletonFactory(VTTParser);\n"]},"metadata":{},"sourceType":"script"}