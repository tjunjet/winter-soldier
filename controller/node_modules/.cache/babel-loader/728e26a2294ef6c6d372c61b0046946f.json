{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _IsoFile = require('./IsoFile');\n\nvar _IsoFile2 = _interopRequireDefault(_IsoFile);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _codemIsoboxer = require('codem-isoboxer');\n\nvar _codemIsoboxer2 = _interopRequireDefault(_codemIsoboxer);\n\nvar _IsoBoxSearchInfo = require('../vo/IsoBoxSearchInfo');\n\nvar _IsoBoxSearchInfo2 = _interopRequireDefault(_IsoBoxSearchInfo);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction BoxParser()\n/*config*/\n{\n  var logger = void 0,\n      instance = void 0;\n  var context = this.context;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n  }\n  /**\n  * @param {ArrayBuffer} data\n  * @returns {IsoFile|null}\n  * @memberof BoxParser#\n  */\n\n\n  function parse(data) {\n    if (!data) return null;\n\n    if (data.fileStart === undefined) {\n      data.fileStart = 0;\n    }\n\n    var parsedFile = _codemIsoboxer2.default.parseBuffer(data);\n\n    var dashIsoFile = (0, _IsoFile2.default)(context).create();\n    dashIsoFile.setData(parsedFile);\n    return dashIsoFile;\n  }\n  /**\n  * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This\n  * method only looks into the list of top boxes and doesn't analyze nested boxes.\n  * @param {string[]} types\n  * @param {ArrayBuffer|uint8Array} buffer\n  * @param {number} offset\n  * @returns {IsoBoxSearchInfo}\n  * @memberof BoxParser#\n  */\n\n\n  function findLastTopIsoBoxCompleted(types, buffer, offset) {\n    if (offset === undefined) {\n      offset = 0;\n    } // 8 = size (uint32) + type (4 characters)\n\n\n    if (!buffer || offset + 8 >= buffer.byteLength) {\n      return new _IsoBoxSearchInfo2.default(0, false);\n    }\n\n    var data = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer;\n    var boxInfo = void 0;\n    var lastCompletedOffset = 0;\n\n    while (offset < data.byteLength) {\n      var boxSize = parseUint32(data, offset);\n      var boxType = parseIsoBoxType(data, offset + 4);\n\n      if (boxSize === 0) {\n        break;\n      }\n\n      if (offset + boxSize <= data.byteLength) {\n        if (types.indexOf(boxType) >= 0) {\n          boxInfo = new _IsoBoxSearchInfo2.default(offset, true, boxSize);\n        } else {\n          lastCompletedOffset = offset + boxSize;\n        }\n      }\n\n      offset += boxSize;\n    }\n\n    if (!boxInfo) {\n      return new _IsoBoxSearchInfo2.default(lastCompletedOffset, false);\n    }\n\n    return boxInfo;\n  }\n\n  function getSamplesInfo(ab) {\n    if (!ab || ab.byteLength === 0) {\n      return {\n        sampleList: [],\n        lastSequenceNumber: NaN,\n        totalDuration: NaN,\n        numSequences: NaN\n      };\n    }\n\n    var isoFile = parse(ab); // zero or more moofs\n\n    var moofBoxes = isoFile.getBoxes('moof'); // exactly one mfhd per moof\n\n    var mfhdBoxes = isoFile.getBoxes('mfhd');\n    var sampleDuration = void 0,\n        sampleCompositionTimeOffset = void 0,\n        sampleCount = void 0,\n        sampleSize = void 0,\n        sampleDts = void 0,\n        sampleList = void 0,\n        sample = void 0,\n        i = void 0,\n        j = void 0,\n        k = void 0,\n        l = void 0,\n        m = void 0,\n        n = void 0,\n        dataOffset = void 0,\n        lastSequenceNumber = void 0,\n        numSequences = void 0,\n        totalDuration = void 0;\n    numSequences = isoFile.getBoxes('moof').length;\n    lastSequenceNumber = mfhdBoxes[mfhdBoxes.length - 1].sequence_number;\n    sampleCount = 0;\n    sampleList = [];\n    var subsIndex = -1;\n    var nextSubsSample = -1;\n\n    for (l = 0; l < moofBoxes.length; l++) {\n      var moofBox = moofBoxes[l]; // zero or more trafs per moof\n\n      var trafBoxes = moofBox.getChildBoxes('traf');\n\n      for (j = 0; j < trafBoxes.length; j++) {\n        var trafBox = trafBoxes[j]; // exactly one tfhd per traf\n\n        var tfhdBox = trafBox.getChildBox('tfhd'); // zero or one tfdt per traf\n\n        var tfdtBox = trafBox.getChildBox('tfdt');\n        sampleDts = tfdtBox.baseMediaDecodeTime; // zero or more truns per traf\n\n        var trunBoxes = trafBox.getChildBoxes('trun'); // zero or more subs per traf\n\n        var subsBoxes = trafBox.getChildBoxes('subs');\n\n        for (k = 0; k < trunBoxes.length; k++) {\n          var trunBox = trunBoxes[k];\n          sampleCount = trunBox.sample_count;\n          dataOffset = (tfhdBox.base_data_offset || 0) + (trunBox.data_offset || 0);\n\n          for (i = 0; i < sampleCount; i++) {\n            sample = trunBox.samples[i];\n            sampleDuration = sample.sample_duration !== undefined ? sample.sample_duration : tfhdBox.default_sample_duration;\n            sampleSize = sample.sample_size !== undefined ? sample.sample_size : tfhdBox.default_sample_size;\n            sampleCompositionTimeOffset = sample.sample_composition_time_offset !== undefined ? sample.sample_composition_time_offset : 0;\n            var sampleData = {\n              'dts': sampleDts,\n              'cts': sampleDts + sampleCompositionTimeOffset,\n              'duration': sampleDuration,\n              'offset': moofBox.offset + dataOffset,\n              'size': sampleSize,\n              'subSizes': [sampleSize]\n            };\n\n            if (subsBoxes) {\n              for (m = 0; m < subsBoxes.length; m++) {\n                var subsBox = subsBoxes[m];\n\n                if (subsIndex < subsBox.entry_count - 1 && i > nextSubsSample) {\n                  subsIndex++;\n                  nextSubsSample += subsBox.entries[subsIndex].sample_delta;\n                }\n\n                if (i == nextSubsSample) {\n                  sampleData.subSizes = [];\n                  var entry = subsBox.entries[subsIndex];\n\n                  for (n = 0; n < entry.subsample_count; n++) {\n                    sampleData.subSizes.push(entry.subsamples[n].subsample_size);\n                  }\n                }\n              }\n            }\n\n            sampleList.push(sampleData);\n            dataOffset += sampleSize;\n            sampleDts += sampleDuration;\n          }\n        }\n\n        totalDuration = sampleDts - tfdtBox.baseMediaDecodeTime;\n      }\n    }\n\n    return {\n      sampleList: sampleList,\n      lastSequenceNumber: lastSequenceNumber,\n      totalDuration: totalDuration,\n      numSequences: numSequences\n    };\n  }\n\n  function getMediaTimescaleFromMoov(ab) {\n    var isoFile = parse(ab);\n    var mdhdBox = isoFile ? isoFile.getBox('mdhd') : undefined;\n    return mdhdBox ? mdhdBox.timescale : NaN;\n  }\n\n  function parseUint32(data, offset) {\n    return data[offset + 3] >>> 0 | data[offset + 2] << 8 >>> 0 | data[offset + 1] << 16 >>> 0 | data[offset] << 24 >>> 0;\n  }\n\n  function parseIsoBoxType(data, offset) {\n    return String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset]);\n  }\n\n  function findInitRange(data) {\n    var initRange = null;\n    var start = void 0,\n        end = void 0;\n    var isoFile = parse(data);\n\n    if (!isoFile) {\n      return initRange;\n    }\n\n    var ftyp = isoFile.getBox('ftyp');\n    var moov = isoFile.getBox('moov');\n    logger.debug('Searching for initialization.');\n\n    if (moov && moov.isComplete) {\n      start = ftyp ? ftyp.offset : moov.offset;\n      end = moov.offset + moov.size - 1;\n      initRange = start + '-' + end;\n      logger.debug('Found the initialization.  Range: ' + initRange);\n    }\n\n    return initRange;\n  }\n  /**\n  * Real-time parsing (whenever data is loaded in the buffer payload) of the payload to capture the moof of a chunk\n  * @param {array} types\n  * @param {ArrayBuffer} buffer\n  * @param {number} offset\n  * @return {IsoBoxSearchInfo}\n  */\n\n\n  function parsePayload(types, buffer, offset) {\n    if (offset === undefined) {\n      offset = 0;\n    }\n\n    if (!buffer || offset + 8 >= buffer.byteLength) {\n      return new _IsoBoxSearchInfo2.default(0, false);\n    }\n\n    var data = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer;\n    var boxInfo = void 0;\n    var lastCompletedOffset = 0;\n\n    while (offset < data.byteLength) {\n      var boxSize = parseUint32(data, offset);\n      var boxType = parseIsoBoxType(data, offset + 4);\n\n      if (boxSize === 0) {\n        break;\n      }\n\n      if (offset + boxSize <= data.byteLength) {\n        if (types.indexOf(boxType) >= 0) {\n          boxInfo = new _IsoBoxSearchInfo2.default(offset, true, boxSize, boxType);\n        } else {\n          lastCompletedOffset = offset + boxSize;\n        }\n      }\n\n      offset += boxSize;\n    }\n\n    if (!boxInfo) {\n      return new _IsoBoxSearchInfo2.default(lastCompletedOffset, false);\n    }\n\n    return boxInfo;\n  }\n\n  instance = {\n    parse: parse,\n    findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted,\n    getMediaTimescaleFromMoov: getMediaTimescaleFromMoov,\n    getSamplesInfo: getSamplesInfo,\n    findInitRange: findInitRange,\n    parsePayload: parsePayload\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nBoxParser.__dashjs_factory_name = 'BoxParser';\nexports.default = _FactoryMaker2.default.getSingletonFactory(BoxParser);","map":{"version":3,"mappings":"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","names":["BoxParser","logger","instance","context","setup","getInstance","getLogger","parse","data","fileStart","undefined","parsedFile","ISOBoxer","parseBuffer","dashIsoFile","create","setData","findLastTopIsoBoxCompleted","types","buffer","offset","byteLength","IsoBoxSearchInfo","ArrayBuffer","Uint8Array","boxInfo","lastCompletedOffset","boxSize","parseUint32","boxType","parseIsoBoxType","indexOf","getSamplesInfo","ab","sampleList","lastSequenceNumber","NaN","totalDuration","numSequences","isoFile","moofBoxes","getBoxes","mfhdBoxes","sampleDuration","sampleCompositionTimeOffset","sampleCount","sampleSize","sampleDts","sample","i","j","k","l","m","n","dataOffset","length","sequence_number","subsIndex","nextSubsSample","moofBox","trafBoxes","getChildBoxes","trafBox","tfhdBox","getChildBox","tfdtBox","baseMediaDecodeTime","trunBoxes","subsBoxes","trunBox","sample_count","base_data_offset","data_offset","samples","sample_duration","default_sample_duration","sample_size","default_sample_size","sample_composition_time_offset","sampleData","subsBox","entry_count","entries","sample_delta","subSizes","entry","subsample_count","push","subsamples","subsample_size","getMediaTimescaleFromMoov","mdhdBox","getBox","timescale","String","fromCharCode","findInitRange","initRange","start","end","ftyp","moov","debug","isComplete","size","parsePayload","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/utils/BoxParser.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Debug from '../../core/Debug';\nimport IsoFile from './IsoFile';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport ISOBoxer from 'codem-isoboxer';\n\nimport IsoBoxSearchInfo from '../vo/IsoBoxSearchInfo';\n\nfunction BoxParser(/*config*/) {\n\n    let logger,\n        instance;\n    let context = this.context;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     * @returns {IsoFile|null}\n     * @memberof BoxParser#\n     */\n    function parse(data) {\n        if (!data) return null;\n\n        if (data.fileStart === undefined) {\n            data.fileStart = 0;\n        }\n\n        let parsedFile = ISOBoxer.parseBuffer(data);\n        let dashIsoFile = IsoFile(context).create();\n\n        dashIsoFile.setData(parsedFile);\n\n        return dashIsoFile;\n    }\n\n    /**\n     * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This\n     * method only looks into the list of top boxes and doesn't analyze nested boxes.\n     * @param {string[]} types\n     * @param {ArrayBuffer|uint8Array} buffer\n     * @param {number} offset\n     * @returns {IsoBoxSearchInfo}\n     * @memberof BoxParser#\n     */\n    function findLastTopIsoBoxCompleted(types, buffer, offset) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n\n        // 8 = size (uint32) + type (4 characters)\n        if (!buffer || offset + 8 >= buffer.byteLength) {\n            return new IsoBoxSearchInfo(0, false);\n        }\n\n        const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer;\n        let boxInfo;\n        let lastCompletedOffset = 0;\n        while (offset < data.byteLength) {\n            const boxSize = parseUint32(data, offset);\n            const boxType = parseIsoBoxType(data, offset + 4);\n\n            if (boxSize === 0) {\n                break;\n            }\n\n            if (offset + boxSize <= data.byteLength) {\n                if (types.indexOf(boxType) >= 0) {\n                    boxInfo = new IsoBoxSearchInfo(offset, true, boxSize);\n                } else {\n                    lastCompletedOffset = offset + boxSize;\n                }\n            }\n\n            offset += boxSize;\n        }\n\n        if (!boxInfo) {\n            return new IsoBoxSearchInfo(lastCompletedOffset, false);\n        }\n\n        return boxInfo;\n    }\n\n    function getSamplesInfo(ab) {\n        if (!ab || ab.byteLength === 0) {\n            return {sampleList: [], lastSequenceNumber: NaN, totalDuration: NaN, numSequences: NaN};\n        }\n        let isoFile = parse(ab);\n        // zero or more moofs\n        let moofBoxes = isoFile.getBoxes('moof');\n        // exactly one mfhd per moof\n        let mfhdBoxes = isoFile.getBoxes('mfhd');\n\n        let sampleDuration,\n            sampleCompositionTimeOffset,\n            sampleCount,\n            sampleSize,\n            sampleDts,\n            sampleList,\n            sample,\n            i, j, k, l, m, n,\n            dataOffset,\n            lastSequenceNumber,\n            numSequences,\n            totalDuration;\n\n        numSequences = isoFile.getBoxes('moof').length;\n        lastSequenceNumber = mfhdBoxes[mfhdBoxes.length - 1].sequence_number;\n        sampleCount = 0;\n\n        sampleList = [];\n        let subsIndex = -1;\n        let nextSubsSample = -1;\n        for (l = 0; l < moofBoxes.length; l++) {\n            let moofBox = moofBoxes[l];\n            // zero or more trafs per moof\n            let trafBoxes = moofBox.getChildBoxes('traf');\n            for (j = 0; j < trafBoxes.length; j++) {\n                let trafBox = trafBoxes[j];\n                // exactly one tfhd per traf\n                let tfhdBox = trafBox.getChildBox('tfhd');\n                // zero or one tfdt per traf\n                let tfdtBox = trafBox.getChildBox('tfdt');\n                sampleDts = tfdtBox.baseMediaDecodeTime;\n                // zero or more truns per traf\n                let trunBoxes = trafBox.getChildBoxes('trun');\n                // zero or more subs per traf\n                let subsBoxes = trafBox.getChildBoxes('subs');\n                for (k = 0; k < trunBoxes.length; k++) {\n                    let trunBox = trunBoxes[k];\n                    sampleCount = trunBox.sample_count;\n                    dataOffset = (tfhdBox.base_data_offset || 0) + (trunBox.data_offset || 0);\n\n                    for (i = 0; i < sampleCount; i++) {\n                        sample = trunBox.samples[i];\n                        sampleDuration = (sample.sample_duration !== undefined) ? sample.sample_duration : tfhdBox.default_sample_duration;\n                        sampleSize = (sample.sample_size !== undefined) ? sample.sample_size : tfhdBox.default_sample_size;\n                        sampleCompositionTimeOffset = (sample.sample_composition_time_offset !== undefined) ? sample.sample_composition_time_offset : 0;\n                        let sampleData = {\n                            'dts': sampleDts,\n                            'cts': (sampleDts + sampleCompositionTimeOffset),\n                            'duration': sampleDuration,\n                            'offset': moofBox.offset + dataOffset,\n                            'size': sampleSize,\n                            'subSizes': [sampleSize]\n                        };\n                        if (subsBoxes) {\n                            for (m = 0; m < subsBoxes.length; m++) {\n                                let subsBox = subsBoxes[m];\n                                if (subsIndex < (subsBox.entry_count - 1) && i > nextSubsSample) {\n                                    subsIndex++;\n                                    nextSubsSample += subsBox.entries[subsIndex].sample_delta;\n                                }\n                                if (i == nextSubsSample) {\n                                    sampleData.subSizes = [];\n                                    let entry = subsBox.entries[subsIndex];\n                                    for (n = 0; n < entry.subsample_count; n++) {\n                                        sampleData.subSizes.push(entry.subsamples[n].subsample_size);\n                                    }\n                                }\n                            }\n                        }\n                        sampleList.push(sampleData);\n                        dataOffset += sampleSize;\n                        sampleDts += sampleDuration;\n                    }\n                }\n                totalDuration = sampleDts - tfdtBox.baseMediaDecodeTime;\n            }\n        }\n        return {sampleList: sampleList, lastSequenceNumber: lastSequenceNumber, totalDuration: totalDuration, numSequences: numSequences};\n    }\n\n    function getMediaTimescaleFromMoov(ab) {\n        let isoFile = parse(ab);\n        let mdhdBox = isoFile ? isoFile.getBox('mdhd') : undefined;\n\n        return mdhdBox ? mdhdBox.timescale : NaN;\n    }\n\n    function parseUint32(data, offset) {\n        return data[offset + 3] >>> 0 |\n            (data[offset + 2] << 8) >>> 0 |\n            (data[offset + 1] << 16) >>> 0 |\n            (data[offset] << 24) >>> 0;\n    }\n\n    function parseIsoBoxType(data, offset) {\n        return String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset]);\n    }\n\n    function findInitRange(data) {\n        let initRange = null;\n        let start,\n            end;\n\n        const isoFile = parse(data);\n\n        if (!isoFile) {\n            return initRange;\n        }\n\n        const ftyp = isoFile.getBox('ftyp');\n        const moov = isoFile.getBox('moov');\n\n        logger.debug('Searching for initialization.');\n\n        if (moov && moov.isComplete) {\n            start = ftyp ? ftyp.offset : moov.offset;\n            end = moov.offset + moov.size - 1;\n            initRange = start + '-' + end;\n\n            logger.debug('Found the initialization.  Range: ' + initRange);\n        }\n\n        return initRange;\n    }\n\n    /**\n     * Real-time parsing (whenever data is loaded in the buffer payload) of the payload to capture the moof of a chunk\n     * @param {array} types\n     * @param {ArrayBuffer} buffer\n     * @param {number} offset\n     * @return {IsoBoxSearchInfo}\n     */\n    function parsePayload(types, buffer, offset) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n\n        if (!buffer || offset + 8 >= buffer.byteLength) {\n            return new IsoBoxSearchInfo(0, false);\n        }\n\n        const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer;\n        let boxInfo;\n        let lastCompletedOffset = 0;\n        while (offset < data.byteLength) {\n            const boxSize = parseUint32(data, offset);\n            const boxType = parseIsoBoxType(data, offset + 4);\n\n            if (boxSize === 0) {\n                break;\n            }\n\n            if (offset + boxSize <= data.byteLength) {\n                if (types.indexOf(boxType) >= 0) {\n                    boxInfo = new IsoBoxSearchInfo(offset, true, boxSize, boxType);\n                } else {\n                    lastCompletedOffset = offset + boxSize;\n                }\n            }\n\n            offset += boxSize;\n        }\n\n        if (!boxInfo) {\n            return new IsoBoxSearchInfo(lastCompletedOffset, false);\n        }\n\n        return boxInfo;\n    }\n\n    instance = {\n        parse: parse,\n        findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted,\n        getMediaTimescaleFromMoov: getMediaTimescaleFromMoov,\n        getSamplesInfo: getSamplesInfo,\n        findInitRange: findInitRange,\n        parsePayload: parsePayload\n    };\n\n    setup();\n\n    return instance;\n}\nBoxParser.__dashjs_factory_name = 'BoxParser';\nexport default FactoryMaker.getSingletonFactory(BoxParser);\n"]},"metadata":{},"sourceType":"script"}