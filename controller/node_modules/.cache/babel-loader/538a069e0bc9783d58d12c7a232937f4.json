{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _InitCache = require('../utils/InitCache');\n\nvar _InitCache2 = _interopRequireDefault(_InitCache);\n\nvar _SourceBufferSink = require('../SourceBufferSink');\n\nvar _SourceBufferSink2 = _interopRequireDefault(_SourceBufferSink);\n\nvar _TextController = require('../../streaming/text/TextController');\n\nvar _TextController2 = _interopRequireDefault(_TextController);\n\nvar _DashJSError = require('../../streaming/vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _Errors = require('../../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar BUFFER_CONTROLLER_TYPE = 'NotFragmentedTextBufferController';\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\nfunction NotFragmentedTextBufferController(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var textController = (0, _TextController2.default)(context).getInstance();\n  var errHandler = config.errHandler;\n  var streamInfo = config.streamInfo;\n  var type = config.type;\n  var mimeType = config.mimeType;\n  var fragmentModel = config.fragmentModel;\n  var instance = void 0,\n      isBufferingCompleted = void 0,\n      initialized = void 0,\n      mediaSource = void 0,\n      buffer = void 0,\n      initCache = void 0;\n\n  function setup() {\n    initialized = false;\n    mediaSource = null;\n    isBufferingCompleted = false;\n    eventBus.on(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    eventBus.on(_Events2.default.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n  }\n\n  function getBufferControllerType() {\n    return BUFFER_CONTROLLER_TYPE;\n  }\n\n  function initialize(source) {\n    setMediaSource(source);\n    initCache = (0, _InitCache2.default)(context).getInstance();\n  }\n\n  function createBuffer(mediaInfoArr) {\n    var mediaInfo = mediaInfoArr[0];\n\n    try {\n      buffer = (0, _SourceBufferSink2.default)(context).create(mediaSource, mediaInfo);\n\n      if (!initialized) {\n        var textBuffer = buffer.getBuffer();\n\n        if (textBuffer.hasOwnProperty(_Constants2.default.INITIALIZE)) {\n          textBuffer.initialize(mimeType, streamInfo, mediaInfoArr, fragmentModel);\n        }\n\n        initialized = true;\n      }\n\n      return buffer;\n    } catch (e) {\n      if (mediaInfo && (mediaInfo.isText || mediaInfo.codec.indexOf('codecs=\"stpp') !== -1 || mediaInfo.codec.indexOf('codecs=\"wvtt') !== -1)) {\n        try {\n          buffer = textController.getTextSourceBuffer();\n        } catch (e) {\n          errHandler.error(new _DashJSError2.default(_Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, _Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type + ' : ' + e.message));\n        }\n      } else {\n        errHandler.error(new _DashJSError2.default(_Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, _Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type));\n      }\n    }\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function getBuffer() {\n    return buffer;\n  }\n\n  function setMediaSource(value) {\n    mediaSource = value;\n  }\n\n  function getMediaSource() {\n    return mediaSource;\n  }\n\n  function getIsPruningInProgress() {\n    return false;\n  }\n\n  function dischargePreBuffer() {}\n\n  function getBufferLevel() {\n    return 0;\n  }\n\n  function getIsBufferingCompleted() {\n    return isBufferingCompleted;\n  }\n\n  function reset(errored) {\n    eventBus.off(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    eventBus.off(_Events2.default.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n\n    if (!errored && buffer) {\n      buffer.abort();\n      buffer.reset();\n      buffer = null;\n    }\n  }\n\n  function onDataUpdateCompleted(e) {\n    if (initCache.extract(streamInfo.id, e.currentRepresentation.id) !== null) {\n      return;\n    } // Representation has changed, clear buffer\n\n\n    isBufferingCompleted = false; // // Text data file is contained in initialization segment\n\n    eventBus.trigger(_Events2.default.INIT_FRAGMENT_NEEDED, {\n      representationId: e.currentRepresentation.id,\n      sender: instance\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function appendInitSegment(representationId) {\n    // If text data file already in cache then no need to append it again\n    return initCache.extract(streamInfo.id, representationId) !== null;\n  }\n\n  function onInitFragmentLoaded(e) {\n    if (!e.chunk.bytes) return;\n    initCache.save(e.chunk);\n    buffer.append(e.chunk);\n    isBufferingCompleted = true;\n    eventBus.trigger(_Events2.default.STREAM_COMPLETED, {\n      request: e.request\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function getRangeAt() {\n    return null;\n  }\n\n  function updateTimestampOffset(MSETimeOffset) {\n    if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n      buffer.timestampOffset = MSETimeOffset;\n    }\n  }\n\n  instance = {\n    getBufferControllerType: getBufferControllerType,\n    initialize: initialize,\n    createBuffer: createBuffer,\n    getStreamId: getStreamId,\n    getType: getType,\n    getBuffer: getBuffer,\n    getBufferLevel: getBufferLevel,\n    setMediaSource: setMediaSource,\n    getMediaSource: getMediaSource,\n    getIsBufferingCompleted: getIsBufferingCompleted,\n    getIsPruningInProgress: getIsPruningInProgress,\n    dischargePreBuffer: dischargePreBuffer,\n    appendInitSegment: appendInitSegment,\n    getRangeAt: getRangeAt,\n    reset: reset,\n    updateTimestampOffset: updateTimestampOffset\n  };\n  setup();\n  return instance;\n}\n\nNotFragmentedTextBufferController.__dashjs_factory_name = BUFFER_CONTROLLER_TYPE;\nexports.default = _FactoryMaker2.default.getClassFactory(NotFragmentedTextBufferController);","map":{"version":3,"mappings":"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","names":["BUFFER_CONTROLLER_TYPE","NotFragmentedTextBufferController","config","context","eventBus","getInstance","textController","errHandler","streamInfo","type","mimeType","fragmentModel","instance","isBufferingCompleted","initialized","mediaSource","buffer","initCache","setup","on","Events","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","INIT_FRAGMENT_LOADED","onInitFragmentLoaded","getBufferControllerType","initialize","source","setMediaSource","createBuffer","mediaInfoArr","mediaInfo","create","textBuffer","getBuffer","hasOwnProperty","Constants","INITIALIZE","e","isText","codec","indexOf","getTextSourceBuffer","error","DashJSError","Errors","MEDIASOURCE_TYPE_UNSUPPORTED_CODE","MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE","message","getStreamId","id","getType","value","getMediaSource","getIsPruningInProgress","dischargePreBuffer","getBufferLevel","getIsBufferingCompleted","reset","errored","off","abort","extract","currentRepresentation","trigger","INIT_FRAGMENT_NEEDED","representationId","sender","streamId","mediaType","appendInitSegment","chunk","bytes","save","append","STREAM_COMPLETED","request","getRangeAt","updateTimestampOffset","MSETimeOffset","timestampOffset","isNaN","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/text/NotFragmentedTextBufferController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport InitCache from '../utils/InitCache';\nimport SourceBufferSink from '../SourceBufferSink';\nimport TextController from '../../streaming/text/TextController';\nimport DashJSError from '../../streaming/vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\n\nconst BUFFER_CONTROLLER_TYPE = 'NotFragmentedTextBufferController';\nfunction NotFragmentedTextBufferController(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const textController = TextController(context).getInstance();\n\n    const errHandler = config.errHandler;\n    const streamInfo = config.streamInfo;\n    const type = config.type;\n    const mimeType = config.mimeType;\n    const fragmentModel = config.fragmentModel;\n\n    let instance,\n        isBufferingCompleted,\n        initialized,\n        mediaSource,\n        buffer,\n        initCache;\n\n    function setup() {\n        initialized = false;\n        mediaSource = null;\n        isBufferingCompleted = false;\n\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.on(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n    }\n\n    function getBufferControllerType() {\n        return BUFFER_CONTROLLER_TYPE;\n    }\n\n    function initialize(source) {\n        setMediaSource(source);\n        initCache = InitCache(context).getInstance();\n    }\n\n    function createBuffer(mediaInfoArr) {\n        const mediaInfo = mediaInfoArr[0];\n        try {\n            buffer = SourceBufferSink(context).create(mediaSource, mediaInfo);\n            if (!initialized) {\n                const textBuffer = buffer.getBuffer();\n                if (textBuffer.hasOwnProperty(Constants.INITIALIZE)) {\n                    textBuffer.initialize(mimeType, streamInfo, mediaInfoArr, fragmentModel);\n                }\n                initialized = true;\n            }\n            return buffer;\n        } catch (e) {\n            if (mediaInfo && ((mediaInfo.isText) || (mediaInfo.codec.indexOf('codecs=\"stpp') !== -1) || (mediaInfo.codec.indexOf('codecs=\"wvtt') !== -1))) {\n                try {\n                    buffer = textController.getTextSourceBuffer();\n                } catch (e) {\n                    errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type + ' : ' + e.message));\n                }\n            } else {\n                errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type));\n            }\n        }\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function setMediaSource(value) {\n        mediaSource = value;\n    }\n\n    function getMediaSource() {\n        return mediaSource;\n    }\n\n    function getIsPruningInProgress() {\n        return false;\n    }\n\n    function dischargePreBuffer() {\n    }\n\n    function getBufferLevel() {\n        return 0;\n    }\n\n    function getIsBufferingCompleted() {\n        return isBufferingCompleted;\n    }\n\n    function reset(errored) {\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n\n        if (!errored && buffer) {\n            buffer.abort();\n            buffer.reset();\n            buffer = null;\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (initCache.extract(streamInfo.id, e.currentRepresentation.id) !== null) {\n            return;\n        }\n\n        // Representation has changed, clear buffer\n        isBufferingCompleted = false;\n\n        // // Text data file is contained in initialization segment\n        eventBus.trigger(Events.INIT_FRAGMENT_NEEDED,\n            { representationId: e.currentRepresentation.id, sender: instance },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function appendInitSegment(representationId) {\n        // If text data file already in cache then no need to append it again\n        return initCache.extract(streamInfo.id, representationId) !== null;\n    }\n\n    function onInitFragmentLoaded(e) {\n        if (!e.chunk.bytes) return;\n\n        initCache.save(e.chunk);\n        buffer.append(e.chunk);\n\n        isBufferingCompleted = true;\n\n        eventBus.trigger(Events.STREAM_COMPLETED,\n            { request: e.request },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function getRangeAt() {\n        return null;\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            buffer.timestampOffset = MSETimeOffset;\n        }\n    }\n\n    instance = {\n        getBufferControllerType: getBufferControllerType,\n        initialize: initialize,\n        createBuffer: createBuffer,\n        getStreamId: getStreamId,\n        getType: getType,\n        getBuffer: getBuffer,\n        getBufferLevel: getBufferLevel,\n        setMediaSource: setMediaSource,\n        getMediaSource: getMediaSource,\n        getIsBufferingCompleted: getIsBufferingCompleted,\n        getIsPruningInProgress: getIsPruningInProgress,\n        dischargePreBuffer: dischargePreBuffer,\n        appendInitSegment: appendInitSegment,\n        getRangeAt: getRangeAt,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset\n    };\n\n    setup();\n\n    return instance;\n}\n\nNotFragmentedTextBufferController.__dashjs_factory_name = BUFFER_CONTROLLER_TYPE;\nexport default FactoryMaker.getClassFactory(NotFragmentedTextBufferController);\n"]},"metadata":{},"sourceType":"script"}