{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Segment = require('./vo/Segment');\n\nvar _Segment2 = _interopRequireDefault(_Segment);\n\nvar _DashJSError = require('../streaming/vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _FragmentRequest = require('../streaming/vo/FragmentRequest');\n\nvar _FragmentRequest2 = _interopRequireDefault(_FragmentRequest);\n\nvar _URLLoader = require('../streaming/net/URLLoader');\n\nvar _URLLoader2 = _interopRequireDefault(_URLLoader);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction SegmentBaseLoader() {\n  var context = this.context;\n  var instance = void 0,\n      logger = void 0,\n      errHandler = void 0,\n      boxParser = void 0,\n      requestModifier = void 0,\n      dashMetrics = void 0,\n      settings = void 0,\n      mediaPlayerModel = void 0,\n      urlLoader = void 0,\n      events = void 0,\n      eventBus = void 0,\n      errors = void 0,\n      constants = void 0,\n      dashConstants = void 0,\n      urlUtils = void 0,\n      baseURLController = void 0;\n\n  function setup() {}\n\n  function initialize() {\n    urlLoader = (0, _URLLoader2.default)(context).create({\n      errHandler: errHandler,\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      requestModifier: requestModifier,\n      useFetch: settings ? settings.get().streaming.lowLatencyEnabled : null,\n      boxParser: boxParser,\n      errors: errors,\n      urlUtils: urlUtils,\n      constants: constants,\n      dashConstants: dashConstants\n    });\n  }\n\n  function setConfig(config) {\n    if (config.baseURLController) {\n      baseURLController = config.baseURLController;\n    }\n\n    if (config.dashMetrics) {\n      dashMetrics = config.dashMetrics;\n    }\n\n    if (config.mediaPlayerModel) {\n      mediaPlayerModel = config.mediaPlayerModel;\n    }\n\n    if (config.errHandler) {\n      errHandler = config.errHandler;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n\n    if (config.boxParser) {\n      boxParser = config.boxParser;\n    }\n\n    if (config.events) {\n      events = config.events;\n    }\n\n    if (config.eventBus) {\n      eventBus = config.eventBus;\n    }\n\n    if (config.debug) {\n      logger = config.debug.getLogger(instance);\n    }\n\n    if (config.requestModifier) {\n      requestModifier = config.requestModifier;\n    }\n\n    if (config.errors) {\n      errors = config.errors;\n    }\n\n    if (config.urlUtils) {\n      urlUtils = config.urlUtils;\n    }\n\n    if (config.constants) {\n      constants = config.constants;\n    }\n\n    if (config.dashConstants) {\n      dashConstants = config.dashConstants;\n    }\n  }\n\n  function checkConfig() {\n    if (!baseURLController || !baseURLController.hasOwnProperty('resolve')) {\n      throw new Error('setConfig function has to be called previously');\n    }\n  }\n\n  function loadInitialization(streamId, mediaType, representation, loadingInfo) {\n    checkConfig();\n    var initRange = null;\n    var baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n    var info = loadingInfo || {\n      init: true,\n      url: baseUrl ? baseUrl.url : undefined,\n      range: {\n        start: 0,\n        end: 1500\n      },\n      searching: false,\n      bytesLoaded: 0,\n      bytesToLoad: 1500,\n      mediaType: mediaType\n    };\n    logger.debug('Start searching for initialization.');\n    var request = getFragmentRequest(info);\n\n    var onload = function onload(response) {\n      info.bytesLoaded = info.range.end;\n      initRange = boxParser.findInitRange(response);\n\n      if (initRange) {\n        representation.range = initRange; // note that we don't explicitly set rep.initialization as this\n        // will be computed when all BaseURLs are resolved later\n\n        eventBus.trigger(events.INITIALIZATION_LOADED, {\n          representation: representation\n        }, {\n          streamId: streamId,\n          mediaType: mediaType\n        });\n      } else {\n        info.range.end = info.bytesLoaded + info.bytesToLoad;\n        loadInitialization(streamId, mediaType, representation, info);\n      }\n    };\n\n    var onerror = function onerror() {\n      eventBus.trigger(events.INITIALIZATION_LOADED, {\n        representation: representation\n      }, {\n        streamId: streamId,\n        mediaType: mediaType\n      });\n    };\n\n    urlLoader.load({\n      request: request,\n      success: onload,\n      error: onerror\n    });\n    logger.debug('Perform init search: ' + info.url);\n  }\n\n  function loadSegments(streamId, mediaType, representation, range, callback, loadingInfo) {\n    checkConfig();\n\n    if (range && (range.start === undefined || range.end === undefined)) {\n      var parts = range ? range.toString().split('-') : null;\n      range = parts ? {\n        start: parseFloat(parts[0]),\n        end: parseFloat(parts[1])\n      } : null;\n    }\n\n    callback = !callback ? onLoaded : callback;\n    var isoFile = null;\n    var sidx = null;\n    var hasRange = !!range;\n    var baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n    var info = {\n      init: false,\n      url: baseUrl ? baseUrl.url : undefined,\n      range: hasRange ? range : {\n        start: 0,\n        end: 1500\n      },\n      searching: !hasRange,\n      bytesLoaded: loadingInfo ? loadingInfo.bytesLoaded : 0,\n      bytesToLoad: 1500,\n      mediaType: mediaType\n    };\n    var request = getFragmentRequest(info);\n\n    var onload = function onload(response) {\n      var extraBytes = info.bytesToLoad;\n      var loadedLength = response.byteLength;\n      info.bytesLoaded = info.range.end - info.range.start;\n      isoFile = boxParser.parse(response);\n      sidx = isoFile.getBox('sidx');\n\n      if (!sidx || !sidx.isComplete) {\n        if (sidx) {\n          info.range.start = sidx.offset || info.range.start;\n          info.range.end = info.range.start + (sidx.size || extraBytes);\n        } else if (loadedLength < info.bytesLoaded) {\n          // if we have reached a search limit or if we have reached the end of the file we have to stop trying to find sidx\n          callback(streamId, mediaType, null, representation);\n          return;\n        } else {\n          var lastBox = isoFile.getLastBox();\n\n          if (lastBox && lastBox.size) {\n            info.range.start = lastBox.offset + lastBox.size;\n            info.range.end = info.range.start + extraBytes;\n          } else {\n            info.range.end += extraBytes;\n          }\n        }\n\n        loadSegments(streamId, mediaType, representation, info.range, callback, info);\n      } else {\n        var ref = sidx.references;\n        var loadMultiSidx = void 0,\n            segments = void 0;\n\n        if (ref !== null && ref !== undefined && ref.length > 0) {\n          loadMultiSidx = ref[0].reference_type === 1;\n        }\n\n        if (loadMultiSidx) {\n          logger.debug('Initiate multiple SIDX load.');\n          info.range.end = info.range.start + sidx.size;\n          var j = void 0,\n              len = void 0,\n              ss = void 0,\n              se = void 0,\n              r = void 0;\n          var segs = [];\n          var count = 0;\n          var offset = (sidx.offset || info.range.start) + sidx.size;\n\n          var tmpCallback = function tmpCallback(streamId, mediaType, result) {\n            if (result) {\n              segs = segs.concat(result);\n              count++;\n\n              if (count >= len) {\n                // http requests can be processed in a wrong order, so, we have to reorder segments with an ascending start Time order\n                segs.sort(function (a, b) {\n                  return a.startTime - b.startTime < 0 ? -1 : 0;\n                });\n                callback(streamId, mediaType, segs, representation);\n              }\n            } else {\n              callback(streamId, mediaType, null, representation);\n            }\n          };\n\n          for (j = 0, len = ref.length; j < len; j++) {\n            ss = offset;\n            se = offset + ref[j].referenced_size - 1;\n            offset = offset + ref[j].referenced_size;\n            r = {\n              start: ss,\n              end: se\n            };\n            loadSegments(streamId, mediaType, representation, r, tmpCallback, info);\n          }\n        } else {\n          logger.debug('Parsing segments from SIDX. representation ' + mediaType + ' - id: ' + representation.id + ' for range : ' + info.range.start + ' - ' + info.range.end);\n          segments = getSegmentsForSidx(sidx, info);\n          callback(streamId, mediaType, segments, representation);\n        }\n      }\n    };\n\n    var onerror = function onerror() {\n      callback(streamId, mediaType, null, representation);\n    };\n\n    urlLoader.load({\n      request: request,\n      success: onload,\n      error: onerror\n    });\n    logger.debug('Perform SIDX load: ' + info.url + ' with range : ' + info.range.start + ' - ' + info.range.end);\n  }\n\n  function reset() {\n    urlLoader.abort();\n    urlLoader = null;\n    errHandler = null;\n    boxParser = null;\n    requestModifier = null;\n  }\n\n  function getSegmentsForSidx(sidx, info) {\n    var refs = sidx.references;\n    var len = refs.length;\n    var timescale = sidx.timescale;\n    var time = sidx.earliest_presentation_time;\n    var start = info.range.start + sidx.offset + sidx.first_offset + sidx.size;\n    var segments = [];\n    var segment = void 0,\n        end = void 0,\n        duration = void 0,\n        size = void 0;\n\n    for (var i = 0; i < len; i++) {\n      duration = refs[i].subsegment_duration;\n      size = refs[i].referenced_size;\n      segment = new _Segment2.default(); // note that we don't explicitly set segment.media as this will be\n      // computed when all BaseURLs are resolved later\n\n      segment.duration = duration;\n      segment.startTime = time;\n      segment.timescale = timescale;\n      end = start + size - 1;\n      segment.mediaRange = start + '-' + end;\n      segments.push(segment);\n      time += duration;\n      start += size;\n    }\n\n    return segments;\n  }\n\n  function getFragmentRequest(info) {\n    if (!info.url) {\n      return;\n    }\n\n    var request = new _FragmentRequest2.default();\n    request.setInfo(info);\n    return request;\n  }\n\n  function onLoaded(streamId, mediaType, segments, representation) {\n    eventBus.trigger(events.SEGMENTS_LOADED, {\n      segments: segments,\n      representation: representation,\n      error: segments ? undefined : new _DashJSError2.default(errors.SEGMENT_BASE_LOADER_ERROR_CODE, errors.SEGMENT_BASE_LOADER_ERROR_MESSAGE)\n    }, {\n      streamId: streamId,\n      mediaType: mediaType\n    });\n  }\n\n  instance = {\n    setConfig: setConfig,\n    initialize: initialize,\n    loadInitialization: loadInitialization,\n    loadSegments: loadSegments,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nSegmentBaseLoader.__dashjs_factory_name = 'SegmentBaseLoader';\nexports.default = _FactoryMaker2.default.getSingletonFactory(SegmentBaseLoader);","map":{"version":3,"mappings":"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","names":["SegmentBaseLoader","context","instance","logger","errHandler","boxParser","requestModifier","dashMetrics","settings","mediaPlayerModel","urlLoader","events","eventBus","errors","constants","dashConstants","urlUtils","baseURLController","setup","initialize","create","useFetch","get","streaming","lowLatencyEnabled","setConfig","config","debug","getLogger","checkConfig","hasOwnProperty","Error","loadInitialization","streamId","mediaType","representation","loadingInfo","initRange","baseUrl","resolve","path","info","init","url","undefined","range","start","end","searching","bytesLoaded","bytesToLoad","request","getFragmentRequest","onload","response","findInitRange","trigger","INITIALIZATION_LOADED","onerror","load","success","error","loadSegments","callback","parts","toString","split","parseFloat","onLoaded","isoFile","sidx","hasRange","extraBytes","loadedLength","byteLength","parse","getBox","isComplete","offset","size","lastBox","getLastBox","ref","references","loadMultiSidx","segments","length","reference_type","j","len","ss","se","r","segs","count","tmpCallback","result","concat","sort","a","b","startTime","referenced_size","id","getSegmentsForSidx","reset","abort","refs","timescale","time","earliest_presentation_time","first_offset","segment","duration","i","subsegment_duration","Segment","mediaRange","push","FragmentRequest","setInfo","SEGMENTS_LOADED","DashJSError","SEGMENT_BASE_LOADER_ERROR_CODE","SEGMENT_BASE_LOADER_ERROR_MESSAGE","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/dash/SegmentBaseLoader.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Segment from './vo/Segment';\nimport DashJSError from '../streaming/vo/DashJSError';\nimport FactoryMaker from '../core/FactoryMaker';\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport URLLoader from '../streaming/net/URLLoader';\n\nfunction SegmentBaseLoader() {\n\n    const context = this.context;\n\n    let instance,\n        logger,\n        errHandler,\n        boxParser,\n        requestModifier,\n        dashMetrics,\n        settings,\n        mediaPlayerModel,\n        urlLoader,\n        events,\n        eventBus,\n        errors,\n        constants,\n        dashConstants,\n        urlUtils,\n        baseURLController;\n\n    function setup() {\n    }\n\n    function initialize() {\n        urlLoader = URLLoader(context).create({\n            errHandler: errHandler,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            requestModifier: requestModifier,\n            useFetch: settings ? settings.get().streaming.lowLatencyEnabled : null,\n            boxParser: boxParser,\n            errors: errors,\n            urlUtils: urlUtils,\n            constants: constants,\n            dashConstants: dashConstants\n        });\n    }\n\n    function setConfig(config) {\n        if (config.baseURLController) {\n            baseURLController = config.baseURLController;\n        }\n\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n\n        if (config.settings) {\n            settings = config.settings;\n        }\n\n        if (config.boxParser) {\n            boxParser = config.boxParser;\n        }\n\n        if (config.events) {\n            events = config.events;\n        }\n\n        if (config.eventBus) {\n            eventBus = config.eventBus;\n        }\n\n        if (config.debug) {\n            logger = config.debug.getLogger(instance);\n        }\n\n        if (config.requestModifier) {\n            requestModifier = config.requestModifier;\n        }\n\n        if (config.errors) {\n            errors = config.errors;\n        }\n\n        if (config.urlUtils) {\n            urlUtils = config.urlUtils;\n        }\n\n        if (config.constants) {\n            constants = config.constants;\n        }\n\n        if (config.dashConstants) {\n            dashConstants = config.dashConstants;\n        }\n    }\n\n    function checkConfig() {\n        if (!baseURLController || !baseURLController.hasOwnProperty('resolve')) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    function loadInitialization(streamId, mediaType, representation, loadingInfo) {\n        checkConfig();\n        let initRange = null;\n        const baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n        const info = loadingInfo || {\n            init: true,\n            url: baseUrl ? baseUrl.url : undefined,\n            range: {\n                start: 0,\n                end: 1500\n            },\n            searching: false,\n            bytesLoaded: 0,\n            bytesToLoad: 1500,\n            mediaType: mediaType\n        };\n\n        logger.debug('Start searching for initialization.');\n\n        const request = getFragmentRequest(info);\n\n        const onload = function (response) {\n            info.bytesLoaded = info.range.end;\n            initRange = boxParser.findInitRange(response);\n\n            if (initRange) {\n                representation.range = initRange;\n                // note that we don't explicitly set rep.initialization as this\n                // will be computed when all BaseURLs are resolved later\n                eventBus.trigger(events.INITIALIZATION_LOADED,\n                    { representation: representation },\n                    { streamId: streamId, mediaType: mediaType }\n                );\n            } else {\n                info.range.end = info.bytesLoaded + info.bytesToLoad;\n                loadInitialization(streamId, mediaType, representation, info);\n            }\n        };\n\n        const onerror = function () {\n            eventBus.trigger(events.INITIALIZATION_LOADED,\n                { representation: representation },\n                { streamId: streamId, mediaType: mediaType }\n            );\n        };\n\n        urlLoader.load({request: request, success: onload, error: onerror});\n\n        logger.debug('Perform init search: ' + info.url);\n    }\n\n    function loadSegments(streamId, mediaType, representation, range, callback, loadingInfo) {\n        checkConfig();\n        if (range && (range.start === undefined || range.end === undefined)) {\n            const parts = range ? range.toString().split('-') : null;\n            range = parts ? {start: parseFloat(parts[0]), end: parseFloat(parts[1])} : null;\n        }\n\n        callback = !callback ? onLoaded : callback;\n        let isoFile = null;\n        let sidx = null;\n        const hasRange = !!range;\n        const baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n        const info = {\n            init: false,\n            url: baseUrl ? baseUrl.url : undefined,\n            range: hasRange ? range : { start: 0, end: 1500 },\n            searching: !hasRange,\n            bytesLoaded: loadingInfo ? loadingInfo.bytesLoaded : 0,\n            bytesToLoad: 1500,\n            mediaType: mediaType\n        };\n\n        const request = getFragmentRequest(info);\n\n        const onload = function (response) {\n            const extraBytes = info.bytesToLoad;\n            const loadedLength = response.byteLength;\n\n            info.bytesLoaded = info.range.end - info.range.start;\n            isoFile = boxParser.parse(response);\n            sidx = isoFile.getBox('sidx');\n\n            if (!sidx || !sidx.isComplete) {\n                if (sidx) {\n                    info.range.start = sidx.offset || info.range.start;\n                    info.range.end = info.range.start + (sidx.size || extraBytes);\n                } else if (loadedLength < info.bytesLoaded) {\n                    // if we have reached a search limit or if we have reached the end of the file we have to stop trying to find sidx\n                    callback(streamId, mediaType, null, representation);\n                    return;\n                } else {\n                    const lastBox = isoFile.getLastBox();\n\n                    if (lastBox && lastBox.size) {\n                        info.range.start = lastBox.offset + lastBox.size;\n                        info.range.end = info.range.start + extraBytes;\n                    } else {\n                        info.range.end += extraBytes;\n                    }\n                }\n                loadSegments(streamId, mediaType, representation, info.range, callback, info);\n            } else {\n                const ref = sidx.references;\n                let loadMultiSidx,\n                    segments;\n\n                if (ref !== null && ref !== undefined && ref.length > 0) {\n                    loadMultiSidx = (ref[0].reference_type === 1);\n                }\n\n                if (loadMultiSidx) {\n                    logger.debug('Initiate multiple SIDX load.');\n                    info.range.end = info.range.start + sidx.size;\n\n                    let j, len, ss, se, r;\n                    let segs = [];\n                    let count = 0;\n                    let offset = (sidx.offset || info.range.start) + sidx.size;\n                    const tmpCallback = function (streamId, mediaType, result) {\n                        if (result) {\n                            segs = segs.concat(result);\n                            count++;\n\n                            if (count >= len) {\n                                // http requests can be processed in a wrong order, so, we have to reorder segments with an ascending start Time order\n                                segs.sort(function (a, b) {\n                                    return a.startTime - b.startTime < 0 ? -1 : 0;\n                                });\n                                callback(streamId, mediaType, segs, representation);\n                            }\n                        } else {\n                            callback(streamId, mediaType, null, representation);\n                        }\n                    };\n\n                    for (j = 0, len = ref.length; j < len; j++) {\n                        ss = offset;\n                        se = offset + ref[j].referenced_size - 1;\n                        offset = offset + ref[j].referenced_size;\n                        r = {start: ss, end: se};\n                        loadSegments(streamId, mediaType, representation, r, tmpCallback, info);\n                    }\n\n                } else {\n                    logger.debug('Parsing segments from SIDX. representation ' + mediaType + ' - id: ' + representation.id + ' for range : ' + info.range.start + ' - ' + info.range.end);\n                    segments = getSegmentsForSidx(sidx, info);\n                    callback(streamId, mediaType, segments, representation);\n                }\n            }\n        };\n\n        const onerror = function () {\n            callback(streamId, mediaType, null, representation);\n        };\n\n        urlLoader.load({request: request, success: onload, error: onerror});\n        logger.debug('Perform SIDX load: ' + info.url + ' with range : ' + info.range.start + ' - ' + info.range.end);\n    }\n\n    function reset() {\n        urlLoader.abort();\n        urlLoader = null;\n        errHandler = null;\n        boxParser = null;\n        requestModifier = null;\n    }\n\n    function getSegmentsForSidx(sidx, info) {\n        const refs = sidx.references;\n        const len = refs.length;\n        const timescale = sidx.timescale;\n        let time = sidx.earliest_presentation_time;\n        let start = info.range.start + sidx.offset + sidx.first_offset + sidx.size;\n        const segments = [];\n        let segment,\n            end,\n            duration,\n            size;\n\n        for (let i = 0; i < len; i++) {\n            duration = refs[i].subsegment_duration;\n            size = refs[i].referenced_size;\n\n            segment = new Segment();\n            // note that we don't explicitly set segment.media as this will be\n            // computed when all BaseURLs are resolved later\n            segment.duration = duration;\n            segment.startTime = time;\n            segment.timescale = timescale;\n            end = start + size - 1;\n            segment.mediaRange = start + '-' + end;\n            segments.push(segment);\n            time += duration;\n            start += size;\n        }\n\n        return segments;\n    }\n\n    function getFragmentRequest(info) {\n        if (!info.url) {\n            return;\n        }\n        const request = new FragmentRequest();\n        request.setInfo(info);\n        return request;\n    }\n\n    function onLoaded(streamId, mediaType, segments, representation) {\n        eventBus.trigger(events.SEGMENTS_LOADED,\n            {\n                segments: segments,\n                representation: representation,\n                error: segments ? undefined : new DashJSError(errors.SEGMENT_BASE_LOADER_ERROR_CODE, errors.SEGMENT_BASE_LOADER_ERROR_MESSAGE)\n            },\n            { streamId: streamId, mediaType: mediaType }\n        );\n    }\n\n    instance = {\n        setConfig: setConfig,\n        initialize: initialize,\n        loadInitialization: loadInitialization,\n        loadSegments: loadSegments,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nSegmentBaseLoader.__dashjs_factory_name = 'SegmentBaseLoader';\nexport default FactoryMaker.getSingletonFactory(SegmentBaseLoader);\n"]},"metadata":{},"sourceType":"script"}