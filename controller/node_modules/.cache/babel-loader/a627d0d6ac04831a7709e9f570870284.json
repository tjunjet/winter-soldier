{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('./constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _DashConstants = require('../dash/constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _XlinkController = require('./controllers/XlinkController');\n\nvar _XlinkController2 = _interopRequireDefault(_XlinkController);\n\nvar _URLLoader = require('./net/URLLoader');\n\nvar _URLLoader2 = _interopRequireDefault(_URLLoader);\n\nvar _URLUtils = require('./utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nvar _TextRequest = require('./vo/TextRequest');\n\nvar _TextRequest2 = _interopRequireDefault(_TextRequest);\n\nvar _DashJSError = require('./vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _HTTPRequest = require('./vo/metrics/HTTPRequest');\n\nvar _EventBus = require('../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Errors = require('../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _DashParser = require('../dash/parser/DashParser');\n\nvar _DashParser2 = _interopRequireDefault(_DashParser);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ManifestLoader(config) {\n  config = config || {};\n  var context = this.context;\n  var debug = config.debug;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      urlLoader = void 0,\n      xlinkController = void 0,\n      parser = void 0;\n  var mssHandler = config.mssHandler;\n  var errHandler = config.errHandler;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    eventBus.on(_Events2.default.XLINK_READY, onXlinkReady, instance);\n    urlLoader = (0, _URLLoader2.default)(context).create({\n      errHandler: config.errHandler,\n      dashMetrics: config.dashMetrics,\n      mediaPlayerModel: config.mediaPlayerModel,\n      requestModifier: config.requestModifier,\n      useFetch: config.settings.get().streaming.lowLatencyEnabled,\n      urlUtils: urlUtils,\n      constants: _Constants2.default,\n      dashConstants: _DashConstants2.default,\n      errors: _Errors2.default\n    });\n    xlinkController = (0, _XlinkController2.default)(context).create({\n      errHandler: errHandler,\n      dashMetrics: config.dashMetrics,\n      mediaPlayerModel: config.mediaPlayerModel,\n      requestModifier: config.requestModifier,\n      settings: config.settings\n    });\n    parser = null;\n  }\n\n  function onXlinkReady(event) {\n    eventBus.trigger(_Events2.default.INTERNAL_MANIFEST_LOADED, {\n      manifest: event.manifest\n    });\n  }\n\n  function createParser(data) {\n    var parser = null; // Analyze manifest content to detect protocol and select appropriate parser\n\n    if (data.indexOf('SmoothStreamingMedia') > -1) {\n      //do some business to transform it into a Dash Manifest\n      if (mssHandler) {\n        parser = mssHandler.createMssParser();\n        mssHandler.registerEvents();\n      }\n\n      return parser;\n    } else if (data.indexOf('MPD') > -1 || data.indexOf('Patch') > -1) {\n      return (0, _DashParser2.default)(context).create({\n        debug: debug\n      });\n    } else {\n      return parser;\n    }\n  }\n\n  function load(url) {\n    var request = new _TextRequest2.default(url, _HTTPRequest.HTTPRequest.MPD_TYPE);\n    urlLoader.load({\n      request: request,\n      success: function success(data, textStatus, responseURL) {\n        // Manage situations in which success is called after calling reset\n        if (!xlinkController) return;\n        var actualUrl = void 0,\n            baseUri = void 0,\n            manifest = void 0; // Handle redirects for the MPD - as per RFC3986 Section 5.1.3\n        // also handily resolves relative MPD URLs to absolute\n\n        if (responseURL && responseURL !== url) {\n          baseUri = urlUtils.parseBaseUrl(responseURL);\n          actualUrl = responseURL;\n        } else {\n          // usually this case will be caught and resolved by\n          // responseURL above but it is not available for IE11 and Edge/12 and Edge/13\n          // baseUri must be absolute for BaseURL resolution later\n          if (urlUtils.isRelative(url)) {\n            url = urlUtils.resolve(url, window.location.href);\n          }\n\n          baseUri = urlUtils.parseBaseUrl(url);\n        } // A response of no content implies in-memory is properly up to date\n\n\n        if (textStatus == 'No Content') {\n          eventBus.trigger(_Events2.default.INTERNAL_MANIFEST_LOADED, {\n            manifest: null\n          });\n          return;\n        } // Create parser according to manifest type\n\n\n        if (parser === null) {\n          parser = createParser(data);\n        }\n\n        if (parser === null) {\n          eventBus.trigger(_Events2.default.INTERNAL_MANIFEST_LOADED, {\n            manifest: null,\n            error: new _DashJSError2.default(_Errors2.default.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE, _Errors2.default.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + ('' + url))\n          });\n          return;\n        } // init xlinkcontroller with matchers and iron object from created parser\n\n\n        xlinkController.setMatchers(parser.getMatchers());\n        xlinkController.setIron(parser.getIron());\n\n        try {\n          manifest = parser.parse(data);\n        } catch (e) {\n          eventBus.trigger(_Events2.default.INTERNAL_MANIFEST_LOADED, {\n            manifest: null,\n            error: new _DashJSError2.default(_Errors2.default.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE, _Errors2.default.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + ('' + url))\n          });\n          return;\n        }\n\n        if (manifest) {\n          manifest.url = actualUrl || url; // URL from which the MPD was originally retrieved (MPD updates will not change this value)\n\n          if (!manifest.originalUrl) {\n            manifest.originalUrl = manifest.url;\n          } // In the following, we only use the first Location entry even if many are available\n          // Compare with ManifestUpdater/DashManifestModel\n\n\n          if (manifest.hasOwnProperty(_Constants2.default.LOCATION)) {\n            baseUri = urlUtils.parseBaseUrl(manifest.Location_asArray[0]);\n            logger.debug('BaseURI set by Location to: ' + baseUri);\n          }\n\n          manifest.baseUri = baseUri;\n          manifest.loadedTime = new Date();\n          xlinkController.resolveManifestOnLoad(manifest);\n          eventBus.trigger(_Events2.default.ORIGINAL_MANIFEST_LOADED, {\n            originalManifest: data\n          });\n        } else {\n          eventBus.trigger(_Events2.default.INTERNAL_MANIFEST_LOADED, {\n            manifest: null,\n            error: new _DashJSError2.default(_Errors2.default.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE, _Errors2.default.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + ('' + url))\n          });\n        }\n      },\n      error: function error(request, statusText, errorText) {\n        eventBus.trigger(_Events2.default.INTERNAL_MANIFEST_LOADED, {\n          manifest: null,\n          error: new _DashJSError2.default(_Errors2.default.MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE, _Errors2.default.MANIFEST_LOADER_LOADING_FAILURE_ERROR_MESSAGE + (url + ', ' + errorText))\n        });\n      }\n    });\n  }\n\n  function reset() {\n    eventBus.off(_Events2.default.XLINK_READY, onXlinkReady, instance);\n\n    if (mssHandler) {\n      mssHandler.reset();\n    }\n\n    if (xlinkController) {\n      xlinkController.reset();\n      xlinkController = null;\n    }\n\n    if (urlLoader) {\n      urlLoader.abort();\n      urlLoader = null;\n    }\n  }\n\n  instance = {\n    load: load,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nManifestLoader.__dashjs_factory_name = 'ManifestLoader';\n\nvar factory = _FactoryMaker2.default.getClassFactory(ManifestLoader);\n\nexports.default = factory;","map":{"version":3,"mappings":"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","names":["ManifestLoader","config","context","debug","eventBus","getInstance","urlUtils","instance","logger","urlLoader","xlinkController","parser","mssHandler","errHandler","setup","getLogger","on","Events","XLINK_READY","onXlinkReady","create","dashMetrics","mediaPlayerModel","requestModifier","useFetch","settings","get","streaming","lowLatencyEnabled","constants","Constants","dashConstants","DashConstants","errors","Errors","event","trigger","INTERNAL_MANIFEST_LOADED","manifest","createParser","data","indexOf","createMssParser","registerEvents","load","url","request","TextRequest","HTTPRequest","MPD_TYPE","success","textStatus","responseURL","actualUrl","baseUri","parseBaseUrl","isRelative","resolve","window","location","href","error","DashJSError","MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE","MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE","setMatchers","getMatchers","setIron","getIron","parse","e","originalUrl","hasOwnProperty","LOCATION","Location_asArray","loadedTime","Date","resolveManifestOnLoad","ORIGINAL_MANIFEST_LOADED","originalManifest","statusText","errorText","MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE","MANIFEST_LOADER_LOADING_FAILURE_ERROR_MESSAGE","reset","off","abort","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/ManifestLoader.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport DashConstants from '../dash/constants/DashConstants';\nimport XlinkController from './controllers/XlinkController';\nimport URLLoader from './net/URLLoader';\nimport URLUtils from './utils/URLUtils';\nimport TextRequest from './vo/TextRequest';\nimport DashJSError from './vo/DashJSError';\nimport {HTTPRequest} from './vo/metrics/HTTPRequest';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport Errors from '../core/errors/Errors';\nimport FactoryMaker from '../core/FactoryMaker';\nimport DashParser from '../dash/parser/DashParser';\n\nfunction ManifestLoader(config) {\n\n    config = config || {};\n    const context = this.context;\n    const debug = config.debug;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        logger,\n        urlLoader,\n        xlinkController,\n        parser;\n\n    let mssHandler = config.mssHandler;\n    let errHandler = config.errHandler;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        eventBus.on(Events.XLINK_READY, onXlinkReady, instance);\n\n        urlLoader = URLLoader(context).create({\n            errHandler: config.errHandler,\n            dashMetrics: config.dashMetrics,\n            mediaPlayerModel: config.mediaPlayerModel,\n            requestModifier: config.requestModifier,\n            useFetch: config.settings.get().streaming.lowLatencyEnabled,\n            urlUtils: urlUtils,\n            constants: Constants,\n            dashConstants: DashConstants,\n            errors: Errors\n        });\n\n        xlinkController = XlinkController(context).create({\n            errHandler: errHandler,\n            dashMetrics: config.dashMetrics,\n            mediaPlayerModel: config.mediaPlayerModel,\n            requestModifier: config.requestModifier,\n            settings: config.settings\n        });\n\n        parser = null;\n    }\n\n    function onXlinkReady(event) {\n        eventBus.trigger(Events.INTERNAL_MANIFEST_LOADED, { manifest: event.manifest });\n    }\n\n    function createParser(data) {\n        let parser = null;\n        // Analyze manifest content to detect protocol and select appropriate parser\n        if (data.indexOf('SmoothStreamingMedia') > -1) {\n            //do some business to transform it into a Dash Manifest\n            if (mssHandler) {\n                parser = mssHandler.createMssParser();\n                mssHandler.registerEvents();\n            }\n            return parser;\n        } else if (data.indexOf('MPD') > -1 || data.indexOf('Patch') > -1) {\n            return DashParser(context).create({debug: debug});\n        } else {\n            return parser;\n        }\n    }\n\n    function load(url) {\n\n        const request = new TextRequest(url, HTTPRequest.MPD_TYPE);\n\n        urlLoader.load({\n            request: request,\n            success: function (data, textStatus, responseURL) {\n                // Manage situations in which success is called after calling reset\n                if (!xlinkController) return;\n\n                let actualUrl,\n                    baseUri,\n                    manifest;\n\n                // Handle redirects for the MPD - as per RFC3986 Section 5.1.3\n                // also handily resolves relative MPD URLs to absolute\n                if (responseURL && responseURL !== url) {\n                    baseUri = urlUtils.parseBaseUrl(responseURL);\n                    actualUrl = responseURL;\n                } else {\n                    // usually this case will be caught and resolved by\n                    // responseURL above but it is not available for IE11 and Edge/12 and Edge/13\n                    // baseUri must be absolute for BaseURL resolution later\n                    if (urlUtils.isRelative(url)) {\n                        url = urlUtils.resolve(url, window.location.href);\n                    }\n\n                    baseUri = urlUtils.parseBaseUrl(url);\n                }\n\n                // A response of no content implies in-memory is properly up to date\n                if (textStatus == 'No Content') {\n                    eventBus.trigger(\n                        Events.INTERNAL_MANIFEST_LOADED, {\n                            manifest: null\n                        }\n                    );\n                    return;\n                }\n\n                // Create parser according to manifest type\n                if (parser === null) {\n                    parser = createParser(data);\n                }\n\n                if (parser === null) {\n                    eventBus.trigger(Events.INTERNAL_MANIFEST_LOADED, {\n                        manifest: null,\n                        error: new DashJSError(\n                            Errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE,\n                            Errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + `${url}`\n                        )\n                    });\n                    return;\n                }\n\n                // init xlinkcontroller with matchers and iron object from created parser\n                xlinkController.setMatchers(parser.getMatchers());\n                xlinkController.setIron(parser.getIron());\n\n                try {\n                    manifest = parser.parse(data);\n                } catch (e) {\n                    eventBus.trigger(Events.INTERNAL_MANIFEST_LOADED, {\n                        manifest: null,\n                        error: new DashJSError(\n                            Errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE,\n                            Errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + `${url}`\n                        )\n                    });\n                    return;\n                }\n\n                if (manifest) {\n                    manifest.url = actualUrl || url;\n\n                    // URL from which the MPD was originally retrieved (MPD updates will not change this value)\n                    if (!manifest.originalUrl) {\n                        manifest.originalUrl = manifest.url;\n                    }\n\n                    // In the following, we only use the first Location entry even if many are available\n                    // Compare with ManifestUpdater/DashManifestModel\n                    if (manifest.hasOwnProperty(Constants.LOCATION)) {\n                        baseUri = urlUtils.parseBaseUrl(manifest.Location_asArray[0]);\n                        logger.debug('BaseURI set by Location to: ' + baseUri);\n                    }\n\n                    manifest.baseUri = baseUri;\n                    manifest.loadedTime = new Date();\n                    xlinkController.resolveManifestOnLoad(manifest);\n\n                    eventBus.trigger(Events.ORIGINAL_MANIFEST_LOADED, { originalManifest: data });\n                } else {\n                    eventBus.trigger(Events.INTERNAL_MANIFEST_LOADED, {\n                        manifest: null,\n                        error: new DashJSError(\n                            Errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE,\n                            Errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + `${url}`\n                        )\n                    });\n                }\n            },\n            error: function (request, statusText, errorText) {\n                eventBus.trigger(Events.INTERNAL_MANIFEST_LOADED, {\n                    manifest: null,\n                    error: new DashJSError(\n                        Errors.MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE,\n                        Errors.MANIFEST_LOADER_LOADING_FAILURE_ERROR_MESSAGE + `${url}, ${errorText}`\n                    )\n                });\n            }\n        });\n    }\n\n    function reset() {\n        eventBus.off(Events.XLINK_READY, onXlinkReady, instance);\n\n        if (mssHandler) {\n            mssHandler.reset();\n        }\n\n        if (xlinkController) {\n            xlinkController.reset();\n            xlinkController = null;\n        }\n\n        if (urlLoader) {\n            urlLoader.abort();\n            urlLoader = null;\n        }\n    }\n\n    instance = {\n        load: load,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nManifestLoader.__dashjs_factory_name = 'ManifestLoader';\n\nconst factory = FactoryMaker.getClassFactory(ManifestLoader);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}