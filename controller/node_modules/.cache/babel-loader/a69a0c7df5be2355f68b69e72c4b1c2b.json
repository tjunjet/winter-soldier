{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction VideoModel() {\n  var instance = void 0,\n      logger = void 0,\n      element = void 0,\n      TTMLRenderingDiv = void 0,\n      previousPlaybackRate = void 0;\n  var VIDEO_MODEL_WRONG_ELEMENT_TYPE = 'element is not video or audio DOM type!';\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var stalledStreams = [];\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n  }\n\n  function initialize() {\n    eventBus.on(_Events2.default.PLAYBACK_PLAYING, onPlaying, this);\n  }\n\n  function reset() {\n    eventBus.off(_Events2.default.PLAYBACK_PLAYING, onPlaying, this);\n  }\n\n  function onPlaybackCanPlay() {\n    if (element) {\n      element.playbackRate = previousPlaybackRate || 1;\n      element.removeEventListener('canplay', onPlaybackCanPlay);\n    }\n  }\n\n  function setPlaybackRate(value) {\n    if (!element) return;\n\n    if (element.readyState <= 2 && value > 0) {\n      // If media element hasn't loaded enough data to play yet, wait until it has\n      element.addEventListener('canplay', onPlaybackCanPlay);\n    } else {\n      element.playbackRate = value;\n    }\n  } //TODO Move the DVR window calculations from MediaPlayer to Here.\n\n\n  function setCurrentTime(currentTime, stickToBuffered) {\n    if (element) {\n      //_currentTime = currentTime;\n      // We don't set the same currentTime because it can cause firing unexpected Pause event in IE11\n      // providing playbackRate property equals to zero.\n      if (element.currentTime == currentTime) return; // TODO Despite the fact that MediaSource 'open' event has been fired IE11 cannot set videoElement.currentTime\n      // immediately (it throws InvalidStateError). It seems that this is related to videoElement.readyState property\n      // Initially it is 0, but soon after 'open' event it goes to 1 and setting currentTime is allowed. Chrome allows to\n      // set currentTime even if readyState = 0.\n      // setTimeout is used to workaround InvalidStateError in IE11\n\n      try {\n        currentTime = stickToBuffered ? stickTimeToBuffered(currentTime) : currentTime;\n        element.currentTime = currentTime;\n      } catch (e) {\n        if (element.readyState === 0 && e.code === e.INVALID_STATE_ERR) {\n          setTimeout(function () {\n            element.currentTime = currentTime;\n          }, 400);\n        }\n      }\n    }\n  }\n\n  function stickTimeToBuffered(time) {\n    var buffered = getBufferRange();\n    var closestTime = time;\n    var closestDistance = 9999999999;\n\n    if (buffered) {\n      for (var i = 0; i < buffered.length; i++) {\n        var start = buffered.start(i);\n        var end = buffered.end(i);\n        var distanceToStart = Math.abs(start - time);\n        var distanceToEnd = Math.abs(end - time);\n\n        if (time >= start && time <= end) {\n          return time;\n        }\n\n        if (distanceToStart < closestDistance) {\n          closestDistance = distanceToStart;\n          closestTime = start;\n        }\n\n        if (distanceToEnd < closestDistance) {\n          closestDistance = distanceToEnd;\n          closestTime = end;\n        }\n      }\n    }\n\n    return closestTime;\n  }\n\n  function getElement() {\n    return element;\n  }\n\n  function setElement(value) {\n    //add check of value type\n    if (value === null || value === undefined || value && /^(VIDEO|AUDIO)$/i.test(value.nodeName)) {\n      element = value; // Workaround to force Firefox to fire the canplay event.\n\n      if (element) {\n        element.preload = 'auto';\n      }\n    } else {\n      throw VIDEO_MODEL_WRONG_ELEMENT_TYPE;\n    }\n  }\n\n  function setSource(source) {\n    if (element) {\n      if (source) {\n        element.src = source;\n      } else {\n        element.removeAttribute('src');\n        element.load();\n      }\n    }\n  }\n\n  function getSource() {\n    return element ? element.src : null;\n  }\n\n  function getTTMLRenderingDiv() {\n    return TTMLRenderingDiv;\n  }\n\n  function setTTMLRenderingDiv(div) {\n    TTMLRenderingDiv = div; // The styling will allow the captions to match the video window size and position.\n\n    TTMLRenderingDiv.style.position = 'absolute';\n    TTMLRenderingDiv.style.display = 'flex';\n    TTMLRenderingDiv.style.overflow = 'hidden';\n    TTMLRenderingDiv.style.pointerEvents = 'none';\n    TTMLRenderingDiv.style.top = 0;\n    TTMLRenderingDiv.style.left = 0;\n  }\n\n  function setStallState(type, state) {\n    stallStream(type, state);\n  }\n\n  function isStalled() {\n    return stalledStreams.length > 0;\n  }\n\n  function addStalledStream(type) {\n    var event = void 0;\n\n    if (type === null || !element || element.seeking || stalledStreams.indexOf(type) !== -1) {\n      return;\n    }\n\n    stalledStreams.push(type);\n\n    if (element && stalledStreams.length === 1) {\n      // Halt playback until nothing is stalled.\n      event = document.createEvent('Event');\n      event.initEvent('waiting', true, false);\n      previousPlaybackRate = element.playbackRate;\n      setPlaybackRate(0);\n      element.dispatchEvent(event);\n    }\n  }\n\n  function removeStalledStream(type) {\n    var index = stalledStreams.indexOf(type);\n    var event = void 0;\n\n    if (type === null) {\n      return;\n    }\n\n    if (index !== -1) {\n      stalledStreams.splice(index, 1);\n    } // If nothing is stalled resume playback.\n\n\n    if (element && isStalled() === false && element.playbackRate === 0) {\n      setPlaybackRate(previousPlaybackRate || 1);\n\n      if (!element.paused) {\n        event = document.createEvent('Event');\n        event.initEvent('playing', true, false);\n        element.dispatchEvent(event);\n      }\n    }\n  }\n\n  function stallStream(type, isStalled) {\n    if (isStalled) {\n      addStalledStream(type);\n    } else {\n      removeStalledStream(type);\n    }\n  } //Calling play on the element will emit playing - even if the stream is stalled. If the stream is stalled, emit a waiting event.\n\n\n  function onPlaying() {\n    if (element && isStalled() && element.playbackRate === 0) {\n      var event = document.createEvent('Event');\n      event.initEvent('waiting', true, false);\n      element.dispatchEvent(event);\n    }\n  }\n\n  function getPlaybackQuality() {\n    if (!element) {\n      return null;\n    }\n\n    var hasWebKit = 'webkitDroppedFrameCount' in element && 'webkitDecodedFrameCount' in element;\n    var hasQuality = ('getVideoPlaybackQuality' in element);\n    var result = null;\n\n    if (hasQuality) {\n      result = element.getVideoPlaybackQuality();\n    } else if (hasWebKit) {\n      result = {\n        droppedVideoFrames: element.webkitDroppedFrameCount,\n        totalVideoFrames: element.webkitDroppedFrameCount + element.webkitDecodedFrameCount,\n        creationTime: new Date()\n      };\n    }\n\n    return result;\n  }\n\n  function play() {\n    if (element) {\n      element.autoplay = true;\n      var p = element.play();\n\n      if (p && p.catch && typeof Promise !== 'undefined') {\n        p.catch(function (e) {\n          if (e.name === 'NotAllowedError') {\n            eventBus.trigger(_Events2.default.PLAYBACK_NOT_ALLOWED);\n          }\n\n          logger.warn('Caught pending play exception - continuing (' + e + ')');\n        });\n      }\n    }\n  }\n\n  function isPaused() {\n    return element ? element.paused : null;\n  }\n\n  function pause() {\n    if (element) {\n      element.pause();\n      element.autoplay = false;\n    }\n  }\n\n  function isSeeking() {\n    return element ? element.seeking : null;\n  }\n\n  function getTime() {\n    return element ? element.currentTime : null;\n  }\n\n  function getPlaybackRate() {\n    return element ? element.playbackRate : null;\n  }\n\n  function getPlayedRanges() {\n    return element ? element.played : null;\n  }\n\n  function getEnded() {\n    return element ? element.ended : null;\n  }\n\n  function addEventListener(eventName, eventCallBack) {\n    if (element) {\n      element.addEventListener(eventName, eventCallBack);\n    }\n  }\n\n  function removeEventListener(eventName, eventCallBack) {\n    if (element) {\n      element.removeEventListener(eventName, eventCallBack);\n    }\n  }\n\n  function getReadyState() {\n    return element ? element.readyState : NaN;\n  }\n\n  function getBufferRange() {\n    return element ? element.buffered : null;\n  }\n\n  function getClientWidth() {\n    return element ? element.clientWidth : NaN;\n  }\n\n  function getClientHeight() {\n    return element ? element.clientHeight : NaN;\n  }\n\n  function getVideoWidth() {\n    return element ? element.videoWidth : NaN;\n  }\n\n  function getVideoHeight() {\n    return element ? element.videoHeight : NaN;\n  }\n\n  function getVideoRelativeOffsetTop() {\n    var parentElement = element.parentNode.host || element.parentNode;\n    return parentElement ? element.getBoundingClientRect().top - parentElement.getBoundingClientRect().top : NaN;\n  }\n\n  function getVideoRelativeOffsetLeft() {\n    var parentElement = element.parentNode.host || element.parentNode;\n    return parentElement ? element.getBoundingClientRect().left - parentElement.getBoundingClientRect().left : NaN;\n  }\n\n  function getTextTracks() {\n    return element ? element.textTracks : [];\n  }\n\n  function getTextTrack(kind, label, lang, isTTML, isEmbedded) {\n    if (element) {\n      for (var i = 0; i < element.textTracks.length; i++) {\n        //label parameter could be a number (due to adaptationSet), but label, the attribute of textTrack, is a string => to modify...\n        //label could also be undefined (due to adaptationSet)\n        if (element.textTracks[i].kind === kind && (label ? element.textTracks[i].label == label : true) && element.textTracks[i].language === lang && element.textTracks[i].isTTML === isTTML && element.textTracks[i].isEmbedded === isEmbedded) {\n          return element.textTracks[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  function addTextTrack(kind, label, lang, isTTML, isEmbedded) {\n    if (!element) {\n      return null;\n    } // check if track of same type has not been already created for previous stream\n    // then use it (no way to remove existing text track from video element)\n\n\n    var track = getTextTrack(kind, label, lang, isTTML, isEmbedded);\n\n    if (!track) {\n      track = element.addTextTrack(kind, label, lang);\n      track.isEmbedded = isEmbedded;\n      track.isTTML = isTTML;\n    }\n\n    return track;\n  }\n\n  function appendChild(childElement) {\n    if (element) {\n      element.appendChild(childElement); //in Chrome, we need to differenciate textTrack with same lang, kind and label but different format (vtt, ttml, etc...)\n\n      if (childElement.isTTML !== undefined) {\n        element.textTracks[element.textTracks.length - 1].isTTML = childElement.isTTML;\n        element.textTracks[element.textTracks.length - 1].isEmbedded = childElement.isEmbedded;\n      }\n    }\n  }\n\n  function removeChild(childElement) {\n    if (element) {\n      element.removeChild(childElement);\n    }\n  }\n\n  instance = {\n    initialize: initialize,\n    setCurrentTime: setCurrentTime,\n    play: play,\n    isPaused: isPaused,\n    pause: pause,\n    isStalled: isStalled,\n    isSeeking: isSeeking,\n    getTime: getTime,\n    getPlaybackRate: getPlaybackRate,\n    setPlaybackRate: setPlaybackRate,\n    getPlayedRanges: getPlayedRanges,\n    getEnded: getEnded,\n    setStallState: setStallState,\n    getElement: getElement,\n    setElement: setElement,\n    setSource: setSource,\n    getSource: getSource,\n    getTTMLRenderingDiv: getTTMLRenderingDiv,\n    setTTMLRenderingDiv: setTTMLRenderingDiv,\n    getPlaybackQuality: getPlaybackQuality,\n    addEventListener: addEventListener,\n    removeEventListener: removeEventListener,\n    getReadyState: getReadyState,\n    getBufferRange: getBufferRange,\n    getClientWidth: getClientWidth,\n    getClientHeight: getClientHeight,\n    getTextTracks: getTextTracks,\n    getTextTrack: getTextTrack,\n    addTextTrack: addTextTrack,\n    appendChild: appendChild,\n    removeChild: removeChild,\n    getVideoWidth: getVideoWidth,\n    getVideoHeight: getVideoHeight,\n    getVideoRelativeOffsetTop: getVideoRelativeOffsetTop,\n    getVideoRelativeOffsetLeft: getVideoRelativeOffsetLeft,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nVideoModel.__dashjs_factory_name = 'VideoModel';\nexports.default = _FactoryMaker2.default.getSingletonFactory(VideoModel);","map":{"version":3,"mappings":"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","names":["VideoModel","instance","logger","element","TTMLRenderingDiv","previousPlaybackRate","VIDEO_MODEL_WRONG_ELEMENT_TYPE","context","eventBus","getInstance","stalledStreams","setup","getLogger","initialize","on","Events","PLAYBACK_PLAYING","onPlaying","reset","off","onPlaybackCanPlay","playbackRate","removeEventListener","setPlaybackRate","value","readyState","addEventListener","setCurrentTime","currentTime","stickToBuffered","stickTimeToBuffered","e","code","INVALID_STATE_ERR","setTimeout","time","buffered","getBufferRange","closestTime","closestDistance","i","length","start","end","distanceToStart","Math","abs","distanceToEnd","getElement","setElement","undefined","test","nodeName","preload","setSource","source","src","removeAttribute","load","getSource","getTTMLRenderingDiv","setTTMLRenderingDiv","div","style","position","display","overflow","pointerEvents","top","left","setStallState","type","state","stallStream","isStalled","addStalledStream","event","seeking","indexOf","push","document","createEvent","initEvent","dispatchEvent","removeStalledStream","index","splice","paused","getPlaybackQuality","hasWebKit","hasQuality","result","getVideoPlaybackQuality","droppedVideoFrames","webkitDroppedFrameCount","totalVideoFrames","webkitDecodedFrameCount","creationTime","Date","play","autoplay","p","catch","Promise","name","trigger","PLAYBACK_NOT_ALLOWED","warn","isPaused","pause","isSeeking","getTime","getPlaybackRate","getPlayedRanges","played","getEnded","ended","eventName","eventCallBack","getReadyState","NaN","getClientWidth","clientWidth","getClientHeight","clientHeight","getVideoWidth","videoWidth","getVideoHeight","videoHeight","getVideoRelativeOffsetTop","parentElement","parentNode","host","getBoundingClientRect","getVideoRelativeOffsetLeft","getTextTracks","textTracks","getTextTrack","kind","label","lang","isTTML","isEmbedded","language","addTextTrack","track","appendChild","childElement","removeChild","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/models/VideoModel.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport Debug from '../../core/Debug';\n\nfunction VideoModel() {\n\n    let instance,\n        logger,\n        element,\n        TTMLRenderingDiv,\n        previousPlaybackRate;\n\n    const VIDEO_MODEL_WRONG_ELEMENT_TYPE = 'element is not video or audio DOM type!';\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const stalledStreams = [];\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function initialize() {\n        eventBus.on(Events.PLAYBACK_PLAYING, onPlaying, this);\n    }\n\n    function reset() {\n        eventBus.off(Events.PLAYBACK_PLAYING, onPlaying, this);\n    }\n\n    function onPlaybackCanPlay() {\n        if (element) {\n            element.playbackRate = previousPlaybackRate || 1;\n            element.removeEventListener('canplay', onPlaybackCanPlay);\n        }\n    }\n\n    function setPlaybackRate(value) {\n        if (!element) return;\n        if (element.readyState <= 2 && value > 0) {\n            // If media element hasn't loaded enough data to play yet, wait until it has\n            element.addEventListener('canplay', onPlaybackCanPlay);\n        } else {\n            element.playbackRate = value;\n        }\n    }\n\n    //TODO Move the DVR window calculations from MediaPlayer to Here.\n    function setCurrentTime(currentTime, stickToBuffered) {\n        if (element) {\n            //_currentTime = currentTime;\n\n            // We don't set the same currentTime because it can cause firing unexpected Pause event in IE11\n            // providing playbackRate property equals to zero.\n            if (element.currentTime == currentTime) return;\n\n            // TODO Despite the fact that MediaSource 'open' event has been fired IE11 cannot set videoElement.currentTime\n            // immediately (it throws InvalidStateError). It seems that this is related to videoElement.readyState property\n            // Initially it is 0, but soon after 'open' event it goes to 1 and setting currentTime is allowed. Chrome allows to\n            // set currentTime even if readyState = 0.\n            // setTimeout is used to workaround InvalidStateError in IE11\n            try {\n                currentTime = stickToBuffered ? stickTimeToBuffered(currentTime) : currentTime;\n                element.currentTime = currentTime;\n            } catch (e) {\n                if (element.readyState === 0 && e.code === e.INVALID_STATE_ERR) {\n                    setTimeout(function () {\n                        element.currentTime = currentTime;\n                    }, 400);\n                }\n            }\n        }\n    }\n\n    function stickTimeToBuffered(time) {\n        const buffered = getBufferRange();\n        let closestTime = time;\n        let closestDistance = 9999999999;\n        if (buffered) {\n            for (let i = 0; i < buffered.length; i++) {\n                const start = buffered.start(i);\n                const end = buffered.end(i);\n                const distanceToStart = Math.abs(start - time);\n                const distanceToEnd = Math.abs(end - time);\n\n                if (time >= start && time <= end) {\n                    return time;\n                }\n\n                if (distanceToStart < closestDistance) {\n                    closestDistance = distanceToStart;\n                    closestTime = start;\n                }\n\n                if (distanceToEnd < closestDistance) {\n                    closestDistance = distanceToEnd;\n                    closestTime = end;\n                }\n            }\n        }\n        return closestTime;\n    }\n\n    function getElement() {\n        return element;\n    }\n\n    function setElement(value) {\n        //add check of value type\n        if (value === null || value === undefined || (value && (/^(VIDEO|AUDIO)$/i).test(value.nodeName))) {\n            element = value;\n            // Workaround to force Firefox to fire the canplay event.\n            if (element) {\n                element.preload = 'auto';\n            }\n        } else {\n            throw VIDEO_MODEL_WRONG_ELEMENT_TYPE;\n        }\n    }\n\n    function setSource(source) {\n        if (element) {\n            if (source) {\n                element.src = source;\n            } else {\n                element.removeAttribute('src');\n                element.load();\n            }\n        }\n    }\n\n    function getSource() {\n        return element ? element.src : null;\n    }\n\n    function getTTMLRenderingDiv() {\n        return TTMLRenderingDiv;\n    }\n\n    function setTTMLRenderingDiv(div) {\n        TTMLRenderingDiv = div;\n        // The styling will allow the captions to match the video window size and position.\n        TTMLRenderingDiv.style.position = 'absolute';\n        TTMLRenderingDiv.style.display = 'flex';\n        TTMLRenderingDiv.style.overflow = 'hidden';\n        TTMLRenderingDiv.style.pointerEvents = 'none';\n        TTMLRenderingDiv.style.top = 0;\n        TTMLRenderingDiv.style.left = 0;\n    }\n\n    function setStallState(type, state) {\n        stallStream(type, state);\n    }\n\n    function isStalled() {\n        return (stalledStreams.length > 0);\n    }\n\n    function addStalledStream(type) {\n        let event;\n\n        if (type === null || !element || element.seeking || stalledStreams.indexOf(type) !== -1) {\n            return;\n        }\n\n        stalledStreams.push(type);\n        if (element && stalledStreams.length === 1) {\n            // Halt playback until nothing is stalled.\n            event = document.createEvent('Event');\n            event.initEvent('waiting', true, false);\n            previousPlaybackRate = element.playbackRate;\n            setPlaybackRate(0);\n            element.dispatchEvent(event);\n        }\n    }\n\n    function removeStalledStream(type) {\n        let index = stalledStreams.indexOf(type);\n        let event;\n\n        if (type === null) {\n            return;\n        }\n        if (index !== -1) {\n            stalledStreams.splice(index, 1);\n        }\n        // If nothing is stalled resume playback.\n        if (element && isStalled() === false && element.playbackRate === 0) {\n            setPlaybackRate(previousPlaybackRate || 1);\n            if (!element.paused) {\n                event = document.createEvent('Event');\n                event.initEvent('playing', true, false);\n                element.dispatchEvent(event);\n            }\n        }\n    }\n\n    function stallStream(type, isStalled) {\n        if (isStalled) {\n            addStalledStream(type);\n        } else {\n            removeStalledStream(type);\n        }\n    }\n\n    //Calling play on the element will emit playing - even if the stream is stalled. If the stream is stalled, emit a waiting event.\n    function onPlaying() {\n        if (element && isStalled() && element.playbackRate === 0) {\n            const event = document.createEvent('Event');\n            event.initEvent('waiting', true, false);\n            element.dispatchEvent(event);\n        }\n    }\n\n    function getPlaybackQuality() {\n        if (!element) { return null; }\n        let hasWebKit = ('webkitDroppedFrameCount' in element) && ('webkitDecodedFrameCount' in element);\n        let hasQuality = ('getVideoPlaybackQuality' in element);\n        let result = null;\n\n        if (hasQuality) {\n            result = element.getVideoPlaybackQuality();\n        } else if (hasWebKit) {\n            result = {\n                droppedVideoFrames: element.webkitDroppedFrameCount,\n                totalVideoFrames: element.webkitDroppedFrameCount + element.webkitDecodedFrameCount,\n                creationTime: new Date()\n            };\n        }\n\n        return result;\n    }\n\n    function play() {\n        if (element) {\n            element.autoplay = true;\n            const p = element.play();\n            if (p && p.catch && typeof Promise !== 'undefined') {\n                p.catch((e) => {\n                    if (e.name === 'NotAllowedError') {\n                        eventBus.trigger(Events.PLAYBACK_NOT_ALLOWED);\n                    }\n                    logger.warn(`Caught pending play exception - continuing (${e})`);\n                });\n            }\n        }\n    }\n\n    function isPaused() {\n        return element ? element.paused : null;\n    }\n\n    function pause() {\n        if (element) {\n            element.pause();\n            element.autoplay = false;\n        }\n    }\n\n    function isSeeking() {\n        return element ? element.seeking : null;\n    }\n\n    function getTime() {\n        return element ? element.currentTime : null;\n    }\n\n    function getPlaybackRate() {\n        return element ? element.playbackRate : null;\n    }\n\n    function getPlayedRanges() {\n        return element ? element.played : null;\n    }\n\n    function getEnded() {\n        return element ? element.ended : null;\n    }\n\n    function addEventListener(eventName, eventCallBack) {\n        if (element) {\n            element.addEventListener(eventName, eventCallBack);\n        }\n    }\n\n    function removeEventListener(eventName, eventCallBack) {\n        if (element) {\n            element.removeEventListener(eventName, eventCallBack);\n        }\n    }\n\n    function getReadyState() {\n        return element ? element.readyState : NaN;\n    }\n\n    function getBufferRange() {\n        return element ? element.buffered : null;\n    }\n\n    function getClientWidth() {\n        return element ? element.clientWidth : NaN;\n    }\n\n    function getClientHeight() {\n        return element ? element.clientHeight : NaN;\n    }\n\n    function getVideoWidth() {\n        return element ? element.videoWidth : NaN;\n    }\n\n    function getVideoHeight() {\n        return element ? element.videoHeight : NaN;\n    }\n\n    function getVideoRelativeOffsetTop() {\n        const parentElement = element.parentNode.host || element.parentNode;\n        return parentElement ? element.getBoundingClientRect().top - parentElement.getBoundingClientRect().top : NaN;\n    }\n\n    function getVideoRelativeOffsetLeft() {\n        const parentElement = element.parentNode.host || element.parentNode;\n        return parentElement ? element.getBoundingClientRect().left - parentElement.getBoundingClientRect().left : NaN;\n    }\n\n    function getTextTracks() {\n        return element ? element.textTracks : [];\n    }\n\n    function getTextTrack(kind, label, lang, isTTML, isEmbedded) {\n        if (element) {\n            for (let i = 0; i < element.textTracks.length; i++) {\n                //label parameter could be a number (due to adaptationSet), but label, the attribute of textTrack, is a string => to modify...\n                //label could also be undefined (due to adaptationSet)\n                if (element.textTracks[i].kind === kind && (label ? element.textTracks[i].label == label : true) &&\n                   element.textTracks[i].language === lang && element.textTracks[i].isTTML === isTTML && element.textTracks[i].isEmbedded === isEmbedded) {\n                    return element.textTracks[i];\n                }\n            }\n        }\n\n        return null;\n    }\n\n    function addTextTrack(kind, label, lang, isTTML, isEmbedded) {\n        if (!element) {\n            return null;\n        }\n        // check if track of same type has not been already created for previous stream\n        // then use it (no way to remove existing text track from video element)\n        let track = getTextTrack(kind, label, lang, isTTML, isEmbedded);\n        if (!track) {\n            track = element.addTextTrack(kind, label, lang);\n            track.isEmbedded = isEmbedded;\n            track.isTTML = isTTML;\n        }\n        return track;\n    }\n\n    function appendChild(childElement) {\n        if (element) {\n            element.appendChild(childElement);\n            //in Chrome, we need to differenciate textTrack with same lang, kind and label but different format (vtt, ttml, etc...)\n            if (childElement.isTTML !== undefined) {\n                element.textTracks[element.textTracks.length - 1].isTTML = childElement.isTTML;\n                element.textTracks[element.textTracks.length - 1].isEmbedded = childElement.isEmbedded;\n            }\n        }\n    }\n\n    function removeChild(childElement) {\n        if (element) {\n            element.removeChild(childElement);\n        }\n    }\n\n    instance = {\n        initialize: initialize,\n        setCurrentTime: setCurrentTime,\n        play: play,\n        isPaused: isPaused,\n        pause: pause,\n        isStalled,\n        isSeeking: isSeeking,\n        getTime: getTime,\n        getPlaybackRate: getPlaybackRate,\n        setPlaybackRate: setPlaybackRate,\n        getPlayedRanges: getPlayedRanges,\n        getEnded: getEnded,\n        setStallState: setStallState,\n        getElement: getElement,\n        setElement: setElement,\n        setSource: setSource,\n        getSource: getSource,\n        getTTMLRenderingDiv: getTTMLRenderingDiv,\n        setTTMLRenderingDiv: setTTMLRenderingDiv,\n        getPlaybackQuality: getPlaybackQuality,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n        getReadyState: getReadyState,\n        getBufferRange: getBufferRange,\n        getClientWidth: getClientWidth,\n        getClientHeight: getClientHeight,\n        getTextTracks: getTextTracks,\n        getTextTrack: getTextTrack,\n        addTextTrack: addTextTrack,\n        appendChild: appendChild,\n        removeChild: removeChild,\n        getVideoWidth: getVideoWidth,\n        getVideoHeight: getVideoHeight,\n        getVideoRelativeOffsetTop: getVideoRelativeOffsetTop,\n        getVideoRelativeOffsetLeft: getVideoRelativeOffsetLeft,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nVideoModel.__dashjs_factory_name = 'VideoModel';\nexport default FactoryMaker.getSingletonFactory(VideoModel);\n"]},"metadata":{},"sourceType":"script"}