{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _XlinkLoader = require('../XlinkLoader');\n\nvar _XlinkLoader2 = _interopRequireDefault(_XlinkLoader);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _xml2json = require('../../../externals/xml2json');\n\nvar _xml2json2 = _interopRequireDefault(_xml2json);\n\nvar _URLUtils = require('../utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nvar _DashConstants = require('../../dash/constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar RESOLVE_TYPE_ONLOAD = 'onLoad';\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\nvar RESOLVE_TYPE_ONACTUATE = 'onActuate';\nvar RESOLVE_TO_ZERO = 'urn:mpeg:dash:resolve-to-zero:2013';\n\nfunction XlinkController(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n  var instance = void 0,\n      matchers = void 0,\n      iron = void 0,\n      manifest = void 0,\n      converter = void 0,\n      xlinkLoader = void 0;\n\n  function setup() {\n    eventBus.on(_Events2.default.XLINK_ELEMENT_LOADED, onXlinkElementLoaded, instance);\n    xlinkLoader = (0, _XlinkLoader2.default)(context).create({\n      errHandler: config.errHandler,\n      dashMetrics: config.dashMetrics,\n      mediaPlayerModel: config.mediaPlayerModel,\n      requestModifier: config.requestModifier,\n      settings: config.settings\n    });\n  }\n\n  function setMatchers(value) {\n    if (value) {\n      matchers = value;\n    }\n  }\n\n  function setIron(value) {\n    if (value) {\n      iron = value;\n    }\n  }\n  /**\n  * <p>Triggers the resolution of the xlink.onLoad attributes in the manifest file </p>\n  * @param {Object} mpd - the manifest\n  */\n\n\n  function resolveManifestOnLoad(mpd) {\n    var elements = void 0; // First resolve all periods, so unnecessary requests inside onLoad Periods with Default content are avoided\n\n    converter = new _xml2json2.default({\n      escapeMode: false,\n      attributePrefix: '',\n      arrayAccessForm: 'property',\n      emptyNodeForm: 'object',\n      stripWhitespaces: false,\n      enableToStringFunc: false,\n      ignoreRoot: true,\n      matchers: matchers\n    });\n    manifest = mpd;\n\n    if (manifest.Period_asArray) {\n      elements = getElementsToResolve(manifest.Period_asArray, manifest, _DashConstants2.default.PERIOD, RESOLVE_TYPE_ONLOAD);\n      resolve(elements, _DashConstants2.default.PERIOD, RESOLVE_TYPE_ONLOAD);\n    } else {\n      eventBus.trigger(_Events2.default.XLINK_READY, {\n        manifest: manifest\n      });\n    }\n  }\n\n  function reset() {\n    eventBus.off(_Events2.default.XLINK_ELEMENT_LOADED, onXlinkElementLoaded, instance);\n\n    if (xlinkLoader) {\n      xlinkLoader.reset();\n      xlinkLoader = null;\n    }\n  }\n\n  function resolve(elements, type, resolveType) {\n    var resolveObject = {};\n    var element = void 0,\n        url = void 0;\n    resolveObject.elements = elements;\n    resolveObject.type = type;\n    resolveObject.resolveType = resolveType; // If nothing to resolve, directly call allElementsLoaded\n\n    if (resolveObject.elements.length === 0) {\n      onXlinkAllElementsLoaded(resolveObject);\n    }\n\n    for (var i = 0; i < resolveObject.elements.length; i++) {\n      element = resolveObject.elements[i];\n\n      if (urlUtils.isHTTPURL(element.url)) {\n        url = element.url;\n      } else {\n        url = element.originalContent.BaseURL + element.url;\n      }\n\n      xlinkLoader.load(url, element, resolveObject);\n    }\n  }\n\n  function onXlinkElementLoaded(event) {\n    var element = void 0,\n        resolveObject = void 0;\n    var openingTag = '<response>';\n    var closingTag = '</response>';\n    var mergedContent = '';\n    element = event.element;\n    resolveObject = event.resolveObject; // if the element resolved into content parse the content\n\n    if (element.resolvedContent) {\n      var index = 0; // we add a parent elements so the converter is able to parse multiple elements of the same type which are not wrapped inside a container\n\n      if (element.resolvedContent.indexOf('<?xml') === 0) {\n        index = element.resolvedContent.indexOf('?>') + 2; //find the closing position of the xml declaration, if it exists.\n      }\n\n      mergedContent = element.resolvedContent.substr(0, index) + openingTag + element.resolvedContent.substr(index) + closingTag;\n      element.resolvedContent = converter.xml_str2json(mergedContent);\n    }\n\n    if (isResolvingFinished(resolveObject)) {\n      onXlinkAllElementsLoaded(resolveObject);\n    }\n  } // We got to wait till all elements of the current queue are resolved before merging back\n\n\n  function onXlinkAllElementsLoaded(resolveObject) {\n    var elements = [];\n    var i = void 0,\n        obj = void 0;\n    mergeElementsBack(resolveObject);\n\n    if (resolveObject.resolveType === RESOLVE_TYPE_ONACTUATE) {\n      eventBus.trigger(_Events2.default.XLINK_READY, {\n        manifest: manifest\n      });\n    }\n\n    if (resolveObject.resolveType === RESOLVE_TYPE_ONLOAD) {\n      switch (resolveObject.type) {\n        // Start resolving the other elements. We can do Adaptation Set and EventStream in parallel\n        case _DashConstants2.default.PERIOD:\n          for (i = 0; i < manifest[_DashConstants2.default.PERIOD + '_asArray'].length; i++) {\n            obj = manifest[_DashConstants2.default.PERIOD + '_asArray'][i];\n\n            if (obj.hasOwnProperty(_DashConstants2.default.ADAPTATION_SET + '_asArray')) {\n              elements = elements.concat(getElementsToResolve(obj[_DashConstants2.default.ADAPTATION_SET + '_asArray'], obj, _DashConstants2.default.ADAPTATION_SET, RESOLVE_TYPE_ONLOAD));\n            }\n\n            if (obj.hasOwnProperty(_DashConstants2.default.EVENT_STREAM + '_asArray')) {\n              elements = elements.concat(getElementsToResolve(obj[_DashConstants2.default.EVENT_STREAM + '_asArray'], obj, _DashConstants2.default.EVENT_STREAM, RESOLVE_TYPE_ONLOAD));\n            }\n          }\n\n          resolve(elements, _DashConstants2.default.ADAPTATION_SET, RESOLVE_TYPE_ONLOAD);\n          break;\n\n        case _DashConstants2.default.ADAPTATION_SET:\n          // TODO: Resolve SegmentList here\n          eventBus.trigger(_Events2.default.XLINK_READY, {\n            manifest: manifest\n          });\n          break;\n      }\n    }\n  } // Returns the elements with the specific resolve Type\n\n\n  function getElementsToResolve(elements, parentElement, type, resolveType) {\n    var toResolve = [];\n    var element = void 0,\n        i = void 0,\n        xlinkObject = void 0; // first remove all the resolve-to-zero elements\n\n    for (i = elements.length - 1; i >= 0; i--) {\n      element = elements[i];\n\n      if (element.hasOwnProperty('xlink:href') && element['xlink:href'] === RESOLVE_TO_ZERO) {\n        elements.splice(i, 1);\n      }\n    } // now get the elements with the right resolve type\n\n\n    for (i = 0; i < elements.length; i++) {\n      element = elements[i];\n\n      if (element.hasOwnProperty('xlink:href') && element.hasOwnProperty('xlink:actuate') && element['xlink:actuate'] === resolveType) {\n        xlinkObject = createXlinkObject(element['xlink:href'], parentElement, type, i, resolveType, element);\n        toResolve.push(xlinkObject);\n      }\n    }\n\n    return toResolve;\n  }\n\n  function mergeElementsBack(resolveObject) {\n    var resolvedElements = [];\n    var element = void 0,\n        type = void 0,\n        obj = void 0,\n        i = void 0,\n        j = void 0,\n        k = void 0; // Start merging back from the end because of index shifting. Note that the elements with the same parent have to be ordered by index ascending\n\n    for (i = resolveObject.elements.length - 1; i >= 0; i--) {\n      element = resolveObject.elements[i];\n      type = element.type + '_asArray'; // Element couldn't be resolved or is TODO Inappropriate target: Remove all Xlink attributes\n\n      if (!element.resolvedContent || isInappropriateTarget()) {\n        delete element.originalContent['xlink:actuate'];\n        delete element.originalContent['xlink:href'];\n        resolvedElements.push(element.originalContent);\n      } // Element was successfully resolved\n      else if (element.resolvedContent) {\n        for (j = 0; j < element.resolvedContent[type].length; j++) {\n          //TODO Contains another Xlink attribute with xlink:actuate set to onload. Remove all xLink attributes\n          obj = element.resolvedContent[type][j];\n          resolvedElements.push(obj);\n        }\n      } // Replace the old elements in the parent with the resolved ones\n\n\n      element.parentElement[type].splice(element.index, 1);\n\n      for (k = 0; k < resolvedElements.length; k++) {\n        element.parentElement[type].splice(element.index + k, 0, resolvedElements[k]);\n      }\n\n      resolvedElements = [];\n    }\n\n    if (resolveObject.elements.length > 0) {\n      iron.run(manifest);\n    }\n  }\n\n  function createXlinkObject(url, parentElement, type, index, resolveType, originalContent) {\n    return {\n      url: url,\n      parentElement: parentElement,\n      type: type,\n      index: index,\n      resolveType: resolveType,\n      originalContent: originalContent,\n      resolvedContent: null,\n      resolved: false\n    };\n  } // Check if all pending requests are finished\n\n\n  function isResolvingFinished(elementsToResolve) {\n    var i = void 0,\n        obj = void 0;\n\n    for (i = 0; i < elementsToResolve.elements.length; i++) {\n      obj = elementsToResolve.elements[i];\n\n      if (obj.resolved === false) {\n        return false;\n      }\n    }\n\n    return true;\n  } // TODO : Do some syntax check here if the target is valid or not\n\n\n  function isInappropriateTarget() {\n    return false;\n  }\n\n  instance = {\n    resolveManifestOnLoad: resolveManifestOnLoad,\n    setMatchers: setMatchers,\n    setIron: setIron,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nXlinkController.__dashjs_factory_name = 'XlinkController';\nexports.default = _FactoryMaker2.default.getClassFactory(XlinkController);","map":{"version":3,"mappings":"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","names":["RESOLVE_TYPE_ONLOAD","RESOLVE_TYPE_ONACTUATE","RESOLVE_TO_ZERO","XlinkController","config","context","eventBus","getInstance","urlUtils","instance","matchers","iron","manifest","converter","xlinkLoader","setup","on","Events","XLINK_ELEMENT_LOADED","onXlinkElementLoaded","create","errHandler","dashMetrics","mediaPlayerModel","requestModifier","settings","setMatchers","value","setIron","resolveManifestOnLoad","mpd","elements","X2JS","escapeMode","attributePrefix","arrayAccessForm","emptyNodeForm","stripWhitespaces","enableToStringFunc","ignoreRoot","Period_asArray","getElementsToResolve","DashConstants","PERIOD","resolve","trigger","XLINK_READY","reset","off","type","resolveType","resolveObject","element","url","length","onXlinkAllElementsLoaded","i","isHTTPURL","originalContent","BaseURL","load","event","openingTag","closingTag","mergedContent","resolvedContent","index","indexOf","substr","xml_str2json","isResolvingFinished","obj","mergeElementsBack","hasOwnProperty","ADAPTATION_SET","concat","EVENT_STREAM","parentElement","toResolve","xlinkObject","splice","createXlinkObject","push","resolvedElements","j","k","isInappropriateTarget","run","resolved","elementsToResolve","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/controllers/XlinkController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport XlinkLoader from '../XlinkLoader';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport X2JS from '../../../externals/xml2json';\nimport URLUtils from '../utils/URLUtils';\nimport DashConstants from '../../dash/constants/DashConstants';\n\nconst RESOLVE_TYPE_ONLOAD = 'onLoad';\nconst RESOLVE_TYPE_ONACTUATE = 'onActuate';\nconst RESOLVE_TO_ZERO = 'urn:mpeg:dash:resolve-to-zero:2013';\n\nfunction XlinkController(config) {\n\n    config = config || {};\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        matchers,\n        iron,\n        manifest,\n        converter,\n        xlinkLoader;\n\n    function setup() {\n        eventBus.on(Events.XLINK_ELEMENT_LOADED, onXlinkElementLoaded, instance);\n\n        xlinkLoader = XlinkLoader(context).create({\n            errHandler: config.errHandler,\n            dashMetrics: config.dashMetrics,\n            mediaPlayerModel: config.mediaPlayerModel,\n            requestModifier: config.requestModifier,\n            settings: config.settings\n        });\n    }\n\n    function setMatchers(value) {\n        if (value) {\n            matchers = value;\n        }\n    }\n\n    function setIron(value) {\n        if (value) {\n            iron = value;\n        }\n    }\n\n    /**\n     * <p>Triggers the resolution of the xlink.onLoad attributes in the manifest file </p>\n     * @param {Object} mpd - the manifest\n     */\n    function resolveManifestOnLoad(mpd) {\n        let elements;\n        // First resolve all periods, so unnecessary requests inside onLoad Periods with Default content are avoided\n        converter = new X2JS({\n            escapeMode:         false,\n            attributePrefix:    '',\n            arrayAccessForm:    'property',\n            emptyNodeForm:      'object',\n            stripWhitespaces:   false,\n            enableToStringFunc: false,\n            ignoreRoot:         true,\n            matchers:           matchers\n        });\n\n        manifest = mpd;\n\n        if (manifest.Period_asArray) {\n            elements = getElementsToResolve(manifest.Period_asArray, manifest, DashConstants.PERIOD, RESOLVE_TYPE_ONLOAD);\n            resolve(elements, DashConstants.PERIOD, RESOLVE_TYPE_ONLOAD);\n        } else {\n            eventBus.trigger(Events.XLINK_READY, {manifest: manifest});\n        }\n    }\n\n    function reset() {\n        eventBus.off(Events.XLINK_ELEMENT_LOADED, onXlinkElementLoaded, instance);\n\n        if (xlinkLoader) {\n            xlinkLoader.reset();\n            xlinkLoader = null;\n        }\n    }\n\n    function resolve(elements, type, resolveType) {\n        let resolveObject = {};\n        let element,\n            url;\n\n        resolveObject.elements = elements;\n        resolveObject.type = type;\n        resolveObject.resolveType = resolveType;\n        // If nothing to resolve, directly call allElementsLoaded\n        if (resolveObject.elements.length === 0) {\n            onXlinkAllElementsLoaded(resolveObject);\n        }\n        for (let i = 0; i < resolveObject.elements.length; i++) {\n            element = resolveObject.elements[i];\n            if (urlUtils.isHTTPURL(element.url)) {\n                url = element.url;\n            } else {\n                url = element.originalContent.BaseURL + element.url;\n            }\n            xlinkLoader.load(url, element, resolveObject);\n        }\n    }\n\n    function onXlinkElementLoaded(event) {\n        let element,\n            resolveObject;\n\n        const openingTag = '<response>';\n        const closingTag = '</response>';\n        let mergedContent = '';\n\n        element = event.element;\n        resolveObject = event.resolveObject;\n        // if the element resolved into content parse the content\n        if (element.resolvedContent) {\n            let index = 0;\n            // we add a parent elements so the converter is able to parse multiple elements of the same type which are not wrapped inside a container\n            if (element.resolvedContent.indexOf('<?xml') === 0) {\n                index = element.resolvedContent.indexOf('?>') + 2; //find the closing position of the xml declaration, if it exists.\n            }\n            mergedContent = element.resolvedContent.substr(0,index) + openingTag + element.resolvedContent.substr(index) + closingTag;\n            element.resolvedContent = converter.xml_str2json(mergedContent);\n        }\n        if (isResolvingFinished(resolveObject)) {\n            onXlinkAllElementsLoaded(resolveObject);\n        }\n    }\n\n    // We got to wait till all elements of the current queue are resolved before merging back\n    function onXlinkAllElementsLoaded (resolveObject) {\n        let elements = [];\n        let i,\n            obj;\n\n        mergeElementsBack(resolveObject);\n        if (resolveObject.resolveType === RESOLVE_TYPE_ONACTUATE) {\n            eventBus.trigger(Events.XLINK_READY, { manifest: manifest });\n        }\n        if (resolveObject.resolveType === RESOLVE_TYPE_ONLOAD) {\n            switch (resolveObject.type) {\n                // Start resolving the other elements. We can do Adaptation Set and EventStream in parallel\n                case DashConstants.PERIOD:\n                    for (i = 0; i < manifest[DashConstants.PERIOD + '_asArray'].length; i++) {\n                        obj = manifest[DashConstants.PERIOD + '_asArray'][i];\n                        if (obj.hasOwnProperty(DashConstants.ADAPTATION_SET + '_asArray')) {\n                            elements = elements.concat(getElementsToResolve(obj[DashConstants.ADAPTATION_SET + '_asArray'], obj, DashConstants.ADAPTATION_SET, RESOLVE_TYPE_ONLOAD));\n                        }\n                        if (obj.hasOwnProperty(DashConstants.EVENT_STREAM + '_asArray')) {\n                            elements = elements.concat(getElementsToResolve(obj[DashConstants.EVENT_STREAM + '_asArray'], obj, DashConstants.EVENT_STREAM, RESOLVE_TYPE_ONLOAD));\n                        }\n                    }\n                    resolve(elements, DashConstants.ADAPTATION_SET, RESOLVE_TYPE_ONLOAD);\n                    break;\n                case DashConstants.ADAPTATION_SET:\n                    // TODO: Resolve SegmentList here\n                    eventBus.trigger(Events.XLINK_READY, { manifest: manifest });\n                    break;\n            }\n        }\n    }\n\n    // Returns the elements with the specific resolve Type\n    function getElementsToResolve(elements, parentElement, type, resolveType) {\n        let toResolve = [];\n        let element,\n            i,\n            xlinkObject;\n        // first remove all the resolve-to-zero elements\n        for (i = elements.length - 1; i >= 0; i--) {\n            element = elements[i];\n            if (element.hasOwnProperty('xlink:href') && element['xlink:href'] === RESOLVE_TO_ZERO) {\n                elements.splice(i, 1);\n            }\n        }\n        // now get the elements with the right resolve type\n        for (i = 0; i < elements.length; i++) {\n            element = elements[i];\n            if (element.hasOwnProperty('xlink:href') && element.hasOwnProperty('xlink:actuate') && element['xlink:actuate'] === resolveType) {\n                xlinkObject = createXlinkObject(element['xlink:href'], parentElement, type, i, resolveType, element);\n                toResolve.push(xlinkObject);\n            }\n        }\n        return toResolve;\n    }\n\n    function mergeElementsBack(resolveObject) {\n        let resolvedElements = [];\n        let element,\n            type,\n            obj,\n            i,\n            j,\n            k;\n        // Start merging back from the end because of index shifting. Note that the elements with the same parent have to be ordered by index ascending\n        for (i = resolveObject.elements.length - 1; i >= 0; i --) {\n            element = resolveObject.elements[i];\n            type = element.type + '_asArray';\n\n            // Element couldn't be resolved or is TODO Inappropriate target: Remove all Xlink attributes\n            if (!element.resolvedContent || isInappropriateTarget()) {\n                delete element.originalContent['xlink:actuate'];\n                delete element.originalContent['xlink:href'];\n                resolvedElements.push(element.originalContent);\n            }\n            // Element was successfully resolved\n            else if (element.resolvedContent) {\n                for (j = 0; j < element.resolvedContent[type].length; j++) {\n                    //TODO Contains another Xlink attribute with xlink:actuate set to onload. Remove all xLink attributes\n                    obj = element.resolvedContent[type][j];\n                    resolvedElements.push(obj);\n                }\n            }\n            // Replace the old elements in the parent with the resolved ones\n            element.parentElement[type].splice(element.index, 1);\n            for (k = 0; k < resolvedElements.length; k++) {\n                element.parentElement[type].splice(element.index + k, 0, resolvedElements[k]);\n            }\n            resolvedElements = [];\n        }\n        if (resolveObject.elements.length > 0) {\n            iron.run(manifest);\n        }\n    }\n\n    function createXlinkObject(url, parentElement, type, index, resolveType, originalContent) {\n        return {\n            url: url,\n            parentElement: parentElement,\n            type: type,\n            index: index,\n            resolveType: resolveType,\n            originalContent: originalContent,\n            resolvedContent: null,\n            resolved: false\n        };\n    }\n\n    // Check if all pending requests are finished\n    function isResolvingFinished(elementsToResolve) {\n        let i,\n            obj;\n        for (i = 0; i < elementsToResolve.elements.length; i++) {\n            obj = elementsToResolve.elements[i];\n            if (obj.resolved === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // TODO : Do some syntax check here if the target is valid or not\n    function isInappropriateTarget() {\n        return false;\n    }\n\n    instance = {\n        resolveManifestOnLoad: resolveManifestOnLoad,\n        setMatchers: setMatchers,\n        setIron: setIron,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nXlinkController.__dashjs_factory_name = 'XlinkController';\nexport default FactoryMaker.getClassFactory(XlinkController);\n"]},"metadata":{},"sourceType":"script"}