{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _MetricsConstants = require('../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _BufferLevelRule = require('../rules/scheduling/BufferLevelRule');\n\nvar _BufferLevelRule2 = _interopRequireDefault(_BufferLevelRule);\n\nvar _FragmentModel = require('../models/FragmentModel');\n\nvar _FragmentModel2 = _interopRequireDefault(_FragmentModel);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction ScheduleController(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var adapter = config.adapter;\n  var dashMetrics = config.dashMetrics;\n  var mediaPlayerModel = config.mediaPlayerModel;\n  var fragmentModel = config.fragmentModel;\n  var abrController = config.abrController;\n  var playbackController = config.playbackController;\n  var textController = config.textController;\n  var type = config.type;\n  var mimeType = config.mimeType;\n  var mediaController = config.mediaController;\n  var bufferController = config.bufferController;\n  var settings = config.settings;\n  var instance = void 0,\n      streamInfo = void 0,\n      logger = void 0,\n      currentRepresentationInfo = void 0,\n      initialRequest = void 0,\n      isStopped = void 0,\n      isFragmentProcessingInProgress = void 0,\n      timeToLoadDelay = void 0,\n      scheduleTimeout = void 0,\n      seekTarget = void 0,\n      hasVideoTrack = void 0,\n      bufferLevelRule = void 0,\n      lastFragmentRequest = void 0,\n      topQualityIndex = void 0,\n      lastInitializedRepresentationInfo = void 0,\n      replaceRequestArray = void 0,\n      switchTrack = void 0,\n      replacingBuffer = void 0,\n      mediaRequest = void 0,\n      checkPlaybackQuality = void 0,\n      isReplacementRequest = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    resetInitialSettings();\n    streamInfo = config.streamInfo;\n  }\n\n  function initialize(_hasVideoTrack) {\n    hasVideoTrack = _hasVideoTrack;\n    bufferLevelRule = (0, _BufferLevelRule2.default)(context).create({\n      abrController: abrController,\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      textController: textController,\n      settings: settings\n    }); //eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n\n    eventBus.on(_Events2.default.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n    eventBus.on(_Events2.default.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n    eventBus.on(_Events2.default.STREAM_COMPLETED, onStreamCompleted, this);\n    eventBus.on(_Events2.default.BUFFER_CLEARED, onBufferCleared, this);\n    eventBus.on(_Events2.default.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n    eventBus.on(_Events2.default.QUOTA_EXCEEDED, onQuotaExceeded, this);\n    eventBus.on(_Events2.default.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n    eventBus.on(_Events2.default.PLAYBACK_STARTED, onPlaybackStarted, this);\n    eventBus.on(_Events2.default.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n    eventBus.on(_Events2.default.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n    eventBus.on(_Events2.default.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n    eventBus.on(_Events2.default.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n    eventBus.on(_Events2.default.BUFFERING_COMPLETED, onBufferingCompleted, this);\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function setCurrentRepresentation(representationInfo) {\n    currentRepresentationInfo = representationInfo;\n  }\n\n  function isStarted() {\n    return isStopped === false;\n  }\n\n  function start() {\n    if (!streamInfo) return;\n    if (isStarted()) return;\n    if (!currentRepresentationInfo || bufferController.getIsBufferingCompleted()) return;\n    logger.debug('Schedule Controller starts');\n    isStopped = false;\n    dashMetrics.createPlaylistTraceMetrics(currentRepresentationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\n\n    if (initialRequest) {\n      initialRequest = false;\n    }\n\n    startScheduleTimer(0);\n  }\n\n  function stop() {\n    if (isStopped) return;\n    logger.debug('Schedule Controller stops');\n    logger.debug(type + ' Schedule Controller stops');\n    isStopped = true;\n    clearTimeout(scheduleTimeout);\n  }\n\n  function hasTopQualityChanged(type, id) {\n    topQualityIndex[id] = topQualityIndex[id] || {};\n    var newTopQualityIndex = abrController.getTopQualityIndexFor(type, id);\n\n    if (topQualityIndex[id][type] != newTopQualityIndex) {\n      logger.info('Top quality ' + type + ' index has changed from ' + topQualityIndex[id][type] + ' to ' + newTopQualityIndex);\n      topQualityIndex[id][type] = newTopQualityIndex;\n      return true;\n    }\n\n    return false;\n  }\n\n  function schedule() {\n    if (!streamInfo) return;\n\n    if (isStopped || isFragmentProcessingInProgress || playbackController.isPaused() && !settings.get().streaming.scheduleWhilePaused || (type === _Constants2.default.FRAGMENTED_TEXT || type === _Constants2.default.TEXT) && !textController.isTextEnabled() || bufferController.getIsBufferingCompleted()) {\n      stop();\n      return;\n    }\n\n    validateExecutedFragmentRequest();\n    var isReplacement = replaceRequestArray.length > 0;\n    var lastInitializedQuality = lastInitializedRepresentationInfo ? lastInitializedRepresentationInfo.quality : NaN;\n\n    if (replacingBuffer || isNaN(lastInitializedQuality) || switchTrack || isReplacement || hasTopQualityChanged(type, streamInfo.id) || bufferLevelRule.execute(type, currentRepresentationInfo, hasVideoTrack)) {\n      var getNextFragment = function getNextFragment() {\n        if ((currentRepresentationInfo.quality !== lastInitializedQuality || switchTrack) && !replacingBuffer) {\n          if (switchTrack) {\n            logger.debug('Switch track for ' + type + ', representation id = ' + currentRepresentationInfo.id);\n            replacingBuffer = mediaController.getSwitchMode(type) === _Constants2.default.TRACK_SWITCH_MODE_ALWAYS_REPLACE;\n\n            if (replacingBuffer && bufferController.replaceBuffer) {\n              bufferController.replaceBuffer();\n            }\n\n            switchTrack = false;\n          } else {\n            logger.debug('Quality has changed, get init request for representationid = ' + currentRepresentationInfo.id);\n          }\n\n          eventBus.trigger(_Events2.default.INIT_FRAGMENT_NEEDED, {\n            representationId: currentRepresentationInfo.id,\n            sender: instance\n          }, {\n            streamId: streamInfo.id,\n            mediaType: type\n          });\n          checkPlaybackQuality = false;\n        } else {\n          var replacement = replaceRequestArray.shift();\n\n          if (replacement && replacement.isInitializationRequest()) {\n            // To be sure the specific init segment had not already been loaded\n            eventBus.trigger(_Events2.default.INIT_FRAGMENT_NEEDED, {\n              representationId: replacement.representationId,\n              sender: instance\n            }, {\n              streamId: streamInfo.id,\n              mediaType: type\n            });\n            checkPlaybackQuality = false;\n          } else {\n            eventBus.trigger(_Events2.default.MEDIA_FRAGMENT_NEEDED, {\n              seekTarget: seekTarget,\n              replacement: replacement\n            }, {\n              streamId: streamInfo.id,\n              mediaType: type\n            });\n            checkPlaybackQuality = true;\n          }\n        }\n      };\n\n      setFragmentProcessState(true);\n\n      if (!isReplacement && checkPlaybackQuality) {\n        abrController.checkPlaybackQuality(type);\n      }\n\n      getNextFragment();\n    } else {\n      startScheduleTimer(500);\n    }\n  }\n\n  function validateExecutedFragmentRequest() {\n    if (!isNaN(seekTarget)) return;\n    if (!lastInitializedRepresentationInfo) return; // Validate that the fragment request executed and appended into the source buffer is as\n    // good of quality as the current quality and is the correct media track.\n\n    var time = playbackController.getTime();\n    var safeBufferLevel = 1.5;\n\n    if (isNaN(lastInitializedRepresentationInfo.fragmentDuration)) {\n      //fragmentDuration of representationInfo is not defined,\n      // call metrics function to have data in the latest scheduling info...\n      // if no metric, returns 0. In this case, rule will return false.\n      var schedulingInfo = dashMetrics.getCurrentSchedulingInfo(currentRepresentationInfo.mediaInfo.type);\n      safeBufferLevel = schedulingInfo ? schedulingInfo.duration * 1.5 : 1.5;\n    }\n\n    var request = fragmentModel.getRequests({\n      state: _FragmentModel2.default.FRAGMENT_MODEL_EXECUTED,\n      time: time + safeBufferLevel,\n      threshold: 0\n    })[0];\n\n    if (request && replaceRequestArray.indexOf(request) === -1 && !adapter.getIsTextTrack(mimeType)) {\n      var fastSwitchModeEnabled = settings.get().streaming.fastSwitchEnabled;\n      var bufferLevel = bufferController.getBufferLevel();\n      var abandonmentState = abrController.getAbandonmentStateFor(type); // Only replace on track switch when NEVER_REPLACE\n\n      var trackChanged = !mediaController.isCurrentTrack(request.mediaInfo) && mediaController.getSwitchMode(request.mediaInfo.type) === _Constants2.default.TRACK_SWITCH_MODE_NEVER_REPLACE;\n\n      var qualityChanged = request.quality < lastInitializedRepresentationInfo.quality;\n\n      if (fastSwitchModeEnabled && (trackChanged || qualityChanged) && bufferLevel >= safeBufferLevel && abandonmentState !== _MetricsConstants2.default.ABANDON_LOAD) {\n        replaceRequest(request);\n        isReplacementRequest = true;\n        logger.debug('Reloading outdated fragment at index: ', request.index);\n      } else if (request.quality > lastInitializedRepresentationInfo.quality && !replacingBuffer) {\n        // The buffer has better quality it in then what we would request so set append point to end of buffer!!\n        setSeekTarget(playbackController.getTime() + bufferLevel);\n      }\n    }\n  }\n\n  function startScheduleTimer(value) {\n    clearTimeout(scheduleTimeout);\n    scheduleTimeout = setTimeout(schedule, value);\n  }\n\n  function setFragmentProcessState(state) {\n    if (isFragmentProcessingInProgress !== state) {\n      isFragmentProcessingInProgress = state;\n    } else {\n      logger.debug('isFragmentProcessingInProgress is already equal to', state);\n    }\n  }\n\n  function processInitRequest(request) {\n    if (request) {\n      setFragmentProcessState(true);\n      fragmentModel.executeRequest(request);\n    }\n  }\n\n  function processMediaRequest(request) {\n    if (request) {\n      logger.debug('Next fragment request url is ' + request.url);\n      fragmentModel.executeRequest(request);\n    } else {\n      // Use case - Playing at the bleeding live edge and frag is not available yet. Cycle back around.\n      if (playbackController.getIsDynamic()) {\n        logger.debug('Next fragment seems to be at the bleeding live edge and is not available yet. Rescheduling.');\n      }\n\n      setFragmentProcessState(false);\n      startScheduleTimer(settings.get().streaming.lowLatencyEnabled ? 100 : 500);\n    }\n  }\n\n  function switchTrackAsked() {\n    switchTrack = true;\n  }\n\n  function replaceRequest(request) {\n    replaceRequestArray.push(request);\n  }\n\n  function completeQualityChange(trigger) {\n    if (playbackController && fragmentModel) {\n      var item = fragmentModel.getRequests({\n        state: _FragmentModel2.default.FRAGMENT_MODEL_EXECUTED,\n        time: playbackController.getTime(),\n        threshold: 0\n      })[0];\n\n      if (item && playbackController.getTime() >= item.startTime) {\n        if ((!lastFragmentRequest.mediaInfo || item.mediaInfo.type === lastFragmentRequest.mediaInfo.type && item.mediaInfo.id !== lastFragmentRequest.mediaInfo.id) && trigger) {\n          eventBus.trigger(_Events2.default.TRACK_CHANGE_RENDERED, {\n            mediaType: type,\n            oldMediaInfo: lastFragmentRequest.mediaInfo,\n            newMediaInfo: item.mediaInfo\n          });\n        }\n\n        if ((item.quality !== lastFragmentRequest.quality || item.adaptationIndex !== lastFragmentRequest.adaptationIndex) && trigger) {\n          eventBus.trigger(_Events2.default.QUALITY_CHANGE_RENDERED, {\n            mediaType: type,\n            oldQuality: lastFragmentRequest.quality,\n            newQuality: item.quality\n          });\n        }\n\n        lastFragmentRequest = {\n          mediaInfo: item.mediaInfo,\n          quality: item.quality,\n          adaptationIndex: item.adaptationIndex\n        };\n      }\n    }\n  }\n\n  function onStreamCompleted() {\n    stop();\n    setFragmentProcessState(false);\n    logger.info('Stream ' + streamInfo.id + ' is complete');\n  }\n\n  function onFragmentLoadingCompleted(e) {\n    if (e.request.mediaInfo.streamInfo.id !== streamInfo.id || e.request.mediaType !== type) return;\n    logger.info('OnFragmentLoadingCompleted - Url:', e.request ? e.request.url : 'undefined', e.request.range ? ', Range:' + e.request.range : '');\n\n    if (adapter.getIsTextTrack(mimeType)) {\n      setFragmentProcessState(false);\n    }\n\n    if (e.error && e.request.serviceLocation && !isStopped) {\n      replaceRequest(e.request);\n      setFragmentProcessState(false);\n      startScheduleTimer(0);\n    }\n\n    if (replacingBuffer) {\n      mediaRequest = e.request;\n    }\n  }\n\n  function onPlaybackTimeUpdated() {\n    completeQualityChange(true);\n  }\n\n  function onBytesAppended(e) {\n    if (replacingBuffer && !isNaN(e.startTime)) {\n      replacingBuffer = false;\n      fragmentModel.addExecutedRequest(mediaRequest);\n    }\n\n    setFragmentProcessState(false);\n\n    if (isNaN(e.index)) {\n      lastInitializedRepresentationInfo = bufferController.getRepresentationInfo(e.quality);\n      logger.info('[' + type + '] ' + 'lastInitializedRepresentationInfo changed to ' + e.quality);\n    }\n\n    if (isReplacementRequest && !isNaN(e.startTime)) {\n      //replace requests process is in progress, call schedule in n seconds.\n      //it is done in order to not add a fragment at the new quality at the end of the buffer before replace process is over.\n      //Indeed, if schedule is called too early, the executed request tested is the same that the one tested during previous schedule (at the new quality).\n      var currentTime = playbackController.getTime();\n      var fragEndTime = e.startTime + currentRepresentationInfo.fragmentDuration;\n      var safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\n\n      if (currentTime + safeBufferLevel >= fragEndTime) {\n        startScheduleTimer(0);\n      } else {\n        startScheduleTimer((fragEndTime - (currentTime + safeBufferLevel)) * 1000);\n      }\n\n      isReplacementRequest = false;\n    } else {\n      startScheduleTimer(0);\n    }\n  }\n\n  function onFragmentLoadingAbandoned(e) {\n    logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has been aborted');\n\n    if (!playbackController.isSeeking() && !switchTrack) {\n      logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has to be downloaded again, origin is not seeking process or switch track call');\n      replaceRequest(e.request);\n    }\n\n    setFragmentProcessState(false);\n    startScheduleTimer(0);\n  }\n\n  function onDataUpdateStarted()\n  /*e*/\n  {// stop();\n  }\n\n  function onBufferingCompleted()\n  /*e*/\n  {\n    stop();\n  }\n\n  function onBufferCleared(e) {\n    if (replacingBuffer && settings.get().streaming.flushBufferAtTrackSwitch) {\n      // For some devices (like chromecast) it is necessary to seek the video element to reset the internal decoding buffer,\n      // otherwise audio track switch will be effective only once after previous buffered track is consumed\n      playbackController.seek(playbackController.getTime() + 0.001, false, true);\n    } // (Re)start schedule once buffer has been pruned after a QuotaExceededError\n\n\n    if (e.hasEnoughSpaceToAppend && e.quotaExceeded) {\n      start();\n    }\n  }\n\n  function onQuotaExceeded()\n  /*e*/\n  {\n    // Stop scheduler (will be restarted once buffer is pruned)\n    stop();\n    setFragmentProcessState(false);\n  }\n\n  function onURLResolutionFailed() {\n    fragmentModel.abortRequests();\n    stop();\n  }\n\n  function onPlaybackStarted() {\n    if (isStopped || !settings.get().streaming.scheduleWhilePaused) {\n      start();\n    }\n  }\n\n  function onPlaybackSeeking(e) {\n    if (!streamInfo) return;\n    setSeekTarget(e.seekTime);\n    setTimeToLoadDelay(0);\n\n    if (isStopped) {\n      start();\n    }\n\n    var latency = currentRepresentationInfo && currentRepresentationInfo.DVRWindow && playbackController ? currentRepresentationInfo.DVRWindow.end - playbackController.getTime() : NaN;\n    dashMetrics.updateManifestUpdateInfo({\n      latency: latency\n    });\n\n    if (!isFragmentProcessingInProgress) {\n      // No pending request, request next segment at seek target\n      startScheduleTimer(0);\n    } else {\n      // Abort current request\n      fragmentModel.abortRequests();\n    }\n  }\n\n  function onPlaybackRateChanged(e) {\n    dashMetrics.updatePlayListTraceMetrics({\n      playbackspeed: e.playbackRate.toString()\n    });\n  }\n\n  function setSeekTarget(value) {\n    seekTarget = value;\n  }\n\n  function setTimeToLoadDelay(value) {\n    timeToLoadDelay = value;\n  }\n\n  function getTimeToLoadDelay() {\n    return timeToLoadDelay;\n  }\n\n  function getBufferTarget() {\n    return bufferLevelRule.getBufferTarget(type, currentRepresentationInfo, hasVideoTrack);\n  }\n\n  function resetInitialSettings() {\n    checkPlaybackQuality = true;\n    isFragmentProcessingInProgress = false;\n    timeToLoadDelay = 0;\n    seekTarget = NaN;\n    initialRequest = true;\n    lastInitializedRepresentationInfo = undefined;\n    lastFragmentRequest = {\n      mediaInfo: undefined,\n      quality: NaN,\n      adaptationIndex: NaN\n    };\n    topQualityIndex = {};\n    replaceRequestArray = [];\n    isStopped = true;\n    switchTrack = false;\n    replacingBuffer = false;\n    mediaRequest = null;\n    isReplacementRequest = false;\n  }\n\n  function reset() {\n    //eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n    eventBus.off(_Events2.default.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n    eventBus.off(_Events2.default.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n    eventBus.off(_Events2.default.STREAM_COMPLETED, onStreamCompleted, this);\n    eventBus.off(_Events2.default.BUFFER_CLEARED, onBufferCleared, this);\n    eventBus.off(_Events2.default.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n    eventBus.off(_Events2.default.QUOTA_EXCEEDED, onQuotaExceeded, this);\n    eventBus.off(_Events2.default.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n    eventBus.off(_Events2.default.PLAYBACK_STARTED, onPlaybackStarted, this);\n    eventBus.off(_Events2.default.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n    eventBus.off(_Events2.default.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n    eventBus.off(_Events2.default.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n    eventBus.off(_Events2.default.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n    eventBus.off(_Events2.default.BUFFERING_COMPLETED, onBufferingCompleted, this);\n    stop();\n    completeQualityChange(false);\n    resetInitialSettings();\n    streamInfo = null;\n  }\n\n  function getPlaybackController() {\n    return playbackController;\n  }\n\n  instance = {\n    initialize: initialize,\n    getType: getType,\n    getStreamId: getStreamId,\n    setCurrentRepresentation: setCurrentRepresentation,\n    setSeekTarget: setSeekTarget,\n    setTimeToLoadDelay: setTimeToLoadDelay,\n    getTimeToLoadDelay: getTimeToLoadDelay,\n    switchTrackAsked: switchTrackAsked,\n    isStarted: isStarted,\n    start: start,\n    stop: stop,\n    reset: reset,\n    getBufferTarget: getBufferTarget,\n    processInitRequest: processInitRequest,\n    processMediaRequest: processMediaRequest,\n    getPlaybackController: getPlaybackController\n  };\n  setup();\n  return instance;\n}\n\nScheduleController.__dashjs_factory_name = 'ScheduleController';\nexports.default = _FactoryMaker2.default.getClassFactory(ScheduleController);","map":{"version":3,"mappings":";;;;;;AA8BA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AArCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,SAASA,kBAAT,CAA4BC,MAA5B,EAAoC;EAEhCA,SAASA,UAAU,EAAnBA;EACA,IAAMC,UAAU,KAAKA,OAArB;EACA,IAAMC,WAAW,wBAASD,OAAT,EAAkBE,WAAlB,EAAjB;EACA,IAAMC,UAAUJ,OAAOI,OAAvB;EACA,IAAMC,cAAcL,OAAOK,WAA3B;EACA,IAAMC,mBAAmBN,OAAOM,gBAAhC;EACA,IAAMC,gBAAgBP,OAAOO,aAA7B;EACA,IAAMC,gBAAgBR,OAAOQ,aAA7B;EACA,IAAMC,qBAAqBT,OAAOS,kBAAlC;EACA,IAAMC,iBAAiBV,OAAOU,cAA9B;EACA,IAAMC,OAAOX,OAAOW,IAApB;EACA,IAAMC,WAAWZ,OAAOY,QAAxB;EACA,IAAMC,kBAAkBb,OAAOa,eAA/B;EACA,IAAMC,mBAAmBd,OAAOc,gBAAhC;EACA,IAAMC,WAAWf,OAAOe,QAAxB;EAEA,IAAIC,iBAAJ;EAAA,IACIC,mBADJ;EAAA,IAEIC,eAFJ;EAAA,IAGIC,kCAHJ;EAAA,IAIIC,uBAJJ;EAAA,IAKIC,kBALJ;EAAA,IAMIC,uCANJ;EAAA,IAOIC,wBAPJ;EAAA,IAQIC,wBARJ;EAAA,IASIC,mBATJ;EAAA,IAUIC,sBAVJ;EAAA,IAWIC,wBAXJ;EAAA,IAYIC,4BAZJ;EAAA,IAaIC,wBAbJ;EAAA,IAcIC,0CAdJ;EAAA,IAeIC,4BAfJ;EAAA,IAgBIC,oBAhBJ;EAAA,IAiBIC,wBAjBJ;EAAA,IAkBIC,qBAlBJ;EAAA,IAmBIC,6BAnBJ;EAAA,IAoBIC,6BApBJ;;EAsBA,SAASC,KAAT,GAAiB;IACbnB,SAAS,qBAAMjB,OAAN,EAAeE,WAAf,GAA6BmC,SAA7B,CAAuCtB,QAAvC,CAATE;IACAqB;IACAtB,aAAajB,OAAOiB,UAApBA;EAGJ;;EAAA,SAASuB,UAAT,CAAoBC,cAApB,EAAoC;IAChCf,gBAAgBe,cAAhBf;IAEAC,kBAAkB,+BAAgB1B,OAAhB,EAAyByC,MAAzB,CAAgC;MAC9ClC,eAAeA,aAD+B;MAE9CH,aAAaA,WAFiC;MAG9CC,kBAAkBA,gBAH4B;MAI9CI,gBAAgBA,cAJ8B;MAK9CK,UAAUA;IALoC,CAAhC,CAAlBY,CAHgC,CAWhC;;IACAzB,SAASyC,EAATzC,CAAY0C,iBAAOC,mBAAnB3C,EAAwC4C,mBAAxC5C,EAA6D,IAA7DA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOG,0BAAnB7C,EAA+C8C,0BAA/C9C,EAA2E,IAA3EA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOK,gBAAnB/C,EAAqCgD,iBAArChD,EAAwD,IAAxDA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOO,cAAnBjD,EAAmCkD,eAAnClD,EAAoD,IAApDA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOS,2BAAnBnD,EAAgDoD,eAAhDpD,EAAiE,IAAjEA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOW,cAAnBrD,EAAmCsD,eAAnCtD,EAAoD,IAApDA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOa,gBAAnBvD,EAAqCwD,iBAArCxD,EAAwD,IAAxDA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOe,gBAAnBzD,EAAqC0D,iBAArC1D,EAAwD,IAAxDA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOiB,qBAAnB3D,EAA0C4D,qBAA1C5D,EAAiE,IAAjEA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOmB,qBAAnB7D,EAA0C8D,qBAA1C9D,EAAiE,IAAjEA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOqB,qBAAnB/D,EAA0CgE,qBAA1ChE,EAAiE,IAAjEA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOuB,0BAAnBjE,EAA+CkE,0BAA/ClE,EAA2E,IAA3EA;IACAA,SAASyC,EAATzC,CAAY0C,iBAAOyB,mBAAnBnE,EAAwCoE,oBAAxCpE,EAA8D,IAA9DA;EAGJ;;EAAA,SAASqE,OAAT,GAAmB;IACf,OAAO5D,IAAP;EAGJ;;EAAA,SAAS6D,WAAT,GAAuB;IACnB,OAAOvD,WAAWwD,EAAlB;EAGJ;;EAAA,SAASC,wBAAT,CAAkCC,kBAAlC,EAAsD;IAClDxD,4BAA4BwD,kBAA5BxD;EAGJ;;EAAA,SAASyD,SAAT,GAAqB;IACjB,OAAQvD,cAAc,KAAtB;EAGJ;;EAAA,SAASwD,KAAT,GAAiB;IACb,IAAI,CAAC5D,UAAL,EAAiB;IACjB,IAAI2D,WAAJ,EAAiB;IACjB,IAAI,CAACzD,yBAAD,IAA8BL,iBAAiBgE,uBAAjBhE,EAAlC,EAA8E;IAE9EI,OAAO6D,KAAP7D,CAAa,4BAAbA;IACAG,YAAY,KAAZA;IACAhB,YAAY2E,0BAAZ3E,CAAuCc,0BAA0BsD,EAAjEpE,EAAqEI,mBAAmBwE,OAAnBxE,KAA+B,IAApGJ,EAA0GI,mBAAmByE,eAAnBzE,EAA1GJ;;IAEA,IAAIe,cAAJ,EAAoB;MAChBA,iBAAiB,KAAjBA;IAGJ+D;;IAAAA,mBAAmB,CAAnBA;EAGJ;;EAAA,SAASC,IAAT,GAAgB;IACZ,IAAI/D,SAAJ,EAAe;IAEfH,OAAO6D,KAAP7D,CAAa,2BAAbA;IACAA,OAAO6D,KAAP7D,CAAaP,OAAO,4BAApBO;IACAG,YAAY,IAAZA;IACAgE,aAAa7D,eAAb6D;EAGJ;;EAAA,SAASC,oBAAT,CAA8B3E,IAA9B,EAAoC8D,EAApC,EAAwC;IACpC5C,gBAAgB4C,EAAhB5C,IAAsBA,gBAAgB4C,EAAhB5C,KAAuB,EAA7CA;IACA,IAAM0D,qBAAqB/E,cAAcgF,qBAAdhF,CAAoCG,IAApCH,EAA0CiE,EAA1CjE,CAA3B;;IAEA,IAAIqB,gBAAgB4C,EAAhB5C,EAAoBlB,IAApBkB,KAA6B0D,kBAAjC,EAAqD;MACjDrE,OAAOuE,IAAPvE,CAAY,iBAAiBP,IAAjB,GAAwB,0BAAxB,GAAqDkB,gBAAgB4C,EAAhB5C,EAAoBlB,IAApBkB,CAArD,GAAiF,MAAjF,GAA0F0D,kBAAtGrE;MACAW,gBAAgB4C,EAAhB5C,EAAoBlB,IAApBkB,IAA4B0D,kBAA5B1D;MACA,OAAO,IAAP;IAEJ;;IAAA,OAAO,KAAP;EAIJ;;EAAA,SAAS6D,QAAT,GAAoB;IAChB,IAAI,CAACzE,UAAL,EAAiB;;IACjB,IAAII,aAAaC,8BAAbD,IACCZ,mBAAmBkF,QAAnBlF,MAAiC,CAACM,SAAS6E,GAAT7E,GAAe8E,SAAf9E,CAAyB+E,mBAD5DzE,IAEC,CAACV,SAASoF,oBAAUC,eAAnBrF,IAAsCA,SAASoF,oBAAUE,IAA1D,KAAmE,CAACvF,eAAewF,aAAfxF,EAFrEW,IAGAP,iBAAiBgE,uBAAjBhE,EAHJ,EAGgD;MAC5CsE;MACA;IAGJe;;IAAAA;IAEA,IAAMC,gBAAgBrE,oBAAoBsE,MAApBtE,GAA6B,CAAnD;IACA,IAAMuE,yBAAyBxE,oCAAoCA,kCAAkCyE,OAAtEzE,GAAgF0E,GAA/G;;IACA,IAAIvE,mBAAmBwE,MAAMH,sBAANG,CAAnBxE,IAAoDD,WAApDC,IAAmEmE,aAAnEnE,IACAqD,qBAAqB3E,IAArB2E,EAA2BrE,WAAWwD,EAAtCa,CADArD,IAEAN,gBAAgB+E,OAAhB/E,CAAwBhB,IAAxBgB,EAA8BR,yBAA9BQ,EAAyDD,aAAzDC,CAFJ,EAE6E;MACzE,IAAMgF,kBAAkB,SAAlBA,eAAkB,GAAY;QAChC,IAAI,CAACxF,0BAA0BoF,OAA1BpF,KAAsCmF,sBAAtCnF,IAAgEa,WAAjE,KAAkF,CAACC,eAAvF,EAAyG;UACrG,IAAID,WAAJ,EAAiB;YACbd,OAAO6D,KAAP7D,CAAa,sBAAsBP,IAAtB,GAA6B,wBAA7B,GAAwDQ,0BAA0BsD,EAA/FvD;YACAe,kBAAkBpB,gBAAgB+F,aAAhB/F,CAA8BF,IAA9BE,MAAwCkF,oBAAUc,gCAApE5E;;YACA,IAAIA,mBAAmBnB,iBAAiBgG,aAAxC,EAAuD;cACnDhG,iBAAiBgG,aAAjBhG;YAEJkB;;YAAAA,cAAc,KAAdA;UANJ,OAOO;YACHd,OAAO6D,KAAP7D,CAAa,kEAAkEC,0BAA0BsD,EAAzGvD;UAEJhB;;UAAAA,SAAS6G,OAAT7G,CAAiB0C,iBAAOoE,oBAAxB9G,EACI;YAAE+G,kBAAkB9F,0BAA0BsD,EAA9C;YAAkDyC,QAAQlG;UAA1D,CADJd,EAEI;YAAEiH,UAAUlG,WAAWwD,EAAvB;YAA2B2C,WAAWzG;UAAtC,CAFJT;UAIAiC,uBAAuB,KAAvBA;QAfJ,OAgBO;UACH,IAAMkF,cAActF,oBAAoBuF,KAApBvF,EAApB;;UAEA,IAAIsF,eAAeA,YAAYE,uBAAZF,EAAnB,EAA0D;YACtD;YACAnH,SAAS6G,OAAT7G,CAAiB0C,iBAAOoE,oBAAxB9G,EACI;cAAE+G,kBAAkBI,YAAYJ,gBAAhC;cAAkDC,QAAQlG;YAA1D,CADJd,EAEI;cAAEiH,UAAUlG,WAAWwD,EAAvB;cAA2B2C,WAAWzG;YAAtC,CAFJT;YAIAiC,uBAAuB,KAAvBA;UANJ,OAOO;YACHjC,SAAS6G,OAAT7G,CAAiB0C,iBAAO4E,qBAAxBtH,EACI;cAAEuB,YAAYA,UAAd;cAA0B4F,aAAaA;YAAvC,CADJnH,EAEI;cAAEiH,UAAUlG,WAAWwD,EAAvB;cAA2B2C,WAAWzG;YAAtC,CAFJT;YAIAiC,uBAAuB,IAAvBA;UAEP;QACJ;MAnCD;;MAqCAsF,wBAAwB,IAAxBA;;MACA,IAAI,CAACrB,aAAD,IAAkBjE,oBAAtB,EAA4C;QACxC3B,cAAc2B,oBAAd3B,CAAmCG,IAAnCH;MAGJmG;;MAAAA;IA7CJ,OA+CO;MACHxB,mBAAmB,GAAnBA;IAEP;EAED;;EAAA,SAASgB,+BAAT,GAA2C;IACvC,IAAI,CAACM,MAAMhF,UAANgF,CAAL,EAAwB;IACxB,IAAI,CAAC3E,iCAAL,EAAwC,OAFD,CAGvC;IACA;;IACA,IAAM4F,OAAOjH,mBAAmBwE,OAAnBxE,EAAb;IACA,IAAIkH,kBAAkB,GAAtB;;IAEA,IAAIlB,MAAM3E,kCAAkC8F,gBAAxCnB,CAAJ,EAA+D;MAAE;MAC7D;MACA;MACA,IAAMoB,iBAAiBxH,YAAYyH,wBAAZzH,CAAqCc,0BAA0B4G,SAA1B5G,CAAoCR,IAAzEN,CAAvB;MACAsH,kBAAkBE,iBAAiBA,eAAeG,QAAfH,GAA0B,GAA3CA,GAAiD,GAAnEF;IAEJ;;IAAA,IAAMM,UAAU1H,cAAc2H,WAAd3H,CAA0B;MACtC4H,OAAOC,wBAAcC,uBADiB;MAEtCX,MAAMA,OAAOC,eAFyB;MAGtCW,WAAW;IAH2B,CAA1B/H,EAIb,CAJaA,CAAhB;;IAMA,IAAI0H,WAAWlG,oBAAoBwG,OAApBxG,CAA4BkG,OAA5BlG,MAAyC,CAAC,CAArDkG,IAA0D,CAAC7H,QAAQoI,cAARpI,CAAuBQ,QAAvBR,CAA/D,EAAiG;MAC7F,IAAMqI,wBAAwB1H,SAAS6E,GAAT7E,GAAe8E,SAAf9E,CAAyB2H,iBAAvD;MACA,IAAMC,cAAc7H,iBAAiB8H,cAAjB9H,EAApB;MACA,IAAM+H,mBAAmBrI,cAAcsI,sBAAdtI,CAAqCG,IAArCH,CAAzB,CAH6F,CAK7F;;MACA,IAAMuI,eAAe,CAAClI,gBAAgBmI,cAAhBnI,CAA+BoH,QAAQF,SAAvClH,CAAD,IAAsDA,gBAAgB+F,aAAhB/F,CAA8BoH,QAAQF,SAARE,CAAkBtH,IAAhDE,MAA0DkF,oBAAUkD,+BAA/I;;MACA,IAAMC,iBAAiBjB,QAAQ1B,OAAR0B,GAAkBnG,kCAAkCyE,OAA3E;;MAEA,IAAIkC,0BAA0BM,gBAAgBG,cAA1CT,KAA6DE,eAAehB,eAA5Ec,IAA+FI,qBAAqBM,2BAAiBC,YAAzI,EAAuJ;QACnJC,eAAepB,OAAfoB;QACAjH,uBAAuB,IAAvBA;QACAlB,OAAO6D,KAAP7D,CAAa,wCAAbA,EAAuD+G,QAAQqB,KAA/DpI;MAHJ,OAIO,IAAI+G,QAAQ1B,OAAR0B,GAAkBnG,kCAAkCyE,OAApD0B,IAA+D,CAAChG,eAApE,EAAqF;QACxF;QACAsH,cAAc9I,mBAAmBwE,OAAnBxE,KAA+BkI,WAA7CY;MAEP;IACJ;EAED;;EAAA,SAASpE,kBAAT,CAA4BqE,KAA5B,EAAmC;IAC/BnE,aAAa7D,eAAb6D;IAEA7D,kBAAkBiI,WAAW/D,QAAX+D,EAAqBD,KAArBC,CAAlBjI;EAGJ;;EAAA,SAASiG,uBAAT,CAAkCU,KAAlC,EAAyC;IACrC,IAAI7G,mCAAmC6G,KAAvC,EAA+C;MAC3C7G,iCAAiC6G,KAAjC7G;IADJ,OAEO;MACHJ,OAAO6D,KAAP7D,CAAa,oDAAbA,EAAmEiH,KAAnEjH;IAEP;EAED;;EAAA,SAASwI,kBAAT,CAA4BzB,OAA5B,EAAqC;IACjC,IAAIA,OAAJ,EAAa;MACTR,wBAAwB,IAAxBA;MACAlH,cAAcoJ,cAAdpJ,CAA6B0H,OAA7B1H;IAEP;EAED;;EAAA,SAASqJ,mBAAT,CAA6B3B,OAA7B,EAAsC;IAClC,IAAIA,OAAJ,EAAa;MACT/G,OAAO6D,KAAP7D,CAAa,kCAAkC+G,QAAQ4B,GAAvD3I;MACAX,cAAcoJ,cAAdpJ,CAA6B0H,OAA7B1H;IAFJ,OAGO;MAAE;MACL,IAAIE,mBAAmBqJ,YAAnBrJ,EAAJ,EAAuC;QACnCS,OAAO6D,KAAP7D,CAAa,6FAAbA;MAEJuG;;MAAAA,wBAAwB,KAAxBA;MACAtC,mBAAmBpE,SAAS6E,GAAT7E,GAAe8E,SAAf9E,CAAyBgJ,iBAAzBhJ,GAA6C,GAA7CA,GAAmD,GAAtEoE;IAEP;EAED;;EAAA,SAAS6E,gBAAT,GAA4B;IACxBhI,cAAc,IAAdA;EAGJ;;EAAA,SAASqH,cAAT,CAAwBpB,OAAxB,EAAiC;IAC7BlG,oBAAoBkI,IAApBlI,CAAyBkG,OAAzBlG;EAGJ;;EAAA,SAASmI,qBAAT,CAA+BnD,OAA/B,EAAwC;IACpC,IAAItG,sBAAsBF,aAA1B,EAAyC;MACrC,IAAM4J,OAAO5J,cAAc2H,WAAd3H,CAA0B;QACnC4H,OAAOC,wBAAcC,uBADc;QAEnCX,MAAMjH,mBAAmBwE,OAAnBxE,EAF6B;QAGnC6H,WAAW;MAHwB,CAA1B/H,EAIV,CAJUA,CAAb;;MAKA,IAAI4J,QAAQ1J,mBAAmBwE,OAAnBxE,MAAgC0J,KAAKC,SAAjD,EAA4D;QACxD,IAAI,CAAC,CAACxI,oBAAoBmG,SAArB,IAAmCoC,KAAKpC,SAALoC,CAAexJ,IAAfwJ,KAAwBvI,oBAAoBmG,SAApBnG,CAA8BjB,IAAtDwJ,IAA8DA,KAAKpC,SAALoC,CAAe1F,EAAf0F,KAAsBvI,oBAAoBmG,SAApBnG,CAA8B6C,EAAtJ,KAA8JsC,OAAlK,EAA2K;UACvK7G,SAAS6G,OAAT7G,CAAiB0C,iBAAOyH,qBAAxBnK,EAA+C;YAC3CkH,WAAWzG,IADgC;YAE3C2J,cAAc1I,oBAAoBmG,SAFS;YAG3CwC,cAAcJ,KAAKpC;UAHwB,CAA/C7H;QAMJ;;QAAA,IAAI,CAACiK,KAAK5D,OAAL4D,KAAiBvI,oBAAoB2E,OAArC4D,IAAgDA,KAAKK,eAALL,KAAyBvI,oBAAoB4I,eAA9F,KAAkHzD,OAAtH,EAA+H;UAC3H7G,SAAS6G,OAAT7G,CAAiB0C,iBAAO6H,uBAAxBvK,EAAiD;YAC7CkH,WAAWzG,IADkC;YAE7C+J,YAAY9I,oBAAoB2E,OAFa;YAG7CoE,YAAYR,KAAK5D;UAH4B,CAAjDrG;QAMJ0B;;QAAAA,sBAAsB;UAClBmG,WAAWoC,KAAKpC,SADE;UAElBxB,SAAS4D,KAAK5D,OAFI;UAGlBiE,iBAAiBL,KAAKK;QAHJ,CAAtB5I;MAMP;IACJ;EAED;;EAAA,SAASsB,iBAAT,GAA6B;IACzBkC;IACAqC,wBAAwB,KAAxBA;IACAvG,OAAOuE,IAAPvE,aAAsBD,WAAWwD,EAAjC;EAGJ;;EAAA,SAASzB,0BAAT,CAAoC4H,CAApC,EAAuC;IACnC,IAAIA,EAAE3C,OAAF2C,CAAU7C,SAAV6C,CAAoB3J,UAApB2J,CAA+BnG,EAA/BmG,KAAsC3J,WAAWwD,EAAjDmG,IAAuDA,EAAE3C,OAAF2C,CAAUxD,SAAVwD,KAAwBjK,IAAnF,EAAyF;IAEzFO,OAAOuE,IAAPvE,CAAY,mCAAZA,EAAiD0J,EAAE3C,OAAF2C,GAAYA,EAAE3C,OAAF2C,CAAUf,GAAtBe,GAA4B,WAA7E1J,EAA0F0J,EAAE3C,OAAF2C,CAAUC,KAAVD,GAAkB,aAAaA,EAAE3C,OAAF2C,CAAUC,KAAzCD,GAAiD,EAA3I1J;;IAEA,IAAId,QAAQoI,cAARpI,CAAuBQ,QAAvBR,CAAJ,EAAsC;MAClCqH,wBAAwB,KAAxBA;IAGJ;;IAAA,IAAImD,EAAEE,KAAFF,IAAWA,EAAE3C,OAAF2C,CAAUG,eAArBH,IAAwC,CAACvJ,SAA7C,EAAwD;MACpDgI,eAAeuB,EAAE3C,OAAjBoB;MACA5B,wBAAwB,KAAxBA;MACAtC,mBAAmB,CAAnBA;IAGJ;;IAAA,IAAIlD,eAAJ,EAAqB;MACjBC,eAAe0I,EAAE3C,OAAjB/F;IAEP;EAED;;EAAA,SAAS8B,qBAAT,GAAiC;IAC7BkG,sBAAsB,IAAtBA;EAGJ;;EAAA,SAAS5G,eAAT,CAAyBsH,CAAzB,EAA4B;IACxB,IAAI3I,mBAAmB,CAACwE,MAAMmE,EAAER,SAAR3D,CAAxB,EAA4C;MACxCxE,kBAAkB,KAAlBA;MACA1B,cAAcyK,kBAAdzK,CAAiC2B,YAAjC3B;IAGJkH;;IAAAA,wBAAwB,KAAxBA;;IACA,IAAIhB,MAAMmE,EAAEtB,KAAR7C,CAAJ,EAAoB;MAChB3E,oCAAoChB,iBAAiBmK,qBAAjBnK,CAAuC8J,EAAErE,OAAzCzF,CAApCgB;MACAZ,OAAOuE,IAAPvE,CAAY,MAAMP,IAAN,GAAa,IAAb,GAAoB,+CAApB,GAAsEiK,EAAErE,OAApFrF;IAEJ;;IAAA,IAAIkB,wBAAwB,CAACqE,MAAMmE,EAAER,SAAR3D,CAA7B,EAAiD;MAC7C;MACA;MACA;MACA,IAAMyE,cAAczK,mBAAmBwE,OAAnBxE,EAApB;MACA,IAAM0K,cAAcP,EAAER,SAAFQ,GAAczJ,0BAA0ByG,gBAA5D;MACA,IAAMD,kBAAkBxG,0BAA0ByG,gBAA1BzG,GAA6C,GAArE;;MACA,IAAK+J,cAAcvD,eAAduD,IAAkCC,WAAvC,EAAoD;QAChDhG,mBAAmB,CAAnBA;MADJ,OAEO;QACHA,mBAAmB,CAACgG,eAAeD,cAAcvD,eAA7BwD,CAAD,IAAkD,IAArEhG;MAEJ/C;;MAAAA,uBAAuB,KAAvBA;IAZJ,OAaO;MACH+C,mBAAmB,CAAnBA;IAEP;EAED;;EAAA,SAASf,0BAAT,CAAoCwG,CAApC,EAAuC;IACnC1J,OAAOuE,IAAPvE,CAAY,yCAAyC0J,EAAE3C,OAAF2C,CAAUf,GAAnD,GAAyD,mBAArE3I;;IACA,IAAI,CAACT,mBAAmB2K,SAAnB3K,EAAD,IAAmC,CAACuB,WAAxC,EAAqD;MACjDd,OAAOuE,IAAPvE,CAAY,yCAAyC0J,EAAE3C,OAAF2C,CAAUf,GAAnD,GAAyD,iFAArE3I;MACAmI,eAAeuB,EAAE3C,OAAjBoB;IAEJ5B;;IAAAA,wBAAwB,KAAxBA;IACAtC,mBAAmB,CAAnBA;EAGJ;;EAAA,SAASrC,mBAAT;EAA6B;EAAO,CAChC;EAGJ;;EAAA,SAASwB,oBAAT;EAA8B;EAAO;IACjCc;EAGJ;;EAAA,SAAShC,eAAT,CAAyBwH,CAAzB,EAA4B;IACxB,IAAI3I,mBAAmBlB,SAAS6E,GAAT7E,GAAe8E,SAAf9E,CAAyBsK,wBAAhD,EAA0E;MACtE;MACA;MACA5K,mBAAmB6K,IAAnB7K,CAAwBA,mBAAmBwE,OAAnBxE,KAA+B,KAAvDA,EAA8D,KAA9DA,EAAqE,IAArEA;IAGJ,CAPwB,CAOxB;;;IACA,IAAImK,EAAEW,sBAAFX,IAA4BA,EAAEY,aAAlC,EAAiD;MAC7C3G;IAEP;EAED;;EAAA,SAASrB,eAAT;EAAyB;EAAO;IAC5B;IACA4B;IACAqC,wBAAwB,KAAxBA;EAGJ;;EAAA,SAASvD,qBAAT,GAAiC;IAC7B3D,cAAckL,aAAdlL;IACA6E;EAGJ;;EAAA,SAASxB,iBAAT,GAA6B;IACzB,IAAIvC,aAAa,CAACN,SAAS6E,GAAT7E,GAAe8E,SAAf9E,CAAyB+E,mBAA3C,EAAgE;MAC5DjB;IAEP;EAED;;EAAA,SAASnB,iBAAT,CAA2BkH,CAA3B,EAA8B;IAC1B,IAAI,CAAC3J,UAAL,EAAiB;IACjBsI,cAAcqB,EAAEc,QAAhBnC;IACAoC,mBAAmB,CAAnBA;;IAEA,IAAItK,SAAJ,EAAe;MACXwD;IAGJ;;IAAA,IAAM+G,UAAUzK,6BAA6BA,0BAA0B0K,SAAvD1K,IAAoEV,kBAApEU,GAAyFA,0BAA0B0K,SAA1B1K,CAAoC2K,GAApC3K,GAA0CV,mBAAmBwE,OAAnBxE,EAAnIU,GAAkKqF,GAAlL;IACAnG,YAAY0L,wBAAZ1L,CAAqC;MACjCuL,SAASA;IADwB,CAArCvL;;IAIA,IAAI,CAACiB,8BAAL,EAAqC;MACjC;MACA6D,mBAAmB,CAAnBA;IAFJ,OAGO;MACH;MACA5E,cAAckL,aAAdlL;IAEP;EAED;;EAAA,SAASuD,qBAAT,CAA+B8G,CAA/B,EAAkC;IAC9BvK,YAAY2L,0BAAZ3L,CAAuC;MAAC4L,eAAerB,EAAEsB,YAAFtB,CAAeuB,QAAfvB;IAAhB,CAAvCvK;EAGJ;;EAAA,SAASkJ,aAAT,CAAuBC,KAAvB,EAA8B;IAC1B/H,aAAa+H,KAAb/H;EAGJ;;EAAA,SAASkK,kBAAT,CAA4BnC,KAA5B,EAAmC;IAC/BjI,kBAAkBiI,KAAlBjI;EAGJ;;EAAA,SAAS6K,kBAAT,GAA8B;IAC1B,OAAO7K,eAAP;EAGJ;;EAAA,SAAS8K,eAAT,GAA2B;IACvB,OAAO1K,gBAAgB0K,eAAhB1K,CAAgChB,IAAhCgB,EAAsCR,yBAAtCQ,EAAiED,aAAjEC,CAAP;EAGJ;;EAAA,SAASY,oBAAT,GAAgC;IAC5BJ,uBAAuB,IAAvBA;IACAb,iCAAiC,KAAjCA;IACAC,kBAAkB,CAAlBA;IACAE,aAAa+E,GAAb/E;IACAL,iBAAiB,IAAjBA;IACAU,oCAAoCwK,SAApCxK;IACAF,sBAAsB;MAClBmG,WAAWuE,SADO;MAElB/F,SAASC,GAFS;MAGlBgE,iBAAiBhE;IAHC,CAAtB5E;IAKAC,kBAAkB,EAAlBA;IACAE,sBAAsB,EAAtBA;IACAV,YAAY,IAAZA;IACAW,cAAc,KAAdA;IACAC,kBAAkB,KAAlBA;IACAC,eAAe,IAAfA;IACAE,uBAAuB,KAAvBA;EAGJ;;EAAA,SAASmK,KAAT,GAAiB;IACb;IACArM,SAASsM,GAATtM,CAAa0C,iBAAOC,mBAApB3C,EAAyC4C,mBAAzC5C,EAA8D,IAA9DA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOG,0BAApB7C,EAAgD8C,0BAAhD9C,EAA4E,IAA5EA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOK,gBAApB/C,EAAsCgD,iBAAtChD,EAAyD,IAAzDA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOO,cAApBjD,EAAoCkD,eAApClD,EAAqD,IAArDA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOS,2BAApBnD,EAAiDoD,eAAjDpD,EAAkE,IAAlEA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOW,cAApBrD,EAAoCsD,eAApCtD,EAAqD,IAArDA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOa,gBAApBvD,EAAsCwD,iBAAtCxD,EAAyD,IAAzDA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOe,gBAApBzD,EAAsC0D,iBAAtC1D,EAAyD,IAAzDA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOiB,qBAApB3D,EAA2C4D,qBAA3C5D,EAAkE,IAAlEA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOmB,qBAApB7D,EAA2C8D,qBAA3C9D,EAAkE,IAAlEA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOqB,qBAApB/D,EAA2CgE,qBAA3ChE,EAAkE,IAAlEA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOuB,0BAApBjE,EAAgDkE,0BAAhDlE,EAA4E,IAA5EA;IACAA,SAASsM,GAATtM,CAAa0C,iBAAOyB,mBAApBnE,EAAyCoE,oBAAzCpE,EAA+D,IAA/DA;IAEAkF;IACA8E,sBAAsB,KAAtBA;IACA3H;IACAtB,aAAa,IAAbA;EAGJ;;EAAA,SAASwL,qBAAT,GAAiC;IAC7B,OAAOhM,kBAAP;EAGJO;;EAAAA,WAAW;IACPwB,YAAYA,UADL;IAEP+B,SAASA,OAFF;IAGPC,aAAaA,WAHN;IAIPE,0BAA0BA,wBAJnB;IAKP6E,eAAeA,aALR;IAMPoC,oBAAoBA,kBANb;IAOPS,oBAAoBA,kBAPb;IAQPpC,kBAAkBA,gBARX;IASPpF,WAAWA,SATJ;IAUPC,OAAOA,KAVA;IAWPO,MAAMA,IAXC;IAYPmH,OAAOA,KAZA;IAaPF,iBAAiBA,eAbV;IAcP3C,oBAAoBA,kBAdb;IAePE,qBAAqBA,mBAfd;IAgBP6C;EAhBO,CAAXzL;EAmBAqB;EAEA,OAAOrB,QAAP;AAGJjB;;AAAAA,mBAAmB2M,qBAAnB3M,GAA2C,oBAA3CA;kBACe4M,uBAAaC,eAAbD,CAA6B5M,kBAA7B4M,C","names":["ScheduleController","config","context","eventBus","getInstance","adapter","dashMetrics","mediaPlayerModel","fragmentModel","abrController","playbackController","textController","type","mimeType","mediaController","bufferController","settings","instance","streamInfo","logger","currentRepresentationInfo","initialRequest","isStopped","isFragmentProcessingInProgress","timeToLoadDelay","scheduleTimeout","seekTarget","hasVideoTrack","bufferLevelRule","lastFragmentRequest","topQualityIndex","lastInitializedRepresentationInfo","replaceRequestArray","switchTrack","replacingBuffer","mediaRequest","checkPlaybackQuality","isReplacementRequest","setup","getLogger","resetInitialSettings","initialize","_hasVideoTrack","create","on","Events","DATA_UPDATE_STARTED","onDataUpdateStarted","FRAGMENT_LOADING_COMPLETED","onFragmentLoadingCompleted","STREAM_COMPLETED","onStreamCompleted","BUFFER_CLEARED","onBufferCleared","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","QUOTA_EXCEEDED","onQuotaExceeded","PLAYBACK_SEEKING","onPlaybackSeeking","PLAYBACK_STARTED","onPlaybackStarted","PLAYBACK_RATE_CHANGED","onPlaybackRateChanged","PLAYBACK_TIME_UPDATED","onPlaybackTimeUpdated","URL_RESOLUTION_FAILED","onURLResolutionFailed","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","BUFFERING_COMPLETED","onBufferingCompleted","getType","getStreamId","id","setCurrentRepresentation","representationInfo","isStarted","start","getIsBufferingCompleted","debug","createPlaylistTraceMetrics","getTime","getPlaybackRate","startScheduleTimer","stop","clearTimeout","hasTopQualityChanged","newTopQualityIndex","getTopQualityIndexFor","info","schedule","isPaused","get","streaming","scheduleWhilePaused","Constants","FRAGMENTED_TEXT","TEXT","isTextEnabled","validateExecutedFragmentRequest","isReplacement","length","lastInitializedQuality","quality","NaN","isNaN","execute","getNextFragment","getSwitchMode","TRACK_SWITCH_MODE_ALWAYS_REPLACE","replaceBuffer","trigger","INIT_FRAGMENT_NEEDED","representationId","sender","streamId","mediaType","replacement","shift","isInitializationRequest","MEDIA_FRAGMENT_NEEDED","setFragmentProcessState","time","safeBufferLevel","fragmentDuration","schedulingInfo","getCurrentSchedulingInfo","mediaInfo","duration","request","getRequests","state","FragmentModel","FRAGMENT_MODEL_EXECUTED","threshold","indexOf","getIsTextTrack","fastSwitchModeEnabled","fastSwitchEnabled","bufferLevel","getBufferLevel","abandonmentState","getAbandonmentStateFor","trackChanged","isCurrentTrack","TRACK_SWITCH_MODE_NEVER_REPLACE","qualityChanged","MetricsConstants","ABANDON_LOAD","replaceRequest","index","setSeekTarget","value","setTimeout","processInitRequest","executeRequest","processMediaRequest","url","getIsDynamic","lowLatencyEnabled","switchTrackAsked","push","completeQualityChange","item","startTime","TRACK_CHANGE_RENDERED","oldMediaInfo","newMediaInfo","adaptationIndex","QUALITY_CHANGE_RENDERED","oldQuality","newQuality","e","range","error","serviceLocation","addExecutedRequest","getRepresentationInfo","currentTime","fragEndTime","isSeeking","flushBufferAtTrackSwitch","seek","hasEnoughSpaceToAppend","quotaExceeded","abortRequests","seekTime","setTimeToLoadDelay","latency","DVRWindow","end","updateManifestUpdateInfo","updatePlayListTraceMetrics","playbackspeed","playbackRate","toString","getTimeToLoadDelay","getBufferTarget","undefined","reset","off","getPlaybackController","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/controllers/ScheduleController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport BufferLevelRule from '../rules/scheduling/BufferLevelRule';\nimport FragmentModel from '../models/FragmentModel';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nfunction ScheduleController(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const adapter = config.adapter;\n    const dashMetrics = config.dashMetrics;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const fragmentModel = config.fragmentModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const textController = config.textController;\n    const type = config.type;\n    const mimeType = config.mimeType;\n    const mediaController = config.mediaController;\n    const bufferController = config.bufferController;\n    const settings = config.settings;\n\n    let instance,\n        streamInfo,\n        logger,\n        currentRepresentationInfo,\n        initialRequest,\n        isStopped,\n        isFragmentProcessingInProgress,\n        timeToLoadDelay,\n        scheduleTimeout,\n        seekTarget,\n        hasVideoTrack,\n        bufferLevelRule,\n        lastFragmentRequest,\n        topQualityIndex,\n        lastInitializedRepresentationInfo,\n        replaceRequestArray,\n        switchTrack,\n        replacingBuffer,\n        mediaRequest,\n        checkPlaybackQuality,\n        isReplacementRequest;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n        streamInfo = config.streamInfo;\n    }\n\n    function initialize(_hasVideoTrack) {\n        hasVideoTrack = _hasVideoTrack;\n\n        bufferLevelRule = BufferLevelRule(context).create({\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            textController: textController,\n            settings: settings\n        });\n\n        //eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.on(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.on(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.on(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.on(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.on(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, this);\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function setCurrentRepresentation(representationInfo) {\n        currentRepresentationInfo = representationInfo;\n    }\n\n    function isStarted() {\n        return (isStopped === false);\n    }\n\n    function start() {\n        if (!streamInfo) return;\n        if (isStarted()) return;\n        if (!currentRepresentationInfo || bufferController.getIsBufferingCompleted()) return;\n\n        logger.debug('Schedule Controller starts');\n        isStopped = false;\n        dashMetrics.createPlaylistTraceMetrics(currentRepresentationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\n\n        if (initialRequest) {\n            initialRequest = false;\n        }\n\n        startScheduleTimer(0);\n    }\n\n    function stop() {\n        if (isStopped) return;\n\n        logger.debug('Schedule Controller stops');\n        logger.debug(type + ' Schedule Controller stops');\n        isStopped = true;\n        clearTimeout(scheduleTimeout);\n    }\n\n    function hasTopQualityChanged(type, id) {\n        topQualityIndex[id] = topQualityIndex[id] || {};\n        const newTopQualityIndex = abrController.getTopQualityIndexFor(type, id);\n\n        if (topQualityIndex[id][type] != newTopQualityIndex) {\n            logger.info('Top quality ' + type + ' index has changed from ' + topQualityIndex[id][type] + ' to ' + newTopQualityIndex);\n            topQualityIndex[id][type] = newTopQualityIndex;\n            return true;\n        }\n        return false;\n\n    }\n\n    function schedule() {\n        if (!streamInfo) return;\n        if (isStopped || isFragmentProcessingInProgress ||\n            (playbackController.isPaused() && !settings.get().streaming.scheduleWhilePaused) ||\n            ((type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) && !textController.isTextEnabled()) ||\n            bufferController.getIsBufferingCompleted()) {\n            stop();\n            return;\n        }\n\n        validateExecutedFragmentRequest();\n\n        const isReplacement = replaceRequestArray.length > 0;\n        const lastInitializedQuality = lastInitializedRepresentationInfo ? lastInitializedRepresentationInfo.quality : NaN;\n        if (replacingBuffer || isNaN(lastInitializedQuality) || switchTrack || isReplacement ||\n            hasTopQualityChanged(type, streamInfo.id) ||\n            bufferLevelRule.execute(type, currentRepresentationInfo, hasVideoTrack)) {\n            const getNextFragment = function () {\n                if ((currentRepresentationInfo.quality !== lastInitializedQuality || switchTrack) && (!replacingBuffer)) {\n                    if (switchTrack) {\n                        logger.debug('Switch track for ' + type + ', representation id = ' + currentRepresentationInfo.id);\n                        replacingBuffer = mediaController.getSwitchMode(type) === Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE;\n                        if (replacingBuffer && bufferController.replaceBuffer) {\n                            bufferController.replaceBuffer();\n                        }\n                        switchTrack = false;\n                    } else {\n                        logger.debug('Quality has changed, get init request for representationid = ' + currentRepresentationInfo.id);\n                    }\n                    eventBus.trigger(Events.INIT_FRAGMENT_NEEDED,\n                        { representationId: currentRepresentationInfo.id, sender: instance },\n                        { streamId: streamInfo.id, mediaType: type }\n                    );\n                    checkPlaybackQuality = false;\n                } else {\n                    const replacement = replaceRequestArray.shift();\n\n                    if (replacement && replacement.isInitializationRequest()) {\n                        // To be sure the specific init segment had not already been loaded\n                        eventBus.trigger(Events.INIT_FRAGMENT_NEEDED,\n                            { representationId: replacement.representationId, sender: instance },\n                            { streamId: streamInfo.id, mediaType: type }\n                        );\n                        checkPlaybackQuality = false;\n                    } else {\n                        eventBus.trigger(Events.MEDIA_FRAGMENT_NEEDED,\n                            { seekTarget: seekTarget, replacement: replacement },\n                            { streamId: streamInfo.id, mediaType: type }\n                        );\n                        checkPlaybackQuality = true;\n                    }\n                }\n            };\n\n            setFragmentProcessState(true);\n            if (!isReplacement && checkPlaybackQuality) {\n                abrController.checkPlaybackQuality(type);\n            }\n\n            getNextFragment();\n\n        } else {\n            startScheduleTimer(500);\n        }\n    }\n\n    function validateExecutedFragmentRequest() {\n        if (!isNaN(seekTarget)) return;\n        if (!lastInitializedRepresentationInfo) return;\n        // Validate that the fragment request executed and appended into the source buffer is as\n        // good of quality as the current quality and is the correct media track.\n        const time = playbackController.getTime();\n        let safeBufferLevel = 1.5;\n\n        if (isNaN(lastInitializedRepresentationInfo.fragmentDuration)) { //fragmentDuration of representationInfo is not defined,\n            // call metrics function to have data in the latest scheduling info...\n            // if no metric, returns 0. In this case, rule will return false.\n            const schedulingInfo = dashMetrics.getCurrentSchedulingInfo(currentRepresentationInfo.mediaInfo.type);\n            safeBufferLevel = schedulingInfo ? schedulingInfo.duration * 1.5 : 1.5;\n        }\n        const request = fragmentModel.getRequests({\n            state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n            time: time + safeBufferLevel,\n            threshold: 0\n        })[0];\n\n        if (request && replaceRequestArray.indexOf(request) === -1 && !adapter.getIsTextTrack(mimeType)) {\n            const fastSwitchModeEnabled = settings.get().streaming.fastSwitchEnabled;\n            const bufferLevel = bufferController.getBufferLevel();\n            const abandonmentState = abrController.getAbandonmentStateFor(type);\n\n            // Only replace on track switch when NEVER_REPLACE\n            const trackChanged = !mediaController.isCurrentTrack(request.mediaInfo) && mediaController.getSwitchMode(request.mediaInfo.type) === Constants.TRACK_SWITCH_MODE_NEVER_REPLACE;\n            const qualityChanged = request.quality < lastInitializedRepresentationInfo.quality;\n\n            if (fastSwitchModeEnabled && (trackChanged || qualityChanged) && bufferLevel >= safeBufferLevel && abandonmentState !== MetricsConstants.ABANDON_LOAD) {\n                replaceRequest(request);\n                isReplacementRequest = true;\n                logger.debug('Reloading outdated fragment at index: ', request.index);\n            } else if (request.quality > lastInitializedRepresentationInfo.quality && !replacingBuffer) {\n                // The buffer has better quality it in then what we would request so set append point to end of buffer!!\n                setSeekTarget(playbackController.getTime() + bufferLevel);\n            }\n        }\n    }\n\n    function startScheduleTimer(value) {\n        clearTimeout(scheduleTimeout);\n\n        scheduleTimeout = setTimeout(schedule, value);\n    }\n\n    function setFragmentProcessState (state) {\n        if (isFragmentProcessingInProgress !== state ) {\n            isFragmentProcessingInProgress = state;\n        } else {\n            logger.debug('isFragmentProcessingInProgress is already equal to', state);\n        }\n    }\n\n    function processInitRequest(request) {\n        if (request) {\n            setFragmentProcessState(true);\n            fragmentModel.executeRequest(request);\n        }\n    }\n\n    function processMediaRequest(request) {\n        if (request) {\n            logger.debug('Next fragment request url is ' + request.url);\n            fragmentModel.executeRequest(request);\n        } else { // Use case - Playing at the bleeding live edge and frag is not available yet. Cycle back around.\n            if (playbackController.getIsDynamic()) {\n                logger.debug('Next fragment seems to be at the bleeding live edge and is not available yet. Rescheduling.');\n            }\n            setFragmentProcessState(false);\n            startScheduleTimer(settings.get().streaming.lowLatencyEnabled ? 100 : 500);\n        }\n    }\n\n    function switchTrackAsked() {\n        switchTrack = true;\n    }\n\n    function replaceRequest(request) {\n        replaceRequestArray.push(request);\n    }\n\n    function completeQualityChange(trigger) {\n        if (playbackController && fragmentModel) {\n            const item = fragmentModel.getRequests({\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n                time: playbackController.getTime(),\n                threshold: 0\n            })[0];\n            if (item && playbackController.getTime() >= item.startTime) {\n                if ((!lastFragmentRequest.mediaInfo || (item.mediaInfo.type === lastFragmentRequest.mediaInfo.type && item.mediaInfo.id !== lastFragmentRequest.mediaInfo.id)) && trigger) {\n                    eventBus.trigger(Events.TRACK_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldMediaInfo: lastFragmentRequest.mediaInfo,\n                        newMediaInfo: item.mediaInfo\n                    });\n                }\n                if ((item.quality !== lastFragmentRequest.quality || item.adaptationIndex !== lastFragmentRequest.adaptationIndex) && trigger) {\n                    eventBus.trigger(Events.QUALITY_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldQuality: lastFragmentRequest.quality,\n                        newQuality: item.quality\n                    });\n                }\n                lastFragmentRequest = {\n                    mediaInfo: item.mediaInfo,\n                    quality: item.quality,\n                    adaptationIndex: item.adaptationIndex\n                };\n            }\n        }\n    }\n\n    function onStreamCompleted() {\n        stop();\n        setFragmentProcessState(false);\n        logger.info(`Stream ${streamInfo.id} is complete`);\n    }\n\n    function onFragmentLoadingCompleted(e) {\n        if (e.request.mediaInfo.streamInfo.id !== streamInfo.id || e.request.mediaType !== type) return;\n\n        logger.info('OnFragmentLoadingCompleted - Url:', e.request ? e.request.url : 'undefined', e.request.range ? ', Range:' + e.request.range : '');\n\n        if (adapter.getIsTextTrack(mimeType)) {\n            setFragmentProcessState(false);\n        }\n\n        if (e.error && e.request.serviceLocation && !isStopped) {\n            replaceRequest(e.request);\n            setFragmentProcessState(false);\n            startScheduleTimer(0);\n        }\n\n        if (replacingBuffer) {\n            mediaRequest = e.request;\n        }\n    }\n\n    function onPlaybackTimeUpdated() {\n        completeQualityChange(true);\n    }\n\n    function onBytesAppended(e) {\n        if (replacingBuffer && !isNaN(e.startTime)) {\n            replacingBuffer = false;\n            fragmentModel.addExecutedRequest(mediaRequest);\n        }\n\n        setFragmentProcessState(false);\n        if (isNaN(e.index)) {\n            lastInitializedRepresentationInfo = bufferController.getRepresentationInfo(e.quality);\n            logger.info('[' + type + '] ' + 'lastInitializedRepresentationInfo changed to ' + e.quality);\n        }\n        if (isReplacementRequest && !isNaN(e.startTime)) {\n            //replace requests process is in progress, call schedule in n seconds.\n            //it is done in order to not add a fragment at the new quality at the end of the buffer before replace process is over.\n            //Indeed, if schedule is called too early, the executed request tested is the same that the one tested during previous schedule (at the new quality).\n            const currentTime = playbackController.getTime();\n            const fragEndTime = e.startTime + currentRepresentationInfo.fragmentDuration;\n            const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\n            if ((currentTime + safeBufferLevel) >= fragEndTime) {\n                startScheduleTimer(0);\n            } else {\n                startScheduleTimer((fragEndTime - (currentTime + safeBufferLevel)) * 1000);\n            }\n            isReplacementRequest = false;\n        } else {\n            startScheduleTimer(0);\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has been aborted');\n        if (!playbackController.isSeeking() && !switchTrack) {\n            logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has to be downloaded again, origin is not seeking process or switch track call');\n            replaceRequest(e.request);\n        }\n        setFragmentProcessState(false);\n        startScheduleTimer(0);\n    }\n\n    function onDataUpdateStarted(/*e*/) {\n        // stop();\n    }\n\n    function onBufferingCompleted(/*e*/) {\n        stop();\n    }\n\n    function onBufferCleared(e) {\n        if (replacingBuffer && settings.get().streaming.flushBufferAtTrackSwitch) {\n            // For some devices (like chromecast) it is necessary to seek the video element to reset the internal decoding buffer,\n            // otherwise audio track switch will be effective only once after previous buffered track is consumed\n            playbackController.seek(playbackController.getTime() + 0.001, false, true);\n        }\n\n        // (Re)start schedule once buffer has been pruned after a QuotaExceededError\n        if (e.hasEnoughSpaceToAppend && e.quotaExceeded) {\n            start();\n        }\n    }\n\n    function onQuotaExceeded(/*e*/) {\n        // Stop scheduler (will be restarted once buffer is pruned)\n        stop();\n        setFragmentProcessState(false);\n    }\n\n    function onURLResolutionFailed() {\n        fragmentModel.abortRequests();\n        stop();\n    }\n\n    function onPlaybackStarted() {\n        if (isStopped || !settings.get().streaming.scheduleWhilePaused) {\n            start();\n        }\n    }\n\n    function onPlaybackSeeking(e) {\n        if (!streamInfo) return;\n        setSeekTarget(e.seekTime);\n        setTimeToLoadDelay(0);\n\n        if (isStopped) {\n            start();\n        }\n\n        const latency = currentRepresentationInfo && currentRepresentationInfo.DVRWindow && playbackController ? currentRepresentationInfo.DVRWindow.end - playbackController.getTime() : NaN;\n        dashMetrics.updateManifestUpdateInfo({\n            latency: latency\n        });\n\n        if (!isFragmentProcessingInProgress) {\n            // No pending request, request next segment at seek target\n            startScheduleTimer(0);\n        } else {\n            // Abort current request\n            fragmentModel.abortRequests();\n        }\n    }\n\n    function onPlaybackRateChanged(e) {\n        dashMetrics.updatePlayListTraceMetrics({playbackspeed: e.playbackRate.toString()});\n    }\n\n    function setSeekTarget(value) {\n        seekTarget = value;\n    }\n\n    function setTimeToLoadDelay(value) {\n        timeToLoadDelay = value;\n    }\n\n    function getTimeToLoadDelay() {\n        return timeToLoadDelay;\n    }\n\n    function getBufferTarget() {\n        return bufferLevelRule.getBufferTarget(type, currentRepresentationInfo, hasVideoTrack);\n    }\n\n    function resetInitialSettings() {\n        checkPlaybackQuality = true;\n        isFragmentProcessingInProgress = false;\n        timeToLoadDelay = 0;\n        seekTarget = NaN;\n        initialRequest = true;\n        lastInitializedRepresentationInfo = undefined;\n        lastFragmentRequest = {\n            mediaInfo: undefined,\n            quality: NaN,\n            adaptationIndex: NaN\n        };\n        topQualityIndex = {};\n        replaceRequestArray = [];\n        isStopped = true;\n        switchTrack = false;\n        replacingBuffer = false;\n        mediaRequest = null;\n        isReplacementRequest = false;\n    }\n\n    function reset() {\n        //eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.off(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.off(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.off(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.off(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.off(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.off(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, this);\n\n        stop();\n        completeQualityChange(false);\n        resetInitialSettings();\n        streamInfo = null;\n    }\n\n    function getPlaybackController() {\n        return playbackController;\n    }\n\n    instance = {\n        initialize: initialize,\n        getType: getType,\n        getStreamId: getStreamId,\n        setCurrentRepresentation: setCurrentRepresentation,\n        setSeekTarget: setSeekTarget,\n        setTimeToLoadDelay: setTimeToLoadDelay,\n        getTimeToLoadDelay: getTimeToLoadDelay,\n        switchTrackAsked: switchTrackAsked,\n        isStarted: isStarted,\n        start: start,\n        stop: stop,\n        reset: reset,\n        getBufferTarget: getBufferTarget,\n        processInitRequest: processInitRequest,\n        processMediaRequest: processMediaRequest,\n        getPlaybackController\n    };\n\n    setup();\n\n    return instance;\n}\n\nScheduleController.__dashjs_factory_name = 'ScheduleController';\nexport default FactoryMaker.getClassFactory(ScheduleController);\n"]},"metadata":{},"sourceType":"script"}