{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('./constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _DashConstants = require('../dash/constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _StreamProcessor = require('./StreamProcessor');\n\nvar _StreamProcessor2 = _interopRequireDefault(_StreamProcessor);\n\nvar _FragmentController = require('./controllers/FragmentController');\n\nvar _FragmentController2 = _interopRequireDefault(_FragmentController);\n\nvar _ThumbnailController = require('./thumbnail/ThumbnailController');\n\nvar _ThumbnailController2 = _interopRequireDefault(_ThumbnailController);\n\nvar _EventBus = require('../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Debug = require('../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _Errors = require('../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _DashJSError = require('./vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _BoxParser = require('./utils/BoxParser');\n\nvar _BoxParser2 = _interopRequireDefault(_BoxParser);\n\nvar _URLUtils = require('./utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction Stream(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n  var manifestModel = config.manifestModel;\n  var mediaPlayerModel = config.mediaPlayerModel;\n  var manifestUpdater = config.manifestUpdater;\n  var adapter = config.adapter;\n  var capabilities = config.capabilities;\n  var capabilitiesFilter = config.capabilitiesFilter;\n  var errHandler = config.errHandler;\n  var timelineConverter = config.timelineConverter;\n  var dashMetrics = config.dashMetrics;\n  var abrController = config.abrController;\n  var playbackController = config.playbackController;\n  var eventController = config.eventController;\n  var mediaController = config.mediaController;\n  var textController = config.textController;\n  var protectionController = config.protectionController;\n  var videoModel = config.videoModel;\n  var settings = config.settings;\n  var streamInfo = config.streamInfo;\n  var instance = void 0,\n      logger = void 0,\n      streamProcessors = void 0,\n      isStreamInitialized = void 0,\n      isStreamActivated = void 0,\n      isMediaInitialized = void 0,\n      hasVideoTrack = void 0,\n      hasAudioTrack = void 0,\n      updateError = void 0,\n      isUpdating = void 0,\n      fragmentController = void 0,\n      thumbnailController = void 0,\n      preloaded = void 0,\n      boxParser = void 0,\n      preloadingScheduled = void 0,\n      debug = void 0,\n      isEndedEventSignaled = void 0,\n      trackChangedEvent = void 0;\n\n  function setup() {\n    debug = (0, _Debug2.default)(context).getInstance();\n    logger = debug.getLogger(instance);\n    resetInitialSettings();\n    boxParser = (0, _BoxParser2.default)(context).getInstance();\n    fragmentController = (0, _FragmentController2.default)(context).create({\n      streamInfo: streamInfo,\n      mediaPlayerModel: mediaPlayerModel,\n      dashMetrics: dashMetrics,\n      errHandler: errHandler,\n      settings: settings,\n      boxParser: boxParser,\n      dashConstants: _DashConstants2.default,\n      urlUtils: urlUtils\n    });\n  }\n\n  function initialize() {\n    registerEvents();\n    registerProtectionEvents();\n    eventBus.trigger(_Events2.default.STREAM_UPDATED, {\n      streamInfo: streamInfo\n    });\n  }\n\n  function registerEvents() {\n    eventBus.on(_Events2.default.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n    eventBus.on(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    eventBus.on(_Events2.default.INBAND_EVENTS, onInbandEvents, instance);\n  }\n\n  function unRegisterEvents() {\n    eventBus.off(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    eventBus.off(_Events2.default.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n    eventBus.off(_Events2.default.INBAND_EVENTS, onInbandEvents, instance);\n  }\n\n  function registerProtectionEvents() {\n    if (protectionController) {\n      eventBus.on(_Events2.default.KEY_ERROR, onProtectionError, instance);\n      eventBus.on(_Events2.default.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n      eventBus.on(_Events2.default.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n      eventBus.on(_Events2.default.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n      eventBus.on(_Events2.default.KEY_SESSION_CREATED, onProtectionError, instance);\n      eventBus.on(_Events2.default.KEY_STATUSES_CHANGED, onProtectionError, instance);\n    }\n  }\n\n  function unRegisterProtectionEvents() {\n    if (protectionController) {\n      eventBus.off(_Events2.default.KEY_ERROR, onProtectionError, instance);\n      eventBus.off(_Events2.default.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n      eventBus.off(_Events2.default.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n      eventBus.off(_Events2.default.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n      eventBus.off(_Events2.default.KEY_SESSION_CREATED, onProtectionError, instance);\n      eventBus.off(_Events2.default.KEY_STATUSES_CHANGED, onProtectionError, instance);\n    }\n  }\n\n  function getStreamId() {\n    return streamInfo ? streamInfo.id : null;\n  }\n  /**\n  * Activates Stream by re-initializing some of its components\n  * @param {MediaSource} mediaSource\n  * @memberof Stream#\n  * @param {SourceBuffer} previousBuffers\n  */\n\n\n  function activate(mediaSource, previousBuffers) {\n    if (!isStreamActivated) {\n      var result = void 0;\n      eventBus.on(_Events2.default.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n\n      if (!getPreloaded()) {\n        result = initializeMedia(mediaSource, previousBuffers);\n      } else {\n        initializeAfterPreload();\n        result = previousBuffers;\n      }\n\n      isStreamActivated = true;\n      return result;\n    }\n\n    return previousBuffers;\n  }\n  /**\n  * Partially resets some of the Stream elements\n  * @memberof Stream#\n  * @param {boolean} keepBuffers\n  */\n\n\n  function deactivate(keepBuffers) {\n    var ln = streamProcessors ? streamProcessors.length : 0;\n    var errored = false;\n\n    for (var i = 0; i < ln; i++) {\n      var fragmentModel = streamProcessors[i].getFragmentModel();\n      fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\n      streamProcessors[i].reset(errored, keepBuffers);\n    }\n\n    streamProcessors = [];\n    isStreamActivated = false;\n    isMediaInitialized = false;\n    setPreloaded(false);\n    eventBus.off(_Events2.default.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n  }\n\n  function isActive() {\n    return isStreamActivated;\n  }\n\n  function setMediaSource(mediaSource) {\n    for (var i = 0; i < streamProcessors.length;) {\n      if (isMediaSupported(streamProcessors[i].getMediaInfo())) {\n        streamProcessors[i].setMediaSource(mediaSource);\n        i++;\n      } else {\n        streamProcessors[i].reset();\n        streamProcessors.splice(i, 1);\n      }\n    }\n\n    for (var _i = 0; _i < streamProcessors.length; _i++) {\n      //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state\n      //so do this after the buffers are created above.\n      streamProcessors[_i].dischargePreBuffer();\n    }\n\n    if (streamProcessors.length === 0) {\n      var msg = 'No streams to play.';\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg + 'nostreams', manifestModel.getValue()));\n      logger.fatal(msg);\n    }\n  }\n\n  function resetInitialSettings() {\n    deactivate();\n    isStreamInitialized = false;\n    hasVideoTrack = false;\n    hasAudioTrack = false;\n    updateError = {};\n    isUpdating = false;\n    preloadingScheduled = false;\n    isEndedEventSignaled = false;\n  }\n\n  function reset() {\n    if (playbackController) {\n      playbackController.pause();\n    }\n\n    if (fragmentController) {\n      fragmentController.reset();\n      fragmentController = null;\n    }\n\n    streamInfo = null;\n    resetInitialSettings();\n    unRegisterEvents();\n    unRegisterProtectionEvents();\n    setPreloaded(false);\n  }\n\n  function getDuration() {\n    return streamInfo ? streamInfo.duration : NaN;\n  }\n\n  function getIsEndedEventSignaled() {\n    return isEndedEventSignaled;\n  }\n\n  function setIsEndedEventSignaled(value) {\n    isEndedEventSignaled = value;\n  }\n\n  function getStartTime() {\n    return streamInfo ? streamInfo.start : NaN;\n  }\n\n  function getPreloadingScheduled() {\n    return preloadingScheduled;\n  }\n\n  function setPreloadingScheduled(value) {\n    preloadingScheduled = value;\n  }\n\n  function getLiveStartTime() {\n    if (!streamInfo.manifestInfo.isDynamic) return NaN; // Get live start time of the video stream (1st in array of streams)\n    // or audio if no video stream\n\n    for (var i = 0; i < streamProcessors.length; i++) {\n      if (streamProcessors[i].getType() === _Constants2.default.AUDIO || streamProcessors[i].getType() === _Constants2.default.VIDEO) {\n        return streamProcessors[i].getLiveStartTime();\n      }\n    }\n\n    return NaN;\n  }\n\n  function getId() {\n    return streamInfo ? streamInfo.id : null;\n  }\n\n  function getStreamInfo() {\n    return streamInfo;\n  }\n\n  function getHasAudioTrack() {\n    return hasAudioTrack;\n  }\n\n  function getHasVideoTrack() {\n    return hasVideoTrack;\n  }\n\n  function getThumbnailController() {\n    return thumbnailController;\n  }\n\n  function checkConfig() {\n    if (!videoModel || !abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n  /**\n  * @param {string} type\n  * @returns {Array}\n  * @memberof Stream#\n  */\n\n\n  function getBitrateListFor(type) {\n    checkConfig();\n\n    if (type === _Constants2.default.IMAGE) {\n      if (!thumbnailController) {\n        return [];\n      }\n\n      return thumbnailController.getBitrateList();\n    }\n\n    var mediaInfo = getMediaInfo(type);\n    return abrController.getBitrateList(mediaInfo);\n  }\n\n  function onProtectionError(event) {\n    if (event.error) {\n      errHandler.error(event.error);\n      logger.fatal(event.error.message);\n      reset();\n    }\n  }\n\n  function isMediaSupported(mediaInfo) {\n    var type = mediaInfo ? mediaInfo.type : null;\n    var codec = void 0,\n        msg = void 0;\n\n    if (type === _Constants2.default.MUXED) {\n      msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines';\n      logger.fatal(msg);\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, msg, manifestModel.getValue()));\n      return false;\n    }\n\n    if (type === _Constants2.default.TEXT || type === _Constants2.default.FRAGMENTED_TEXT || type === _Constants2.default.EMBEDDED_TEXT || type === _Constants2.default.IMAGE) {\n      return true;\n    }\n\n    codec = mediaInfo.codec;\n    logger.debug(type + ' codec: ' + codec);\n\n    if (!!mediaInfo.contentProtection && !capabilities.supportsEncryptedMedia()) {\n      errHandler.error(new _DashJSError2.default(_Errors2.default.CAPABILITY_MEDIAKEYS_ERROR_CODE, _Errors2.default.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE));\n    } else if (!capabilities.supportsCodec(codec)) {\n      msg = type + 'Codec (' + codec + ') is not supported.';\n      logger.error(msg);\n      return false;\n    }\n\n    return true;\n  }\n\n  function onCurrentTrackChanged(e) {\n    if (!streamInfo || e.newMediaInfo.streamInfo.id !== streamInfo.id) return;\n    var mediaInfo = e.newMediaInfo;\n    var manifest = manifestModel.getValue();\n    adapter.setCurrentMediaInfo(streamInfo.id, mediaInfo.type, mediaInfo);\n    var processor = getProcessorForMediaInfo(mediaInfo);\n    if (!processor) return;\n    var currentTime = playbackController.getTime();\n    logger.info('Stream -  Process track changed at current time ' + currentTime);\n    logger.debug('Stream -  Update stream controller');\n\n    if (manifest.refreshManifestOnSwitchTrack) {\n      // Applies only for MSS streams\n      logger.debug('Stream -  Refreshing manifest for switch track');\n      trackChangedEvent = e;\n      manifestUpdater.refreshManifest();\n    } else {\n      processor.selectMediaInfo(mediaInfo);\n\n      if (mediaInfo.type !== _Constants2.default.FRAGMENTED_TEXT) {\n        abrController.updateTopQualityIndex(mediaInfo);\n        processor.switchTrackAsked();\n        processor.getFragmentModel().abortRequests();\n      } else {\n        processor.getScheduleController().setSeekTarget(currentTime);\n        processor.setBufferingTime(currentTime);\n        processor.resetIndexHandler();\n      }\n    }\n  }\n\n  function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) {\n    var fragmentModel = fragmentController.getModel(mediaInfo ? mediaInfo.type : null);\n    var streamProcessor = (0, _StreamProcessor2.default)(context).create({\n      streamInfo: streamInfo,\n      type: mediaInfo ? mediaInfo.type : null,\n      mimeType: mediaInfo ? mediaInfo.mimeType : null,\n      timelineConverter: timelineConverter,\n      adapter: adapter,\n      manifestModel: manifestModel,\n      mediaPlayerModel: mediaPlayerModel,\n      fragmentModel: fragmentModel,\n      dashMetrics: config.dashMetrics,\n      baseURLController: config.baseURLController,\n      abrController: abrController,\n      playbackController: playbackController,\n      mediaController: mediaController,\n      textController: textController,\n      errHandler: errHandler,\n      settings: settings,\n      boxParser: boxParser\n    });\n    streamProcessor.initialize(mediaSource, hasVideoTrack);\n    abrController.updateTopQualityIndex(mediaInfo);\n\n    if (optionalSettings) {\n      streamProcessor.setBuffer(optionalSettings.buffer);\n      streamProcessor.setBufferingTime(optionalSettings.currentTime);\n      streamProcessors[optionalSettings.replaceIdx] = streamProcessor;\n    } else {\n      streamProcessors.push(streamProcessor);\n    }\n\n    if (optionalSettings && optionalSettings.ignoreMediaInfo) {\n      return;\n    }\n\n    if (mediaInfo && (mediaInfo.type === _Constants2.default.TEXT || mediaInfo.type === _Constants2.default.FRAGMENTED_TEXT)) {\n      var idx = void 0;\n\n      for (var i = 0; i < allMediaForType.length; i++) {\n        if (allMediaForType[i].index === mediaInfo.index) {\n          idx = i;\n        }\n\n        streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor\n      }\n\n      streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info\n    } else {\n      streamProcessor.addMediaInfo(mediaInfo, true);\n    }\n  }\n\n  function initializeMediaForType(type, mediaSource) {\n    var allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type);\n    var mediaInfo = null;\n    var initialMediaInfo = void 0;\n\n    if (!allMediaForType || allMediaForType.length === 0) {\n      logger.info('No ' + type + ' data.');\n      return;\n    }\n\n    if (type === _Constants2.default.VIDEO) {\n      hasVideoTrack = true;\n    }\n\n    if (type === _Constants2.default.AUDIO) {\n      hasAudioTrack = true;\n    }\n\n    for (var i = 0, ln = allMediaForType.length; i < ln; i++) {\n      mediaInfo = allMediaForType[i];\n\n      if (type === _Constants2.default.EMBEDDED_TEXT) {\n        textController.addEmbeddedTrack(mediaInfo);\n      } else {\n        if (!isMediaSupported(mediaInfo)) continue;\n        mediaController.addTrack(mediaInfo);\n      }\n    }\n\n    if (type === _Constants2.default.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) {\n      return;\n    }\n\n    if (type === _Constants2.default.IMAGE) {\n      thumbnailController = (0, _ThumbnailController2.default)(context).create({\n        streamInfo: streamInfo,\n        adapter: adapter,\n        baseURLController: config.baseURLController,\n        timelineConverter: config.timelineConverter,\n        debug: debug,\n        eventBus: eventBus,\n        events: _Events2.default,\n        dashConstants: _DashConstants2.default\n      });\n      return;\n    }\n\n    mediaController.checkInitialMediaSettingsForType(type, streamInfo);\n    initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo);\n    eventBus.trigger(_Events2.default.STREAM_INITIALIZING, {\n      streamInfo: streamInfo,\n      mediaInfo: mediaInfo\n    }); // TODO : How to tell index handler live/duration?\n    // TODO : Pass to controller and then pass to each method on handler?\n\n    createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource);\n  }\n\n  function addInlineEvents() {\n    if (eventController) {\n      var events = adapter.getEventsFor(streamInfo);\n      eventController.addInlineEvents(events);\n    }\n  }\n\n  function addInbandEvents(events) {\n    if (eventController) {\n      eventController.addInbandEvents(events);\n    }\n  }\n\n  function initializeMedia(mediaSource, previousBuffers) {\n    checkConfig();\n    var element = videoModel.getElement();\n    addInlineEvents();\n    isUpdating = true;\n    capabilitiesFilter.filterUnsupportedFeaturesOfPeriod(streamInfo);\n\n    if (!element || element && /^VIDEO$/i.test(element.nodeName)) {\n      initializeMediaForType(_Constants2.default.VIDEO, mediaSource);\n    }\n\n    initializeMediaForType(_Constants2.default.AUDIO, mediaSource);\n    initializeMediaForType(_Constants2.default.TEXT, mediaSource);\n    initializeMediaForType(_Constants2.default.FRAGMENTED_TEXT, mediaSource);\n    initializeMediaForType(_Constants2.default.EMBEDDED_TEXT, mediaSource);\n    initializeMediaForType(_Constants2.default.MUXED, mediaSource);\n    initializeMediaForType(_Constants2.default.IMAGE, mediaSource); //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText.\n\n    var buffers = createBuffers(previousBuffers);\n    isMediaInitialized = true;\n    isUpdating = false;\n\n    if (streamProcessors.length === 0) {\n      var msg = 'No streams to play.';\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n      logger.fatal(msg);\n    } else {\n      checkIfInitializationCompleted();\n    }\n\n    return buffers;\n  }\n\n  function initializeAfterPreload() {\n    isUpdating = true;\n    checkConfig();\n    capabilitiesFilter.filterUnsupportedFeaturesOfPeriod(streamInfo);\n    isMediaInitialized = true;\n    isUpdating = false;\n\n    if (streamProcessors.length === 0) {\n      var msg = 'No streams to play.';\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n      logger.debug(msg);\n    } else {\n      checkIfInitializationCompleted();\n    }\n  }\n\n  function checkIfInitializationCompleted() {\n    var ln = streamProcessors.length;\n    var hasError = !!updateError.audio || !!updateError.video;\n    var error = hasError ? new _DashJSError2.default(_Errors2.default.DATA_UPDATE_FAILED_ERROR_CODE, _Errors2.default.DATA_UPDATE_FAILED_ERROR_MESSAGE) : null;\n\n    for (var i = 0; i < ln; i++) {\n      if (streamProcessors[i].isUpdating() || isUpdating) {\n        return;\n      }\n    }\n\n    if (!isMediaInitialized) {\n      return;\n    }\n\n    if (protectionController) {\n      // Need to check if streamProcessors exists because streamProcessors\n      // could be cleared in case an error is detected while initializing DRM keysystem\n      protectionController.clearMediaInfoArrayByStreamId(getId());\n\n      for (var _i2 = 0; _i2 < ln && streamProcessors[_i2]; _i2++) {\n        var type = streamProcessors[_i2].getType();\n\n        if (type === _Constants2.default.AUDIO || type === _Constants2.default.VIDEO || type === _Constants2.default.FRAGMENTED_TEXT) {\n          var mediaInfo = streamProcessors[_i2].getMediaInfo();\n\n          if (mediaInfo) {\n            protectionController.initializeForMedia(mediaInfo);\n          }\n        }\n      }\n    }\n\n    if (error) {\n      errHandler.error(error);\n    } else if (!isStreamInitialized) {\n      isStreamInitialized = true;\n      eventBus.trigger(_Events2.default.STREAM_INITIALIZED, {\n        streamInfo: streamInfo,\n        liveStartTime: !preloaded ? getLiveStartTime() : NaN\n      });\n    } // (Re)start ScheduleController:\n    // - in case stream initialization has been completed after 'play' event (case for SegmentBase streams)\n    // - in case stream is complete but a track switch has been requested\n\n\n    for (var _i3 = 0; _i3 < ln && streamProcessors[_i3]; _i3++) {\n      streamProcessors[_i3].getScheduleController().start();\n    }\n  }\n\n  function getMediaInfo(type) {\n    var streamProcessor = null;\n\n    for (var i = 0; i < streamProcessors.length; i++) {\n      streamProcessor = streamProcessors[i];\n\n      if (streamProcessor.getType() === type) {\n        return streamProcessor.getMediaInfo();\n      }\n    }\n\n    return null;\n  }\n\n  function createBuffers(previousBuffers) {\n    var buffers = {};\n\n    for (var i = 0, ln = streamProcessors.length; i < ln; i++) {\n      var buffer = streamProcessors[i].createBuffer(previousBuffers);\n\n      if (buffer) {\n        buffers[streamProcessors[i].getType()] = buffer.getBuffer();\n      }\n    }\n\n    return buffers;\n  }\n\n  function onBufferingCompleted() {\n    var processors = getProcessors();\n    var ln = processors.length;\n\n    if (ln === 0) {\n      logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined');\n      return;\n    } // if there is at least one buffer controller that has not completed buffering yet do nothing\n\n\n    for (var i = 0; i < ln; i++) {\n      //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED\n      if (!processors[i].isBufferingCompleted() && (processors[i].getType() === _Constants2.default.AUDIO || processors[i].getType() === _Constants2.default.VIDEO)) {\n        logger.warn('onBufferingCompleted - One streamProcessor has finished but', processors[i].getType(), 'one is not buffering completed');\n        return;\n      }\n    }\n\n    logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED');\n    eventBus.trigger(_Events2.default.STREAM_BUFFERING_COMPLETED, {\n      streamInfo: streamInfo\n    });\n  }\n\n  function onDataUpdateCompleted(e) {\n    updateError[e.mediaType] = e.error;\n    checkIfInitializationCompleted();\n  }\n\n  function onInbandEvents(e) {\n    addInbandEvents(e.events);\n  }\n\n  function getProcessorForMediaInfo(mediaInfo) {\n    if (!mediaInfo) {\n      return null;\n    }\n\n    var processors = getProcessors();\n    return processors.filter(function (processor) {\n      return processor.getType() === mediaInfo.type;\n    })[0];\n  }\n\n  function getProcessors() {\n    var arr = [];\n    var type = void 0,\n        streamProcessor = void 0;\n\n    for (var i = 0; i < streamProcessors.length; i++) {\n      streamProcessor = streamProcessors[i];\n      type = streamProcessor.getType();\n\n      if (type === _Constants2.default.AUDIO || type === _Constants2.default.VIDEO || type === _Constants2.default.FRAGMENTED_TEXT || type === _Constants2.default.TEXT) {\n        arr.push(streamProcessor);\n      }\n    }\n\n    return arr;\n  }\n\n  function updateData(updatedStreamInfo) {\n    logger.info('Manifest updated... updating data system wide.');\n    isStreamActivated = false;\n    isUpdating = true;\n    streamInfo = updatedStreamInfo;\n    eventBus.trigger(_Events2.default.STREAM_UPDATED, {\n      streamInfo: streamInfo\n    });\n\n    if (eventController) {\n      addInlineEvents();\n    }\n\n    capabilitiesFilter.filterUnsupportedFeaturesOfPeriod(streamInfo);\n\n    for (var i = 0, ln = streamProcessors.length; i < ln; i++) {\n      var streamProcessor = streamProcessors[i];\n      streamProcessor.updateStreamInfo(streamInfo);\n      var mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType()); // Check if AdaptationSet has not been removed in MPD update\n\n      if (mediaInfo) {\n        abrController.updateTopQualityIndex(mediaInfo);\n        streamProcessor.addMediaInfo(mediaInfo, true);\n      }\n    }\n\n    if (trackChangedEvent) {\n      var _mediaInfo = trackChangedEvent.newMediaInfo;\n\n      if (_mediaInfo.type !== _Constants2.default.FRAGMENTED_TEXT) {\n        var processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo);\n        if (!processor) return;\n        processor.switchTrackAsked();\n        trackChangedEvent = undefined;\n      }\n    }\n\n    isUpdating = false;\n    checkIfInitializationCompleted();\n  }\n\n  function isMediaCodecCompatible(newStream) {\n    var previousStream = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return compareCodecs(newStream, _Constants2.default.VIDEO, previousStream) && compareCodecs(newStream, _Constants2.default.AUDIO, previousStream);\n  }\n\n  function isProtectionCompatible(stream) {\n    var previousStream = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return compareProtectionConfig(stream, _Constants2.default.VIDEO, previousStream) && compareProtectionConfig(stream, _Constants2.default.AUDIO, previousStream);\n  }\n\n  function compareProtectionConfig(stream, type) {\n    var previousStream = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (!stream) {\n      return false;\n    }\n\n    var newStreamInfo = stream.getStreamInfo();\n    var currentStreamInfo = previousStream ? previousStream.getStreamInfo() : getStreamInfo();\n\n    if (!newStreamInfo || !currentStreamInfo) {\n      return false;\n    }\n\n    var newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\n    var currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\n\n    if (!newAdaptation || !currentAdaptation) {\n      // If there is no adaptation for neither the old or the new stream they're compatible\n      return !newAdaptation && !currentAdaptation;\n    } // If the current period is unencrypted and the upcoming one is encrypted we need to reset sourcebuffers.\n\n\n    return !(!isAdaptationDrmProtected(currentAdaptation) && isAdaptationDrmProtected(newAdaptation));\n  }\n\n  function isAdaptationDrmProtected(adaptation) {\n    if (!adaptation) {\n      // If there is no adaptation for neither the old or the new stream they're compatible\n      return false;\n    } // If the current period is unencrypted and the upcoming one is encrypted we need to reset sourcebuffers.\n\n\n    return !!(adaptation.ContentProtection || adaptation.Representation && adaptation.Representation.length > 0 && adaptation.Representation[0].ContentProtection);\n  }\n\n  function compareCodecs(newStream, type) {\n    var previousStream = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (!newStream || !newStream.hasOwnProperty('getStreamInfo')) {\n      return false;\n    }\n\n    var newStreamInfo = newStream.getStreamInfo();\n    var currentStreamInfo = previousStream ? previousStream.getStreamInfo() : getStreamInfo();\n\n    if (!newStreamInfo || !currentStreamInfo) {\n      return false;\n    }\n\n    var newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\n    var currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\n\n    if (!newAdaptation || !currentAdaptation) {\n      // If there is no adaptation for neither the old or the new stream they're compatible\n      return !newAdaptation && !currentAdaptation;\n    }\n\n    var sameMimeType = newAdaptation && currentAdaptation && newAdaptation.mimeType === currentAdaptation.mimeType;\n    var oldCodecs = currentAdaptation.Representation_asArray.map(function (representation) {\n      return representation.codecs;\n    });\n    var newCodecs = newAdaptation.Representation_asArray.map(function (representation) {\n      return representation.codecs;\n    });\n    var codecMatch = newCodecs.some(function (newCodec) {\n      return oldCodecs.indexOf(newCodec) > -1;\n    });\n    var partialCodecMatch = newCodecs.some(function (newCodec) {\n      return oldCodecs.some(function (oldCodec) {\n        return capabilities.codecRootCompatibleWithCodec(oldCodec, newCodec);\n      });\n    });\n    return codecMatch || partialCodecMatch && sameMimeType;\n  }\n\n  function setPreloaded(value) {\n    preloaded = value;\n  }\n\n  function getPreloaded() {\n    return preloaded;\n  }\n\n  function preload(mediaSource, previousBuffers) {\n    if (!getPreloaded()) {\n      addInlineEvents();\n      initializeMediaForType(_Constants2.default.VIDEO, mediaSource);\n      initializeMediaForType(_Constants2.default.AUDIO, mediaSource);\n      initializeMediaForType(_Constants2.default.TEXT, mediaSource);\n      initializeMediaForType(_Constants2.default.FRAGMENTED_TEXT, mediaSource);\n      initializeMediaForType(_Constants2.default.EMBEDDED_TEXT, mediaSource);\n      initializeMediaForType(_Constants2.default.MUXED, mediaSource);\n      initializeMediaForType(_Constants2.default.IMAGE, mediaSource);\n      createBuffers(previousBuffers);\n      eventBus.on(_Events2.default.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n\n      for (var i = 0; i < streamProcessors.length && streamProcessors[i]; i++) {\n        streamProcessors[i].getScheduleController().start();\n      }\n\n      setPreloaded(true);\n    }\n  }\n\n  instance = {\n    initialize: initialize,\n    getStreamId: getStreamId,\n    activate: activate,\n    deactivate: deactivate,\n    isActive: isActive,\n    getDuration: getDuration,\n    getStartTime: getStartTime,\n    getId: getId,\n    getStreamInfo: getStreamInfo,\n    getHasAudioTrack: getHasAudioTrack,\n    getHasVideoTrack: getHasVideoTrack,\n    preload: preload,\n    getThumbnailController: getThumbnailController,\n    getBitrateListFor: getBitrateListFor,\n    updateData: updateData,\n    reset: reset,\n    getProcessors: getProcessors,\n    setMediaSource: setMediaSource,\n    isMediaCodecCompatible: isMediaCodecCompatible,\n    isProtectionCompatible: isProtectionCompatible,\n    getPreloaded: getPreloaded,\n    getPreloadingScheduled: getPreloadingScheduled,\n    setPreloadingScheduled: setPreloadingScheduled,\n    getIsEndedEventSignaled: getIsEndedEventSignaled,\n    setIsEndedEventSignaled: setIsEndedEventSignaled\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nStream.__dashjs_factory_name = 'Stream';\nexports.default = _FactoryMaker2.default.getClassFactory(Stream);","map":{"version":3,"mappings":"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","names":["Stream","config","context","eventBus","getInstance","urlUtils","manifestModel","mediaPlayerModel","manifestUpdater","adapter","capabilities","capabilitiesFilter","errHandler","timelineConverter","dashMetrics","abrController","playbackController","eventController","mediaController","textController","protectionController","videoModel","settings","streamInfo","instance","logger","streamProcessors","isStreamInitialized","isStreamActivated","isMediaInitialized","hasVideoTrack","hasAudioTrack","updateError","isUpdating","fragmentController","thumbnailController","preloaded","boxParser","preloadingScheduled","debug","isEndedEventSignaled","trackChangedEvent","setup","getLogger","resetInitialSettings","create","dashConstants","DashConstants","initialize","registerEvents","registerProtectionEvents","trigger","Events","STREAM_UPDATED","on","BUFFERING_COMPLETED","onBufferingCompleted","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","INBAND_EVENTS","onInbandEvents","unRegisterEvents","off","KEY_ERROR","onProtectionError","SERVER_CERTIFICATE_UPDATED","LICENSE_REQUEST_COMPLETE","KEY_SYSTEM_SELECTED","KEY_SESSION_CREATED","KEY_STATUSES_CHANGED","unRegisterProtectionEvents","getStreamId","id","activate","mediaSource","previousBuffers","result","CURRENT_TRACK_CHANGED","onCurrentTrackChanged","getPreloaded","initializeMedia","initializeAfterPreload","deactivate","keepBuffers","ln","length","errored","i","fragmentModel","getFragmentModel","removeExecutedRequestsBeforeTime","getStartTime","getDuration","reset","setPreloaded","isActive","setMediaSource","isMediaSupported","getMediaInfo","splice","dischargePreBuffer","msg","error","DashJSError","Errors","MANIFEST_ERROR_ID_NOSTREAMS_CODE","getValue","fatal","pause","duration","NaN","getIsEndedEventSignaled","setIsEndedEventSignaled","value","start","getPreloadingScheduled","setPreloadingScheduled","getLiveStartTime","manifestInfo","isDynamic","getType","Constants","AUDIO","VIDEO","getId","getStreamInfo","getHasAudioTrack","getHasVideoTrack","getThumbnailController","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","getBitrateListFor","type","IMAGE","getBitrateList","mediaInfo","event","message","codec","MUXED","MANIFEST_ERROR_ID_MULTIPLEXED_CODE","TEXT","FRAGMENTED_TEXT","EMBEDDED_TEXT","contentProtection","supportsEncryptedMedia","CAPABILITY_MEDIAKEYS_ERROR_CODE","CAPABILITY_MEDIAKEYS_ERROR_MESSAGE","supportsCodec","e","newMediaInfo","manifest","setCurrentMediaInfo","processor","getProcessorForMediaInfo","currentTime","getTime","info","refreshManifestOnSwitchTrack","refreshManifest","selectMediaInfo","updateTopQualityIndex","switchTrackAsked","abortRequests","getScheduleController","setSeekTarget","setBufferingTime","resetIndexHandler","createStreamProcessor","allMediaForType","optionalSettings","getModel","streamProcessor","mimeType","baseURLController","setBuffer","buffer","replaceIdx","push","ignoreMediaInfo","idx","index","addMediaInfo","initializeMediaForType","getAllMediaInfoForType","initialMediaInfo","addEmbeddedTrack","addTrack","getTracksFor","events","checkInitialMediaSettingsForType","getCurrentTrackFor","STREAM_INITIALIZING","addInlineEvents","getEventsFor","addInbandEvents","element","getElement","filterUnsupportedFeaturesOfPeriod","test","nodeName","buffers","createBuffers","checkIfInitializationCompleted","hasError","audio","video","DATA_UPDATE_FAILED_ERROR_CODE","DATA_UPDATE_FAILED_ERROR_MESSAGE","clearMediaInfoArrayByStreamId","initializeForMedia","STREAM_INITIALIZED","liveStartTime","createBuffer","getBuffer","processors","getProcessors","warn","isBufferingCompleted","STREAM_BUFFERING_COMPLETED","mediaType","filter","arr","updateData","updatedStreamInfo","updateStreamInfo","getMediaInfoForType","oldMediaInfo","undefined","isMediaCodecCompatible","newStream","previousStream","compareCodecs","isProtectionCompatible","stream","compareProtectionConfig","newStreamInfo","currentStreamInfo","newAdaptation","getAdaptationForType","currentAdaptation","isAdaptationDrmProtected","adaptation","ContentProtection","Representation","sameMimeType","oldCodecs","Representation_asArray","map","representation","codecs","newCodecs","codecMatch","some","newCodec","indexOf","partialCodecMatch","oldCodec","codecRootCompatibleWithCodec","preload","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/Stream.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport DashConstants from '../dash/constants/DashConstants';\nimport StreamProcessor from './StreamProcessor';\nimport FragmentController from './controllers/FragmentController';\nimport ThumbnailController from './thumbnail/ThumbnailController';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport Debug from '../core/Debug';\nimport Errors from '../core/errors/Errors';\nimport FactoryMaker from '../core/FactoryMaker';\nimport DashJSError from './vo/DashJSError';\nimport BoxParser from './utils/BoxParser';\nimport URLUtils from './utils/URLUtils';\n\nfunction Stream(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    const manifestModel = config.manifestModel;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const manifestUpdater = config.manifestUpdater;\n    const adapter = config.adapter;\n    const capabilities = config.capabilities;\n    const capabilitiesFilter = config.capabilitiesFilter;\n    const errHandler = config.errHandler;\n    const timelineConverter = config.timelineConverter;\n    const dashMetrics = config.dashMetrics;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const eventController = config.eventController;\n    const mediaController = config.mediaController;\n    const textController = config.textController;\n    const protectionController = config.protectionController;\n    const videoModel = config.videoModel;\n    const settings = config.settings;\n    let streamInfo = config.streamInfo;\n\n    let instance,\n        logger,\n        streamProcessors,\n        isStreamInitialized,\n        isStreamActivated,\n        isMediaInitialized,\n        hasVideoTrack,\n        hasAudioTrack,\n        updateError,\n        isUpdating,\n        fragmentController,\n        thumbnailController,\n        preloaded,\n        boxParser,\n        preloadingScheduled,\n        debug,\n        isEndedEventSignaled,\n        trackChangedEvent;\n\n    function setup() {\n        debug = Debug(context).getInstance();\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n\n        boxParser = BoxParser(context).getInstance();\n\n        fragmentController = FragmentController(context).create({\n            streamInfo: streamInfo,\n            mediaPlayerModel: mediaPlayerModel,\n            dashMetrics: dashMetrics,\n            errHandler: errHandler,\n            settings: settings,\n            boxParser: boxParser,\n            dashConstants: DashConstants,\n            urlUtils: urlUtils\n        });\n    }\n\n    function initialize() {\n        registerEvents();\n        registerProtectionEvents();\n        eventBus.trigger(Events.STREAM_UPDATED, { streamInfo: streamInfo });\n    }\n\n    function registerEvents() {\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.on(Events.INBAND_EVENTS, onInbandEvents, instance);\n    }\n\n    function unRegisterEvents() {\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n        eventBus.off(Events.INBAND_EVENTS, onInbandEvents, instance);\n    }\n\n    function registerProtectionEvents() {\n        if (protectionController) {\n            eventBus.on(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.on(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.on(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.on(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.on(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.on(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    function unRegisterProtectionEvents() {\n        if (protectionController) {\n            eventBus.off(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.off(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.off(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.off(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.off(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.off(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    function getStreamId() {\n        return streamInfo ? streamInfo.id : null;\n    }\n\n    /**\n     * Activates Stream by re-initializing some of its components\n     * @param {MediaSource} mediaSource\n     * @memberof Stream#\n     * @param {SourceBuffer} previousBuffers\n     */\n    function activate(mediaSource, previousBuffers) {\n        if (!isStreamActivated) {\n            let result;\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n            if (!getPreloaded()) {\n                result = initializeMedia(mediaSource, previousBuffers);\n            } else {\n                initializeAfterPreload();\n                result = previousBuffers;\n            }\n            isStreamActivated = true;\n            return result;\n        }\n        return previousBuffers;\n    }\n\n    /**\n     * Partially resets some of the Stream elements\n     * @memberof Stream#\n     * @param {boolean} keepBuffers\n     */\n    function deactivate(keepBuffers) {\n        let ln = streamProcessors ? streamProcessors.length : 0;\n        const errored = false;\n        for (let i = 0; i < ln; i++) {\n            let fragmentModel = streamProcessors[i].getFragmentModel();\n            fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\n            streamProcessors[i].reset(errored, keepBuffers);\n        }\n        streamProcessors = [];\n        isStreamActivated = false;\n        isMediaInitialized = false;\n        setPreloaded(false);\n        eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n    }\n\n    function isActive() {\n        return isStreamActivated;\n    }\n\n    function setMediaSource(mediaSource) {\n        for (let i = 0; i < streamProcessors.length;) {\n            if (isMediaSupported(streamProcessors[i].getMediaInfo())) {\n                streamProcessors[i].setMediaSource(mediaSource);\n                i++;\n            } else {\n                streamProcessors[i].reset();\n                streamProcessors.splice(i, 1);\n            }\n        }\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state\n            //so do this after the buffers are created above.\n            streamProcessors[i].dischargePreBuffer();\n        }\n\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg + 'nostreams', manifestModel.getValue()));\n            logger.fatal(msg);\n        }\n    }\n\n    function resetInitialSettings() {\n        deactivate();\n        isStreamInitialized = false;\n        hasVideoTrack = false;\n        hasAudioTrack = false;\n        updateError = {};\n        isUpdating = false;\n        preloadingScheduled = false;\n        isEndedEventSignaled = false;\n    }\n\n    function reset() {\n\n        if (playbackController) {\n            playbackController.pause();\n        }\n\n        if (fragmentController) {\n            fragmentController.reset();\n            fragmentController = null;\n        }\n\n        streamInfo = null;\n\n        resetInitialSettings();\n\n        unRegisterEvents();\n\n        unRegisterProtectionEvents();\n\n        setPreloaded(false);\n    }\n\n    function getDuration() {\n        return streamInfo ? streamInfo.duration : NaN;\n    }\n\n    function getIsEndedEventSignaled() {\n        return isEndedEventSignaled;\n    }\n\n    function setIsEndedEventSignaled(value) {\n        isEndedEventSignaled = value;\n    }\n\n    function getStartTime() {\n        return streamInfo ? streamInfo.start : NaN;\n    }\n\n    function getPreloadingScheduled() {\n        return preloadingScheduled;\n    }\n\n    function setPreloadingScheduled(value) {\n        preloadingScheduled = value;\n    }\n\n    function getLiveStartTime() {\n        if (!streamInfo.manifestInfo.isDynamic) return NaN;\n        // Get live start time of the video stream (1st in array of streams)\n        // or audio if no video stream\n        for (let i = 0; i < streamProcessors.length; i++) {\n            if (streamProcessors[i].getType() === Constants.AUDIO ||\n                streamProcessors[i].getType() === Constants.VIDEO) {\n                return streamProcessors[i].getLiveStartTime();\n            }\n        }\n        return NaN;\n    }\n\n    function getId() {\n        return streamInfo ? streamInfo.id : null;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function getHasAudioTrack() {\n        return hasAudioTrack;\n    }\n\n    function getHasVideoTrack() {\n        return hasVideoTrack;\n    }\n\n    function getThumbnailController() {\n        return thumbnailController;\n    }\n\n    function checkConfig() {\n        if (!videoModel || !abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @returns {Array}\n     * @memberof Stream#\n     */\n    function getBitrateListFor(type) {\n        checkConfig();\n        if (type === Constants.IMAGE) {\n            if (!thumbnailController) {\n                return [];\n            }\n            return thumbnailController.getBitrateList();\n        }\n        const mediaInfo = getMediaInfo(type);\n        return abrController.getBitrateList(mediaInfo);\n    }\n\n    function onProtectionError(event) {\n        if (event.error) {\n            errHandler.error(event.error);\n            logger.fatal(event.error.message);\n            reset();\n        }\n    }\n\n    function isMediaSupported(mediaInfo) {\n        const type = mediaInfo ? mediaInfo.type : null;\n        let codec,\n            msg;\n\n        if (type === Constants.MUXED) {\n            msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines';\n            logger.fatal(msg);\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, msg, manifestModel.getValue()));\n            return false;\n        }\n\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.EMBEDDED_TEXT || type === Constants.IMAGE) {\n            return true;\n        }\n        codec = mediaInfo.codec;\n        logger.debug(type + ' codec: ' + codec);\n\n        if (!!mediaInfo.contentProtection && !capabilities.supportsEncryptedMedia()) {\n            errHandler.error(new DashJSError(Errors.CAPABILITY_MEDIAKEYS_ERROR_CODE, Errors.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE));\n        } else if (!capabilities.supportsCodec(codec)) {\n            msg = type + 'Codec (' + codec + ') is not supported.';\n            logger.error(msg);\n            return false;\n        }\n\n        return true;\n    }\n\n    function onCurrentTrackChanged(e) {\n        if (!streamInfo || e.newMediaInfo.streamInfo.id !== streamInfo.id) return;\n        let mediaInfo = e.newMediaInfo;\n        let manifest = manifestModel.getValue();\n\n        adapter.setCurrentMediaInfo(streamInfo.id, mediaInfo.type, mediaInfo);\n\n        let processor = getProcessorForMediaInfo(mediaInfo);\n        if (!processor) return;\n\n        let currentTime = playbackController.getTime();\n        logger.info('Stream -  Process track changed at current time ' + currentTime);\n\n        logger.debug('Stream -  Update stream controller');\n        if (manifest.refreshManifestOnSwitchTrack) { // Applies only for MSS streams\n            logger.debug('Stream -  Refreshing manifest for switch track');\n            trackChangedEvent = e;\n            manifestUpdater.refreshManifest();\n        } else {\n            processor.selectMediaInfo(mediaInfo);\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\n                abrController.updateTopQualityIndex(mediaInfo);\n                processor.switchTrackAsked();\n                processor.getFragmentModel().abortRequests();\n            } else {\n                processor.getScheduleController().setSeekTarget(currentTime);\n                processor.setBufferingTime(currentTime);\n                processor.resetIndexHandler();\n            }\n        }\n    }\n\n    function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) {\n\n        let fragmentModel = fragmentController.getModel(mediaInfo ? mediaInfo.type : null);\n\n        let streamProcessor = StreamProcessor(context).create({\n            streamInfo: streamInfo,\n            type: mediaInfo ? mediaInfo.type : null,\n            mimeType: mediaInfo ? mediaInfo.mimeType : null,\n            timelineConverter: timelineConverter,\n            adapter: adapter,\n            manifestModel: manifestModel,\n            mediaPlayerModel: mediaPlayerModel,\n            fragmentModel: fragmentModel,\n            dashMetrics: config.dashMetrics,\n            baseURLController: config.baseURLController,\n            abrController: abrController,\n            playbackController: playbackController,\n            mediaController: mediaController,\n            textController: textController,\n            errHandler: errHandler,\n            settings: settings,\n            boxParser: boxParser\n        });\n\n        streamProcessor.initialize(mediaSource, hasVideoTrack);\n        abrController.updateTopQualityIndex(mediaInfo);\n\n        if (optionalSettings) {\n            streamProcessor.setBuffer(optionalSettings.buffer);\n            streamProcessor.setBufferingTime(optionalSettings.currentTime);\n            streamProcessors[optionalSettings.replaceIdx] = streamProcessor;\n        } else {\n            streamProcessors.push(streamProcessor);\n        }\n\n        if (optionalSettings && optionalSettings.ignoreMediaInfo) {\n            return;\n        }\n\n        if (mediaInfo && (mediaInfo.type === Constants.TEXT || mediaInfo.type === Constants.FRAGMENTED_TEXT)) {\n            let idx;\n            for (let i = 0; i < allMediaForType.length; i++) {\n                if (allMediaForType[i].index === mediaInfo.index) {\n                    idx = i;\n                }\n                streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor\n            }\n            streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info\n        } else {\n            streamProcessor.addMediaInfo(mediaInfo, true);\n        }\n    }\n\n    function initializeMediaForType(type, mediaSource) {\n        const allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type);\n\n        let mediaInfo = null;\n        let initialMediaInfo;\n\n        if (!allMediaForType || allMediaForType.length === 0) {\n            logger.info('No ' + type + ' data.');\n            return;\n        }\n\n        if (type === Constants.VIDEO) {\n            hasVideoTrack = true;\n        }\n\n        if (type === Constants.AUDIO) {\n            hasAudioTrack = true;\n        }\n\n        for (let i = 0, ln = allMediaForType.length; i < ln; i++) {\n            mediaInfo = allMediaForType[i];\n\n            if (type === Constants.EMBEDDED_TEXT) {\n                textController.addEmbeddedTrack(mediaInfo);\n            } else {\n                if (!isMediaSupported(mediaInfo)) continue;\n                mediaController.addTrack(mediaInfo);\n            }\n        }\n\n        if (type === Constants.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) {\n            return;\n        }\n\n        if (type === Constants.IMAGE) {\n            thumbnailController = ThumbnailController(context).create({\n                streamInfo: streamInfo,\n                adapter: adapter,\n                baseURLController: config.baseURLController,\n                timelineConverter: config.timelineConverter,\n                debug: debug,\n                eventBus: eventBus,\n                events: Events,\n                dashConstants: DashConstants\n            });\n            return;\n        }\n\n\n        mediaController.checkInitialMediaSettingsForType(type, streamInfo);\n        initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo);\n\n        eventBus.trigger(Events.STREAM_INITIALIZING, {\n            streamInfo: streamInfo,\n            mediaInfo: mediaInfo\n        });\n\n        // TODO : How to tell index handler live/duration?\n        // TODO : Pass to controller and then pass to each method on handler?\n\n        createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource);\n    }\n\n    function addInlineEvents() {\n        if (eventController) {\n            const events = adapter.getEventsFor(streamInfo);\n            eventController.addInlineEvents(events);\n        }\n    }\n\n    function addInbandEvents(events) {\n        if (eventController) {\n            eventController.addInbandEvents(events);\n        }\n    }\n\n    function initializeMedia(mediaSource, previousBuffers) {\n        checkConfig();\n        let element = videoModel.getElement();\n\n        addInlineEvents();\n\n        isUpdating = true;\n\n        capabilitiesFilter.filterUnsupportedFeaturesOfPeriod( streamInfo);\n\n        if (!element || (element && (/^VIDEO$/i).test(element.nodeName))) {\n            initializeMediaForType(Constants.VIDEO, mediaSource);\n        }\n        initializeMediaForType(Constants.AUDIO, mediaSource);\n        initializeMediaForType(Constants.TEXT, mediaSource);\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n        initializeMediaForType(Constants.MUXED, mediaSource);\n        initializeMediaForType(Constants.IMAGE, mediaSource);\n\n        //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText.\n        const buffers = createBuffers(previousBuffers);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n            logger.fatal(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n\n        return buffers;\n    }\n\n    function initializeAfterPreload() {\n        isUpdating = true;\n        checkConfig();\n        capabilitiesFilter.filterUnsupportedFeaturesOfPeriod(streamInfo);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n            logger.debug(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n    }\n\n    function checkIfInitializationCompleted() {\n        const ln = streamProcessors.length;\n        const hasError = !!updateError.audio || !!updateError.video;\n        let error = hasError ? new DashJSError(Errors.DATA_UPDATE_FAILED_ERROR_CODE, Errors.DATA_UPDATE_FAILED_ERROR_MESSAGE) : null;\n\n        for (let i = 0; i < ln; i++) {\n            if (streamProcessors[i].isUpdating() || isUpdating) {\n                return;\n            }\n        }\n\n        if (!isMediaInitialized) {\n            return;\n        }\n\n        if (protectionController) {\n            // Need to check if streamProcessors exists because streamProcessors\n            // could be cleared in case an error is detected while initializing DRM keysystem\n            protectionController.clearMediaInfoArrayByStreamId(getId());\n            for (let i = 0; i < ln && streamProcessors[i]; i++) {\n                const type = streamProcessors[i].getType();\n                if (type === Constants.AUDIO ||\n                    type === Constants.VIDEO ||\n                    type === Constants.FRAGMENTED_TEXT) {\n                    let mediaInfo = streamProcessors[i].getMediaInfo();\n                    if (mediaInfo) {\n                        protectionController.initializeForMedia(mediaInfo);\n                    }\n                }\n            }\n        }\n\n        if (error) {\n            errHandler.error(error);\n        } else if (!isStreamInitialized) {\n            isStreamInitialized = true;\n\n            eventBus.trigger(Events.STREAM_INITIALIZED, {\n                streamInfo: streamInfo,\n                liveStartTime: !preloaded ? getLiveStartTime() : NaN\n            });\n        }\n\n        // (Re)start ScheduleController:\n        // - in case stream initialization has been completed after 'play' event (case for SegmentBase streams)\n        // - in case stream is complete but a track switch has been requested\n        for (let i = 0; i < ln && streamProcessors[i]; i++) {\n            streamProcessors[i].getScheduleController().start();\n        }\n    }\n\n    function getMediaInfo(type) {\n        let streamProcessor = null;\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            streamProcessor = streamProcessors[i];\n\n            if (streamProcessor.getType() === type) {\n                return streamProcessor.getMediaInfo();\n            }\n        }\n\n        return null;\n    }\n\n    function createBuffers(previousBuffers) {\n        const buffers = {};\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            const buffer = streamProcessors[i].createBuffer(previousBuffers);\n            if (buffer) {\n                buffers[streamProcessors[i].getType()] = buffer.getBuffer();\n            }\n        }\n        return buffers;\n    }\n\n    function onBufferingCompleted() {\n        let processors = getProcessors();\n        const ln = processors.length;\n\n        if (ln === 0) {\n            logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined');\n            return;\n        }\n\n        // if there is at least one buffer controller that has not completed buffering yet do nothing\n        for (let i = 0; i < ln; i++) {\n            //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED\n            if (!processors[i].isBufferingCompleted() && (processors[i].getType() === Constants.AUDIO || processors[i].getType() === Constants.VIDEO)) {\n                logger.warn('onBufferingCompleted - One streamProcessor has finished but', processors[i].getType(), 'one is not buffering completed');\n                return;\n            }\n        }\n\n        logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED');\n        eventBus.trigger(Events.STREAM_BUFFERING_COMPLETED, { streamInfo: streamInfo });\n    }\n\n    function onDataUpdateCompleted(e) {\n        updateError[e.mediaType] = e.error;\n        checkIfInitializationCompleted();\n    }\n\n    function onInbandEvents(e) {\n        addInbandEvents(e.events);\n    }\n\n    function getProcessorForMediaInfo(mediaInfo) {\n        if (!mediaInfo) {\n            return null;\n        }\n\n        let processors = getProcessors();\n\n        return processors.filter(function (processor) {\n            return (processor.getType() === mediaInfo.type);\n        })[0];\n    }\n\n    function getProcessors() {\n        let arr = [];\n\n        let type,\n            streamProcessor;\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            streamProcessor = streamProcessors[i];\n            type = streamProcessor.getType();\n\n            if (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) {\n                arr.push(streamProcessor);\n            }\n        }\n\n        return arr;\n    }\n\n    function updateData(updatedStreamInfo) {\n        logger.info('Manifest updated... updating data system wide.');\n\n        isStreamActivated = false;\n        isUpdating = true;\n        streamInfo = updatedStreamInfo;\n\n        eventBus.trigger(Events.STREAM_UPDATED, { streamInfo: streamInfo });\n\n        if (eventController) {\n            addInlineEvents();\n        }\n\n        capabilitiesFilter.filterUnsupportedFeaturesOfPeriod(streamInfo);\n\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            let streamProcessor = streamProcessors[i];\n            streamProcessor.updateStreamInfo(streamInfo);\n            let mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType());\n            // Check if AdaptationSet has not been removed in MPD update\n            if (mediaInfo) {\n                abrController.updateTopQualityIndex(mediaInfo);\n                streamProcessor.addMediaInfo(mediaInfo, true);\n            }\n        }\n\n        if (trackChangedEvent) {\n            let mediaInfo = trackChangedEvent.newMediaInfo;\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\n                let processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo);\n                if (!processor) return;\n                processor.switchTrackAsked();\n                trackChangedEvent = undefined;\n            }\n        }\n\n        isUpdating = false;\n        checkIfInitializationCompleted();\n    }\n\n    function isMediaCodecCompatible(newStream, previousStream = null) {\n        return compareCodecs(newStream, Constants.VIDEO, previousStream) && compareCodecs(newStream, Constants.AUDIO, previousStream);\n    }\n\n    function isProtectionCompatible(stream, previousStream = null) {\n        return compareProtectionConfig(stream, Constants.VIDEO, previousStream) && compareProtectionConfig(stream, Constants.AUDIO, previousStream);\n    }\n\n    function compareProtectionConfig(stream, type, previousStream = null) {\n        if (!stream) {\n            return false;\n        }\n        const newStreamInfo = stream.getStreamInfo();\n        const currentStreamInfo = previousStream ? previousStream.getStreamInfo() : getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        // If the current period is unencrypted and the upcoming one is encrypted we need to reset sourcebuffers.\n        return !(!isAdaptationDrmProtected(currentAdaptation) && isAdaptationDrmProtected(newAdaptation));\n    }\n\n    function isAdaptationDrmProtected(adaptation) {\n\n        if (!adaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return false;\n        }\n\n        // If the current period is unencrypted and the upcoming one is encrypted we need to reset sourcebuffers.\n        return !!(adaptation.ContentProtection || (adaptation.Representation && adaptation.Representation.length > 0 && adaptation.Representation[0].ContentProtection));\n    }\n\n    function compareCodecs(newStream, type, previousStream = null) {\n        if (!newStream || !newStream.hasOwnProperty('getStreamInfo')) {\n            return false;\n        }\n        const newStreamInfo = newStream.getStreamInfo();\n        const currentStreamInfo = previousStream ? previousStream.getStreamInfo() : getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        const sameMimeType = newAdaptation && currentAdaptation && newAdaptation.mimeType === currentAdaptation.mimeType;\n        const oldCodecs = currentAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const newCodecs = newAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const codecMatch = newCodecs.some((newCodec) => {\n            return oldCodecs.indexOf(newCodec) > -1;\n        });\n\n        const partialCodecMatch = newCodecs.some((newCodec) => oldCodecs.some((oldCodec) => capabilities.codecRootCompatibleWithCodec(oldCodec, newCodec)));\n        return codecMatch || (partialCodecMatch && sameMimeType);\n    }\n\n    function setPreloaded(value) {\n        preloaded = value;\n    }\n\n    function getPreloaded() {\n        return preloaded;\n    }\n\n    function preload(mediaSource, previousBuffers) {\n        if (!getPreloaded()) {\n            addInlineEvents();\n\n            initializeMediaForType(Constants.VIDEO, mediaSource);\n            initializeMediaForType(Constants.AUDIO, mediaSource);\n            initializeMediaForType(Constants.TEXT, mediaSource);\n            initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n            initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n            initializeMediaForType(Constants.MUXED, mediaSource);\n            initializeMediaForType(Constants.IMAGE, mediaSource);\n\n            createBuffers(previousBuffers);\n\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n            for (let i = 0; i < streamProcessors.length && streamProcessors[i]; i++) {\n                streamProcessors[i].getScheduleController().start();\n            }\n\n            setPreloaded(true);\n        }\n    }\n\n\n    instance = {\n        initialize: initialize,\n        getStreamId: getStreamId,\n        activate: activate,\n        deactivate: deactivate,\n        isActive: isActive,\n        getDuration: getDuration,\n        getStartTime: getStartTime,\n        getId: getId,\n        getStreamInfo: getStreamInfo,\n        getHasAudioTrack: getHasAudioTrack,\n        getHasVideoTrack: getHasVideoTrack,\n        preload: preload,\n        getThumbnailController: getThumbnailController,\n        getBitrateListFor: getBitrateListFor,\n        updateData: updateData,\n        reset: reset,\n        getProcessors: getProcessors,\n        setMediaSource: setMediaSource,\n        isMediaCodecCompatible: isMediaCodecCompatible,\n        isProtectionCompatible: isProtectionCompatible,\n        getPreloaded: getPreloaded,\n        getPreloadingScheduled,\n        setPreloadingScheduled,\n        getIsEndedEventSignaled,\n        setIsEndedEventSignaled\n    };\n\n    setup();\n    return instance;\n}\n\nStream.__dashjs_factory_name = 'Stream';\nexport default FactoryMaker.getClassFactory(Stream);\n"]},"metadata":{},"sourceType":"script"}