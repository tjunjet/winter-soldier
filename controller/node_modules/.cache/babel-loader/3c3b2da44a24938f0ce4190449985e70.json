{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DashJSError = require('./../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _HTTPRequest = require('../vo/metrics/HTTPRequest');\n\nvar _EventBus = require('./../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('./../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Errors = require('./../../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _URLUtils = require('../utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar HTTP_TIMEOUT_MS = 5000;\nvar DEFAULT_MAXIMUM_ALLOWED_DRIFT = 100;\nvar DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR = 2;\nvar DEFAULT_BACKGROUND_ATTEMPTS = 2;\nvar DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS = 30;\nvar DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS = 30;\nvar DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC = 600;\nvar DEFAULT_MINIMUM_TIME_BETWEEN_SYNC = 2;\n\nfunction TimeSyncController() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      isSynchronizing = void 0,\n      isBackgroundSynchronizing = void 0,\n      settings = void 0,\n      handlers = void 0,\n      dashMetrics = void 0,\n      backgroundSyncTimeOffsets = void 0,\n      timingSources = void 0,\n      timeOfLastSync = void 0,\n      timeOfLastBackgroundSync = void 0,\n      lastOffset = void 0,\n      lastTimingSource = void 0,\n      internalTimeBetweenSyncAttempts = void 0,\n      baseURLController = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    eventBus.on(_Events2.default.ATTEMPT_BACKGROUND_SYNC, _onAttemptBackgroundSync, instance);\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.dashMetrics) {\n      dashMetrics = config.dashMetrics;\n    }\n\n    if (config.baseURLController) {\n      baseURLController = config.baseURLController;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n  }\n\n  function _resetInitialSettings() {\n    backgroundSyncTimeOffsets = [];\n    timingSources = [];\n    timeOfLastSync = null;\n    timeOfLastBackgroundSync = null;\n    lastTimingSource = null;\n    lastOffset = NaN;\n    isSynchronizing = false;\n    isBackgroundSynchronizing = false;\n    internalTimeBetweenSyncAttempts = settings.get().streaming.utcSynchronization.timeBetweenSyncAttempts;\n  }\n  /**\n  * Register the timing handler depending on the schemeIdUris. This method is called once when the StreamController is initialized\n  */\n\n\n  function initialize() {\n    _resetInitialSettings(); // a list of known schemeIdUris and a method to call with @value\n\n\n    handlers = {\n      'urn:mpeg:dash:utc:http-head:2014': _httpHeadHandler,\n      'urn:mpeg:dash:utc:http-xsdate:2014': _httpHandler.bind(null, _xsdatetimeDecoder),\n      'urn:mpeg:dash:utc:http-iso:2014': _httpHandler.bind(null, _iso8601Decoder),\n      'urn:mpeg:dash:utc:direct:2014': _directHandler,\n      // some specs referencing early ISO23009-1 drafts incorrectly use\n      // 2012 in the URI, rather than 2014. support these for now.\n      'urn:mpeg:dash:utc:http-head:2012': _httpHeadHandler,\n      'urn:mpeg:dash:utc:http-xsdate:2012': _httpHandler.bind(null, _xsdatetimeDecoder),\n      'urn:mpeg:dash:utc:http-iso:2012': _httpHandler.bind(null, _iso8601Decoder),\n      'urn:mpeg:dash:utc:direct:2012': _directHandler,\n      // it isn't clear how the data returned would be formatted, and\n      // no public examples available so http-ntp not supported for now.\n      // presumably you would do an arraybuffer type xhr and decode the\n      // binary data returned but I would want to see a sample first.\n      'urn:mpeg:dash:utc:http-ntp:2014': _notSupportedHandler,\n      // not clear how this would be supported in javascript (in browser)\n      'urn:mpeg:dash:utc:ntp:2014': _notSupportedHandler,\n      'urn:mpeg:dash:utc:sntp:2014': _notSupportedHandler\n    };\n  }\n  /**\n  * Sync against a timing source. T\n  * @param {array} tSources\n  */\n\n\n  function attemptSync(tSources) {\n    timingSources = tSources; // Stop if we are already synchronizing\n\n    if (isSynchronizing) {\n      return;\n    } // No synchronization required we can signal the completion immediately\n\n\n    if (!_shouldPerformSynchronization()) {\n      eventBus.trigger(_Events2.default.TIME_SYNCHRONIZATION_COMPLETED);\n      return;\n    }\n\n    isSynchronizing = true;\n\n    _attemptRecursiveSync();\n  }\n  /**\n  * Does a synchronization in the background in case the last offset should be verified or a 404 occurs\n  */\n\n\n  function _onAttemptBackgroundSync() {\n    if (isSynchronizing || isBackgroundSynchronizing || !lastTimingSource || !lastTimingSource.value || !lastTimingSource.schemeIdUri || isNaN(lastOffset) || isNaN(settings.get().streaming.utcSynchronization.backgroundAttempts)) {\n      return;\n    }\n\n    if (timeOfLastBackgroundSync && (Date.now() - timeOfLastBackgroundSync) / 1000 < DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS) {\n      return;\n    }\n\n    backgroundSyncTimeOffsets = [];\n    isBackgroundSynchronizing = true;\n    var backgroundAttempts = !isNaN(settings.get().streaming.utcSynchronization.backgroundAttempts) ? settings.get().streaming.utcSynchronization.backgroundAttempts : DEFAULT_BACKGROUND_ATTEMPTS;\n\n    _attemptBackgroundSync(backgroundAttempts);\n  }\n  /**\n  * Perform a defined number of background attempts\n  * @param {number} attempts\n  * @private\n  */\n\n\n  function _attemptBackgroundSync(attempts) {\n    try {\n      if (attempts <= 0) {\n        _completeBackgroundTimeSyncSequence();\n\n        return;\n      }\n\n      var deviceTimeBeforeSync = Date.now();\n      handlers[lastTimingSource.schemeIdUri](lastTimingSource.value, function (serverTime) {\n        // the timing source returned something useful\n        var deviceTimeAfterSync = Date.now();\n\n        var offset = _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime);\n\n        backgroundSyncTimeOffsets.push(offset);\n\n        _attemptBackgroundSync(attempts - 1);\n      }, function () {\n        _completeBackgroundTimeSyncSequence();\n      });\n    } catch (e) {\n      _completeBackgroundTimeSyncSequence();\n    }\n  }\n  /**\n  * Sync against a timing source. This method is called recursively if the time sync for the first entry in timingSources fails.\n  * @param {number} sourceIndex\n  */\n\n\n  function _attemptRecursiveSync() {\n    var sourceIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null; // if called with no sourceIndex, use zero (highest priority)\n\n    var index = sourceIndex || 0; // the sources should be ordered in priority from the manifest.\n    // try each in turn, from the top, until either something\n    // sensible happens, or we run out of sources to try.\n\n    if (!timingSources || timingSources.length === 0 || index >= timingSources.length) {\n      _onComplete();\n\n      return;\n    }\n\n    var source = timingSources[index];\n\n    if (source) {\n      // check if there is a handler for this @schemeIdUri\n      if (handlers.hasOwnProperty(source.schemeIdUri)) {\n        // if so, call it with its @value\n        var deviceTimeBeforeSync = new Date().getTime();\n        handlers[source.schemeIdUri](source.value, function (serverTime) {\n          // the timing source returned something useful\n          var deviceTimeAfterSync = new Date().getTime();\n\n          var offset = _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime);\n\n          lastTimingSource = source;\n\n          _onComplete(offset);\n        }, function () {\n          // the timing source was probably uncontactable\n          // or returned something we can't use - try again\n          // with the remaining sources\n          _attemptRecursiveSync(index + 1);\n        });\n      } else {\n        // an unknown schemeIdUri must have been found\n        // try again with the remaining sources\n        _attemptRecursiveSync(index + 1);\n      }\n    } else {\n      // no valid time source could be found, just use device time\n      _onComplete();\n    }\n  }\n  /**\n  * Calculate the offset between client and server. Account for the roundtrip time\n  * @param {number} deviceTimeBeforeSync\n  * @param {number} deviceTimeAfterSync\n  * @param {number} serverTime\n  * @return {number}\n  * @private\n  */\n\n\n  function _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime) {\n    var deviceReferenceTime = deviceTimeAfterSync - (deviceTimeAfterSync - deviceTimeBeforeSync) / 2;\n    return serverTime - deviceReferenceTime;\n  }\n  /**\n  * Checks if a synchronization is required\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _shouldPerformSynchronization() {\n    try {\n      var timeBetweenSyncAttempts = !isNaN(internalTimeBetweenSyncAttempts) ? internalTimeBetweenSyncAttempts : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS;\n\n      if (!timeOfLastSync || !timeBetweenSyncAttempts || isNaN(timeBetweenSyncAttempts)) {\n        return true;\n      }\n\n      return (Date.now() - timeOfLastSync) / 1000 >= timeBetweenSyncAttempts;\n    } catch (e) {\n      return true;\n    }\n  }\n  /**\n  * Callback after sync has been completed\n  * @param {number} offset\n  * @private\n  */\n\n\n  function _onComplete() {\n    var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;\n    var failed = isNaN(offset);\n\n    if (failed && settings.get().streaming.useManifestDateHeaderTimeSource) {\n      //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\n      _checkForDateHeader();\n    } else {\n      _completeTimeSyncSequence(failed, offset);\n    }\n  }\n  /**\n  * Takes xsdatetime and returns milliseconds since UNIX epoch. May not be necessary as xsdatetime is very similar to ISO 8601 which is natively understood by javascript Date parser\n  * @param {string} xsdatetimeStr\n  * @return {number}\n  * @private\n  */\n\n\n  function _alternateXsdatetimeDecoder(xsdatetimeStr) {\n    // taken from DashParser - should probably refactor both uses\n    var SECONDS_IN_MIN = 60;\n    var MINUTES_IN_HOUR = 60;\n    var MILLISECONDS_IN_SECONDS = 1000;\n    var datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\n    var utcDate = void 0,\n        timezoneOffset = void 0;\n    var match = datetimeRegex.exec(xsdatetimeStr); // If the string does not contain a timezone offset different browsers can interpret it either\n    // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\n    // all browsers\n\n    utcDate = Date.UTC(parseInt(match[1], 10), parseInt(match[2], 10) - 1, // months start from zero\n    parseInt(match[3], 10), parseInt(match[4], 10), parseInt(match[5], 10), match[6] && (parseInt(match[6], 10) || 0), match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS || 0); // If the date has timezone offset take it into account as well\n\n    if (match[9] && match[10]) {\n      timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\n      utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\n    }\n\n    return new Date(utcDate).getTime();\n  }\n  /**\n  * Try to use the built in parser, since xsdate is a constrained ISO8601 which is supported natively by Date.parse. if that fails, try a regex-based version used elsewhere in this application.\n  * @param {string} xsdatetimeStr\n  * @return {number}\n  */\n\n\n  function _xsdatetimeDecoder(xsdatetimeStr) {\n    var parsedDate = Date.parse(xsdatetimeStr);\n\n    if (isNaN(parsedDate)) {\n      parsedDate = _alternateXsdatetimeDecoder(xsdatetimeStr);\n    }\n\n    return parsedDate;\n  }\n  /**\n  * Takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\n  * @param {string} isoStr\n  * @return {number}\n  */\n\n\n  function _iso8601Decoder(isoStr) {\n    return Date.parse(isoStr);\n  }\n  /**\n  * Takes RFC 1123 timestamp (which is same as ISO8601) and returns milliseconds since UNIX epoch\n  * @param {string} dateStr\n  * @return {number}\n  */\n\n\n  function _rfc1123Decoder(dateStr) {\n    return Date.parse(dateStr);\n  }\n  /**\n  * Handler for unsupported scheme ids.\n  * @param {string} url\n  * @param {function} onSuccessCB\n  * @param {function} onFailureCB\n  * @private\n  */\n\n\n  function _notSupportedHandler(url, onSuccessCB, onFailureCB) {\n    onFailureCB();\n  }\n  /**\n  * Direct handler\n  * @param {string} xsdatetimeStr\n  * @param {function} onSuccessCB\n  * @param {function} onFailureCB\n  */\n\n\n  function _directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\n    var time = _xsdatetimeDecoder(xsdatetimeStr);\n\n    if (!isNaN(time)) {\n      onSuccessCB(time);\n      return;\n    }\n\n    onFailureCB();\n  }\n  /**\n  * Generic http handler\n  * @param {function} decoder\n  * @param {string} url\n  * @param {function} onSuccessCB\n  * @param {function} onFailureCB\n  * @param {boolean} isHeadRequest\n  * @private\n  */\n\n\n  function _httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\n    var oncomplete = void 0,\n        onload = void 0;\n    var complete = false;\n    var req = new XMLHttpRequest();\n    var verb = isHeadRequest ? _HTTPRequest.HTTPRequest.HEAD : _HTTPRequest.HTTPRequest.GET;\n    var urls = url.match(/\\S+/g); // according to ISO 23009-1, url could be a white-space\n    // separated list of URLs. just handle one at a time.\n\n    url = urls.shift();\n\n    oncomplete = function oncomplete() {\n      if (complete) {\n        return;\n      } // we only want to pass through here once per xhr,\n      // regardless of whether the load was successful.\n\n\n      complete = true; // if there are more urls to try, call self.\n\n      if (urls.length) {\n        _httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\n      } else {\n        onFailureCB();\n      }\n    };\n\n    onload = function onload() {\n      var time = void 0,\n          result = void 0;\n\n      if (req.status === 200) {\n        time = isHeadRequest ? req.getResponseHeader('Date') : req.response;\n        result = decoder(time); // decoder returns NaN if non-standard input\n\n        if (!isNaN(result)) {\n          onSuccessCB(result);\n          complete = true;\n        }\n      }\n    };\n\n    if (urlUtils.isRelative(url)) {\n      // passing no path to resolve will return just MPD BaseURL/baseUri\n      var baseUrl = baseURLController.resolve();\n\n      if (baseUrl) {\n        url = urlUtils.resolve(url, baseUrl.url);\n      }\n    }\n\n    req.open(verb, url);\n    req.timeout = HTTP_TIMEOUT_MS || 0;\n    req.onload = onload;\n    req.onloadend = oncomplete;\n    req.send();\n  }\n  /**\n  * Handler for http-head schemeIdUri\n  * @param {string} url\n  * @param {function} onSuccessCB\n  * @param {function} onFailureCB\n  * @private\n  */\n\n\n  function _httpHeadHandler(url, onSuccessCB, onFailureCB) {\n    _httpHandler(_rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\n  }\n  /**\n  * Checks if a date header is present in the MPD response and calculates the offset based on the header\n  * @private\n  */\n\n\n  function _checkForDateHeader() {\n    var dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID('Date');\n    var dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\n\n    if (!isNaN(dateHeaderTime)) {\n      var offsetToDeviceTimeMs = dateHeaderTime - Date.now();\n\n      _completeTimeSyncSequence(false, offsetToDeviceTimeMs);\n    } else {\n      _completeTimeSyncSequence(true);\n    }\n  }\n  /**\n  * Triggers the event to signal that the time synchronization was completed\n  * @param {boolean} failed\n  * @param {number} offset\n  * @private\n  */\n\n\n  function _completeTimeSyncSequence(failed, offset) {\n    // Adjust the time of the next sync based on the drift between current offset and last offset\n    if (!isNaN(lastOffset) && !isNaN(offset) && !failed) {\n      _adjustTimeBetweenSyncAttempts(offset);\n    } // Update the internal data\n\n\n    if (!failed && !isNaN(offset)) {\n      timeOfLastSync = Date.now();\n      isSynchronizing = false; // if this is the first sync we are doing perform background syncs as well to confirm current offset\n\n      var shouldAttemptBackgroundSync = isNaN(lastOffset);\n      lastOffset = offset;\n\n      if (shouldAttemptBackgroundSync) {\n        _onAttemptBackgroundSync();\n      }\n\n      logger.debug('Completed UTC sync. Setting client - server offset to ' + offset);\n    }\n\n    if (failed) {\n      lastTimingSource = null;\n    } // Notify other classes\n\n\n    eventBus.trigger(_Events2.default.UPDATE_TIME_SYNC_OFFSET, {\n      offset: offset,\n      error: failed ? new _DashJSError2.default(_Errors2.default.TIME_SYNC_FAILED_ERROR_CODE, _Errors2.default.TIME_SYNC_FAILED_ERROR_MESSAGE) : null\n    });\n    eventBus.trigger(_Events2.default.TIME_SYNCHRONIZATION_COMPLETED);\n  }\n\n  function _adjustTimeBetweenSyncAttempts(offset) {\n    try {\n      var isOffsetDriftWithinThreshold = _isOffsetDriftWithinThreshold(offset);\n\n      var timeBetweenSyncAttempts = !isNaN(internalTimeBetweenSyncAttempts) ? internalTimeBetweenSyncAttempts : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS;\n      var timeBetweenSyncAttemptsAdjustmentFactor = !isNaN(settings.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor) ? settings.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR;\n      var maximumTimeBetweenSyncAttempts = !isNaN(settings.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts) ? settings.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts : DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC;\n      var minimumTimeBetweenSyncAttempts = !isNaN(settings.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts) ? settings.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts : DEFAULT_MINIMUM_TIME_BETWEEN_SYNC;\n      var adjustedTimeBetweenSyncAttempts = void 0;\n\n      if (isOffsetDriftWithinThreshold) {\n        // The drift between the current offset and the last offset is within the allowed threshold. Increase sync time\n        adjustedTimeBetweenSyncAttempts = Math.min(timeBetweenSyncAttempts * timeBetweenSyncAttemptsAdjustmentFactor, maximumTimeBetweenSyncAttempts);\n        logger.debug('Increasing timeBetweenSyncAttempts to ' + adjustedTimeBetweenSyncAttempts);\n      } else {\n        // Drift between the current offset and the last offset is not within the allowed threshold. Decrease sync time\n        adjustedTimeBetweenSyncAttempts = Math.max(timeBetweenSyncAttempts / timeBetweenSyncAttemptsAdjustmentFactor, minimumTimeBetweenSyncAttempts);\n        logger.debug('Decreasing timeBetweenSyncAttempts to ' + adjustedTimeBetweenSyncAttempts);\n      }\n\n      internalTimeBetweenSyncAttempts = adjustedTimeBetweenSyncAttempts;\n    } catch (e) {}\n  }\n  /**\n  * Callback after all background syncs have been completed.\n  * @private\n  */\n\n\n  function _completeBackgroundTimeSyncSequence() {\n    if (!backgroundSyncTimeOffsets || backgroundSyncTimeOffsets.length === 0) {\n      return;\n    }\n\n    var averageOffset = backgroundSyncTimeOffsets.reduce(function (acc, curr) {\n      return acc + curr;\n    }, 0) / backgroundSyncTimeOffsets.length;\n\n    if (!_isOffsetDriftWithinThreshold(averageOffset)) {\n      logger.debug('Completed background UTC sync. Setting client - server offset to ' + averageOffset);\n      lastOffset = averageOffset;\n      eventBus.trigger(_Events2.default.UPDATE_TIME_SYNC_OFFSET, {\n        offset: lastOffset\n      });\n    } else {\n      logger.debug('Completed background UTC sync. Offset is within allowed threshold and is not adjusted.');\n    }\n\n    isBackgroundSynchronizing = false;\n    timeOfLastBackgroundSync = Date.now();\n  }\n\n  function _isOffsetDriftWithinThreshold(offset) {\n    try {\n      if (isNaN(lastOffset)) {\n        return true;\n      }\n\n      var maxAllowedDrift = settings.get().streaming.utcSynchronization.maximumAllowedDrift && !isNaN(settings.get().streaming.utcSynchronization.maximumAllowedDrift) ? settings.get().streaming.utcSynchronization.maximumAllowedDrift : DEFAULT_MAXIMUM_ALLOWED_DRIFT;\n      var lowerBound = lastOffset - maxAllowedDrift;\n      var upperBound = lastOffset + maxAllowedDrift;\n      return offset >= lowerBound && offset <= upperBound;\n    } catch (e) {\n      return true;\n    }\n  }\n\n  function reset() {\n    _resetInitialSettings();\n\n    eventBus.off(_Events2.default.ATTEMPT_BACKGROUND_SYNC, _onAttemptBackgroundSync, instance);\n  }\n\n  instance = {\n    initialize: initialize,\n    attemptSync: attemptSync,\n    setConfig: setConfig,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\n\nvar factory = _FactoryMaker2.default.getSingletonFactory(TimeSyncController);\n\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\n\n_FactoryMaker2.default.updateSingletonFactory(TimeSyncController.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"mappings":"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","names":["HTTP_TIMEOUT_MS","DEFAULT_MAXIMUM_ALLOWED_DRIFT","DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR","DEFAULT_BACKGROUND_ATTEMPTS","DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS","DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS","DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC","DEFAULT_MINIMUM_TIME_BETWEEN_SYNC","TimeSyncController","context","eventBus","getInstance","urlUtils","instance","logger","isSynchronizing","isBackgroundSynchronizing","settings","handlers","dashMetrics","backgroundSyncTimeOffsets","timingSources","timeOfLastSync","timeOfLastBackgroundSync","lastOffset","lastTimingSource","internalTimeBetweenSyncAttempts","baseURLController","setup","getLogger","on","Events","ATTEMPT_BACKGROUND_SYNC","_onAttemptBackgroundSync","setConfig","config","_resetInitialSettings","NaN","get","streaming","utcSynchronization","timeBetweenSyncAttempts","initialize","_httpHeadHandler","_httpHandler","bind","_xsdatetimeDecoder","_iso8601Decoder","_directHandler","_notSupportedHandler","attemptSync","tSources","_shouldPerformSynchronization","trigger","TIME_SYNCHRONIZATION_COMPLETED","_attemptRecursiveSync","value","schemeIdUri","isNaN","backgroundAttempts","Date","now","_attemptBackgroundSync","attempts","_completeBackgroundTimeSyncSequence","deviceTimeBeforeSync","serverTime","deviceTimeAfterSync","offset","_calculateOffset","push","e","sourceIndex","index","length","_onComplete","source","hasOwnProperty","getTime","deviceReferenceTime","failed","useManifestDateHeaderTimeSource","_checkForDateHeader","_completeTimeSyncSequence","_alternateXsdatetimeDecoder","xsdatetimeStr","SECONDS_IN_MIN","MINUTES_IN_HOUR","MILLISECONDS_IN_SECONDS","datetimeRegex","utcDate","timezoneOffset","match","exec","UTC","parseInt","parseFloat","parsedDate","parse","isoStr","_rfc1123Decoder","dateStr","url","onSuccessCB","onFailureCB","time","decoder","isHeadRequest","oncomplete","onload","complete","req","XMLHttpRequest","verb","HTTPRequest","HEAD","GET","urls","shift","join","result","status","getResponseHeader","response","isRelative","baseUrl","resolve","open","timeout","onloadend","send","dateHeaderValue","getLatestMPDRequestHeaderValueByID","dateHeaderTime","Number","offsetToDeviceTimeMs","_adjustTimeBetweenSyncAttempts","shouldAttemptBackgroundSync","debug","UPDATE_TIME_SYNC_OFFSET","error","DashJSError","Errors","TIME_SYNC_FAILED_ERROR_CODE","TIME_SYNC_FAILED_ERROR_MESSAGE","isOffsetDriftWithinThreshold","_isOffsetDriftWithinThreshold","timeBetweenSyncAttemptsAdjustmentFactor","maximumTimeBetweenSyncAttempts","minimumTimeBetweenSyncAttempts","adjustedTimeBetweenSyncAttempts","Math","min","max","averageOffset","reduce","acc","curr","maxAllowedDrift","maximumAllowedDrift","lowerBound","upperBound","reset","off","__dashjs_factory_name","factory","FactoryMaker","getSingletonFactory","updateSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/controllers/TimeSyncController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport DashJSError from './../vo/DashJSError';\nimport {HTTPRequest} from '../vo/metrics/HTTPRequest';\nimport EventBus from './../../core/EventBus';\nimport Events from './../../core/events/Events';\nimport Errors from './../../core/errors/Errors';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport URLUtils from '../utils/URLUtils';\n\nconst HTTP_TIMEOUT_MS = 5000;\nconst DEFAULT_MAXIMUM_ALLOWED_DRIFT = 100;\nconst DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR = 2;\nconst DEFAULT_BACKGROUND_ATTEMPTS = 2;\nconst DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS = 30;\nconst DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS = 30;\nconst DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC = 600;\nconst DEFAULT_MINIMUM_TIME_BETWEEN_SYNC = 2;\n\nfunction TimeSyncController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        logger,\n        isSynchronizing,\n        isBackgroundSynchronizing,\n        settings,\n        handlers,\n        dashMetrics,\n        backgroundSyncTimeOffsets,\n        timingSources,\n        timeOfLastSync,\n        timeOfLastBackgroundSync,\n        lastOffset,\n        lastTimingSource,\n        internalTimeBetweenSyncAttempts,\n        baseURLController;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        eventBus.on(Events.ATTEMPT_BACKGROUND_SYNC, _onAttemptBackgroundSync, instance);\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n\n        if (config.baseURLController) {\n            baseURLController = config.baseURLController;\n        }\n\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function _resetInitialSettings() {\n        backgroundSyncTimeOffsets = [];\n        timingSources = [];\n        timeOfLastSync = null;\n        timeOfLastBackgroundSync = null;\n        lastTimingSource = null;\n        lastOffset = NaN;\n        isSynchronizing = false;\n        isBackgroundSynchronizing = false;\n        internalTimeBetweenSyncAttempts = settings.get().streaming.utcSynchronization.timeBetweenSyncAttempts;\n    }\n\n    /**\n     * Register the timing handler depending on the schemeIdUris. This method is called once when the StreamController is initialized\n     */\n    function initialize() {\n        _resetInitialSettings();\n\n        // a list of known schemeIdUris and a method to call with @value\n        handlers = {\n            'urn:mpeg:dash:utc:http-head:2014': _httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2014': _httpHandler.bind(null, _xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2014': _httpHandler.bind(null, _iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2014': _directHandler,\n\n            // some specs referencing early ISO23009-1 drafts incorrectly use\n            // 2012 in the URI, rather than 2014. support these for now.\n            'urn:mpeg:dash:utc:http-head:2012': _httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2012': _httpHandler.bind(null, _xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2012': _httpHandler.bind(null, _iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2012': _directHandler,\n\n            // it isn't clear how the data returned would be formatted, and\n            // no public examples available so http-ntp not supported for now.\n            // presumably you would do an arraybuffer type xhr and decode the\n            // binary data returned but I would want to see a sample first.\n            'urn:mpeg:dash:utc:http-ntp:2014': _notSupportedHandler,\n\n            // not clear how this would be supported in javascript (in browser)\n            'urn:mpeg:dash:utc:ntp:2014': _notSupportedHandler,\n            'urn:mpeg:dash:utc:sntp:2014': _notSupportedHandler\n        };\n\n    }\n\n    /**\n     * Sync against a timing source. T\n     * @param {array} tSources\n     */\n    function attemptSync(tSources) {\n\n        timingSources = tSources;\n\n        // Stop if we are already synchronizing\n        if (isSynchronizing) {\n            return;\n        }\n\n        // No synchronization required we can signal the completion immediately\n        if (!_shouldPerformSynchronization()) {\n            eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED);\n            return;\n        }\n\n        isSynchronizing = true;\n        _attemptRecursiveSync();\n    }\n\n    /**\n     * Does a synchronization in the background in case the last offset should be verified or a 404 occurs\n     */\n    function _onAttemptBackgroundSync() {\n        if (isSynchronizing || isBackgroundSynchronizing || !lastTimingSource || !lastTimingSource.value || !lastTimingSource.schemeIdUri || isNaN(lastOffset) || isNaN(settings.get().streaming.utcSynchronization.backgroundAttempts)) {\n            return;\n        }\n\n        if (timeOfLastBackgroundSync && ((Date.now() - timeOfLastBackgroundSync) / 1000) < DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS) {\n            return;\n        }\n\n        backgroundSyncTimeOffsets = [];\n        isBackgroundSynchronizing = true;\n        const backgroundAttempts = !isNaN(settings.get().streaming.utcSynchronization.backgroundAttempts) ? settings.get().streaming.utcSynchronization.backgroundAttempts : DEFAULT_BACKGROUND_ATTEMPTS;\n        _attemptBackgroundSync(backgroundAttempts);\n    }\n\n    /**\n     * Perform a defined number of background attempts\n     * @param {number} attempts\n     * @private\n     */\n    function _attemptBackgroundSync(attempts) {\n        try {\n            if (attempts <= 0) {\n                _completeBackgroundTimeSyncSequence();\n                return;\n            }\n\n            const deviceTimeBeforeSync = Date.now();\n            handlers[lastTimingSource.schemeIdUri](\n                lastTimingSource.value,\n                function (serverTime) {\n                    // the timing source returned something useful\n                    const deviceTimeAfterSync = Date.now();\n                    const offset = _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime);\n\n                    backgroundSyncTimeOffsets.push(offset);\n                    _attemptBackgroundSync(attempts - 1);\n                },\n                function () {\n                    _completeBackgroundTimeSyncSequence();\n                }\n            );\n        } catch (e) {\n            _completeBackgroundTimeSyncSequence();\n        }\n    }\n\n    /**\n     * Sync against a timing source. This method is called recursively if the time sync for the first entry in timingSources fails.\n     * @param {number} sourceIndex\n     */\n    function _attemptRecursiveSync(sourceIndex = null) {\n        // if called with no sourceIndex, use zero (highest priority)\n        let index = sourceIndex || 0;\n\n        // the sources should be ordered in priority from the manifest.\n        // try each in turn, from the top, until either something\n        // sensible happens, or we run out of sources to try.\n        if (!timingSources || timingSources.length === 0 || index >= timingSources.length) {\n            _onComplete();\n            return;\n        }\n        let source = timingSources[index];\n\n        if (source) {\n            // check if there is a handler for this @schemeIdUri\n            if (handlers.hasOwnProperty(source.schemeIdUri)) {\n                // if so, call it with its @value\n                const deviceTimeBeforeSync = new Date().getTime();\n                handlers[source.schemeIdUri](\n                    source.value,\n                    function (serverTime) {\n                        // the timing source returned something useful\n                        const deviceTimeAfterSync = new Date().getTime();\n                        const offset = _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime);\n                        lastTimingSource = source;\n\n                        _onComplete(offset);\n                    },\n                    function () {\n                        // the timing source was probably uncontactable\n                        // or returned something we can't use - try again\n                        // with the remaining sources\n                        _attemptRecursiveSync(index + 1);\n                    }\n                );\n            } else {\n                // an unknown schemeIdUri must have been found\n                // try again with the remaining sources\n                _attemptRecursiveSync(index + 1);\n            }\n        } else {\n            // no valid time source could be found, just use device time\n            _onComplete();\n        }\n\n    }\n\n    /**\n     * Calculate the offset between client and server. Account for the roundtrip time\n     * @param {number} deviceTimeBeforeSync\n     * @param {number} deviceTimeAfterSync\n     * @param {number} serverTime\n     * @return {number}\n     * @private\n     */\n    function _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime) {\n        const deviceReferenceTime = deviceTimeAfterSync - ((deviceTimeAfterSync - deviceTimeBeforeSync) / 2);\n\n        return serverTime - deviceReferenceTime;\n    }\n\n    /**\n     * Checks if a synchronization is required\n     * @return {boolean}\n     * @private\n     */\n    function _shouldPerformSynchronization() {\n        try {\n            const timeBetweenSyncAttempts = !isNaN(internalTimeBetweenSyncAttempts) ? internalTimeBetweenSyncAttempts : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS;\n\n            if (!timeOfLastSync || !timeBetweenSyncAttempts || isNaN(timeBetweenSyncAttempts)) {\n                return true;\n            }\n\n            return ((Date.now() - timeOfLastSync) / 1000) >= timeBetweenSyncAttempts;\n        } catch (e) {\n            return true;\n        }\n    }\n\n    /**\n     * Callback after sync has been completed\n     * @param {number} offset\n     * @private\n     */\n    function _onComplete(offset = NaN) {\n        let failed = isNaN(offset);\n        if (failed && settings.get().streaming.useManifestDateHeaderTimeSource) {\n            //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\n            _checkForDateHeader();\n        } else {\n            _completeTimeSyncSequence(failed, offset);\n        }\n    }\n\n    /**\n     * Takes xsdatetime and returns milliseconds since UNIX epoch. May not be necessary as xsdatetime is very similar to ISO 8601 which is natively understood by javascript Date parser\n     * @param {string} xsdatetimeStr\n     * @return {number}\n     * @private\n     */\n    function _alternateXsdatetimeDecoder(xsdatetimeStr) {\n        // taken from DashParser - should probably refactor both uses\n        const SECONDS_IN_MIN = 60;\n        const MINUTES_IN_HOUR = 60;\n        const MILLISECONDS_IN_SECONDS = 1000;\n        let datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\n\n        let utcDate,\n            timezoneOffset;\n\n        let match = datetimeRegex.exec(xsdatetimeStr);\n\n        // If the string does not contain a timezone offset different browsers can interpret it either\n        // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\n        // all browsers\n        utcDate = Date.UTC(\n            parseInt(match[1], 10),\n            parseInt(match[2], 10) - 1, // months start from zero\n            parseInt(match[3], 10),\n            parseInt(match[4], 10),\n            parseInt(match[5], 10),\n            (match[6] && (parseInt(match[6], 10) || 0)),\n            (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0\n        );\n        // If the date has timezone offset take it into account as well\n        if (match[9] && match[10]) {\n            timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\n            utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\n        }\n\n        return new Date(utcDate).getTime();\n    }\n\n\n    /**\n     * Try to use the built in parser, since xsdate is a constrained ISO8601 which is supported natively by Date.parse. if that fails, try a regex-based version used elsewhere in this application.\n     * @param {string} xsdatetimeStr\n     * @return {number}\n     */\n    function _xsdatetimeDecoder(xsdatetimeStr) {\n        let parsedDate = Date.parse(xsdatetimeStr);\n\n        if (isNaN(parsedDate)) {\n            parsedDate = _alternateXsdatetimeDecoder(xsdatetimeStr);\n        }\n\n        return parsedDate;\n    }\n\n    /**\n     * Takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\n     * @param {string} isoStr\n     * @return {number}\n     */\n    function _iso8601Decoder(isoStr) {\n        return Date.parse(isoStr);\n    }\n\n    /**\n     * Takes RFC 1123 timestamp (which is same as ISO8601) and returns milliseconds since UNIX epoch\n     * @param {string} dateStr\n     * @return {number}\n     */\n    function _rfc1123Decoder(dateStr) {\n        return Date.parse(dateStr);\n    }\n\n    /**\n     * Handler for unsupported scheme ids.\n     * @param {string} url\n     * @param {function} onSuccessCB\n     * @param {function} onFailureCB\n     * @private\n     */\n    function _notSupportedHandler(url, onSuccessCB, onFailureCB) {\n        onFailureCB();\n    }\n\n    /**\n     * Direct handler\n     * @param {string} xsdatetimeStr\n     * @param {function} onSuccessCB\n     * @param {function} onFailureCB\n     */\n    function _directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\n        let time = _xsdatetimeDecoder(xsdatetimeStr);\n\n        if (!isNaN(time)) {\n            onSuccessCB(time);\n            return;\n        }\n\n        onFailureCB();\n    }\n\n    /**\n     * Generic http handler\n     * @param {function} decoder\n     * @param {string} url\n     * @param {function} onSuccessCB\n     * @param {function} onFailureCB\n     * @param {boolean} isHeadRequest\n     * @private\n     */\n    function _httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\n        let oncomplete,\n            onload;\n        let complete = false;\n        let req = new XMLHttpRequest();\n\n        let verb = isHeadRequest ? HTTPRequest.HEAD : HTTPRequest.GET;\n        let urls = url.match(/\\S+/g);\n\n        // according to ISO 23009-1, url could be a white-space\n        // separated list of URLs. just handle one at a time.\n        url = urls.shift();\n\n        oncomplete = function () {\n            if (complete) {\n                return;\n            }\n\n            // we only want to pass through here once per xhr,\n            // regardless of whether the load was successful.\n            complete = true;\n\n            // if there are more urls to try, call self.\n            if (urls.length) {\n                _httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\n            } else {\n                onFailureCB();\n            }\n        };\n\n        onload = function () {\n            let time,\n                result;\n\n            if (req.status === 200) {\n                time = isHeadRequest ?\n                    req.getResponseHeader('Date') :\n                    req.response;\n\n                result = decoder(time);\n\n                // decoder returns NaN if non-standard input\n                if (!isNaN(result)) {\n                    onSuccessCB(result);\n                    complete = true;\n                }\n            }\n        };\n\n        if (urlUtils.isRelative(url)) {\n            // passing no path to resolve will return just MPD BaseURL/baseUri\n            const baseUrl = baseURLController.resolve();\n            if (baseUrl) {\n                url = urlUtils.resolve(url, baseUrl.url);\n            }\n        }\n\n        req.open(verb, url);\n        req.timeout = HTTP_TIMEOUT_MS || 0;\n        req.onload = onload;\n        req.onloadend = oncomplete;\n        req.send();\n    }\n\n    /**\n     * Handler for http-head schemeIdUri\n     * @param {string} url\n     * @param {function} onSuccessCB\n     * @param {function} onFailureCB\n     * @private\n     */\n    function _httpHeadHandler(url, onSuccessCB, onFailureCB) {\n        _httpHandler(_rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\n    }\n\n    /**\n     * Checks if a date header is present in the MPD response and calculates the offset based on the header\n     * @private\n     */\n    function _checkForDateHeader() {\n        let dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID('Date');\n        let dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\n\n        if (!isNaN(dateHeaderTime)) {\n            const offsetToDeviceTimeMs = dateHeaderTime - Date.now();\n            _completeTimeSyncSequence(false, offsetToDeviceTimeMs);\n        } else {\n            _completeTimeSyncSequence(true);\n        }\n    }\n\n    /**\n     * Triggers the event to signal that the time synchronization was completed\n     * @param {boolean} failed\n     * @param {number} offset\n     * @private\n     */\n    function _completeTimeSyncSequence(failed, offset) {\n\n        // Adjust the time of the next sync based on the drift between current offset and last offset\n        if (!isNaN(lastOffset) && !isNaN(offset) && !failed) {\n            _adjustTimeBetweenSyncAttempts(offset);\n        }\n\n        // Update the internal data\n        if (!failed && !isNaN(offset)) {\n            timeOfLastSync = Date.now();\n            isSynchronizing = false;\n\n            // if this is the first sync we are doing perform background syncs as well to confirm current offset\n            const shouldAttemptBackgroundSync = isNaN(lastOffset);\n            lastOffset = offset;\n            if (shouldAttemptBackgroundSync) {\n                _onAttemptBackgroundSync();\n            }\n            logger.debug(`Completed UTC sync. Setting client - server offset to ${offset}`);\n        }\n\n        if (failed) {\n            lastTimingSource = null;\n        }\n\n        // Notify other classes\n        eventBus.trigger(Events.UPDATE_TIME_SYNC_OFFSET, {\n            offset: offset,\n            error: failed ? new DashJSError(Errors.TIME_SYNC_FAILED_ERROR_CODE, Errors.TIME_SYNC_FAILED_ERROR_MESSAGE) : null\n        });\n        eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED);\n    }\n\n    function _adjustTimeBetweenSyncAttempts(offset) {\n        try {\n            const isOffsetDriftWithinThreshold = _isOffsetDriftWithinThreshold(offset);\n            const timeBetweenSyncAttempts = !isNaN(internalTimeBetweenSyncAttempts) ? internalTimeBetweenSyncAttempts : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS;\n            const timeBetweenSyncAttemptsAdjustmentFactor = !isNaN(settings.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor) ? settings.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR;\n            const maximumTimeBetweenSyncAttempts = !isNaN(settings.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts) ? settings.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts : DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC;\n            const minimumTimeBetweenSyncAttempts = !isNaN(settings.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts) ? settings.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts : DEFAULT_MINIMUM_TIME_BETWEEN_SYNC;\n            let adjustedTimeBetweenSyncAttempts;\n\n            if (isOffsetDriftWithinThreshold) {\n                // The drift between the current offset and the last offset is within the allowed threshold. Increase sync time\n                adjustedTimeBetweenSyncAttempts = Math.min(timeBetweenSyncAttempts * timeBetweenSyncAttemptsAdjustmentFactor, maximumTimeBetweenSyncAttempts);\n                logger.debug(`Increasing timeBetweenSyncAttempts to ${adjustedTimeBetweenSyncAttempts}`);\n            } else {\n                // Drift between the current offset and the last offset is not within the allowed threshold. Decrease sync time\n                adjustedTimeBetweenSyncAttempts = Math.max(timeBetweenSyncAttempts / timeBetweenSyncAttemptsAdjustmentFactor, minimumTimeBetweenSyncAttempts);\n                logger.debug(`Decreasing timeBetweenSyncAttempts to ${adjustedTimeBetweenSyncAttempts}`);\n            }\n\n            internalTimeBetweenSyncAttempts = adjustedTimeBetweenSyncAttempts;\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Callback after all background syncs have been completed.\n     * @private\n     */\n    function _completeBackgroundTimeSyncSequence() {\n        if (!backgroundSyncTimeOffsets || backgroundSyncTimeOffsets.length === 0) {\n            return;\n        }\n\n        const averageOffset = backgroundSyncTimeOffsets.reduce((acc, curr) => {\n            return acc + curr;\n        }, 0) / backgroundSyncTimeOffsets.length;\n\n        if (!_isOffsetDriftWithinThreshold(averageOffset)) {\n            logger.debug(`Completed background UTC sync. Setting client - server offset to ${averageOffset}`);\n            lastOffset = averageOffset;\n            eventBus.trigger(Events.UPDATE_TIME_SYNC_OFFSET, {\n                offset: lastOffset\n            });\n        } else {\n            logger.debug(`Completed background UTC sync. Offset is within allowed threshold and is not adjusted.`);\n        }\n\n        isBackgroundSynchronizing = false;\n        timeOfLastBackgroundSync = Date.now();\n    }\n\n    function _isOffsetDriftWithinThreshold(offset) {\n        try {\n            if (isNaN(lastOffset)) {\n                return true;\n            }\n\n            const maxAllowedDrift = settings.get().streaming.utcSynchronization.maximumAllowedDrift && !isNaN(settings.get().streaming.utcSynchronization.maximumAllowedDrift) ? settings.get().streaming.utcSynchronization.maximumAllowedDrift : DEFAULT_MAXIMUM_ALLOWED_DRIFT;\n            const lowerBound = lastOffset - maxAllowedDrift;\n            const upperBound = lastOffset + maxAllowedDrift;\n\n            return offset >= lowerBound && offset <= upperBound;\n        } catch (e) {\n            return true;\n        }\n    }\n\n    function reset() {\n        _resetInitialSettings();\n\n        eventBus.off(Events.ATTEMPT_BACKGROUND_SYNC, _onAttemptBackgroundSync, instance);\n    }\n\n    instance = {\n        initialize,\n        attemptSync,\n        setConfig,\n        reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\nconst factory = FactoryMaker.getSingletonFactory(TimeSyncController);\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\nFactoryMaker.updateSingletonFactory(TimeSyncController.__dashjs_factory_name, factory);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}