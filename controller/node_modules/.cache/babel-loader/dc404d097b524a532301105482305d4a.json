{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ABRRulesCollection = require('../rules/abr/ABRRulesCollection');\n\nvar _ABRRulesCollection2 = _interopRequireDefault(_ABRRulesCollection);\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _MetricsConstants = require('../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _BitrateInfo = require('../vo/BitrateInfo');\n\nvar _BitrateInfo2 = _interopRequireDefault(_BitrateInfo);\n\nvar _FragmentModel = require('../models/FragmentModel');\n\nvar _FragmentModel2 = _interopRequireDefault(_FragmentModel);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _RulesContext = require('../rules/RulesContext');\n\nvar _RulesContext2 = _interopRequireDefault(_RulesContext);\n\nvar _SwitchRequest = require('../rules/SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _SwitchRequestHistory = require('../rules/SwitchRequestHistory');\n\nvar _SwitchRequestHistory2 = _interopRequireDefault(_SwitchRequestHistory);\n\nvar _DroppedFramesHistory = require('../rules/DroppedFramesHistory');\n\nvar _DroppedFramesHistory2 = _interopRequireDefault(_DroppedFramesHistory);\n\nvar _ThroughputHistory = require('../rules/ThroughputHistory');\n\nvar _ThroughputHistory2 = _interopRequireDefault(_ThroughputHistory);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _HTTPRequest = require('../vo/metrics/HTTPRequest');\n\nvar _SupervisorTools = require('../utils/SupervisorTools');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar DEFAULT_VIDEO_BITRATE = 1000;\nvar DEFAULT_AUDIO_BITRATE = 100;\nvar QUALITY_DEFAULT = 0;\n\nfunction AbrController() {\n  var context = this.context;\n  var debug = (0, _Debug2.default)(context).getInstance();\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      abrRulesCollection = void 0,\n      streamController = void 0,\n      topQualities = void 0,\n      qualityDict = void 0,\n      streamProcessorDict = void 0,\n      abandonmentStateDict = void 0,\n      abandonmentTimeout = void 0,\n      windowResizeEventCalled = void 0,\n      elementWidth = void 0,\n      elementHeight = void 0,\n      adapter = void 0,\n      videoModel = void 0,\n      mediaPlayerModel = void 0,\n      domStorage = void 0,\n      playbackIndex = void 0,\n      switchHistoryDict = void 0,\n      droppedFramesHistory = void 0,\n      throughputHistory = void 0,\n      isUsingBufferOccupancyABRDict = void 0,\n      isUsingL2AABRDict = void 0,\n      isUsingLoLPBRDict = void 0,\n      dashMetrics = void 0,\n      settings = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    resetInitialSettings();\n  }\n\n  function registerStreamType(type, streamProcessor) {\n    switchHistoryDict[type] = switchHistoryDict[type] || (0, _SwitchRequestHistory2.default)(context).create();\n    streamProcessorDict[type] = streamProcessor;\n    abandonmentStateDict[type] = abandonmentStateDict[type] || {};\n    abandonmentStateDict[type].state = _MetricsConstants2.default.ALLOW_LOAD;\n    isUsingBufferOccupancyABRDict[type] = false;\n    isUsingL2AABRDict[type] = false;\n    isUsingLoLPBRDict[type] = false;\n    eventBus.on(_Events2.default.LOADING_PROGRESS, onFragmentLoadProgress, instance);\n\n    if (type === _Constants2.default.VIDEO) {\n      eventBus.on(_Events2.default.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, instance);\n      droppedFramesHistory = droppedFramesHistory || (0, _DroppedFramesHistory2.default)(context).create();\n      setElementSize();\n    }\n\n    eventBus.on(_Events2.default.METRIC_ADDED, onMetricAdded, instance);\n    eventBus.on(_Events2.default.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, instance);\n    throughputHistory = throughputHistory || (0, _ThroughputHistory2.default)(context).create({\n      settings: settings\n    });\n  }\n\n  function unRegisterStreamType(type) {\n    delete streamProcessorDict[type];\n  }\n\n  function createAbrRulesCollection() {\n    abrRulesCollection = (0, _ABRRulesCollection2.default)(context).create({\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      settings: settings\n    });\n    abrRulesCollection.initialize();\n  }\n\n  function resetInitialSettings() {\n    topQualities = {};\n    qualityDict = {};\n    abandonmentStateDict = {};\n    streamProcessorDict = {};\n    switchHistoryDict = {};\n    isUsingBufferOccupancyABRDict = {};\n    isUsingL2AABRDict = {};\n    isUsingLoLPBRDict = {};\n\n    if (windowResizeEventCalled === undefined) {\n      windowResizeEventCalled = false;\n    }\n\n    playbackIndex = undefined;\n    droppedFramesHistory = undefined;\n    throughputHistory = undefined;\n    clearTimeout(abandonmentTimeout);\n    abandonmentTimeout = null;\n  }\n\n  function reset() {\n    resetInitialSettings();\n    eventBus.off(_Events2.default.LOADING_PROGRESS, onFragmentLoadProgress, instance);\n    eventBus.off(_Events2.default.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, instance);\n    eventBus.off(_Events2.default.METRIC_ADDED, onMetricAdded, instance);\n    eventBus.off(_Events2.default.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, instance);\n\n    if (abrRulesCollection) {\n      abrRulesCollection.reset();\n    }\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.streamController) {\n      streamController = config.streamController;\n    }\n\n    if (config.domStorage) {\n      domStorage = config.domStorage;\n    }\n\n    if (config.mediaPlayerModel) {\n      mediaPlayerModel = config.mediaPlayerModel;\n    }\n\n    if (config.dashMetrics) {\n      dashMetrics = config.dashMetrics;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n\n    if (config.videoModel) {\n      videoModel = config.videoModel;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n  }\n\n  function checkConfig() {\n    if (!domStorage || !domStorage.hasOwnProperty('getSavedBitrateSettings')) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n\n  function onQualityChangeRendered(e) {\n    if (e.mediaType === _Constants2.default.VIDEO) {\n      if (playbackIndex !== undefined) {\n        droppedFramesHistory.push(playbackIndex, videoModel.getPlaybackQuality());\n      }\n\n      playbackIndex = e.newQuality;\n    }\n  }\n\n  function onMetricAdded(e) {\n    if (e.metric === _MetricsConstants2.default.HTTP_REQUEST && e.value && e.value.type === _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE && (e.mediaType === _Constants2.default.AUDIO || e.mediaType === _Constants2.default.VIDEO)) {\n      throughputHistory.push(e.mediaType, e.value, settings.get().streaming.abr.useDeadTimeLatency);\n    }\n\n    if (e.metric === _MetricsConstants2.default.BUFFER_LEVEL && (e.mediaType === _Constants2.default.AUDIO || e.mediaType === _Constants2.default.VIDEO)) {\n      _updateAbrStrategy(e.mediaType, 0.001 * e.value.level);\n    }\n  }\n\n  function getTopQualityIndexFor(type, id) {\n    var idx = void 0;\n    topQualities[id] = topQualities[id] || {};\n\n    if (!topQualities[id].hasOwnProperty(type)) {\n      topQualities[id][type] = 0;\n    }\n\n    idx = checkMaxBitrate(topQualities[id][type], type);\n    idx = checkMaxRepresentationRatio(idx, type, topQualities[id][type]);\n    idx = checkPortalSize(idx, type);\n    return idx;\n  }\n  /**\n  * Gets top BitrateInfo for the player\n  * @param {string} type - 'video' or 'audio' are the type options.\n  * @returns {BitrateInfo | null}\n  */\n\n\n  function getTopBitrateInfoFor(type) {\n    if (type && streamProcessorDict && streamProcessorDict[type]) {\n      var streamInfo = streamProcessorDict[type].getStreamInfo();\n\n      if (streamInfo && streamInfo.id) {\n        var idx = getTopQualityIndexFor(type, streamInfo.id);\n        var bitrates = getBitrateList(streamProcessorDict[type].getMediaInfo());\n        return bitrates[idx] ? bitrates[idx] : null;\n      }\n    }\n\n    return null;\n  }\n  /**\n  * @param {string} type\n  * @returns {number} A value of the initial bitrate, kbps\n  * @memberof AbrController#\n  */\n\n\n  function getInitialBitrateFor(type) {\n    checkConfig();\n\n    if (type === _Constants2.default.TEXT || type === _Constants2.default.FRAGMENTED_TEXT) {\n      return NaN;\n    }\n\n    var savedBitrate = domStorage.getSavedBitrateSettings(type);\n    var configBitrate = settings.get().streaming.abr.initialBitrate[type];\n    var configRatio = settings.get().streaming.abr.initialRepresentationRatio[type];\n\n    if (configBitrate === -1) {\n      if (configRatio > -1) {\n        var representation = adapter.getAdaptationForType(0, type).Representation;\n\n        if (Array.isArray(representation)) {\n          var repIdx = Math.max(Math.round(representation.length * configRatio) - 1, 0);\n          configBitrate = representation[repIdx].bandwidth;\n        } else {\n          configBitrate = 0;\n        }\n      } else if (!isNaN(savedBitrate)) {\n        configBitrate = savedBitrate;\n      } else {\n        configBitrate = type === _Constants2.default.VIDEO ? DEFAULT_VIDEO_BITRATE : DEFAULT_AUDIO_BITRATE;\n      }\n    }\n\n    return configBitrate;\n  }\n\n  function getMaxAllowedBitrateFor(type) {\n    return settings.get().streaming.abr.maxBitrate[type];\n  }\n\n  function getMinAllowedBitrateFor(type) {\n    return settings.get().streaming.abr.minBitrate[type];\n  }\n\n  function getMaxAllowedIndexFor(type) {\n    var maxBitrate = getMaxAllowedBitrateFor(type);\n\n    if (maxBitrate > -1) {\n      return getQualityForBitrate(streamProcessorDict[type].getMediaInfo(), maxBitrate);\n    } else {\n      return undefined;\n    }\n  }\n\n  function getMinAllowedIndexFor(type) {\n    var minBitrate = getMinAllowedBitrateFor(type);\n\n    if (minBitrate > -1) {\n      var mediaInfo = streamProcessorDict[type].getMediaInfo();\n      var bitrateList = getBitrateList(mediaInfo); // This returns the quality index <= for the given bitrate\n\n      var minIdx = getQualityForBitrate(mediaInfo, minBitrate);\n\n      if (bitrateList[minIdx] && minIdx < bitrateList.length - 1 && bitrateList[minIdx].bitrate < minBitrate * 1000) {\n        minIdx++; // Go to the next bitrate\n      }\n\n      return minIdx;\n    } else {\n      return undefined;\n    }\n  }\n\n  function checkPlaybackQuality(type) {\n    if (type && streamProcessorDict && streamProcessorDict[type]) {\n      var streamInfo = streamProcessorDict[type].getStreamInfo();\n      var streamId = streamInfo ? streamInfo.id : null;\n      var oldQuality = getQualityFor(type);\n      var rulesContext = (0, _RulesContext2.default)(context).create({\n        abrController: instance,\n        streamProcessor: streamProcessorDict[type],\n        currentValue: oldQuality,\n        switchHistory: switchHistoryDict[type],\n        droppedFramesHistory: droppedFramesHistory,\n        useBufferOccupancyABR: useBufferOccupancyABR(type),\n        useL2AABR: useL2AABR(type),\n        useLoLPABR: useLoLPABR(type),\n        videoModel: videoModel\n      });\n\n      if (droppedFramesHistory) {\n        var playbackQuality = videoModel.getPlaybackQuality();\n\n        if (playbackQuality) {\n          droppedFramesHistory.push(playbackIndex, playbackQuality);\n        }\n      }\n\n      if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n        var minIdx = getMinAllowedIndexFor(type);\n        var topQualityIdx = getTopQualityIndexFor(type, streamId);\n        var switchRequest = abrRulesCollection.getMaxQuality(rulesContext);\n        var newQuality = switchRequest.quality;\n\n        if (minIdx !== undefined && (newQuality > _SwitchRequest2.default.NO_CHANGE ? newQuality : oldQuality) < minIdx) {\n          newQuality = minIdx;\n        }\n\n        if (newQuality > topQualityIdx) {\n          newQuality = topQualityIdx;\n        }\n\n        switchHistoryDict[type].push({\n          oldValue: oldQuality,\n          newValue: newQuality\n        });\n\n        if (newQuality > _SwitchRequest2.default.NO_CHANGE && newQuality != oldQuality) {\n          if (abandonmentStateDict[type].state === _MetricsConstants2.default.ALLOW_LOAD || newQuality > oldQuality) {\n            changeQuality(type, oldQuality, newQuality, topQualityIdx, switchRequest.reason);\n          }\n        } else if (settings.get().debug.logLevel === _Debug2.default.LOG_LEVEL_DEBUG) {\n          var bufferLevel = dashMetrics.getCurrentBufferLevel(type, true);\n          logger.debug('[' + type + '] stay on ' + oldQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ')');\n        }\n      }\n    }\n  }\n\n  function setPlaybackQuality(type, streamInfo, newQuality, reason) {\n    var id = streamInfo.id;\n    var oldQuality = getQualityFor(type);\n    (0, _SupervisorTools.checkInteger)(newQuality);\n    var topQualityIdx = getTopQualityIndexFor(type, id);\n\n    if (newQuality !== oldQuality && newQuality >= 0 && newQuality <= topQualityIdx) {\n      changeQuality(type, oldQuality, newQuality, topQualityIdx, reason);\n    }\n  }\n\n  function changeQuality(type, oldQuality, newQuality, topQualityIdx, reason) {\n    if (type && streamProcessorDict[type]) {\n      var streamInfo = streamProcessorDict[type].getStreamInfo();\n      var id = streamInfo ? streamInfo.id : null;\n\n      if (settings.get().debug.logLevel === _Debug2.default.LOG_LEVEL_DEBUG) {\n        var bufferLevel = dashMetrics.getCurrentBufferLevel(type);\n        logger.info('[' + type + '] switch from ' + oldQuality + ' to ' + newQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ') ' + (reason ? JSON.stringify(reason) : '.'));\n      }\n\n      setQualityFor(type, id, newQuality);\n      eventBus.trigger(_Events2.default.QUALITY_CHANGE_REQUESTED, {\n        oldQuality: oldQuality,\n        newQuality: newQuality,\n        reason: reason\n      }, {\n        streamId: streamInfo.id,\n        mediaType: type\n      });\n      var bitrate = throughputHistory.getAverageThroughput(type);\n\n      if (!isNaN(bitrate)) {\n        domStorage.setSavedBitrateSettings(type, bitrate);\n      }\n    }\n  }\n\n  function setAbandonmentStateFor(type, state) {\n    abandonmentStateDict[type].state = state;\n  }\n\n  function getAbandonmentStateFor(type) {\n    return abandonmentStateDict[type] ? abandonmentStateDict[type].state : null;\n  }\n  /**\n  * @param {MediaInfo} mediaInfo\n  * @param {number} bitrate A bitrate value, kbps\n  * @param {number} latency Expected latency of connection, ms\n  * @returns {number} A quality index <= for the given bitrate\n  * @memberof AbrController#\n  */\n\n\n  function getQualityForBitrate(mediaInfo, bitrate, latency) {\n    var voRepresentation = mediaInfo && mediaInfo.type ? streamProcessorDict[mediaInfo.type].getRepresentationInfo() : null;\n\n    if (settings.get().streaming.abr.useDeadTimeLatency && latency && voRepresentation && voRepresentation.fragmentDuration) {\n      latency = latency / 1000;\n      var fragmentDuration = voRepresentation.fragmentDuration;\n\n      if (latency > fragmentDuration) {\n        return 0;\n      } else {\n        var deadTimeRatio = latency / fragmentDuration;\n        bitrate = bitrate * (1 - deadTimeRatio);\n      }\n    }\n\n    var bitrateList = getBitrateList(mediaInfo);\n\n    for (var i = bitrateList.length - 1; i >= 0; i--) {\n      var bitrateInfo = bitrateList[i];\n\n      if (bitrate * 1000 >= bitrateInfo.bitrate) {\n        return i;\n      }\n    }\n\n    return QUALITY_DEFAULT;\n  }\n  /**\n  * @param {MediaInfo} mediaInfo\n  * @returns {Array|null} A list of {@link BitrateInfo} objects\n  * @memberof AbrController#\n  */\n\n\n  function getBitrateList(mediaInfo) {\n    var infoList = [];\n    if (!mediaInfo || !mediaInfo.bitrateList) return infoList;\n    var bitrateList = mediaInfo.bitrateList;\n    var type = mediaInfo.type;\n    var bitrateInfo = void 0;\n\n    for (var i = 0, ln = bitrateList.length; i < ln; i++) {\n      bitrateInfo = new _BitrateInfo2.default();\n      bitrateInfo.mediaType = type;\n      bitrateInfo.qualityIndex = i;\n      bitrateInfo.bitrate = bitrateList[i].bandwidth;\n      bitrateInfo.width = bitrateList[i].width;\n      bitrateInfo.height = bitrateList[i].height;\n      bitrateInfo.scanType = bitrateList[i].scanType;\n      infoList.push(bitrateInfo);\n    }\n\n    return infoList;\n  }\n\n  function _updateAbrStrategy(mediaType, bufferLevel) {\n    var strategy = settings.get().streaming.abr.ABRStrategy;\n\n    if (strategy === _Constants2.default.ABR_STRATEGY_L2A) {\n      isUsingBufferOccupancyABRDict[mediaType] = false;\n      isUsingLoLPBRDict[mediaType] = false;\n      isUsingL2AABRDict[mediaType] = true;\n      return;\n    }\n\n    if (strategy === _Constants2.default.ABR_STRATEGY_LoLP) {\n      isUsingBufferOccupancyABRDict[mediaType] = false;\n      isUsingLoLPBRDict[mediaType] = true;\n      isUsingL2AABRDict[mediaType] = false;\n      return;\n    } else if (strategy === _Constants2.default.ABR_STRATEGY_BOLA) {\n      isUsingBufferOccupancyABRDict[mediaType] = true;\n      isUsingLoLPBRDict[mediaType] = false;\n      isUsingL2AABRDict[mediaType] = false;\n      return;\n    } else if (strategy === _Constants2.default.ABR_STRATEGY_THROUGHPUT) {\n      isUsingBufferOccupancyABRDict[mediaType] = false;\n      isUsingLoLPBRDict[mediaType] = false;\n      isUsingL2AABRDict[mediaType] = false;\n      return;\n    } // else ABR_STRATEGY_DYNAMIC\n\n\n    _updateDynamicAbrStrategy(mediaType, bufferLevel);\n  }\n\n  function _updateDynamicAbrStrategy(mediaType, bufferLevel) {\n    var stableBufferTime = mediaPlayerModel.getStableBufferTime();\n    var switchOnThreshold = stableBufferTime;\n    var switchOffThreshold = 0.5 * stableBufferTime;\n    var useBufferABR = isUsingBufferOccupancyABRDict[mediaType];\n    var newUseBufferABR = bufferLevel > (useBufferABR ? switchOffThreshold : switchOnThreshold); // use hysteresis to avoid oscillating rules\n\n    isUsingBufferOccupancyABRDict[mediaType] = newUseBufferABR;\n\n    if (newUseBufferABR !== useBufferABR) {\n      if (newUseBufferABR) {\n        logger.info('[' + mediaType + '] switching from throughput to buffer occupancy ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n      } else {\n        logger.info('[' + mediaType + '] switching from buffer occupancy to throughput ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n      }\n    }\n  }\n\n  function useBufferOccupancyABR(mediaType) {\n    return isUsingBufferOccupancyABRDict[mediaType];\n  }\n\n  function useL2AABR(mediaType) {\n    return isUsingL2AABRDict[mediaType];\n  }\n\n  function useLoLPABR(mediaType) {\n    return isUsingLoLPBRDict[mediaType];\n  }\n\n  function getThroughputHistory() {\n    return throughputHistory;\n  }\n\n  function updateTopQualityIndex(mediaInfo) {\n    var type = mediaInfo.type;\n    var streamId = mediaInfo.streamInfo.id;\n    var max = mediaInfo.representationCount - 1;\n    setTopQualityIndex(type, streamId, max);\n    return max;\n  }\n\n  function isPlayingAtTopQuality(streamInfo) {\n    var streamId = streamInfo ? streamInfo.id : null;\n    var audioQuality = getQualityFor(_Constants2.default.AUDIO);\n    var videoQuality = getQualityFor(_Constants2.default.VIDEO);\n    var isAtTop = audioQuality === getTopQualityIndexFor(_Constants2.default.AUDIO, streamId) && videoQuality === getTopQualityIndexFor(_Constants2.default.VIDEO, streamId);\n    return isAtTop;\n  }\n\n  function getQualityFor(type) {\n    if (type && streamProcessorDict[type]) {\n      var streamInfo = streamProcessorDict[type].getStreamInfo();\n      var id = streamInfo ? streamInfo.id : null;\n      var quality = void 0;\n\n      if (id) {\n        qualityDict[id] = qualityDict[id] || {};\n\n        if (!qualityDict[id].hasOwnProperty(type)) {\n          qualityDict[id][type] = QUALITY_DEFAULT;\n        }\n\n        quality = qualityDict[id][type];\n        return quality;\n      }\n    }\n\n    return QUALITY_DEFAULT;\n  }\n\n  function setQualityFor(type, id, value) {\n    qualityDict[id] = qualityDict[id] || {};\n    qualityDict[id][type] = value;\n  }\n\n  function setTopQualityIndex(type, id, value) {\n    topQualities[id] = topQualities[id] || {};\n    topQualities[id][type] = value;\n  }\n\n  function checkMaxBitrate(idx, type) {\n    var newIdx = idx;\n\n    if (!streamProcessorDict[type]) {\n      return newIdx;\n    }\n\n    var minIdx = getMinAllowedIndexFor(type);\n\n    if (minIdx !== undefined) {\n      newIdx = Math.max(idx, minIdx);\n    }\n\n    var maxIdx = getMaxAllowedIndexFor(type);\n\n    if (maxIdx !== undefined) {\n      newIdx = Math.min(newIdx, maxIdx);\n    }\n\n    return newIdx;\n  }\n\n  function checkMaxRepresentationRatio(idx, type, maxIdx) {\n    var maxRepresentationRatio = settings.get().streaming.abr.maxRepresentationRatio[type];\n\n    if (isNaN(maxRepresentationRatio) || maxRepresentationRatio >= 1 || maxRepresentationRatio < 0) {\n      return idx;\n    }\n\n    return Math.min(idx, Math.round(maxIdx * maxRepresentationRatio));\n  }\n\n  function setWindowResizeEventCalled(value) {\n    windowResizeEventCalled = value;\n  }\n\n  function setElementSize() {\n    if (videoModel) {\n      var hasPixelRatio = settings.get().streaming.abr.usePixelRatioInLimitBitrateByPortal && window.hasOwnProperty('devicePixelRatio');\n      var pixelRatio = hasPixelRatio ? window.devicePixelRatio : 1;\n      elementWidth = videoModel.getClientWidth() * pixelRatio;\n      elementHeight = videoModel.getClientHeight() * pixelRatio;\n    }\n  }\n\n  function checkPortalSize(idx, type) {\n    if (type !== _Constants2.default.VIDEO || !settings.get().streaming.abr.limitBitrateByPortal || !streamProcessorDict[type]) {\n      return idx;\n    }\n\n    if (!windowResizeEventCalled) {\n      setElementSize();\n    }\n\n    var representation = adapter.getAdaptationForType(0, type).Representation;\n    var newIdx = idx;\n\n    if (elementWidth > 0 && elementHeight > 0) {\n      while (newIdx > 0 && representation[newIdx] && elementWidth < representation[newIdx].width && elementWidth - representation[newIdx - 1].width < representation[newIdx].width - elementWidth) {\n        newIdx = newIdx - 1;\n      } // Make sure that in case of multiple representation elements have same\n      // resolution, every such element is included\n\n\n      while (newIdx < representation.length - 1 && representation[newIdx].width === representation[newIdx + 1].width) {\n        newIdx = newIdx + 1;\n      }\n    }\n\n    return newIdx;\n  }\n\n  function onFragmentLoadProgress(e) {\n    var type = e.request.mediaType;\n\n    if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n      var streamProcessor = streamProcessorDict[type];\n      if (!streamProcessor) return; // There may be a fragment load in progress when we switch periods and recreated some controllers.\n\n      var rulesContext = (0, _RulesContext2.default)(context).create({\n        abrController: instance,\n        streamProcessor: streamProcessor,\n        currentRequest: e.request,\n        useBufferOccupancyABR: useBufferOccupancyABR(type),\n        useL2AABR: useL2AABR(type),\n        useLoLPABR: useLoLPABR(type),\n        videoModel: videoModel\n      });\n      var switchRequest = abrRulesCollection.shouldAbandonFragment(rulesContext);\n\n      if (switchRequest.quality > _SwitchRequest2.default.NO_CHANGE) {\n        var fragmentModel = streamProcessor.getFragmentModel();\n        var request = fragmentModel.getRequests({\n          state: _FragmentModel2.default.FRAGMENT_MODEL_LOADING,\n          index: e.request.index\n        })[0];\n\n        if (request) {\n          //TODO Check if we should abort or if better to finish download. check bytesLoaded/Total\n          fragmentModel.abortRequests();\n          setAbandonmentStateFor(type, _MetricsConstants2.default.ABANDON_LOAD);\n          switchHistoryDict[type].reset();\n          switchHistoryDict[type].push({\n            oldValue: getQualityFor(type),\n            newValue: switchRequest.quality,\n            confidence: 1,\n            reason: switchRequest.reason\n          });\n          setPlaybackQuality(type, streamController.getActiveStreamInfo(), switchRequest.quality, switchRequest.reason);\n          clearTimeout(abandonmentTimeout);\n          abandonmentTimeout = setTimeout(function () {\n            setAbandonmentStateFor(type, _MetricsConstants2.default.ALLOW_LOAD);\n            abandonmentTimeout = null;\n          }, settings.get().streaming.abandonLoadTimeout);\n        }\n      }\n    }\n  }\n\n  instance = {\n    isPlayingAtTopQuality: isPlayingAtTopQuality,\n    updateTopQualityIndex: updateTopQualityIndex,\n    getThroughputHistory: getThroughputHistory,\n    getBitrateList: getBitrateList,\n    getQualityForBitrate: getQualityForBitrate,\n    getTopBitrateInfoFor: getTopBitrateInfoFor,\n    getMaxAllowedIndexFor: getMaxAllowedIndexFor,\n    getMinAllowedIndexFor: getMinAllowedIndexFor,\n    getInitialBitrateFor: getInitialBitrateFor,\n    getQualityFor: getQualityFor,\n    getAbandonmentStateFor: getAbandonmentStateFor,\n    setPlaybackQuality: setPlaybackQuality,\n    checkPlaybackQuality: checkPlaybackQuality,\n    getTopQualityIndexFor: getTopQualityIndexFor,\n    setElementSize: setElementSize,\n    setWindowResizeEventCalled: setWindowResizeEventCalled,\n    createAbrRulesCollection: createAbrRulesCollection,\n    registerStreamType: registerStreamType,\n    unRegisterStreamType: unRegisterStreamType,\n    setConfig: setConfig,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nAbrController.__dashjs_factory_name = 'AbrController';\n\nvar factory = _FactoryMaker2.default.getSingletonFactory(AbrController);\n\nfactory.QUALITY_DEFAULT = QUALITY_DEFAULT;\n\n_FactoryMaker2.default.updateSingletonFactory(AbrController.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"mappings":"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","names":["DEFAULT_VIDEO_BITRATE","DEFAULT_AUDIO_BITRATE","QUALITY_DEFAULT","AbrController","context","debug","getInstance","eventBus","instance","logger","abrRulesCollection","streamController","topQualities","qualityDict","streamProcessorDict","abandonmentStateDict","abandonmentTimeout","windowResizeEventCalled","elementWidth","elementHeight","adapter","videoModel","mediaPlayerModel","domStorage","playbackIndex","switchHistoryDict","droppedFramesHistory","throughputHistory","isUsingBufferOccupancyABRDict","isUsingL2AABRDict","isUsingLoLPBRDict","dashMetrics","settings","setup","getLogger","resetInitialSettings","registerStreamType","type","streamProcessor","create","state","MetricsConstants","ALLOW_LOAD","on","Events","LOADING_PROGRESS","onFragmentLoadProgress","Constants","VIDEO","QUALITY_CHANGE_RENDERED","onQualityChangeRendered","setElementSize","METRIC_ADDED","onMetricAdded","PERIOD_SWITCH_COMPLETED","createAbrRulesCollection","unRegisterStreamType","initialize","undefined","clearTimeout","reset","off","setConfig","config","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","e","mediaType","push","getPlaybackQuality","newQuality","metric","HTTP_REQUEST","value","HTTPRequest","MEDIA_SEGMENT_TYPE","AUDIO","get","streaming","abr","useDeadTimeLatency","BUFFER_LEVEL","_updateAbrStrategy","level","getTopQualityIndexFor","id","idx","checkMaxBitrate","checkMaxRepresentationRatio","checkPortalSize","getTopBitrateInfoFor","streamInfo","getStreamInfo","bitrates","getBitrateList","getMediaInfo","getInitialBitrateFor","TEXT","FRAGMENTED_TEXT","NaN","savedBitrate","getSavedBitrateSettings","configBitrate","initialBitrate","configRatio","initialRepresentationRatio","representation","getAdaptationForType","Representation","Array","isArray","repIdx","Math","max","round","length","bandwidth","isNaN","getMaxAllowedBitrateFor","maxBitrate","getMinAllowedBitrateFor","minBitrate","getMaxAllowedIndexFor","getQualityForBitrate","getMinAllowedIndexFor","mediaInfo","bitrateList","minIdx","bitrate","checkPlaybackQuality","streamId","oldQuality","getQualityFor","rulesContext","abrController","currentValue","switchHistory","useBufferOccupancyABR","useL2AABR","useLoLPABR","playbackQuality","autoSwitchBitrate","topQualityIdx","switchRequest","getMaxQuality","quality","SwitchRequest","NO_CHANGE","oldValue","newValue","changeQuality","reason","logLevel","Debug","LOG_LEVEL_DEBUG","bufferLevel","getCurrentBufferLevel","setPlaybackQuality","info","JSON","stringify","setQualityFor","trigger","QUALITY_CHANGE_REQUESTED","getAverageThroughput","setSavedBitrateSettings","setAbandonmentStateFor","getAbandonmentStateFor","latency","voRepresentation","getRepresentationInfo","fragmentDuration","deadTimeRatio","i","bitrateInfo","infoList","ln","BitrateInfo","qualityIndex","width","height","scanType","strategy","ABRStrategy","ABR_STRATEGY_L2A","ABR_STRATEGY_LoLP","ABR_STRATEGY_BOLA","ABR_STRATEGY_THROUGHPUT","_updateDynamicAbrStrategy","stableBufferTime","getStableBufferTime","switchOnThreshold","switchOffThreshold","useBufferABR","newUseBufferABR","toFixed","getThroughputHistory","updateTopQualityIndex","representationCount","setTopQualityIndex","isPlayingAtTopQuality","audioQuality","videoQuality","isAtTop","newIdx","maxIdx","min","maxRepresentationRatio","setWindowResizeEventCalled","hasPixelRatio","usePixelRatioInLimitBitrateByPortal","window","pixelRatio","devicePixelRatio","getClientWidth","getClientHeight","limitBitrateByPortal","request","currentRequest","shouldAbandonFragment","fragmentModel","getFragmentModel","getRequests","FragmentModel","FRAGMENT_MODEL_LOADING","index","abortRequests","ABANDON_LOAD","confidence","getActiveStreamInfo","setTimeout","abandonLoadTimeout","__dashjs_factory_name","factory","FactoryMaker","getSingletonFactory","updateSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/controllers/AbrController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport ABRRulesCollection from '../rules/abr/ABRRulesCollection';\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport BitrateInfo from '../vo/BitrateInfo';\nimport FragmentModel from '../models/FragmentModel';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport RulesContext from '../rules/RulesContext';\nimport SwitchRequest from '../rules/SwitchRequest';\nimport SwitchRequestHistory from '../rules/SwitchRequestHistory';\nimport DroppedFramesHistory from '../rules/DroppedFramesHistory';\nimport ThroughputHistory from '../rules/ThroughputHistory';\nimport Debug from '../../core/Debug';\nimport { HTTPRequest } from '../vo/metrics/HTTPRequest';\nimport { checkInteger } from '../utils/SupervisorTools';\n\nconst DEFAULT_VIDEO_BITRATE = 1000;\nconst DEFAULT_AUDIO_BITRATE = 100;\nconst QUALITY_DEFAULT = 0;\n\nfunction AbrController() {\n\n    const context = this.context;\n    const debug = Debug(context).getInstance();\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        abrRulesCollection,\n        streamController,\n        topQualities,\n        qualityDict,\n        streamProcessorDict,\n        abandonmentStateDict,\n        abandonmentTimeout,\n        windowResizeEventCalled,\n        elementWidth,\n        elementHeight,\n        adapter,\n        videoModel,\n        mediaPlayerModel,\n        domStorage,\n        playbackIndex,\n        switchHistoryDict,\n        droppedFramesHistory,\n        throughputHistory,\n        isUsingBufferOccupancyABRDict,\n        isUsingL2AABRDict,\n        isUsingLoLPBRDict,\n        dashMetrics,\n        settings;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n    }\n\n    function registerStreamType(type, streamProcessor) {\n        switchHistoryDict[type] = switchHistoryDict[type] || SwitchRequestHistory(context).create();\n        streamProcessorDict[type] = streamProcessor;\n        abandonmentStateDict[type] = abandonmentStateDict[type] || {};\n        abandonmentStateDict[type].state = MetricsConstants.ALLOW_LOAD;\n        isUsingBufferOccupancyABRDict[type] = false;\n        isUsingL2AABRDict[type] = false;\n        isUsingLoLPBRDict[type] = false;\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, instance);\n        if (type === Constants.VIDEO) {\n            eventBus.on(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, instance);\n            droppedFramesHistory = droppedFramesHistory || DroppedFramesHistory(context).create();\n            setElementSize();\n        }\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.on(Events.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, instance);\n\n        throughputHistory = throughputHistory || ThroughputHistory(context).create({\n            settings: settings\n        });\n    }\n\n    function unRegisterStreamType(type) {\n        delete streamProcessorDict[type];\n    }\n\n    function createAbrRulesCollection() {\n        abrRulesCollection = ABRRulesCollection(context).create({\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            settings: settings\n        });\n\n        abrRulesCollection.initialize();\n    }\n\n    function resetInitialSettings() {\n        topQualities = {};\n        qualityDict = {};\n        abandonmentStateDict = {};\n        streamProcessorDict = {};\n        switchHistoryDict = {};\n        isUsingBufferOccupancyABRDict = {};\n        isUsingL2AABRDict = {};\n        isUsingLoLPBRDict = {};\n        if (windowResizeEventCalled === undefined) {\n            windowResizeEventCalled = false;\n        }\n        playbackIndex = undefined;\n        droppedFramesHistory = undefined;\n        throughputHistory = undefined;\n        clearTimeout(abandonmentTimeout);\n        abandonmentTimeout = null;\n    }\n\n    function reset() {\n\n        resetInitialSettings();\n\n        eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, instance);\n        eventBus.off(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, instance);\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.off(Events.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, instance);\n\n        if (abrRulesCollection) {\n            abrRulesCollection.reset();\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.domStorage) {\n            domStorage = config.domStorage;\n        }\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function checkConfig() {\n        if (!domStorage || !domStorage.hasOwnProperty('getSavedBitrateSettings')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function onQualityChangeRendered(e) {\n        if (e.mediaType === Constants.VIDEO) {\n            if (playbackIndex !== undefined) {\n                droppedFramesHistory.push(playbackIndex, videoModel.getPlaybackQuality());\n            }\n            playbackIndex = e.newQuality;\n        }\n    }\n\n    function onMetricAdded(e) {\n        if (e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) {\n            throughputHistory.push(e.mediaType, e.value, settings.get().streaming.abr.useDeadTimeLatency);\n        }\n\n        if (e.metric === MetricsConstants.BUFFER_LEVEL && (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) {\n            _updateAbrStrategy(e.mediaType, 0.001 * e.value.level);\n        }\n    }\n\n    function getTopQualityIndexFor(type, id) {\n        let idx;\n        topQualities[id] = topQualities[id] || {};\n\n        if (!topQualities[id].hasOwnProperty(type)) {\n            topQualities[id][type] = 0;\n        }\n\n        idx = checkMaxBitrate(topQualities[id][type], type);\n        idx = checkMaxRepresentationRatio(idx, type, topQualities[id][type]);\n        idx = checkPortalSize(idx, type);\n        return idx;\n    }\n\n    /**\n     * Gets top BitrateInfo for the player\n     * @param {string} type - 'video' or 'audio' are the type options.\n     * @returns {BitrateInfo | null}\n     */\n    function getTopBitrateInfoFor(type) {\n        if (type && streamProcessorDict && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            if (streamInfo && streamInfo.id) {\n                const idx = getTopQualityIndexFor(type, streamInfo.id);\n                const bitrates = getBitrateList(streamProcessorDict[type].getMediaInfo());\n                return bitrates[idx] ? bitrates[idx] : null;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param {string} type\n     * @returns {number} A value of the initial bitrate, kbps\n     * @memberof AbrController#\n     */\n    function getInitialBitrateFor(type) {\n        checkConfig();\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT) {\n            return NaN;\n        }\n        const savedBitrate = domStorage.getSavedBitrateSettings(type);\n        let configBitrate = settings.get().streaming.abr.initialBitrate[type];\n        let configRatio = settings.get().streaming.abr.initialRepresentationRatio[type];\n\n        if (configBitrate === -1) {\n            if (configRatio > -1) {\n                const representation = adapter.getAdaptationForType(0, type).Representation;\n                if (Array.isArray(representation)) {\n                    const repIdx = Math.max(Math.round(representation.length * configRatio) - 1, 0);\n                    configBitrate = representation[repIdx].bandwidth;\n                } else {\n                    configBitrate = 0;\n                }\n            } else if (!isNaN(savedBitrate)) {\n                configBitrate = savedBitrate;\n            } else {\n                configBitrate = (type === Constants.VIDEO) ? DEFAULT_VIDEO_BITRATE : DEFAULT_AUDIO_BITRATE;\n            }\n        }\n\n        return configBitrate;\n    }\n\n    function getMaxAllowedBitrateFor(type) {\n        return settings.get().streaming.abr.maxBitrate[type];\n    }\n\n    function getMinAllowedBitrateFor(type) {\n        return settings.get().streaming.abr.minBitrate[type];\n    }\n\n    function getMaxAllowedIndexFor(type) {\n        const maxBitrate = getMaxAllowedBitrateFor(type);\n        if (maxBitrate > -1) {\n            return getQualityForBitrate(streamProcessorDict[type].getMediaInfo(), maxBitrate);\n        } else {\n            return undefined;\n        }\n    }\n\n    function getMinAllowedIndexFor(type) {\n        const minBitrate = getMinAllowedBitrateFor(type);\n\n        if (minBitrate > -1) {\n            const mediaInfo = streamProcessorDict[type].getMediaInfo();\n            const bitrateList = getBitrateList(mediaInfo);\n            // This returns the quality index <= for the given bitrate\n            let minIdx = getQualityForBitrate(mediaInfo, minBitrate);\n            if (bitrateList[minIdx] && minIdx < bitrateList.length - 1 && bitrateList[minIdx].bitrate < minBitrate * 1000) {\n                minIdx++; // Go to the next bitrate\n            }\n            return minIdx;\n        } else {\n            return undefined;\n        }\n    }\n\n    function checkPlaybackQuality(type) {\n        if (type && streamProcessorDict && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const streamId = streamInfo ? streamInfo.id : null;\n            const oldQuality = getQualityFor(type);\n            const rulesContext = RulesContext(context).create({\n                abrController: instance,\n                streamProcessor: streamProcessorDict[type],\n                currentValue: oldQuality,\n                switchHistory: switchHistoryDict[type],\n                droppedFramesHistory: droppedFramesHistory,\n                useBufferOccupancyABR: useBufferOccupancyABR(type),\n                useL2AABR: useL2AABR(type),\n                useLoLPABR: useLoLPABR(type),\n                videoModel\n            });\n\n            if (droppedFramesHistory) {\n                const playbackQuality = videoModel.getPlaybackQuality();\n                if (playbackQuality) {\n                    droppedFramesHistory.push(playbackIndex, playbackQuality);\n                }\n            }\n            if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n                const minIdx = getMinAllowedIndexFor(type);\n                const topQualityIdx = getTopQualityIndexFor(type, streamId);\n                const switchRequest = abrRulesCollection.getMaxQuality(rulesContext);\n                let newQuality = switchRequest.quality;\n                if (minIdx !== undefined && ((newQuality > SwitchRequest.NO_CHANGE) ? newQuality : oldQuality) < minIdx) {\n                    newQuality = minIdx;\n                }\n                if (newQuality > topQualityIdx) {\n                    newQuality = topQualityIdx;\n                }\n\n                switchHistoryDict[type].push({ oldValue: oldQuality, newValue: newQuality });\n\n                if (newQuality > SwitchRequest.NO_CHANGE && newQuality != oldQuality) {\n                    if (abandonmentStateDict[type].state === MetricsConstants.ALLOW_LOAD || newQuality > oldQuality) {\n                        changeQuality(type, oldQuality, newQuality, topQualityIdx, switchRequest.reason);\n                    }\n                } else if (settings.get().debug.logLevel === Debug.LOG_LEVEL_DEBUG) {\n                    const bufferLevel = dashMetrics.getCurrentBufferLevel(type, true);\n                    logger.debug('[' + type + '] stay on ' + oldQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ')');\n                }\n            }\n        }\n    }\n\n    function setPlaybackQuality(type, streamInfo, newQuality, reason) {\n        const id = streamInfo.id;\n        const oldQuality = getQualityFor(type);\n\n        checkInteger(newQuality);\n\n        const topQualityIdx = getTopQualityIndexFor(type, id);\n        if (newQuality !== oldQuality && newQuality >= 0 && newQuality <= topQualityIdx) {\n            changeQuality(type, oldQuality, newQuality, topQualityIdx, reason);\n        }\n    }\n\n    function changeQuality(type, oldQuality, newQuality, topQualityIdx, reason) {\n        if (type && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const id = streamInfo ? streamInfo.id : null;\n            if (settings.get().debug.logLevel === Debug.LOG_LEVEL_DEBUG) {\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(type);\n                logger.info('[' + type + '] switch from ' + oldQuality + ' to ' + newQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ') ' + (reason ? JSON.stringify(reason) : '.'));\n            }\n            setQualityFor(type, id, newQuality);\n            eventBus.trigger(Events.QUALITY_CHANGE_REQUESTED,\n                {\n                    oldQuality: oldQuality,\n                    newQuality: newQuality,\n                    reason: reason\n                },\n                { streamId: streamInfo.id, mediaType: type }\n            );\n            const bitrate = throughputHistory.getAverageThroughput(type);\n            if (!isNaN(bitrate)) {\n                domStorage.setSavedBitrateSettings(type, bitrate);\n            }\n        }\n    }\n\n    function setAbandonmentStateFor(type, state) {\n        abandonmentStateDict[type].state = state;\n    }\n\n    function getAbandonmentStateFor(type) {\n        return abandonmentStateDict[type] ? abandonmentStateDict[type].state : null;\n    }\n\n    /**\n     * @param {MediaInfo} mediaInfo\n     * @param {number} bitrate A bitrate value, kbps\n     * @param {number} latency Expected latency of connection, ms\n     * @returns {number} A quality index <= for the given bitrate\n     * @memberof AbrController#\n     */\n    function getQualityForBitrate(mediaInfo, bitrate, latency) {\n        const voRepresentation = mediaInfo && mediaInfo.type ? streamProcessorDict[mediaInfo.type].getRepresentationInfo() : null;\n\n        if (settings.get().streaming.abr.useDeadTimeLatency && latency && voRepresentation && voRepresentation.fragmentDuration) {\n            latency = latency / 1000;\n            const fragmentDuration = voRepresentation.fragmentDuration;\n            if (latency > fragmentDuration) {\n                return 0;\n            } else {\n                const deadTimeRatio = latency / fragmentDuration;\n                bitrate = bitrate * (1 - deadTimeRatio);\n            }\n        }\n\n        const bitrateList = getBitrateList(mediaInfo);\n\n        for (let i = bitrateList.length - 1; i >= 0; i--) {\n            const bitrateInfo = bitrateList[i];\n            if (bitrate * 1000 >= bitrateInfo.bitrate) {\n                return i;\n            }\n        }\n        return QUALITY_DEFAULT;\n    }\n\n    /**\n     * @param {MediaInfo} mediaInfo\n     * @returns {Array|null} A list of {@link BitrateInfo} objects\n     * @memberof AbrController#\n     */\n    function getBitrateList(mediaInfo) {\n        const infoList = [];\n        if (!mediaInfo || !mediaInfo.bitrateList) return infoList;\n\n        const bitrateList = mediaInfo.bitrateList;\n        const type = mediaInfo.type;\n\n        let bitrateInfo;\n\n        for (let i = 0, ln = bitrateList.length; i < ln; i++) {\n            bitrateInfo = new BitrateInfo();\n            bitrateInfo.mediaType = type;\n            bitrateInfo.qualityIndex = i;\n            bitrateInfo.bitrate = bitrateList[i].bandwidth;\n            bitrateInfo.width = bitrateList[i].width;\n            bitrateInfo.height = bitrateList[i].height;\n            bitrateInfo.scanType = bitrateList[i].scanType;\n            infoList.push(bitrateInfo);\n        }\n\n        return infoList;\n    }\n\n    function _updateAbrStrategy(mediaType, bufferLevel) {\n        const strategy = settings.get().streaming.abr.ABRStrategy;\n\n        if (strategy === Constants.ABR_STRATEGY_L2A) {\n            isUsingBufferOccupancyABRDict[mediaType] = false;\n            isUsingLoLPBRDict[mediaType] = false;\n            isUsingL2AABRDict[mediaType] = true;\n            return;\n        }\n        if (strategy === Constants.ABR_STRATEGY_LoLP) {\n            isUsingBufferOccupancyABRDict[mediaType] = false;\n            isUsingLoLPBRDict[mediaType] = true;\n            isUsingL2AABRDict[mediaType] = false;\n            return;\n        } else if (strategy === Constants.ABR_STRATEGY_BOLA) {\n            isUsingBufferOccupancyABRDict[mediaType] = true;\n            isUsingLoLPBRDict[mediaType] = false;\n            isUsingL2AABRDict[mediaType] = false;\n            return;\n        } else if (strategy === Constants.ABR_STRATEGY_THROUGHPUT) {\n            isUsingBufferOccupancyABRDict[mediaType] = false;\n            isUsingLoLPBRDict[mediaType] = false;\n            isUsingL2AABRDict[mediaType] = false;\n            return;\n        }\n        // else ABR_STRATEGY_DYNAMIC\n        _updateDynamicAbrStrategy(mediaType, bufferLevel);\n    }\n\n    function _updateDynamicAbrStrategy(mediaType, bufferLevel) {\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        const switchOnThreshold = stableBufferTime;\n        const switchOffThreshold = 0.5 * stableBufferTime;\n\n        const useBufferABR = isUsingBufferOccupancyABRDict[mediaType];\n        const newUseBufferABR = bufferLevel > (useBufferABR ? switchOffThreshold : switchOnThreshold); // use hysteresis to avoid oscillating rules\n        isUsingBufferOccupancyABRDict[mediaType] = newUseBufferABR;\n\n        if (newUseBufferABR !== useBufferABR) {\n            if (newUseBufferABR) {\n                logger.info('[' + mediaType + '] switching from throughput to buffer occupancy ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n            } else {\n                logger.info('[' + mediaType + '] switching from buffer occupancy to throughput ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n            }\n        }\n    }\n\n    function useBufferOccupancyABR(mediaType) {\n        return isUsingBufferOccupancyABRDict[mediaType];\n    }\n\n    function useL2AABR(mediaType) {\n        return isUsingL2AABRDict[mediaType];\n    }\n\n    function useLoLPABR(mediaType) {\n        return isUsingLoLPBRDict[mediaType];\n    }\n\n    function getThroughputHistory() {\n        return throughputHistory;\n    }\n\n    function updateTopQualityIndex(mediaInfo) {\n        const type = mediaInfo.type;\n        const streamId = mediaInfo.streamInfo.id;\n        const max = mediaInfo.representationCount - 1;\n\n        setTopQualityIndex(type, streamId, max);\n\n        return max;\n    }\n\n    function isPlayingAtTopQuality(streamInfo) {\n        const streamId = streamInfo ? streamInfo.id : null;\n        const audioQuality = getQualityFor(Constants.AUDIO);\n        const videoQuality = getQualityFor(Constants.VIDEO);\n\n        const isAtTop = (audioQuality === getTopQualityIndexFor(Constants.AUDIO, streamId)) &&\n            (videoQuality === getTopQualityIndexFor(Constants.VIDEO, streamId));\n\n        return isAtTop;\n    }\n\n    function getQualityFor(type) {\n        if (type && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const id = streamInfo ? streamInfo.id : null;\n            let quality;\n\n            if (id) {\n                qualityDict[id] = qualityDict[id] || {};\n\n                if (!qualityDict[id].hasOwnProperty(type)) {\n                    qualityDict[id][type] = QUALITY_DEFAULT;\n                }\n\n                quality = qualityDict[id][type];\n                return quality;\n            }\n        }\n        return QUALITY_DEFAULT;\n    }\n\n    function setQualityFor(type, id, value) {\n        qualityDict[id] = qualityDict[id] || {};\n        qualityDict[id][type] = value;\n    }\n\n    function setTopQualityIndex(type, id, value) {\n        topQualities[id] = topQualities[id] || {};\n        topQualities[id][type] = value;\n    }\n\n    function checkMaxBitrate(idx, type) {\n        let newIdx = idx;\n\n        if (!streamProcessorDict[type]) {\n            return newIdx;\n        }\n\n        const minIdx = getMinAllowedIndexFor(type);\n        if (minIdx !== undefined) {\n            newIdx = Math.max(idx, minIdx);\n        }\n\n        const maxIdx = getMaxAllowedIndexFor(type);\n        if (maxIdx !== undefined) {\n            newIdx = Math.min(newIdx, maxIdx);\n        }\n\n        return newIdx;\n    }\n\n    function checkMaxRepresentationRatio(idx, type, maxIdx) {\n        const maxRepresentationRatio = settings.get().streaming.abr.maxRepresentationRatio[type];\n        if (isNaN(maxRepresentationRatio) || maxRepresentationRatio >= 1 || maxRepresentationRatio < 0) {\n            return idx;\n        }\n        return Math.min(idx, Math.round(maxIdx * maxRepresentationRatio));\n    }\n\n    function setWindowResizeEventCalled(value) {\n        windowResizeEventCalled = value;\n    }\n\n    function setElementSize() {\n        if (videoModel) {\n            const hasPixelRatio = settings.get().streaming.abr.usePixelRatioInLimitBitrateByPortal && window.hasOwnProperty('devicePixelRatio');\n            const pixelRatio = hasPixelRatio ? window.devicePixelRatio : 1;\n            elementWidth = videoModel.getClientWidth() * pixelRatio;\n            elementHeight = videoModel.getClientHeight() * pixelRatio;\n        }\n    }\n\n    function checkPortalSize(idx, type) {\n        if (type !== Constants.VIDEO || !settings.get().streaming.abr.limitBitrateByPortal || !streamProcessorDict[type]) {\n            return idx;\n        }\n\n        if (!windowResizeEventCalled) {\n            setElementSize();\n        }\n\n        const representation = adapter.getAdaptationForType(0, type).Representation;\n        let newIdx = idx;\n\n        if (elementWidth > 0 && elementHeight > 0) {\n            while (\n                newIdx > 0 &&\n                representation[newIdx] &&\n                elementWidth < representation[newIdx].width &&\n                elementWidth - representation[newIdx - 1].width < representation[newIdx].width - elementWidth) {\n                newIdx = newIdx - 1;\n            }\n\n            // Make sure that in case of multiple representation elements have same\n            // resolution, every such element is included\n            while (newIdx < representation.length - 1 && representation[newIdx].width === representation[newIdx + 1].width) {\n                newIdx = newIdx + 1;\n            }\n        }\n\n        return newIdx;\n    }\n\n    function onFragmentLoadProgress(e) {\n        const type = e.request.mediaType;\n        if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n            const streamProcessor = streamProcessorDict[type];\n            if (!streamProcessor) return; // There may be a fragment load in progress when we switch periods and recreated some controllers.\n\n            const rulesContext = RulesContext(context).create({\n                abrController: instance,\n                streamProcessor: streamProcessor,\n                currentRequest: e.request,\n                useBufferOccupancyABR: useBufferOccupancyABR(type),\n                useL2AABR: useL2AABR(type),\n                useLoLPABR: useLoLPABR(type),\n                videoModel\n            });\n            const switchRequest = abrRulesCollection.shouldAbandonFragment(rulesContext);\n\n            if (switchRequest.quality > SwitchRequest.NO_CHANGE) {\n                const fragmentModel = streamProcessor.getFragmentModel();\n                const request = fragmentModel.getRequests({\n                    state: FragmentModel.FRAGMENT_MODEL_LOADING,\n                    index: e.request.index\n                })[0];\n                if (request) {\n                    //TODO Check if we should abort or if better to finish download. check bytesLoaded/Total\n                    fragmentModel.abortRequests();\n                    setAbandonmentStateFor(type, MetricsConstants.ABANDON_LOAD);\n                    switchHistoryDict[type].reset();\n                    switchHistoryDict[type].push({\n                        oldValue: getQualityFor(type),\n                        newValue: switchRequest.quality,\n                        confidence: 1,\n                        reason: switchRequest.reason\n                    });\n                    setPlaybackQuality(type, streamController.getActiveStreamInfo(), switchRequest.quality, switchRequest.reason);\n\n                    clearTimeout(abandonmentTimeout);\n                    abandonmentTimeout = setTimeout(\n                        () => {\n                            setAbandonmentStateFor(type, MetricsConstants.ALLOW_LOAD);\n                            abandonmentTimeout = null;\n                        },\n                        settings.get().streaming.abandonLoadTimeout\n                    );\n                }\n            }\n        }\n    }\n\n    instance = {\n        isPlayingAtTopQuality: isPlayingAtTopQuality,\n        updateTopQualityIndex: updateTopQualityIndex,\n        getThroughputHistory: getThroughputHistory,\n        getBitrateList: getBitrateList,\n        getQualityForBitrate: getQualityForBitrate,\n        getTopBitrateInfoFor: getTopBitrateInfoFor,\n        getMaxAllowedIndexFor: getMaxAllowedIndexFor,\n        getMinAllowedIndexFor: getMinAllowedIndexFor,\n        getInitialBitrateFor: getInitialBitrateFor,\n        getQualityFor: getQualityFor,\n        getAbandonmentStateFor: getAbandonmentStateFor,\n        setPlaybackQuality: setPlaybackQuality,\n        checkPlaybackQuality: checkPlaybackQuality,\n        getTopQualityIndexFor: getTopQualityIndexFor,\n        setElementSize: setElementSize,\n        setWindowResizeEventCalled: setWindowResizeEventCalled,\n        createAbrRulesCollection: createAbrRulesCollection,\n        registerStreamType: registerStreamType,\n        unRegisterStreamType: unRegisterStreamType,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nAbrController.__dashjs_factory_name = 'AbrController';\nconst factory = FactoryMaker.getSingletonFactory(AbrController);\nfactory.QUALITY_DEFAULT = QUALITY_DEFAULT;\nFactoryMaker.updateSingletonFactory(AbrController.__dashjs_factory_name, factory);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}