{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Debug = require('../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _DashJSError = require('./vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _EventBus = require('../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _TextController = require('./text/TextController');\n\nvar _TextController2 = _interopRequireDefault(_TextController);\n\nvar _Errors = require('../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar MAX_ALLOWED_DISCONTINUITY = 0.1; // 100 milliseconds\n\n/**\n * @class SourceBufferSink\n * @ignore\n * @implements FragmentSink\n */\n\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\nfunction SourceBufferSink(mediaSource, mediaInfo, onAppendedCallback, oldBuffer) {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      type = void 0,\n      logger = void 0,\n      buffer = void 0,\n      isAppendingInProgress = void 0,\n      intervalId = void 0;\n  var callbacks = [];\n  var appendQueue = [];\n  var onAppended = onAppendedCallback;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    isAppendingInProgress = false;\n    type = mediaInfo.type;\n    var codec = mediaInfo.codec;\n\n    try {\n      // Safari claims to support anything starting 'application/mp4'.\n      // it definitely doesn't understand 'application/mp4;codecs=\"stpp\"'\n      // - currently no browser does, so check for it and use our own\n      // implementation. The same is true for codecs=\"wvtt\".\n      if (codec.match(/application\\/mp4;\\s*codecs=\"(stpp|wvtt).*\"/i)) {\n        throw new Error('not really supported');\n      }\n\n      buffer = oldBuffer ? oldBuffer : mediaSource.addSourceBuffer(codec);\n\n      if (buffer.changeType && oldBuffer) {\n        logger.debug('Doing period transition with changeType');\n        buffer.changeType(codec);\n      }\n\n      updateAppendWindow();\n      var CHECK_INTERVAL = 50; // use updateend event if possible\n\n      if (typeof buffer.addEventListener === 'function') {\n        try {\n          buffer.addEventListener('updateend', updateEndHandler, false);\n          buffer.addEventListener('error', errHandler, false);\n          buffer.addEventListener('abort', errHandler, false);\n        } catch (err) {\n          // use setInterval to periodically check if updating has been completed\n          intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n        }\n      } else {\n        // use setInterval to periodically check if updating has been completed\n        intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n      }\n    } catch (ex) {\n      // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt\n      if (mediaInfo.isText || codec.indexOf('codecs=\"stpp') !== -1 || codec.indexOf('codecs=\"wvtt') !== -1) {\n        var textController = (0, _TextController2.default)(context).getInstance();\n        buffer = textController.getTextSourceBuffer();\n      } else {\n        throw ex;\n      }\n    }\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function reset(keepBuffer) {\n    if (buffer) {\n      if (typeof buffer.removeEventListener === 'function') {\n        buffer.removeEventListener('updateend', updateEndHandler, false);\n        buffer.removeEventListener('error', errHandler, false);\n        buffer.removeEventListener('abort', errHandler, false);\n      }\n\n      clearInterval(intervalId);\n      callbacks = [];\n\n      if (!keepBuffer) {\n        try {\n          if (!buffer.getClassName || buffer.getClassName() !== 'TextSourceBuffer') {\n            logger.debug('Removing sourcebuffer from media source');\n            mediaSource.removeSourceBuffer(buffer);\n          }\n        } catch (e) {\n          logger.error('Failed to remove source buffer from media source.');\n        }\n\n        buffer = null;\n      }\n\n      isAppendingInProgress = false;\n    }\n\n    appendQueue = [];\n    onAppended = null;\n  }\n\n  function getBuffer() {\n    return buffer;\n  }\n\n  function getAllBufferRanges() {\n    try {\n      return buffer.buffered;\n    } catch (e) {\n      logger.error('getAllBufferRanges exception: ' + e.message);\n      return null;\n    }\n  }\n\n  function hasDiscontinuitiesAfter(time) {\n    try {\n      var ranges = getAllBufferRanges();\n\n      if (ranges && ranges.length > 1) {\n        for (var i = 0, len = ranges.length; i < len; i++) {\n          if (i > 0) {\n            if (time < ranges.start(i) && ranges.start(i) > ranges.end(i - 1) + MAX_ALLOWED_DISCONTINUITY) {\n              return true;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      logger.error('hasDiscontinuities exception: ' + e.message);\n    }\n\n    return false;\n  }\n\n  function append(chunk) {\n    if (!chunk) {\n      onAppended({\n        chunk: chunk,\n        error: new _DashJSError2.default(_Errors2.default.APPEND_ERROR_CODE, _Errors2.default.APPEND_ERROR_MESSAGE)\n      });\n      return;\n    }\n\n    appendQueue.push(chunk);\n\n    if (!isAppendingInProgress) {\n      waitForUpdateEnd(appendNextInQueue.bind(this));\n    }\n  }\n\n  function updateTimestampOffset(MSETimeOffset) {\n    if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n      waitForUpdateEnd(function () {\n        if (MSETimeOffset < 0) {\n          MSETimeOffset += 0.001;\n        }\n\n        buffer.timestampOffset = MSETimeOffset;\n      });\n    }\n  }\n\n  function updateAppendWindow(sInfo) {\n    if (!buffer) {\n      return;\n    }\n\n    waitForUpdateEnd(function () {\n      try {\n        var appendWindowEnd = mediaSource.duration;\n        var appendWindowStart = 0;\n\n        if (sInfo && !isNaN(sInfo.start) && !isNaN(sInfo.duration) && isFinite(sInfo.duration)) {\n          appendWindowEnd = sInfo.start + sInfo.duration;\n        }\n\n        if (sInfo && !isNaN(sInfo.start)) {\n          appendWindowStart = sInfo.start;\n        }\n\n        buffer.appendWindowStart = 0;\n        buffer.appendWindowEnd = appendWindowEnd;\n        buffer.appendWindowStart = appendWindowStart;\n        logger.debug('Updated append window. Set start to ' + buffer.appendWindowStart + ' and end to ' + buffer.appendWindowEnd);\n      } catch (e) {\n        logger.warn('Failed to set append window');\n      }\n    });\n  }\n\n  function remove(start, end, forceRemoval) {\n    var sourceBufferSink = this; // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\n\n    waitForUpdateEnd(function () {\n      try {\n        if (start >= 0 && end > start && (forceRemoval || mediaSource.readyState !== 'ended')) {\n          buffer.remove(start, end);\n        } // updating is in progress, we should wait for it to complete before signaling that this operation is done\n\n\n        waitForUpdateEnd(function () {\n          eventBus.trigger(_Events2.default.SOURCEBUFFER_REMOVE_COMPLETED, {\n            buffer: sourceBufferSink,\n            from: start,\n            to: end,\n            unintended: false\n          });\n        });\n      } catch (err) {\n        eventBus.trigger(_Events2.default.SOURCEBUFFER_REMOVE_COMPLETED, {\n          buffer: sourceBufferSink,\n          from: start,\n          to: end,\n          unintended: false,\n          error: new _DashJSError2.default(err.code, err.message)\n        });\n      }\n    });\n  }\n\n  function appendNextInQueue() {\n    var sourceBufferSink = this;\n\n    if (appendQueue.length > 0) {\n      isAppendingInProgress = true;\n      var nextChunk = appendQueue[0];\n      appendQueue.splice(0, 1);\n      var oldRanges = [];\n\n      var afterSuccess = function afterSuccess() {\n        // Safari sometimes drops a portion of a buffer after appending. Handle these situations here\n        var newRanges = getAllBufferRanges();\n        checkBufferGapsAfterAppend(sourceBufferSink, oldRanges, newRanges, nextChunk);\n\n        if (appendQueue.length > 0) {\n          appendNextInQueue.call(this);\n        } else {\n          isAppendingInProgress = false;\n\n          if (onAppended) {\n            onAppended({\n              chunk: nextChunk\n            });\n          }\n        }\n      };\n\n      try {\n        if (nextChunk.bytes.length === 0) {\n          afterSuccess.call(this);\n        } else {\n          oldRanges = getAllBufferRanges();\n\n          if (buffer.appendBuffer) {\n            buffer.appendBuffer(nextChunk.bytes);\n          } else {\n            buffer.append(nextChunk.bytes, nextChunk);\n          } // updating is in progress, we should wait for it to complete before signaling that this operation is done\n\n\n          waitForUpdateEnd(afterSuccess.bind(this));\n        }\n      } catch (err) {\n        logger.fatal('SourceBuffer append failed \"' + err + '\"');\n\n        if (appendQueue.length > 0) {\n          appendNextInQueue();\n        } else {\n          isAppendingInProgress = false;\n        }\n\n        if (onAppended) {\n          onAppended({\n            chunk: nextChunk,\n            error: new _DashJSError2.default(err.code, err.message)\n          });\n        }\n      }\n    }\n  }\n\n  function checkBufferGapsAfterAppend(buffer, oldRanges, newRanges, chunk) {\n    if (oldRanges && oldRanges.length > 0 && oldRanges.length < newRanges.length && isChunkAlignedWithRange(oldRanges, chunk)) {\n      // A split in the range was created while appending\n      eventBus.trigger(_Events2.default.SOURCEBUFFER_REMOVE_COMPLETED, {\n        buffer: buffer,\n        from: newRanges.end(newRanges.length - 2),\n        to: newRanges.start(newRanges.length - 1),\n        unintended: true\n      });\n    }\n  }\n\n  function isChunkAlignedWithRange(oldRanges, chunk) {\n    for (var i = 0; i < oldRanges.length; i++) {\n      var start = Math.round(oldRanges.start(i));\n      var end = Math.round(oldRanges.end(i));\n\n      if (end === chunk.start || start === chunk.end || chunk.start >= start && chunk.end <= end) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function abort() {\n    try {\n      if (mediaSource.readyState === 'open') {\n        buffer.abort();\n      } else if (buffer.setTextTrack && mediaSource.readyState === 'ended') {\n        buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort()\n      }\n    } catch (ex) {\n      logger.error('SourceBuffer append abort failed: \"' + ex + '\"');\n    }\n\n    appendQueue = [];\n  }\n\n  function executeCallback() {\n    if (callbacks.length > 0) {\n      var cb = callbacks.shift();\n\n      if (buffer.updating) {\n        waitForUpdateEnd(cb);\n      } else {\n        cb(); // Try to execute next callback if still not updating\n\n        executeCallback();\n      }\n    }\n  }\n\n  function checkIsUpdateEnded() {\n    // if updating is still in progress do nothing and wait for the next check again.\n    if (buffer.updating) return; // updating is completed, now we can stop checking and resolve the promise\n\n    executeCallback();\n  }\n\n  function updateEndHandler() {\n    if (buffer.updating) return;\n    executeCallback();\n  }\n\n  function errHandler() {\n    logger.error('SourceBufferSink error');\n  }\n\n  function waitForUpdateEnd(callback) {\n    callbacks.push(callback);\n\n    if (!buffer.updating) {\n      executeCallback();\n    }\n  }\n\n  instance = {\n    getType: getType,\n    getAllBufferRanges: getAllBufferRanges,\n    getBuffer: getBuffer,\n    append: append,\n    remove: remove,\n    abort: abort,\n    reset: reset,\n    updateTimestampOffset: updateTimestampOffset,\n    hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\n    waitForUpdateEnd: waitForUpdateEnd,\n    updateAppendWindow: updateAppendWindow\n  };\n  setup();\n  return instance;\n}\n\nSourceBufferSink.__dashjs_factory_name = 'SourceBufferSink';\n\nvar factory = _FactoryMaker2.default.getClassFactory(SourceBufferSink);\n\nexports.default = factory;","map":{"version":3,"mappings":"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","names":["MAX_ALLOWED_DISCONTINUITY","SourceBufferSink","mediaSource","mediaInfo","onAppendedCallback","oldBuffer","context","eventBus","getInstance","instance","type","logger","buffer","isAppendingInProgress","intervalId","callbacks","appendQueue","onAppended","setup","getLogger","codec","match","Error","addSourceBuffer","changeType","debug","updateAppendWindow","CHECK_INTERVAL","addEventListener","updateEndHandler","errHandler","err","setInterval","checkIsUpdateEnded","ex","isText","indexOf","textController","getTextSourceBuffer","getType","reset","keepBuffer","removeEventListener","clearInterval","getClassName","removeSourceBuffer","e","error","getBuffer","getAllBufferRanges","buffered","message","hasDiscontinuitiesAfter","time","ranges","length","i","len","start","end","append","chunk","DashJSError","Errors","APPEND_ERROR_CODE","APPEND_ERROR_MESSAGE","push","waitForUpdateEnd","appendNextInQueue","bind","updateTimestampOffset","MSETimeOffset","timestampOffset","isNaN","sInfo","appendWindowEnd","duration","appendWindowStart","isFinite","warn","remove","forceRemoval","sourceBufferSink","readyState","trigger","Events","SOURCEBUFFER_REMOVE_COMPLETED","from","to","unintended","code","nextChunk","splice","oldRanges","afterSuccess","newRanges","checkBufferGapsAfterAppend","call","bytes","appendBuffer","fatal","isChunkAlignedWithRange","Math","round","abort","setTextTrack","executeCallback","cb","shift","updating","callback","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/SourceBufferSink.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport DashJSError from './vo/DashJSError';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport FactoryMaker from '../core/FactoryMaker';\nimport TextController from './text/TextController';\nimport Errors from '../core/errors/Errors';\n\nconst MAX_ALLOWED_DISCONTINUITY = 0.1; // 100 milliseconds\n\n/**\n * @class SourceBufferSink\n * @ignore\n * @implements FragmentSink\n */\nfunction SourceBufferSink(mediaSource, mediaInfo, onAppendedCallback, oldBuffer) {\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        type,\n        logger,\n        buffer,\n        isAppendingInProgress,\n        intervalId;\n\n    let callbacks = [];\n    let appendQueue = [];\n    let onAppended = onAppendedCallback;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        isAppendingInProgress = false;\n\n        type = mediaInfo.type;\n        const codec = mediaInfo.codec;\n        try {\n            // Safari claims to support anything starting 'application/mp4'.\n            // it definitely doesn't understand 'application/mp4;codecs=\"stpp\"'\n            // - currently no browser does, so check for it and use our own\n            // implementation. The same is true for codecs=\"wvtt\".\n            if (codec.match(/application\\/mp4;\\s*codecs=\"(stpp|wvtt).*\"/i)) {\n                throw new Error('not really supported');\n            }\n            buffer = oldBuffer ? oldBuffer : mediaSource.addSourceBuffer(codec);\n            if (buffer.changeType && oldBuffer) {\n                logger.debug('Doing period transition with changeType');\n                buffer.changeType(codec);\n            }\n\n            updateAppendWindow();\n\n            const CHECK_INTERVAL = 50;\n            // use updateend event if possible\n            if (typeof buffer.addEventListener === 'function') {\n                try {\n                    buffer.addEventListener('updateend', updateEndHandler, false);\n                    buffer.addEventListener('error', errHandler, false);\n                    buffer.addEventListener('abort', errHandler, false);\n\n                } catch (err) {\n                    // use setInterval to periodically check if updating has been completed\n                    intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n                }\n            } else {\n                // use setInterval to periodically check if updating has been completed\n                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n            }\n        } catch (ex) {\n            // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt\n            if ((mediaInfo.isText) || (codec.indexOf('codecs=\"stpp') !== -1) || (codec.indexOf('codecs=\"wvtt') !== -1)) {\n                const textController = TextController(context).getInstance();\n                buffer = textController.getTextSourceBuffer();\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function reset(keepBuffer) {\n        if (buffer) {\n            if (typeof buffer.removeEventListener === 'function') {\n                buffer.removeEventListener('updateend', updateEndHandler, false);\n                buffer.removeEventListener('error', errHandler, false);\n                buffer.removeEventListener('abort', errHandler, false);\n            }\n            clearInterval(intervalId);\n            callbacks = [];\n            if (!keepBuffer) {\n                try {\n                    if (!buffer.getClassName || buffer.getClassName() !== 'TextSourceBuffer') {\n                        logger.debug(`Removing sourcebuffer from media source`);\n                        mediaSource.removeSourceBuffer(buffer);\n                    }\n                } catch (e) {\n                    logger.error('Failed to remove source buffer from media source.');\n                }\n                buffer = null;\n            }\n            isAppendingInProgress = false;\n        }\n        appendQueue = [];\n        onAppended = null;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function getAllBufferRanges() {\n        try {\n            return buffer.buffered;\n        } catch (e) {\n            logger.error('getAllBufferRanges exception: ' + e.message);\n            return null;\n        }\n    }\n\n    function hasDiscontinuitiesAfter(time) {\n        try {\n            const ranges = getAllBufferRanges();\n            if (ranges && ranges.length > 1) {\n                for (let i = 0, len = ranges.length; i < len; i++) {\n                    if (i > 0) {\n                        if (time < ranges.start(i) && ranges.start(i) > ranges.end(i - 1) + MAX_ALLOWED_DISCONTINUITY) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n            logger.error('hasDiscontinuities exception: ' + e.message);\n        }\n        return false;\n    }\n\n    function append(chunk) {\n        if (!chunk) {\n            onAppended({\n                chunk: chunk,\n                error: new DashJSError(Errors.APPEND_ERROR_CODE, Errors.APPEND_ERROR_MESSAGE)\n            });\n            return;\n        }\n        appendQueue.push(chunk);\n        if (!isAppendingInProgress) {\n            waitForUpdateEnd(appendNextInQueue.bind(this));\n        }\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            waitForUpdateEnd(() => {\n                if (MSETimeOffset < 0) {\n                    MSETimeOffset += 0.001;\n                }\n                buffer.timestampOffset = MSETimeOffset;\n            });\n        }\n    }\n\n    function updateAppendWindow(sInfo) {\n        if (!buffer) {\n            return;\n        }\n        waitForUpdateEnd(() => {\n            try {\n                let appendWindowEnd = mediaSource.duration;\n                let appendWindowStart = 0;\n                if (sInfo && !isNaN(sInfo.start) && !isNaN(sInfo.duration) && isFinite(sInfo.duration)) {\n                    appendWindowEnd = sInfo.start + sInfo.duration;\n                }\n                if (sInfo && !isNaN(sInfo.start)) {\n                    appendWindowStart = sInfo.start;\n                }\n                buffer.appendWindowStart = 0;\n                buffer.appendWindowEnd = appendWindowEnd;\n                buffer.appendWindowStart = appendWindowStart;\n                logger.debug(`Updated append window. Set start to ${buffer.appendWindowStart} and end to ${buffer.appendWindowEnd}`);\n            } catch (e) {\n                logger.warn(`Failed to set append window`);\n            }\n        });\n    }\n\n    function remove(start, end, forceRemoval) {\n        const sourceBufferSink = this;\n        // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\n        waitForUpdateEnd(function () {\n            try {\n                if ((start >= 0) && (end > start) && (forceRemoval || mediaSource.readyState !== 'ended')) {\n                    buffer.remove(start, end);\n                }\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                waitForUpdateEnd(function () {\n                    eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                        buffer: sourceBufferSink,\n                        from: start,\n                        to: end,\n                        unintended: false\n                    });\n                });\n            } catch (err) {\n                eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                    buffer: sourceBufferSink,\n                    from: start,\n                    to: end,\n                    unintended: false,\n                    error: new DashJSError(err.code, err.message)\n                });\n            }\n        });\n    }\n\n    function appendNextInQueue() {\n        const sourceBufferSink = this;\n\n        if (appendQueue.length > 0) {\n            isAppendingInProgress = true;\n            const nextChunk = appendQueue[0];\n            appendQueue.splice(0, 1);\n            let oldRanges = [];\n            const afterSuccess = function () {\n                // Safari sometimes drops a portion of a buffer after appending. Handle these situations here\n                const newRanges = getAllBufferRanges();\n                checkBufferGapsAfterAppend(sourceBufferSink, oldRanges, newRanges, nextChunk);\n                if (appendQueue.length > 0) {\n                    appendNextInQueue.call(this);\n                } else {\n                    isAppendingInProgress = false;\n                    if (onAppended) {\n                        onAppended({\n                            chunk: nextChunk\n                        });\n                    }\n                }\n            };\n\n            try {\n                if (nextChunk.bytes.length === 0) {\n                    afterSuccess.call(this);\n                } else {\n                    oldRanges = getAllBufferRanges();\n                    if (buffer.appendBuffer) {\n                        buffer.appendBuffer(nextChunk.bytes);\n                    } else {\n                        buffer.append(nextChunk.bytes, nextChunk);\n                    }\n                    // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                    waitForUpdateEnd(afterSuccess.bind(this));\n                }\n            } catch (err) {\n                logger.fatal('SourceBuffer append failed \"' + err + '\"');\n                if (appendQueue.length > 0) {\n                    appendNextInQueue();\n                } else {\n                    isAppendingInProgress = false;\n                }\n\n                if (onAppended) {\n                    onAppended({\n                        chunk: nextChunk,\n                        error: new DashJSError(err.code, err.message)\n                    });\n                }\n            }\n        }\n    }\n\n    function checkBufferGapsAfterAppend(buffer, oldRanges, newRanges, chunk) {\n        if (oldRanges && oldRanges.length > 0 && oldRanges.length < newRanges.length &&\n            isChunkAlignedWithRange(oldRanges, chunk)) {\n            // A split in the range was created while appending\n            eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                buffer: buffer,\n                from: newRanges.end(newRanges.length - 2),\n                to: newRanges.start(newRanges.length - 1),\n                unintended: true\n            });\n        }\n    }\n\n    function isChunkAlignedWithRange(oldRanges, chunk) {\n        for (let i = 0; i < oldRanges.length; i++) {\n            const start = Math.round(oldRanges.start(i));\n            const end = Math.round(oldRanges.end(i));\n            if (end === chunk.start || start === chunk.end || (chunk.start >= start && chunk.end <= end)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function abort() {\n        try {\n            if (mediaSource.readyState === 'open') {\n                buffer.abort();\n            } else if (buffer.setTextTrack && mediaSource.readyState === 'ended') {\n                buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort()\n            }\n        } catch (ex) {\n            logger.error('SourceBuffer append abort failed: \"' + ex + '\"');\n        }\n        appendQueue = [];\n    }\n\n    function executeCallback() {\n        if (callbacks.length > 0) {\n            const cb = callbacks.shift();\n            if (buffer.updating) {\n                waitForUpdateEnd(cb);\n            } else {\n                cb();\n                // Try to execute next callback if still not updating\n                executeCallback();\n            }\n        }\n    }\n\n    function checkIsUpdateEnded() {\n        // if updating is still in progress do nothing and wait for the next check again.\n        if (buffer.updating) return;\n        // updating is completed, now we can stop checking and resolve the promise\n        executeCallback();\n    }\n\n    function updateEndHandler() {\n        if (buffer.updating) return;\n\n        executeCallback();\n    }\n\n    function errHandler() {\n        logger.error('SourceBufferSink error');\n    }\n\n    function waitForUpdateEnd(callback) {\n        callbacks.push(callback);\n\n        if (!buffer.updating) {\n            executeCallback();\n        }\n    }\n\n    instance = {\n        getType: getType,\n        getAllBufferRanges: getAllBufferRanges,\n        getBuffer: getBuffer,\n        append: append,\n        remove: remove,\n        abort: abort,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset,\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\n        waitForUpdateEnd: waitForUpdateEnd,\n        updateAppendWindow\n    };\n\n    setup();\n\n    return instance;\n}\n\nSourceBufferSink.__dashjs_factory_name = 'SourceBufferSink';\nconst factory = FactoryMaker.getClassFactory(SourceBufferSink);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}