{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ProtectionKeyController = require('../controllers/ProtectionKeyController');\n\nvar _ProtectionKeyController2 = _interopRequireDefault(_ProtectionKeyController);\n\nvar _NeedKey = require('../vo/NeedKey');\n\nvar _NeedKey2 = _interopRequireDefault(_NeedKey);\n\nvar _ProtectionErrors = require('../errors/ProtectionErrors');\n\nvar _ProtectionErrors2 = _interopRequireDefault(_ProtectionErrors);\n\nvar _DashJSError = require('../../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _KeyMessage = require('../vo/KeyMessage');\n\nvar _KeyMessage2 = _interopRequireDefault(_KeyMessage);\n\nvar _KeySystemAccess = require('../vo/KeySystemAccess');\n\nvar _KeySystemAccess2 = _interopRequireDefault(_KeySystemAccess);\n\nvar _ProtectionConstants = require('../../constants/ProtectionConstants');\n\nvar _ProtectionConstants2 = _interopRequireDefault(_ProtectionConstants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ProtectionModel_21Jan2015(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = config.eventBus; //Need to pass in here so we can use same instance since this is optional module\n\n  var events = config.events;\n  var debug = config.debug;\n  var instance = void 0,\n      logger = void 0,\n      keySystem = void 0,\n      videoElement = void 0,\n      mediaKeys = void 0,\n      sessions = void 0,\n      eventHandler = void 0,\n      protectionKeyController = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    keySystem = null;\n    videoElement = null;\n    mediaKeys = null;\n    sessions = [];\n    protectionKeyController = (0, _ProtectionKeyController2.default)(context).getInstance();\n    eventHandler = createEventHandler();\n  }\n\n  function reset() {\n    var numSessions = sessions.length;\n    var session = void 0;\n\n    if (numSessions !== 0) {\n      (function () {\n        // Called when we are done closing a session.  Success or fail\n        var done = function done(session) {\n          removeSession(session);\n\n          if (sessions.length === 0) {\n            if (videoElement) {\n              videoElement.removeEventListener('encrypted', eventHandler);\n              videoElement.setMediaKeys(null).then(function () {\n                eventBus.trigger(events.TEARDOWN_COMPLETE);\n              });\n            } else {\n              eventBus.trigger(events.TEARDOWN_COMPLETE);\n            }\n          }\n        };\n\n        for (var i = 0; i < numSessions; i++) {\n          session = sessions[i];\n\n          (function (s) {\n            // Override closed promise resolver\n            session.session.closed.then(function () {\n              done(s);\n            }); // Close the session and handle errors, otherwise promise\n            // resolver above will be called\n\n            closeKeySessionInternal(session).catch(function () {\n              done(s);\n            });\n          })(session);\n        }\n      })();\n    } else {\n      eventBus.trigger(events.TEARDOWN_COMPLETE);\n    }\n  }\n\n  function stop() {\n    // Close and remove not usable sessions\n    var session = void 0;\n\n    for (var i = 0; i < sessions.length; i++) {\n      session = sessions[i];\n\n      if (!session.getUsable()) {\n        closeKeySessionInternal(session).catch(function () {\n          removeSession(session);\n        });\n      }\n    }\n  }\n\n  function getKeySystem() {\n    return keySystem;\n  }\n\n  function getAllInitData() {\n    var retVal = [];\n\n    for (var i = 0; i < sessions.length; i++) {\n      if (sessions[i].initData) {\n        retVal.push(sessions[i].initData);\n      }\n    }\n\n    return retVal;\n  }\n\n  function requestKeySystemAccess(ksConfigurations) {\n    requestKeySystemAccessInternal(ksConfigurations, 0);\n  }\n\n  function selectKeySystem(keySystemAccess) {\n    keySystemAccess.mksa.createMediaKeys().then(function (mkeys) {\n      keySystem = keySystemAccess.keySystem;\n      mediaKeys = mkeys;\n\n      if (videoElement) {\n        videoElement.setMediaKeys(mediaKeys).then(function () {\n          eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n        });\n      } else {\n        eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n      }\n    }).catch(function () {\n      eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED, {\n        error: 'Error selecting keys system (' + keySystemAccess.keySystem.systemString + ')! Could not create MediaKeys -- TODO'\n      });\n    });\n  }\n\n  function setMediaElement(mediaElement) {\n    if (videoElement === mediaElement) return; // Replacing the previous element\n\n    if (videoElement) {\n      videoElement.removeEventListener('encrypted', eventHandler);\n\n      if (videoElement.setMediaKeys) {\n        videoElement.setMediaKeys(null);\n      }\n    }\n\n    videoElement = mediaElement; // Only if we are not detaching from the existing element\n\n    if (videoElement) {\n      videoElement.addEventListener('encrypted', eventHandler);\n\n      if (videoElement.setMediaKeys && mediaKeys) {\n        videoElement.setMediaKeys(mediaKeys);\n      }\n    }\n  }\n\n  function setServerCertificate(serverCertificate) {\n    if (!keySystem || !mediaKeys) {\n      throw new Error('Can not set server certificate until you have selected a key system');\n    }\n\n    mediaKeys.setServerCertificate(serverCertificate).then(function () {\n      logger.info('DRM: License server certificate successfully updated.');\n      eventBus.trigger(events.SERVER_CERTIFICATE_UPDATED);\n    }).catch(function (error) {\n      eventBus.trigger(events.SERVER_CERTIFICATE_UPDATED, {\n        error: new _DashJSError2.default(_ProtectionErrors2.default.SERVER_CERTIFICATE_UPDATED_ERROR_CODE, _ProtectionErrors2.default.SERVER_CERTIFICATE_UPDATED_ERROR_MESSAGE + error.name)\n      });\n    });\n  }\n\n  function createKeySession(initData, protData, sessionType) {\n    if (!keySystem || !mediaKeys) {\n      throw new Error('Can not create sessions until you have selected a key system');\n    }\n\n    var session = mediaKeys.createSession(sessionType);\n    var sessionToken = createSessionToken(session, initData, sessionType);\n    var ks = this.getKeySystem(); // Generate initial key request.\n    // keyids type is used for clearkey when keys are provided directly in the protection data and then request to a license server is not needed\n\n    var dataType = ks.systemString === _ProtectionConstants2.default.CLEARKEY_KEYSTEM_STRING && (initData || protData && protData.clearkeys) ? 'keyids' : 'cenc';\n    session.generateRequest(dataType, initData).then(function () {\n      logger.debug('DRM: Session created.  SessionID = ' + sessionToken.getSessionID());\n      eventBus.trigger(events.KEY_SESSION_CREATED, {\n        data: sessionToken\n      });\n    }).catch(function (error) {\n      // TODO: Better error string\n      removeSession(sessionToken);\n      eventBus.trigger(events.KEY_SESSION_CREATED, {\n        data: null,\n        error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_CODE, _ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Error generating key request -- ' + error.name)\n      });\n    });\n  }\n\n  function updateKeySession(sessionToken, message) {\n    var session = sessionToken.session; // Send our request to the key session\n\n    if (protectionKeyController.isClearKey(keySystem)) {\n      message = message.toJWK();\n    }\n\n    session.update(message).catch(function (error) {\n      eventBus.trigger(events.KEY_ERROR, {\n        data: new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEYERR_CODE, 'Error sending update() message! ' + error.name, sessionToken)\n      });\n    });\n  }\n\n  function loadKeySession(sessionID, initData, sessionType) {\n    if (!keySystem || !mediaKeys) {\n      throw new Error('Can not load sessions until you have selected a key system');\n    } // Check if session Id is not already loaded or loading\n\n\n    for (var i = 0; i < sessions.length; i++) {\n      if (sessionID === sessions[i].sessionId) {\n        logger.warn('DRM: Ignoring session ID because we have already seen it!');\n        return;\n      }\n    }\n\n    var session = mediaKeys.createSession(sessionType);\n    var sessionToken = createSessionToken(session, initData, sessionType, sessionID); // Load persisted session data into our newly created session object\n\n    session.load(sessionID).then(function (success) {\n      if (success) {\n        logger.debug('DRM: Session loaded.  SessionID = ' + sessionToken.getSessionID());\n        eventBus.trigger(events.KEY_SESSION_CREATED, {\n          data: sessionToken\n        });\n      } else {\n        removeSession(sessionToken);\n        eventBus.trigger(events.KEY_SESSION_CREATED, {\n          data: null,\n          error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_CODE, _ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Could not load session! Invalid Session ID (' + sessionID + ')')\n        });\n      }\n    }).catch(function (error) {\n      removeSession(sessionToken);\n      eventBus.trigger(events.KEY_SESSION_CREATED, {\n        data: null,\n        error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_CODE, _ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Could not load session (' + sessionID + ')! ' + error.name)\n      });\n    });\n  }\n\n  function removeKeySession(sessionToken) {\n    var session = sessionToken.session;\n    session.remove().then(function () {\n      logger.debug('DRM: Session removed.  SessionID = ' + sessionToken.getSessionID());\n      eventBus.trigger(events.KEY_SESSION_REMOVED, {\n        data: sessionToken.getSessionID()\n      });\n    }, function (error) {\n      eventBus.trigger(events.KEY_SESSION_REMOVED, {\n        data: null,\n        error: 'Error removing session (' + sessionToken.getSessionID() + '). ' + error.name\n      });\n    });\n  }\n\n  function closeKeySession(sessionToken) {\n    // Send our request to the key session\n    closeKeySessionInternal(sessionToken).catch(function (error) {\n      removeSession(sessionToken);\n      eventBus.trigger(events.KEY_SESSION_CLOSED, {\n        data: null,\n        error: 'Error closing session (' + sessionToken.getSessionID() + ') ' + error.name\n      });\n    });\n  }\n\n  function requestKeySystemAccessInternal(ksConfigurations, idx) {\n    if (navigator.requestMediaKeySystemAccess === undefined || typeof navigator.requestMediaKeySystemAccess !== 'function') {\n      eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {\n        error: 'Insecure origins are not allowed'\n      });\n      return;\n    }\n\n    (function (i) {\n      var keySystem = ksConfigurations[i].ks;\n      var configs = ksConfigurations[i].configs;\n      var systemString = keySystem.systemString; // PATCH to support persistent licenses on Edge browser (see issue #2658)\n\n      if (systemString === _ProtectionConstants2.default.PLAYREADY_KEYSTEM_STRING && configs[0].persistentState === 'required') {\n        systemString += '.recommendation';\n      }\n\n      navigator.requestMediaKeySystemAccess(systemString, configs).then(function (mediaKeySystemAccess) {\n        // Chrome 40 does not currently implement MediaKeySystemAccess.getConfiguration()\n        var configuration = typeof mediaKeySystemAccess.getConfiguration === 'function' ? mediaKeySystemAccess.getConfiguration() : null;\n        var keySystemAccess = new _KeySystemAccess2.default(keySystem, configuration);\n        keySystemAccess.mksa = mediaKeySystemAccess;\n        eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {\n          data: keySystemAccess\n        });\n      }).catch(function (error) {\n        if (++i < ksConfigurations.length) {\n          requestKeySystemAccessInternal(ksConfigurations, i);\n        } else {\n          eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {\n            error: 'Key system access denied! ' + error.message\n          });\n        }\n      });\n    })(idx);\n  }\n\n  function closeKeySessionInternal(sessionToken) {\n    var session = sessionToken.session; // Remove event listeners\n\n    session.removeEventListener('keystatuseschange', sessionToken);\n    session.removeEventListener('message', sessionToken); // Send our request to the key session\n\n    return session.close();\n  } // This is our main event handler for all desired HTMLMediaElement events\n  // related to EME.  These events are translated into our API-independent\n  // versions of the same events\n\n\n  function createEventHandler() {\n    return {\n      handleEvent: function handleEvent(event) {\n        switch (event.type) {\n          case 'encrypted':\n            if (event.initData) {\n              var initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n              eventBus.trigger(events.NEED_KEY, {\n                key: new _NeedKey2.default(initData, event.initDataType)\n              });\n            }\n\n            break;\n        }\n      }\n    };\n  }\n\n  function removeSession(token) {\n    // Remove from our session list\n    for (var i = 0; i < sessions.length; i++) {\n      if (sessions[i] === token) {\n        sessions.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  function parseKeyStatus(args) {\n    // Edge and Chrome implement different version of keystatues, param are not on same order\n    var status = void 0,\n        keyId = void 0;\n\n    if (args && args.length > 0) {\n      if (args[0]) {\n        if (typeof args[0] === 'string') {\n          status = args[0];\n        } else {\n          keyId = args[0];\n        }\n      }\n\n      if (args[1]) {\n        if (typeof args[1] === 'string') {\n          status = args[1];\n        } else {\n          keyId = args[1];\n        }\n      }\n    }\n\n    return {\n      status: status,\n      keyId: keyId\n    };\n  } // Function to create our session token objects which manage the EME\n  // MediaKeySession and session-specific event handler\n\n\n  function createSessionToken(session, initData, sessionType, sessionID) {\n    var token = {\n      // Implements SessionToken\n      session: session,\n      initData: initData,\n      sessionId: sessionID,\n      // This is our main event handler for all desired MediaKeySession events\n      // These events are translated into our API-independent versions of the\n      // same events\n      handleEvent: function handleEvent(event) {\n        switch (event.type) {\n          case 'keystatuseschange':\n            eventBus.trigger(events.KEY_STATUSES_CHANGED, {\n              data: this\n            });\n            event.target.keyStatuses.forEach(function () {\n              var keyStatus = parseKeyStatus(arguments);\n\n              switch (keyStatus.status) {\n                case 'expired':\n                  eventBus.trigger(events.INTERNAL_KEY_STATUS_CHANGED, {\n                    error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE, _ProtectionErrors2.default.KEY_STATUS_CHANGED_EXPIRED_ERROR_MESSAGE)\n                  });\n                  break;\n\n                default:\n                  eventBus.trigger(events.INTERNAL_KEY_STATUS_CHANGED, keyStatus);\n                  break;\n              }\n            });\n            break;\n\n          case 'message':\n            var message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n            eventBus.trigger(events.INTERNAL_KEY_MESSAGE, {\n              data: new _KeyMessage2.default(this, message, undefined, event.messageType)\n            });\n            break;\n        }\n      },\n      getSessionID: function getSessionID() {\n        return session.sessionId;\n      },\n      getExpirationTime: function getExpirationTime() {\n        return session.expiration;\n      },\n      getKeyStatuses: function getKeyStatuses() {\n        return session.keyStatuses;\n      },\n      getUsable: function getUsable() {\n        var usable = false;\n        session.keyStatuses.forEach(function () {\n          var keyStatus = parseKeyStatus(arguments);\n\n          if (keyStatus.status === 'usable') {\n            usable = true;\n          }\n        });\n        return usable;\n      },\n      getSessionType: function getSessionType() {\n        return sessionType;\n      }\n    }; // Add all event listeners\n\n    session.addEventListener('keystatuseschange', token);\n    session.addEventListener('message', token); // Register callback for session closed Promise\n\n    session.closed.then(function () {\n      removeSession(token);\n      logger.debug('DRM: Session closed.  SessionID = ' + token.getSessionID());\n      eventBus.trigger(events.KEY_SESSION_CLOSED, {\n        data: token.getSessionID()\n      });\n    }); // Add to our session list\n\n    sessions.push(token);\n    return token;\n  }\n\n  instance = {\n    getAllInitData: getAllInitData,\n    requestKeySystemAccess: requestKeySystemAccess,\n    getKeySystem: getKeySystem,\n    selectKeySystem: selectKeySystem,\n    setMediaElement: setMediaElement,\n    setServerCertificate: setServerCertificate,\n    createKeySession: createKeySession,\n    updateKeySession: updateKeySession,\n    loadKeySession: loadKeySession,\n    removeKeySession: removeKeySession,\n    closeKeySession: closeKeySession,\n    stop: stop,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Most recent EME implementation\n*\n* Implemented by Google Chrome v36+ (Windows, OSX, Linux)\n*\n* @implements ProtectionModel\n* @class\n*/\n\n\nProtectionModel_21Jan2015.__dashjs_factory_name = 'ProtectionModel_21Jan2015';\nexports.default = dashjs.FactoryMaker.getClassFactory(ProtectionModel_21Jan2015);\n/* jshint ignore:line */","map":{"version":3,"mappings":"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","names":["ProtectionModel_21Jan2015","config","context","eventBus","events","debug","instance","logger","keySystem","videoElement","mediaKeys","sessions","eventHandler","protectionKeyController","setup","getLogger","getInstance","createEventHandler","reset","numSessions","length","session","done","removeSession","removeEventListener","setMediaKeys","then","trigger","TEARDOWN_COMPLETE","i","s","closed","closeKeySessionInternal","catch","stop","getUsable","getKeySystem","getAllInitData","retVal","initData","push","requestKeySystemAccess","ksConfigurations","requestKeySystemAccessInternal","selectKeySystem","keySystemAccess","mksa","createMediaKeys","mkeys","INTERNAL_KEY_SYSTEM_SELECTED","error","systemString","setMediaElement","mediaElement","addEventListener","setServerCertificate","serverCertificate","Error","info","SERVER_CERTIFICATE_UPDATED","DashJSError","ProtectionErrors","SERVER_CERTIFICATE_UPDATED_ERROR_CODE","SERVER_CERTIFICATE_UPDATED_ERROR_MESSAGE","name","createKeySession","protData","sessionType","createSession","sessionToken","createSessionToken","ks","dataType","ProtectionConstants","CLEARKEY_KEYSTEM_STRING","clearkeys","generateRequest","getSessionID","KEY_SESSION_CREATED","data","KEY_SESSION_CREATED_ERROR_CODE","KEY_SESSION_CREATED_ERROR_MESSAGE","updateKeySession","message","isClearKey","toJWK","update","KEY_ERROR","MEDIA_KEYERR_CODE","loadKeySession","sessionID","sessionId","warn","load","success","removeKeySession","remove","KEY_SESSION_REMOVED","closeKeySession","KEY_SESSION_CLOSED","idx","navigator","requestMediaKeySystemAccess","undefined","KEY_SYSTEM_ACCESS_COMPLETE","configs","PLAYREADY_KEYSTEM_STRING","persistentState","mediaKeySystemAccess","configuration","getConfiguration","KeySystemAccess","close","handleEvent","event","type","ArrayBuffer","isView","buffer","NEED_KEY","key","NeedKey","initDataType","token","splice","parseKeyStatus","args","status","keyId","KEY_STATUSES_CHANGED","target","keyStatuses","forEach","keyStatus","arguments","INTERNAL_KEY_STATUS_CHANGED","KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE","KEY_STATUS_CHANGED_EXPIRED_ERROR_MESSAGE","INTERNAL_KEY_MESSAGE","KeyMessage","messageType","getExpirationTime","expiration","getKeyStatuses","usable","getSessionType","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/protection/models/ProtectionModel_21Jan2015.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Most recent EME implementation\n *\n * Implemented by Google Chrome v36+ (Windows, OSX, Linux)\n *\n * @implements ProtectionModel\n * @class\n */\nimport ProtectionKeyController from '../controllers/ProtectionKeyController';\nimport NeedKey from '../vo/NeedKey';\nimport ProtectionErrors from '../errors/ProtectionErrors';\nimport DashJSError from '../../vo/DashJSError';\nimport KeyMessage from '../vo/KeyMessage';\nimport KeySystemAccess from '../vo/KeySystemAccess';\nimport ProtectionConstants from '../../constants/ProtectionConstants';\n\nfunction ProtectionModel_21Jan2015(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = config.eventBus;//Need to pass in here so we can use same instance since this is optional module\n    const events = config.events;\n    const debug = config.debug;\n\n    let instance,\n        logger,\n        keySystem,\n        videoElement,\n        mediaKeys,\n        sessions,\n        eventHandler,\n        protectionKeyController;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        keySystem = null;\n        videoElement = null;\n        mediaKeys = null;\n        sessions = [];\n        protectionKeyController = ProtectionKeyController(context).getInstance();\n        eventHandler = createEventHandler();\n    }\n\n    function reset() {\n        const numSessions = sessions.length;\n        let session;\n\n        if (numSessions !== 0) {\n            // Called when we are done closing a session.  Success or fail\n            const done = function (session) {\n                removeSession(session);\n                if (sessions.length === 0) {\n                    if (videoElement) {\n                        videoElement.removeEventListener('encrypted', eventHandler);\n                        videoElement.setMediaKeys(null).then(function () {\n                            eventBus.trigger(events.TEARDOWN_COMPLETE);\n                        });\n                    } else {\n                        eventBus.trigger(events.TEARDOWN_COMPLETE);\n                    }\n                }\n            };\n            for (let i = 0; i < numSessions; i++) {\n                session = sessions[i];\n                (function (s) {\n                    // Override closed promise resolver\n                    session.session.closed.then(function () {\n                        done(s);\n                    });\n                    // Close the session and handle errors, otherwise promise\n                    // resolver above will be called\n                    closeKeySessionInternal(session).catch(function () {\n                        done(s);\n                    });\n\n                })(session);\n            }\n        } else {\n            eventBus.trigger(events.TEARDOWN_COMPLETE);\n        }\n    }\n\n    function stop() {\n        // Close and remove not usable sessions\n        let session;\n        for (let i = 0; i < sessions.length; i++) {\n            session = sessions[i];\n            if (!session.getUsable()) {\n                closeKeySessionInternal(session).catch(function () {\n                    removeSession(session);\n                });\n            }\n        }\n    }\n\n    function getKeySystem() {\n        return keySystem;\n    }\n\n    function getAllInitData() {\n        const retVal = [];\n        for (let i = 0; i < sessions.length; i++) {\n            if (sessions[i].initData) {\n                retVal.push(sessions[i].initData);\n            }\n        }\n        return retVal;\n    }\n\n    function requestKeySystemAccess(ksConfigurations) {\n        requestKeySystemAccessInternal(ksConfigurations, 0);\n    }\n\n    function selectKeySystem(keySystemAccess) {\n        keySystemAccess.mksa.createMediaKeys().then(function (mkeys) {\n            keySystem = keySystemAccess.keySystem;\n            mediaKeys = mkeys;\n            if (videoElement) {\n                videoElement.setMediaKeys(mediaKeys).then(function () {\n                    eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n                });\n            } else {\n                eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n            }\n\n        }).catch(function () {\n            eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED, { error: 'Error selecting keys system (' + keySystemAccess.keySystem.systemString + ')! Could not create MediaKeys -- TODO' });\n        });\n    }\n\n    function setMediaElement(mediaElement) {\n        if (videoElement === mediaElement)\n            return;\n\n        // Replacing the previous element\n        if (videoElement) {\n            videoElement.removeEventListener('encrypted', eventHandler);\n            if (videoElement.setMediaKeys) {\n                videoElement.setMediaKeys(null);\n            }\n        }\n\n        videoElement = mediaElement;\n\n        // Only if we are not detaching from the existing element\n        if (videoElement) {\n            videoElement.addEventListener('encrypted', eventHandler);\n            if (videoElement.setMediaKeys && mediaKeys) {\n                videoElement.setMediaKeys(mediaKeys);\n            }\n        }\n    }\n\n    function setServerCertificate(serverCertificate) {\n        if (!keySystem || !mediaKeys) {\n            throw new Error('Can not set server certificate until you have selected a key system');\n        }\n        mediaKeys.setServerCertificate(serverCertificate).then(function () {\n            logger.info('DRM: License server certificate successfully updated.');\n            eventBus.trigger(events.SERVER_CERTIFICATE_UPDATED);\n        }).catch(function (error) {\n            eventBus.trigger(events.SERVER_CERTIFICATE_UPDATED, { error: new DashJSError(ProtectionErrors.SERVER_CERTIFICATE_UPDATED_ERROR_CODE, ProtectionErrors.SERVER_CERTIFICATE_UPDATED_ERROR_MESSAGE + error.name) });\n        });\n    }\n\n    function createKeySession(initData, protData, sessionType) {\n        if (!keySystem || !mediaKeys) {\n            throw new Error('Can not create sessions until you have selected a key system');\n        }\n\n        const session = mediaKeys.createSession(sessionType);\n        const sessionToken = createSessionToken(session, initData, sessionType);\n        const ks = this.getKeySystem();\n\n        // Generate initial key request.\n        // keyids type is used for clearkey when keys are provided directly in the protection data and then request to a license server is not needed\n        const dataType = ks.systemString === ProtectionConstants.CLEARKEY_KEYSTEM_STRING && (initData ||  (protData && protData.clearkeys)) ? 'keyids' : 'cenc';\n        session.generateRequest(dataType, initData).then(function () {\n            logger.debug('DRM: Session created.  SessionID = ' + sessionToken.getSessionID());\n            eventBus.trigger(events.KEY_SESSION_CREATED, { data: sessionToken });\n        }).catch(function (error) {\n            // TODO: Better error string\n            removeSession(sessionToken);\n            eventBus.trigger(events.KEY_SESSION_CREATED, {\n                data: null,\n                error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Error generating key request -- ' + error.name)\n            });\n        });\n    }\n\n    function updateKeySession(sessionToken, message) {\n        const session = sessionToken.session;\n\n        // Send our request to the key session\n        if (protectionKeyController.isClearKey(keySystem)) {\n            message = message.toJWK();\n        }\n        session.update(message).catch(function (error) {\n            eventBus.trigger(events.KEY_ERROR, { data: new DashJSError(ProtectionErrors.MEDIA_KEYERR_CODE, 'Error sending update() message! ' + error.name, sessionToken) });\n        });\n    }\n\n    function loadKeySession(sessionID, initData, sessionType) {\n        if (!keySystem || !mediaKeys) {\n            throw new Error('Can not load sessions until you have selected a key system');\n        }\n\n        // Check if session Id is not already loaded or loading\n        for (let i = 0; i < sessions.length; i++) {\n            if (sessionID === sessions[i].sessionId) {\n                logger.warn('DRM: Ignoring session ID because we have already seen it!');\n                return;\n            }\n        }\n\n        const session = mediaKeys.createSession(sessionType);\n        const sessionToken = createSessionToken(session, initData, sessionType, sessionID);\n\n        // Load persisted session data into our newly created session object\n        session.load(sessionID).then(function (success) {\n            if (success) {\n                logger.debug('DRM: Session loaded.  SessionID = ' + sessionToken.getSessionID());\n                eventBus.trigger(events.KEY_SESSION_CREATED, { data: sessionToken });\n            } else {\n                removeSession(sessionToken);\n                eventBus.trigger(events.KEY_SESSION_CREATED, {\n                    data: null,\n                    error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Could not load session! Invalid Session ID (' + sessionID + ')')\n                });\n            }\n        }).catch(function (error) {\n            removeSession(sessionToken);\n            eventBus.trigger(events.KEY_SESSION_CREATED, {\n                data: null,\n                error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Could not load session (' + sessionID + ')! ' + error.name)\n            });\n        });\n    }\n\n    function removeKeySession(sessionToken) {\n        const session = sessionToken.session;\n\n        session.remove().then(function () {\n            logger.debug('DRM: Session removed.  SessionID = ' + sessionToken.getSessionID());\n            eventBus.trigger(events.KEY_SESSION_REMOVED, { data: sessionToken.getSessionID() });\n        }, function (error) {\n            eventBus.trigger(events.KEY_SESSION_REMOVED, {\n                data: null,\n                error: 'Error removing session (' + sessionToken.getSessionID() + '). ' + error.name\n            });\n\n        });\n    }\n\n    function closeKeySession(sessionToken) {\n        // Send our request to the key session\n        closeKeySessionInternal(sessionToken).catch(function (error) {\n            removeSession(sessionToken);\n            eventBus.trigger(events.KEY_SESSION_CLOSED, {\n                data: null,\n                error: 'Error closing session (' + sessionToken.getSessionID() + ') ' + error.name\n            });\n        });\n    }\n\n    function requestKeySystemAccessInternal(ksConfigurations, idx) {\n\n        if (navigator.requestMediaKeySystemAccess === undefined ||\n            typeof navigator.requestMediaKeySystemAccess !== 'function') {\n            eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { error: 'Insecure origins are not allowed' });\n            return;\n        }\n\n        (function (i) {\n            const keySystem = ksConfigurations[i].ks;\n            const configs = ksConfigurations[i].configs;\n            let systemString = keySystem.systemString;\n\n            // PATCH to support persistent licenses on Edge browser (see issue #2658)\n            if (systemString === ProtectionConstants.PLAYREADY_KEYSTEM_STRING && configs[0].persistentState === 'required') {\n                systemString += '.recommendation';\n            }\n\n            navigator.requestMediaKeySystemAccess(systemString, configs).then(function (mediaKeySystemAccess) {\n                // Chrome 40 does not currently implement MediaKeySystemAccess.getConfiguration()\n                const configuration = (typeof mediaKeySystemAccess.getConfiguration === 'function') ?\n                    mediaKeySystemAccess.getConfiguration() : null;\n                const keySystemAccess = new KeySystemAccess(keySystem, configuration);\n                keySystemAccess.mksa = mediaKeySystemAccess;\n                eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { data: keySystemAccess });\n\n            }).catch(function (error) {\n                if (++i < ksConfigurations.length) {\n                    requestKeySystemAccessInternal(ksConfigurations, i);\n                } else {\n                    eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { error: 'Key system access denied! ' + error.message });\n                }\n            });\n        })(idx);\n    }\n\n    function closeKeySessionInternal(sessionToken) {\n        const session = sessionToken.session;\n\n        // Remove event listeners\n        session.removeEventListener('keystatuseschange', sessionToken);\n        session.removeEventListener('message', sessionToken);\n\n        // Send our request to the key session\n        return session.close();\n    }\n\n    // This is our main event handler for all desired HTMLMediaElement events\n    // related to EME.  These events are translated into our API-independent\n    // versions of the same events\n    function createEventHandler() {\n        return {\n            handleEvent: function (event) {\n                switch (event.type) {\n                    case 'encrypted':\n                        if (event.initData) {\n                            let initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n                            eventBus.trigger(events.NEED_KEY, { key: new NeedKey(initData, event.initDataType) });\n                        }\n                        break;\n                }\n            }\n        };\n    }\n\n    function removeSession(token) {\n        // Remove from our session list\n        for (let i = 0; i < sessions.length; i++) {\n            if (sessions[i] === token) {\n                sessions.splice(i, 1);\n                break;\n            }\n        }\n    }\n\n    function parseKeyStatus(args) {\n        // Edge and Chrome implement different version of keystatues, param are not on same order\n        let status, keyId;\n        if (args && args.length > 0) {\n            if (args[0]) {\n                if (typeof args[0] === 'string') {\n                    status = args[0];\n                } else {\n                    keyId = args[0];\n                }\n            }\n\n            if (args[1]) {\n                if (typeof args[1] === 'string') {\n                    status = args[1];\n                } else {\n                    keyId = args[1];\n                }\n            }\n        }\n        return {\n            status: status,\n            keyId: keyId\n        };\n    }\n\n    // Function to create our session token objects which manage the EME\n    // MediaKeySession and session-specific event handler\n    function createSessionToken(session, initData, sessionType, sessionID) {\n        const token = { // Implements SessionToken\n            session: session,\n            initData: initData,\n            sessionId: sessionID,\n\n            // This is our main event handler for all desired MediaKeySession events\n            // These events are translated into our API-independent versions of the\n            // same events\n            handleEvent: function (event) {\n                switch (event.type) {\n                    case 'keystatuseschange':\n                        eventBus.trigger(events.KEY_STATUSES_CHANGED, { data: this });\n                        event.target.keyStatuses.forEach(function () {\n                            let keyStatus = parseKeyStatus(arguments);\n                            switch (keyStatus.status) {\n                                case 'expired':\n                                    eventBus.trigger(events.INTERNAL_KEY_STATUS_CHANGED, { error: new DashJSError(ProtectionErrors.KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE, ProtectionErrors.KEY_STATUS_CHANGED_EXPIRED_ERROR_MESSAGE) });\n                                    break;\n                                default:\n                                    eventBus.trigger(events.INTERNAL_KEY_STATUS_CHANGED, keyStatus);\n                                    break;\n                            }\n                        });\n                        break;\n\n                    case 'message':\n                        let message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n                        eventBus.trigger(events.INTERNAL_KEY_MESSAGE, { data: new KeyMessage(this, message, undefined, event.messageType) });\n                        break;\n                }\n            },\n\n            getSessionID: function () {\n                return session.sessionId;\n            },\n\n            getExpirationTime: function () {\n                return session.expiration;\n            },\n\n            getKeyStatuses: function () {\n                return session.keyStatuses;\n            },\n\n            getUsable: function () {\n                let usable = false;\n                session.keyStatuses.forEach(function () {\n                    let keyStatus = parseKeyStatus(arguments);\n                    if (keyStatus.status === 'usable') {\n                        usable = true;\n                    }\n                });\n                return usable;\n            },\n\n            getSessionType: function () {\n                return sessionType;\n            }\n        };\n\n        // Add all event listeners\n        session.addEventListener('keystatuseschange', token);\n        session.addEventListener('message', token);\n\n        // Register callback for session closed Promise\n        session.closed.then(function () {\n            removeSession(token);\n            logger.debug('DRM: Session closed.  SessionID = ' + token.getSessionID());\n            eventBus.trigger(events.KEY_SESSION_CLOSED, { data: token.getSessionID() });\n        });\n\n        // Add to our session list\n        sessions.push(token);\n\n        return token;\n    }\n\n    instance = {\n        getAllInitData: getAllInitData,\n        requestKeySystemAccess: requestKeySystemAccess,\n        getKeySystem: getKeySystem,\n        selectKeySystem: selectKeySystem,\n        setMediaElement: setMediaElement,\n        setServerCertificate: setServerCertificate,\n        createKeySession: createKeySession,\n        updateKeySession: updateKeySession,\n        loadKeySession: loadKeySession,\n        removeKeySession: removeKeySession,\n        closeKeySession: closeKeySession,\n        stop: stop,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nProtectionModel_21Jan2015.__dashjs_factory_name = 'ProtectionModel_21Jan2015';\nexport default dashjs.FactoryMaker.getClassFactory(ProtectionModel_21Jan2015); /* jshint ignore:line */\n"]},"metadata":{},"sourceType":"script"}