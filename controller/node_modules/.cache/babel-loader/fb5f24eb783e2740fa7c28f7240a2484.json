{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _DashConstants = require('../constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _DashManifestModel = require('../models/DashManifestModel');\n\nvar _DashManifestModel2 = _interopRequireDefault(_DashManifestModel);\n\nvar _Settings = require('../../core/Settings');\n\nvar _Settings2 = _interopRequireDefault(_Settings);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction TimelineConverter() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var settings = (0, _Settings2.default)(context).getInstance();\n  var instance = void 0,\n      dashManifestModel = void 0,\n      clientServerTimeShift = void 0,\n      isClientServerTimeSyncCompleted = void 0,\n      expectedLiveEdge = void 0;\n\n  function setup() {\n    dashManifestModel = (0, _DashManifestModel2.default)(context).getInstance();\n    reset();\n  }\n\n  function initialize() {\n    resetInitialSettings();\n    eventBus.on(_Events2.default.UPDATE_TIME_SYNC_OFFSET, _onUpdateTimeSyncOffset, this);\n  }\n\n  function getClientTimeOffset() {\n    return clientServerTimeShift;\n  }\n\n  function setClientTimeOffset(value) {\n    clientServerTimeShift = value;\n  }\n\n  function getExpectedLiveEdge() {\n    return expectedLiveEdge;\n  }\n\n  function setExpectedLiveEdge(value) {\n    expectedLiveEdge = value;\n  }\n\n  function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n    var availabilityTime = NaN;\n\n    if (calculateEnd) {\n      //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n      // to be available for a Media Presentation with type 'dynamic'.\n      // When not present, the value is infinite.\n      if (isDynamic && mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY) {\n        availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime + mpd.timeShiftBufferDepth) * 1000);\n      } else {\n        availabilityTime = mpd.availabilityEndTime;\n      }\n    } else {\n      if (isDynamic) {\n        availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n      } else {\n        // in static mpd, all segments are available at the same time\n        availabilityTime = mpd.availabilityStartTime;\n      }\n    }\n\n    return availabilityTime;\n  }\n\n  function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n    return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n  }\n\n  function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n    return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n  }\n\n  function calcPresentationTimeFromWallTime(wallTime, period) {\n    return (wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000;\n  }\n\n  function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n    var periodStart = representation.adaptation.period.start;\n    var presentationOffset = representation.presentationTimeOffset;\n    return mediaTime + (periodStart - presentationOffset);\n  }\n\n  function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n    var periodStart = representation.adaptation.period.start;\n    var presentationOffset = representation.presentationTimeOffset;\n    return presentationTime - periodStart + presentationOffset;\n  }\n\n  function calcWallTimeForSegment(segment, isDynamic) {\n    var suggestedPresentationDelay = void 0,\n        displayStartTime = void 0,\n        wallTime = void 0;\n\n    if (isDynamic) {\n      suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n      displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n      wallTime = new Date(segment.availabilityStartTime.getTime() + displayStartTime * 1000);\n    }\n\n    return wallTime;\n  }\n\n  function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\n    // Static Range Finder\n    var voPeriod = voRepresentation.adaptation.period;\n    var range = {\n      start: voPeriod.start,\n      end: voPeriod.start + voPeriod.duration\n    };\n    if (!isDynamic) return range;\n\n    if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n      return voRepresentation.segmentAvailabilityRange;\n    } // Dynamic Range Finder\n\n\n    var d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0); // Specific use case of SegmentTimeline without timeShiftBufferDepth\n\n    if (voRepresentation.segmentInfoType === _DashConstants2.default.SEGMENT_TIMELINE && settings.get().streaming.calcSegmentAvailabilityRangeFromTimeline) {\n      return calcSegmentAvailabilityRangeFromTimeline(voRepresentation);\n    }\n\n    var now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n    var periodEnd = voPeriod.start + voPeriod.duration;\n    range.start = Math.max(now - voPeriod.mpd.timeShiftBufferDepth, voPeriod.start);\n    var endOffset = voRepresentation.availabilityTimeOffset !== undefined && voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n    range.end = now >= periodEnd && now - endOffset < periodEnd ? periodEnd : now - endOffset;\n    return range;\n  }\n\n  function calcSegmentAvailabilityRangeFromTimeline(voRepresentation) {\n    var adaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\n    var representation = dashManifestModel.getRepresentationFor(voRepresentation.index, adaptation);\n    var timeline = representation.SegmentTemplate.SegmentTimeline;\n    var timescale = representation.SegmentTemplate.timescale;\n    var segments = timeline.S_asArray;\n    var range = {\n      start: 0,\n      end: 0\n    };\n    var d = 0;\n    var segment = void 0,\n        repeat = void 0,\n        i = void 0,\n        len = void 0;\n    range.start = calcPresentationTimeFromMediaTime(segments[0].t / timescale, voRepresentation);\n\n    for (i = 0, len = segments.length; i < len; i++) {\n      segment = segments[i];\n      repeat = 0;\n\n      if (segment.hasOwnProperty('r')) {\n        repeat = segment.r;\n      }\n\n      d += segment.d / timescale * (1 + repeat);\n    }\n\n    range.end = range.start + d;\n    return range;\n  }\n\n  function getPeriodEnd(voRepresentation, isDynamic) {\n    // Static Range Finder\n    var voPeriod = voRepresentation.adaptation.period;\n\n    if (!isDynamic) {\n      return voPeriod.start + voPeriod.duration;\n    }\n\n    if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n      return voRepresentation.segmentAvailabilityRange;\n    } // Dynamic Range Finder\n\n\n    var d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n    var now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n    var periodEnd = voPeriod.start + voPeriod.duration;\n    var endOffset = voRepresentation.availabilityTimeOffset !== undefined && voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n    return Math.min(now - endOffset, periodEnd);\n  }\n\n  function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n    var periodStartTime = representation.adaptation.period.start;\n    return mpdRelativeTime - periodStartTime;\n  }\n  /*\n  * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\n  * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\n  * FYI StreamController's onManifestUpdated entry point to timeSync\n  * */\n\n\n  function _onUpdateTimeSyncOffset(e) {\n    if (e.offset !== undefined) {\n      setClientTimeOffset(e.offset / 1000);\n      isClientServerTimeSyncCompleted = true;\n    }\n  }\n\n  function resetInitialSettings() {\n    clientServerTimeShift = 0;\n    isClientServerTimeSyncCompleted = false;\n    expectedLiveEdge = NaN;\n  }\n\n  function reset() {\n    eventBus.off(_Events2.default.UPDATE_TIME_SYNC_OFFSET, _onUpdateTimeSyncOffset, this);\n    resetInitialSettings();\n  }\n\n  instance = {\n    initialize: initialize,\n    getClientTimeOffset: getClientTimeOffset,\n    setClientTimeOffset: setClientTimeOffset,\n    getExpectedLiveEdge: getExpectedLiveEdge,\n    setExpectedLiveEdge: setExpectedLiveEdge,\n    calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n    calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n    calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n    calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n    calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n    calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n    calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n    getPeriodEnd: getPeriodEnd,\n    calcWallTimeForSegment: calcWallTimeForSegment,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexports.default = _FactoryMaker2.default.getSingletonFactory(TimelineConverter);","map":{"version":3,"mappings":";;;;;;AA8BA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AAnCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,SAASA,iBAAT,GAA6B;EAEzB,IAAMC,UAAU,KAAKA,OAArB;EACA,IAAMC,WAAW,wBAASD,OAAT,EAAkBE,WAAlB,EAAjB;EACA,IAAMC,WAAW,wBAASH,OAAT,EAAkBE,WAAlB,EAAjB;EAEA,IAAIE,iBAAJ;EAAA,IACIC,0BADJ;EAAA,IAEIC,8BAFJ;EAAA,IAGIC,wCAHJ;EAAA,IAIIC,yBAJJ;;EAMA,SAASC,KAAT,GAAiB;IACbJ,oBAAoB,iCAAkBL,OAAlB,EAA2BE,WAA3B,EAApBG;IACAK;EAGJ;;EAAA,SAASC,UAAT,GAAsB;IAClBC;IACAX,SAASY,EAATZ,CAAYa,iBAAOC,uBAAnBd,EAA4Ce,uBAA5Cf,EAAqE,IAArEA;EAGJ;;EAAA,SAASgB,mBAAT,GAA+B;IAC3B,OAAOX,qBAAP;EAGJ;;EAAA,SAASY,mBAAT,CAA6BC,KAA7B,EAAoC;IAChCb,wBAAwBa,KAAxBb;EAGJ;;EAAA,SAASc,mBAAT,GAA+B;IAC3B,OAAOZ,gBAAP;EAGJ;;EAAA,SAASa,mBAAT,CAA6BF,KAA7B,EAAoC;IAChCX,mBAAmBW,KAAnBX;EAGJ;;EAAA,SAASc,wCAAT,CAAkDC,gBAAlD,EAAoEC,GAApE,EAAyEC,SAAzE,EAAoFC,YAApF,EAAkG;IAC9F,IAAIC,mBAAmBC,GAAvB;;IAEA,IAAIF,YAAJ,EAAkB;MACd;MACA;MACA;MACA,IAAID,aAAcD,IAAIK,oBAAJL,IAA4BM,OAAOC,iBAArD,EAAyE;QACrEJ,mBAAmB,IAAIK,IAAJ,CAASR,IAAIS,qBAAJT,CAA0BU,OAA1BV,KAAuC,CAACD,mBAAmBC,IAAIK,oBAAxB,IAAgD,IAAhG,CAAnBF;MADJ,OAEO;QACHA,mBAAmBH,IAAIW,mBAAvBR;MAEP;IATD,OASO;MACH,IAAIF,SAAJ,EAAe;QACXE,mBAAmB,IAAIK,IAAJ,CAASR,IAAIS,qBAAJT,CAA0BU,OAA1BV,KAAsC,CAACD,mBAAmBjB,qBAApB,IAA6C,IAA5F,CAAnBqB;MADJ,OAEO;QACH;QACAA,mBAAmBH,IAAIS,qBAAvBN;MAEP;IAED;;IAAA,OAAOA,gBAAP;EAGJ;;EAAA,SAASS,6CAAT,CAAuDb,gBAAvD,EAAyEC,GAAzE,EAA8EC,SAA9E,EAAyF;IACrF,OAAOH,yCAAyCe,IAAzCf,CAA8C,IAA9CA,EAAoDC,gBAApDD,EAAsEE,GAAtEF,EAA2EG,SAA3EH,CAAP;EAGJ;;EAAA,SAASgB,2CAAT,CAAqDf,gBAArD,EAAuEC,GAAvE,EAA4EC,SAA5E,EAAuF;IACnF,OAAOH,yCAAyCe,IAAzCf,CAA8C,IAA9CA,EAAoDC,gBAApDD,EAAsEE,GAAtEF,EAA2EG,SAA3EH,EAAsF,IAAtFA,CAAP;EAGJ;;EAAA,SAASiB,gCAAT,CAA0CC,QAA1C,EAAoDC,MAApD,EAA4D;IACxD,OAAQ,CAACD,SAASN,OAATM,KAAqBC,OAAOjB,GAAPiB,CAAWR,qBAAXQ,CAAiCP,OAAjCO,EAArBD,GAAkElC,wBAAwB,IAA3F,IAAmG,IAA3G;EAGJ;;EAAA,SAASoC,iCAAT,CAA2CC,SAA3C,EAAsDC,cAAtD,EAAsE;IAClE,IAAMC,cAAcD,eAAeE,UAAfF,CAA0BH,MAA1BG,CAAiCG,KAArD;IACA,IAAMC,qBAAqBJ,eAAeK,sBAA1C;IAEA,OAAON,aAAaE,cAAcG,kBAA3BL,CAAP;EAGJ;;EAAA,SAASO,iCAAT,CAA2C3B,gBAA3C,EAA6DqB,cAA7D,EAA6E;IACzE,IAAMC,cAAcD,eAAeE,UAAfF,CAA0BH,MAA1BG,CAAiCG,KAArD;IACA,IAAMC,qBAAqBJ,eAAeK,sBAA1C;IAEA,OAAO1B,mBAAmBsB,WAAnBtB,GAAiCyB,kBAAxC;EAGJ;;EAAA,SAASG,sBAAT,CAAgCC,OAAhC,EAAyC3B,SAAzC,EAAoD;IAChD,IAAI4B,mCAAJ;IAAA,IACIC,yBADJ;IAAA,IAEId,iBAFJ;;IAIA,IAAIf,SAAJ,EAAe;MACX4B,6BAA6BD,QAAQR,cAARQ,CAAuBN,UAAvBM,CAAkCX,MAAlCW,CAAyC5B,GAAzC4B,CAA6CC,0BAA1EA;MACAC,mBAAmBF,QAAQG,qBAARH,GAAgCC,0BAAnDC;MACAd,WAAW,IAAIR,IAAJ,CAASoB,QAAQnB,qBAARmB,CAA8BlB,OAA9BkB,KAA2CE,mBAAmB,IAAvE,CAAXd;IAGJ;;IAAA,OAAOA,QAAP;EAGJ;;EAAA,SAASgB,4BAAT,CAAsCC,gBAAtC,EAAwDhC,SAAxD,EAAmE;IAC/D;IACA,IAAMiC,WAAWD,iBAAiBX,UAAjBW,CAA4BhB,MAA7C;IACA,IAAMkB,QAAQ;MAACZ,OAAOW,SAASX,KAAjB;MAAwBa,KAAKF,SAASX,KAATW,GAAiBA,SAASG;IAAvD,CAAd;IACA,IAAI,CAACpC,SAAL,EAAgB,OAAOkC,KAAP;;IAEhB,IAAI,CAACpD,+BAAD,IAAoCkD,iBAAiBK,wBAAzD,EAAmF;MAC/E,OAAOL,iBAAiBK,wBAAxB;IAGJ,CAV+D,CAU/D;;;IACA,IAAMC,IAAIN,iBAAiBO,eAAjBP,KAAqCA,iBAAiBQ,QAAjBR,IAA6BA,iBAAiBQ,QAAjBR,CAA0BS,MAAvDT,GAAgEA,iBAAiBQ,QAAjBR,CAA0BA,iBAAiBQ,QAAjBR,CAA0BS,MAA1BT,GAAmC,CAA7DA,EAAgEI,QAAhIJ,GAA2I,CAAhLA,CAAV,CAX+D,CAa/D;;IACA,IAAIA,iBAAiBU,eAAjBV,KAAqCW,wBAAcC,gBAAnDZ,IAAuEtD,SAASmE,GAATnE,GAAeoE,SAAfpE,CAAyBqE,wCAApG,EAA8I;MAC1I,OAAOA,yCAAyCf,gBAAzCe,CAAP;IAGJ;;IAAA,IAAMC,MAAMlC,iCAAiC,IAAIP,IAAJ,EAAjCO,EAA6CmB,QAA7CnB,CAAZ;IACA,IAAMmC,YAAYhB,SAASX,KAATW,GAAiBA,SAASG,QAA5C;IACAF,MAAMZ,KAANY,GAAcgB,KAAKC,GAALD,CAAUF,MAAMf,SAASlC,GAATkC,CAAa7B,oBAA7B8C,EAAoDjB,SAASX,KAA7D4B,CAAdhB;IAEA,IAAMkB,YAAYpB,iBAAiBqB,sBAAjBrB,KAA4CsB,SAA5CtB,IAClBA,iBAAiBqB,sBAAjBrB,GAA0CM,CADxBN,GAC4BM,IAAIN,iBAAiBqB,sBADjDrB,GAC0EM,CAD5F;IAGAJ,MAAMC,GAAND,GAAYc,OAAOC,SAAPD,IAAoBA,MAAMI,SAANJ,GAAkBC,SAAtCD,GAAkDC,SAAlDD,GAA8DA,MAAMI,SAAhFlB;IAEA,OAAOA,KAAP;EAGJ;;EAAA,SAASa,wCAAT,CAAkDf,gBAAlD,EAAoE;IAChE,IAAMX,aAAaW,iBAAiBX,UAAjBW,CAA4BhB,MAA5BgB,CAAmCjC,GAAnCiC,CAAuCuB,QAAvCvB,CAAgDwB,cAAhDxB,CAA+DA,iBAAiBX,UAAjBW,CAA4BhB,MAA5BgB,CAAmCyB,KAAlGzB,EAAyG0B,qBAAzG1B,CAA+HA,iBAAiBX,UAAjBW,CAA4ByB,KAA3JzB,CAAnB;IACA,IAAMb,iBAAiBvC,kBAAkB+E,oBAAlB/E,CAAuCoD,iBAAiByB,KAAxD7E,EAA+DyC,UAA/DzC,CAAvB;IACA,IAAMgF,WAAWzC,eAAe0C,eAAf1C,CAA+B2C,eAAhD;IACA,IAAMC,YAAY5C,eAAe0C,eAAf1C,CAA+B4C,SAAjD;IACA,IAAMvB,WAAWoB,SAASI,SAA1B;IACA,IAAM9B,QAAQ;MAACZ,OAAO,CAAR;MAAWa,KAAK;IAAhB,CAAd;IACA,IAAIG,IAAI,CAAR;IACA,IAAIX,gBAAJ;IAAA,IACIsC,eADJ;IAAA,IAEIC,UAFJ;IAAA,IAGIC,YAHJ;IAKAjC,MAAMZ,KAANY,GAAcjB,kCAAkCuB,SAAS,CAATA,EAAY4B,CAAZ5B,GAAgBuB,SAAlD9C,EAA6De,gBAA7Df,CAAdiB;;IAEA,KAAKgC,IAAI,CAAJA,EAAOC,MAAM3B,SAASC,MAA3B,EAAmCyB,IAAIC,GAAvC,EAA4CD,GAA5C,EAAiD;MAC7CvC,UAAUa,SAAS0B,CAAT1B,CAAVb;MACAsC,SAAS,CAATA;;MACA,IAAItC,QAAQ0C,cAAR1C,CAAuB,GAAvBA,CAAJ,EAAiC;QAC7BsC,SAAStC,QAAQ2C,CAAjBL;MAEJ3B;;MAAAA,KAAMX,QAAQW,CAARX,GAAYoC,SAAZpC,IAA0B,IAAIsC,MAA9BtC,CAANW;IAGJJ;;IAAAA,MAAMC,GAAND,GAAYA,MAAMZ,KAANY,GAAcI,CAA1BJ;IAEA,OAAOA,KAAP;EAGJ;;EAAA,SAASqC,YAAT,CAAsBvC,gBAAtB,EAAwChC,SAAxC,EAAmD;IAC/C;IACA,IAAMiC,WAAWD,iBAAiBX,UAAjBW,CAA4BhB,MAA7C;;IACA,IAAI,CAAChB,SAAL,EAAgB;MACZ,OAAOiC,SAASX,KAATW,GAAiBA,SAASG,QAAjC;IAGJ;;IAAA,IAAI,CAACtD,+BAAD,IAAoCkD,iBAAiBK,wBAAzD,EAAmF;MAC/E,OAAOL,iBAAiBK,wBAAxB;IAGJ,CAX+C,CAW/C;;;IACA,IAAMC,IAAIN,iBAAiBO,eAAjBP,KAAqCA,iBAAiBQ,QAAjBR,IAA6BA,iBAAiBQ,QAAjBR,CAA0BS,MAAvDT,GAAgEA,iBAAiBQ,QAAjBR,CAA0BA,iBAAiBQ,QAAjBR,CAA0BS,MAA1BT,GAAmC,CAA7DA,EAAgEI,QAAhIJ,GAA2I,CAAhLA,CAAV;IACA,IAAMgB,MAAMlC,iCAAiC,IAAIP,IAAJ,EAAjCO,EAA6CmB,QAA7CnB,CAAZ;IACA,IAAMmC,YAAYhB,SAASX,KAATW,GAAiBA,SAASG,QAA5C;IAEA,IAAMgB,YAAYpB,iBAAiBqB,sBAAjBrB,KAA4CsB,SAA5CtB,IAClBA,iBAAiBqB,sBAAjBrB,GAA0CM,CADxBN,GAC4BM,IAAIN,iBAAiBqB,sBADjDrB,GAC0EM,CAD5F;IAGA,OAAOY,KAAKsB,GAALtB,CAASF,MAAMI,SAAfF,EAA0BD,SAA1BC,CAAP;EAGJ;;EAAA,SAASuB,yCAAT,CAAmDtD,cAAnD,EAAmEuD,eAAnE,EAAoF;IAChF,IAAMC,kBAAkBxD,eAAeE,UAAfF,CAA0BH,MAA1BG,CAAiCG,KAAzD;IACA,OAAOoD,kBAAkBC,eAAzB;EAGJ;EAAA;;;;;;;EAKA,SAASpF,uBAAT,CAAiCqF,CAAjC,EAAoC;IAChC,IAAIA,EAAEC,MAAFD,KAAatB,SAAjB,EAA4B;MACxB7D,oBAAoBmF,EAAEC,MAAFD,GAAW,IAA/BnF;MACAX,kCAAkC,IAAlCA;IAEP;EAED;;EAAA,SAASK,oBAAT,GAAgC;IAC5BN,wBAAwB,CAAxBA;IACAC,kCAAkC,KAAlCA;IACAC,mBAAmBoB,GAAnBpB;EAGJ;;EAAA,SAASE,KAAT,GAAiB;IACbT,SAASsG,GAATtG,CAAaa,iBAAOC,uBAApBd,EAA6Ce,uBAA7Cf,EAAsE,IAAtEA;IACAW;EAGJR;;EAAAA,WAAW;IACPO,YAAYA,UADL;IAEPM,qBAAqBA,mBAFd;IAGPC,qBAAqBA,mBAHd;IAIPE,qBAAqBA,mBAJd;IAKPC,qBAAqBA,mBALd;IAMPe,+CAA+CA,6CANxC;IAOPE,6CAA6CA,2CAPtC;IAQPC,kCAAkCA,gCAR3B;IASPG,mCAAmCA,iCAT5B;IAUPwD,2CAA2CA,yCAVpC;IAWPhD,mCAAmCA,iCAX5B;IAYPM,8BAA8BA,4BAZvB;IAaPwC,cAAcA,YAbP;IAcP7C,wBAAwBA,sBAdjB;IAePzC,OAAOA;EAfA,CAAXN;EAkBAK;EACA,OAAOL,QAAP;AAGJL;;AAAAA,kBAAkByG,qBAAlBzG,GAA0C,mBAA1CA;kBACe0G,uBAAaC,mBAAbD,CAAiC1G,iBAAjC0G,C","names":["TimelineConverter","context","eventBus","getInstance","settings","instance","dashManifestModel","clientServerTimeShift","isClientServerTimeSyncCompleted","expectedLiveEdge","setup","reset","initialize","resetInitialSettings","on","Events","UPDATE_TIME_SYNC_OFFSET","_onUpdateTimeSyncOffset","getClientTimeOffset","setClientTimeOffset","value","getExpectedLiveEdge","setExpectedLiveEdge","calcAvailabilityTimeFromPresentationTime","presentationTime","mpd","isDynamic","calculateEnd","availabilityTime","NaN","timeShiftBufferDepth","Number","POSITIVE_INFINITY","Date","availabilityStartTime","getTime","availabilityEndTime","calcAvailabilityStartTimeFromPresentationTime","call","calcAvailabilityEndTimeFromPresentationTime","calcPresentationTimeFromWallTime","wallTime","period","calcPresentationTimeFromMediaTime","mediaTime","representation","periodStart","adaptation","start","presentationOffset","presentationTimeOffset","calcMediaTimeFromPresentationTime","calcWallTimeForSegment","segment","suggestedPresentationDelay","displayStartTime","presentationStartTime","calcSegmentAvailabilityRange","voRepresentation","voPeriod","range","end","duration","segmentAvailabilityRange","d","segmentDuration","segments","length","segmentInfoType","DashConstants","SEGMENT_TIMELINE","get","streaming","calcSegmentAvailabilityRangeFromTimeline","now","periodEnd","Math","max","endOffset","availabilityTimeOffset","undefined","manifest","Period_asArray","index","AdaptationSet_asArray","getRepresentationFor","timeline","SegmentTemplate","SegmentTimeline","timescale","S_asArray","repeat","i","len","t","hasOwnProperty","r","getPeriodEnd","min","calcPeriodRelativeTimeFromMpdRelativeTime","mpdRelativeTime","periodStartTime","e","offset","off","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/dash/utils/TimelineConverter.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport DashConstants from '../constants/DashConstants';\nimport DashManifestModel from '../models/DashManifestModel';\nimport Settings from '../../core/Settings';\n\nfunction TimelineConverter() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const settings = Settings(context).getInstance();\n\n    let instance,\n        dashManifestModel,\n        clientServerTimeShift,\n        isClientServerTimeSyncCompleted,\n        expectedLiveEdge;\n\n    function setup() {\n        dashManifestModel = DashManifestModel(context).getInstance();\n        reset();\n    }\n\n    function initialize() {\n        resetInitialSettings();\n        eventBus.on(Events.UPDATE_TIME_SYNC_OFFSET, _onUpdateTimeSyncOffset, this);\n    }\n\n    function getClientTimeOffset() {\n        return clientServerTimeShift;\n    }\n\n    function setClientTimeOffset(value) {\n        clientServerTimeShift = value;\n    }\n\n    function getExpectedLiveEdge() {\n        return expectedLiveEdge;\n    }\n\n    function setExpectedLiveEdge(value) {\n        expectedLiveEdge = value;\n    }\n\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n        let availabilityTime = NaN;\n\n        if (calculateEnd) {\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n            // to be available for a Media Presentation with type 'dynamic'.\n            // When not present, the value is infinite.\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\n            } else {\n                availabilityTime = mpd.availabilityEndTime;\n            }\n        } else {\n            if (isDynamic) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n            } else {\n                // in static mpd, all segments are available at the same time\n                availabilityTime = mpd.availabilityStartTime;\n            }\n        }\n\n        return availabilityTime;\n    }\n\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n    }\n\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n    }\n\n    function calcPresentationTimeFromWallTime(wallTime, period) {\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\n    }\n\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return mediaTime + (periodStart - presentationOffset);\n    }\n\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return presentationTime - periodStart + presentationOffset;\n    }\n\n    function calcWallTimeForSegment(segment, isDynamic) {\n        let suggestedPresentationDelay,\n            displayStartTime,\n            wallTime;\n\n        if (isDynamic) {\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\n        }\n\n        return wallTime;\n    }\n\n    function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        const range = {start: voPeriod.start, end: voPeriod.start + voPeriod.duration};\n        if (!isDynamic) return range;\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n\n        // Specific use case of SegmentTimeline without timeShiftBufferDepth\n        if (voRepresentation.segmentInfoType === DashConstants.SEGMENT_TIMELINE && settings.get().streaming.calcSegmentAvailabilityRangeFromTimeline) {\n            return calcSegmentAvailabilityRangeFromTimeline(voRepresentation);\n        }\n\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n        range.start = Math.max((now - voPeriod.mpd.timeShiftBufferDepth), voPeriod.start);\n\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\n        voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n\n        range.end = now >= periodEnd && now - endOffset < periodEnd ? periodEnd : now - endOffset;\n\n        return range;\n    }\n\n    function calcSegmentAvailabilityRangeFromTimeline(voRepresentation) {\n        const adaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\n        const representation = dashManifestModel.getRepresentationFor(voRepresentation.index, adaptation);\n        const timeline = representation.SegmentTemplate.SegmentTimeline;\n        const timescale = representation.SegmentTemplate.timescale;\n        const segments = timeline.S_asArray;\n        const range = {start: 0, end: 0};\n        let d = 0;\n        let segment,\n            repeat,\n            i,\n            len;\n\n        range.start = calcPresentationTimeFromMediaTime(segments[0].t / timescale, voRepresentation);\n\n        for (i = 0, len = segments.length; i < len; i++) {\n            segment = segments[i];\n            repeat = 0;\n            if (segment.hasOwnProperty('r')) {\n                repeat = segment.r;\n            }\n            d += (segment.d / timescale) * (1 + repeat);\n        }\n\n        range.end = range.start + d;\n\n        return range;\n    }\n\n    function getPeriodEnd(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        if (!isDynamic) {\n            return voPeriod.start + voPeriod.duration;\n        }\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\n        voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n\n        return Math.min(now - endOffset, periodEnd);\n    }\n\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n        const periodStartTime = representation.adaptation.period.start;\n        return mpdRelativeTime - periodStartTime;\n    }\n\n    /*\n    * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\n    * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\n    * FYI StreamController's onManifestUpdated entry point to timeSync\n    * */\n    function _onUpdateTimeSyncOffset(e) {\n        if (e.offset !== undefined) {\n            setClientTimeOffset(e.offset / 1000);\n            isClientServerTimeSyncCompleted = true;\n        }\n    }\n\n    function resetInitialSettings() {\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n    }\n\n    function reset() {\n        eventBus.off(Events.UPDATE_TIME_SYNC_OFFSET, _onUpdateTimeSyncOffset, this);\n        resetInitialSettings();\n    }\n\n    instance = {\n        initialize: initialize,\n        getClientTimeOffset: getClientTimeOffset,\n        setClientTimeOffset: setClientTimeOffset,\n        getExpectedLiveEdge: getExpectedLiveEdge,\n        setExpectedLiveEdge: setExpectedLiveEdge,\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n        getPeriodEnd: getPeriodEnd,\n        calcWallTimeForSegment: calcWallTimeForSegment,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);\n"]},"metadata":{},"sourceType":"script"}