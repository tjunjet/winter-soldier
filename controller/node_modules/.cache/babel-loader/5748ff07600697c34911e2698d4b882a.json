{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction LoLpWeightSelector(config) {\n  var targetLatency = config.targetLatency;\n  var bufferMin = config.bufferMin;\n  var segmentDuration = config.segmentDuration;\n  var qoeEvaluator = config.qoeEvaluator;\n  var instance = void 0,\n      valueList = void 0,\n      weightTypeCount = void 0,\n      weightOptions = void 0,\n      previousLatency = void 0;\n  /**\n  *\n  * @private\n  */\n\n  function _setup() {\n    _resetInitialSettings();\n  }\n  /**\n  *\n  * @private\n  */\n\n\n  function _resetInitialSettings() {\n    valueList = [0.2, 0.4, 0.6, 0.8, 1];\n    weightTypeCount = 4;\n    weightOptions = _getPermutations(valueList, weightTypeCount);\n    previousLatency = 0;\n  }\n  /**\n  * Next, at each segment boundary, ABR to input current neurons and target state (only used in Method II) to find the desired weight vector\n  * @param {array} neurons\n  * @param {number} currentLatency\n  * @param {number} currentBuffer\n  * @param {number} currentRebuffer\n  * @param {number} currentThroughput\n  * @param {number} playbackRate\n  * @return {null}\n  * @private\n  */\n\n\n  function findWeightVector(neurons, currentLatency, currentBuffer, currentRebuffer, currentThroughput, playbackRate) {\n    var maxQoE = null;\n    var winnerWeights = null;\n    var winnerBitrate = null;\n    var deltaLatency = Math.abs(currentLatency - previousLatency); // For each neuron, m\n\n    neurons.forEach(function (neuron) {\n      // For each possible weight vector, z\n      // E.g. For [ throughput, latency, buffer, playbackRate, QoE ]\n      //      Possible weightVector = [ 0.2, 0.4, 0.2, 0, 0.2 ]\n      weightOptions.forEach(function (weightVector) {\n        // Apply weightVector to neuron, compute utility and determine winnerWeights\n        // Method I: Utility based on QoE given current state\n        var weightsObj = {\n          throughput: weightVector[0],\n          latency: weightVector[1],\n          buffer: weightVector[2],\n          switch: weightVector[3]\n        };\n        var downloadTime = neuron.bitrate * segmentDuration / currentThroughput;\n        var nextBuffer = getNextBuffer(currentBuffer, downloadTime);\n        var rebuffer = Math.max(0.00001, downloadTime - nextBuffer);\n        var wt = void 0;\n\n        if (weightsObj.buffer === 0) {\n          wt = 10;\n        } else {\n          wt = 1 / weightsObj.buffer;\n        }\n\n        var weightedRebuffer = wt * rebuffer;\n\n        if (weightsObj.latency === 0) {\n          wt = 10;\n        } else {\n          wt = 1 / weightsObj.latency; // inverse the weight because wt and latency should have positive relationship, i.e., higher latency = higher wt\n        }\n\n        var weightedLatency = wt * neuron.state.latency;\n        var totalQoE = qoeEvaluator.calculateSingleUseQoe(neuron.bitrate, weightedRebuffer, weightedLatency, playbackRate);\n\n        if ((maxQoE === null || totalQoE > maxQoE) && _checkConstraints(currentLatency, nextBuffer, deltaLatency)) {\n          maxQoE = totalQoE;\n          winnerWeights = weightVector;\n          winnerBitrate = neuron.bitrate;\n        }\n      });\n    }); // winnerWeights was found, check if constraints are satisfied\n\n    if (winnerWeights === null && winnerBitrate === null) {\n      winnerWeights = -1;\n    }\n\n    previousLatency = currentLatency;\n    return winnerWeights;\n  }\n  /**\n  *\n  * @param {number} nextLatency\n  * @param {number} nextBuffer\n  * @param {number} deltaLatency\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _checkConstraints(nextLatency, nextBuffer, deltaLatency) {\n    // A1\n    // disabled till we find a better way of estimating latency\n    // fails for all with current value\n    if (nextLatency > targetLatency + deltaLatency) {\n      return false;\n    }\n\n    return nextBuffer >= bufferMin;\n  }\n  /**\n  *\n  * @param {array} list\n  * @param {number} length\n  * @return {*}\n  * @private\n  */\n\n\n  function _getPermutations(list, length) {\n    // Copy initial values as arrays\n    var perm = list.map(function (val) {\n      return [val];\n    }); // Our permutation generator\n\n    var generate = function generate(perm, length, currLen) {\n      // Reached desired length\n      if (currLen === length) {\n        return perm;\n      } // For each existing permutation\n\n\n      var len = perm.length;\n\n      for (var i = 0; i < len; i++) {\n        var currPerm = perm.shift(); // Create new permutation\n\n        for (var k = 0; k < list.length; k++) {\n          perm.push(currPerm.concat(list[k]));\n        }\n      } // Recurse\n\n\n      return generate(perm, length, currLen + 1);\n    }; // Start with size 1 because of initial values\n\n\n    return generate(perm, length, 1);\n  }\n  /**\n  *\n  * @return {number}\n  */\n\n\n  function getMinBuffer() {\n    return bufferMin;\n  }\n  /**\n  *\n  * @return {number}\n  */\n\n\n  function getSegmentDuration() {\n    return segmentDuration;\n  }\n  /**\n  *\n  * @param {number} bitrateToDownload\n  * @param {number} currentBuffer\n  * @param {number} currentThroughput\n  * @return {number}\n  */\n\n\n  function getNextBufferWithBitrate(bitrateToDownload, currentBuffer, currentThroughput) {\n    var downloadTime = bitrateToDownload * segmentDuration / currentThroughput;\n    return getNextBuffer(currentBuffer, downloadTime);\n  }\n  /**\n  *\n  * @param {number} currentBuffer\n  * @param {number} downloadTime\n  * @return {number}\n  */\n\n\n  function getNextBuffer(currentBuffer, downloadTime) {\n    var segmentDuration = getSegmentDuration();\n    var nextBuffer = void 0;\n\n    if (downloadTime > segmentDuration) {\n      nextBuffer = currentBuffer - segmentDuration;\n    } else {\n      nextBuffer = currentBuffer + segmentDuration - downloadTime;\n    }\n\n    return nextBuffer;\n  }\n\n  instance = {\n    getMinBuffer: getMinBuffer,\n    getSegmentDuration: getSegmentDuration,\n    getNextBufferWithBitrate: getNextBufferWithBitrate,\n    getNextBuffer: getNextBuffer,\n    findWeightVector: findWeightVector\n  };\n\n  _setup();\n\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Authors:\n* Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n* Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n* May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n*/\n\n\nLoLpWeightSelector.__dashjs_factory_name = 'LoLpWeightSelector';\nexports.default = _FactoryMaker2.default.getClassFactory(LoLpWeightSelector);","map":{"version":3,"mappings":"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","names":["LoLpWeightSelector","config","targetLatency","bufferMin","segmentDuration","qoeEvaluator","instance","valueList","weightTypeCount","weightOptions","previousLatency","_setup","_resetInitialSettings","_getPermutations","findWeightVector","neurons","currentLatency","currentBuffer","currentRebuffer","currentThroughput","playbackRate","maxQoE","winnerWeights","winnerBitrate","deltaLatency","Math","abs","forEach","neuron","weightVector","weightsObj","throughput","latency","buffer","switch","downloadTime","bitrate","nextBuffer","getNextBuffer","rebuffer","max","wt","weightedRebuffer","weightedLatency","state","totalQoE","calculateSingleUseQoe","_checkConstraints","nextLatency","list","length","perm","map","val","generate","currLen","len","i","currPerm","shift","k","push","concat","getMinBuffer","getSegmentDuration","getNextBufferWithBitrate","bitrateToDownload","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/rules/abr/lolp/LoLpWeightSelector.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Authors:\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n */\n\nimport FactoryMaker from '../../../../core/FactoryMaker';\n\nfunction LoLpWeightSelector(config) {\n    let targetLatency = config.targetLatency;\n    let bufferMin = config.bufferMin;\n    let segmentDuration = config.segmentDuration;\n    let qoeEvaluator = config.qoeEvaluator;\n    let instance,\n        valueList,\n        weightTypeCount,\n        weightOptions,\n        previousLatency;\n\n    /**\n     *\n     * @private\n     */\n    function _setup() {\n        _resetInitialSettings();\n    }\n\n    /**\n     *\n     * @private\n     */\n    function _resetInitialSettings() {\n        valueList = [0.2, 0.4, 0.6, 0.8, 1];\n        weightTypeCount = 4;\n        weightOptions = _getPermutations(valueList, weightTypeCount);\n        previousLatency = 0;\n    }\n\n    /**\n     * Next, at each segment boundary, ABR to input current neurons and target state (only used in Method II) to find the desired weight vector\n     * @param {array} neurons\n     * @param {number} currentLatency\n     * @param {number} currentBuffer\n     * @param {number} currentRebuffer\n     * @param {number} currentThroughput\n     * @param {number} playbackRate\n     * @return {null}\n     * @private\n     */\n    function findWeightVector(neurons, currentLatency, currentBuffer, currentRebuffer, currentThroughput, playbackRate) {\n        let maxQoE = null;\n        let winnerWeights = null;\n        let winnerBitrate = null;\n        let deltaLatency = Math.abs(currentLatency - previousLatency);\n\n        // For each neuron, m\n        neurons.forEach((neuron) => {\n\n            // For each possible weight vector, z\n            // E.g. For [ throughput, latency, buffer, playbackRate, QoE ]\n            //      Possible weightVector = [ 0.2, 0.4, 0.2, 0, 0.2 ]\n            weightOptions.forEach((weightVector) => {\n\n                // Apply weightVector to neuron, compute utility and determine winnerWeights\n                // Method I: Utility based on QoE given current state\n\n                let weightsObj = {\n                    throughput: weightVector[0],\n                    latency: weightVector[1],\n                    buffer: weightVector[2],\n                    switch: weightVector[3]\n                };\n\n                let downloadTime = (neuron.bitrate * segmentDuration) / currentThroughput;\n                let nextBuffer = getNextBuffer(currentBuffer, downloadTime);\n                let rebuffer = Math.max(0.00001, (downloadTime - nextBuffer));\n                let wt;\n                if (weightsObj.buffer === 0) {\n                    wt = 10;\n                } else {\n                    wt = (1 / weightsObj.buffer);\n                }\n                let weightedRebuffer = wt * rebuffer;\n\n                if (weightsObj.latency === 0) {\n                    wt = 10;\n                } else {\n                    wt = (1 / weightsObj.latency); // inverse the weight because wt and latency should have positive relationship, i.e., higher latency = higher wt\n                }\n                let weightedLatency = wt * neuron.state.latency;\n\n                let totalQoE = qoeEvaluator.calculateSingleUseQoe(neuron.bitrate, weightedRebuffer, weightedLatency, playbackRate);\n                if ((maxQoE === null || totalQoE > maxQoE) && _checkConstraints(currentLatency, nextBuffer, deltaLatency)) {\n                    maxQoE = totalQoE;\n                    winnerWeights = weightVector;\n                    winnerBitrate = neuron.bitrate;\n                }\n            });\n        });\n\n        // winnerWeights was found, check if constraints are satisfied\n        if (winnerWeights === null && winnerBitrate === null) {\n            winnerWeights = -1;\n        }\n\n        previousLatency = currentLatency;\n        return winnerWeights;\n    }\n\n    /**\n     *\n     * @param {number} nextLatency\n     * @param {number} nextBuffer\n     * @param {number} deltaLatency\n     * @return {boolean}\n     * @private\n     */\n    function _checkConstraints(nextLatency, nextBuffer, deltaLatency) {\n        // A1\n        // disabled till we find a better way of estimating latency\n        // fails for all with current value\n        if (nextLatency > targetLatency + deltaLatency) {\n            return false;\n        }\n\n        return nextBuffer >= bufferMin;\n    }\n\n    /**\n     *\n     * @param {array} list\n     * @param {number} length\n     * @return {*}\n     * @private\n     */\n    function _getPermutations(list, length) {\n        // Copy initial values as arrays\n        let perm = list.map(function (val) {\n            return [val];\n        });\n        // Our permutation generator\n        let generate = function (perm, length, currLen) {\n            // Reached desired length\n            if (currLen === length) {\n                return perm;\n            }\n            // For each existing permutation\n            let len = perm.length;\n            for (let i = 0; i < len; i++) {\n                let currPerm = perm.shift();\n                // Create new permutation\n                for (let k = 0; k < list.length; k++) {\n                    perm.push(currPerm.concat(list[k]));\n                }\n            }\n            // Recurse\n            return generate(perm, length, currLen + 1);\n        };\n        // Start with size 1 because of initial values\n        return generate(perm, length, 1);\n    }\n\n    /**\n     *\n     * @return {number}\n     */\n    function getMinBuffer() {\n        return bufferMin;\n    }\n\n    /**\n     *\n     * @return {number}\n     */\n    function getSegmentDuration() {\n        return segmentDuration;\n    }\n\n    /**\n     *\n     * @param {number} bitrateToDownload\n     * @param {number} currentBuffer\n     * @param {number} currentThroughput\n     * @return {number}\n     */\n    function getNextBufferWithBitrate(bitrateToDownload, currentBuffer, currentThroughput) {\n        let downloadTime = (bitrateToDownload * segmentDuration) / currentThroughput;\n        return getNextBuffer(currentBuffer, downloadTime);\n    }\n\n    /**\n     *\n     * @param {number} currentBuffer\n     * @param {number} downloadTime\n     * @return {number}\n     */\n    function getNextBuffer(currentBuffer, downloadTime) {\n        const segmentDuration = getSegmentDuration();\n        let nextBuffer;\n        if (downloadTime > segmentDuration) {\n            nextBuffer = currentBuffer - segmentDuration;\n        } else {\n            nextBuffer = currentBuffer + segmentDuration - downloadTime;\n        }\n        return nextBuffer;\n    }\n\n    instance = {\n        getMinBuffer,\n        getSegmentDuration,\n        getNextBufferWithBitrate,\n        getNextBuffer,\n        findWeightVector\n    };\n\n    _setup();\n\n    return instance;\n}\n\nLoLpWeightSelector.__dashjs_factory_name = 'LoLpWeightSelector';\nexport default FactoryMaker.getClassFactory(LoLpWeightSelector);\n"]},"metadata":{},"sourceType":"script"}