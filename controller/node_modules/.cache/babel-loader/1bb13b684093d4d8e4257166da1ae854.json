{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../../streaming/constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _DashJSError = require('../../streaming/vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction RepresentationController(config) {\n  config = config || {};\n  var eventBus = config.eventBus;\n  var events = config.events;\n  var errors = config.errors;\n  var abrController = config.abrController;\n  var dashMetrics = config.dashMetrics;\n  var playbackController = config.playbackController;\n  var timelineConverter = config.timelineConverter;\n  var type = config.type;\n  var streamInfo = config.streamInfo;\n  var dashConstants = config.dashConstants;\n  var instance = void 0,\n      realAdaptation = void 0,\n      updating = void 0,\n      voAvailableRepresentations = void 0,\n      currentVoRepresentation = void 0;\n\n  function setup() {\n    resetInitialSettings();\n    eventBus.on(events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n    eventBus.on(events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n    eventBus.on(events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n    eventBus.on(events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function checkConfig() {\n    if (!abrController || !dashMetrics || !playbackController || !timelineConverter) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n\n  function getData() {\n    return realAdaptation;\n  }\n\n  function isUpdating() {\n    return updating;\n  }\n\n  function getCurrentRepresentation() {\n    return currentVoRepresentation;\n  }\n\n  function resetInitialSettings() {\n    realAdaptation = null;\n    updating = true;\n    voAvailableRepresentations = [];\n  }\n\n  function reset() {\n    eventBus.off(events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n    eventBus.off(events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n    eventBus.off(events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n    eventBus.off(events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n    resetInitialSettings();\n  }\n\n  function updateData(newRealAdaptation, availableRepresentations, type, quality) {\n    checkConfig();\n    startDataUpdate();\n    voAvailableRepresentations = availableRepresentations;\n    currentVoRepresentation = getRepresentationForQuality(quality);\n    realAdaptation = newRealAdaptation;\n\n    if (type !== _Constants2.default.VIDEO && type !== _Constants2.default.AUDIO && type !== _Constants2.default.FRAGMENTED_TEXT) {\n      endDataUpdate();\n      return;\n    }\n\n    updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n  }\n\n  function addRepresentationSwitch() {\n    checkConfig();\n    var now = new Date();\n    var currentRepresentation = getCurrentRepresentation();\n    var currentVideoTimeMs = playbackController.getTime() * 1000;\n\n    if (currentRepresentation) {\n      dashMetrics.addRepresentationSwitch(currentRepresentation.adaptation.type, now, currentVideoTimeMs, currentRepresentation.id);\n    }\n  }\n\n  function getRepresentationForQuality(quality) {\n    return quality === null || quality === undefined || quality >= voAvailableRepresentations.length ? null : voAvailableRepresentations[quality];\n  }\n\n  function getQualityForRepresentation(voRepresentation) {\n    return voAvailableRepresentations.indexOf(voRepresentation);\n  }\n\n  function isAllRepresentationsUpdated() {\n    for (var i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n      var segmentInfoType = voAvailableRepresentations[i].segmentInfoType;\n\n      if (voAvailableRepresentations[i].segmentAvailabilityRange === null || !voAvailableRepresentations[i].hasInitialization() || (segmentInfoType === dashConstants.SEGMENT_BASE || segmentInfoType === dashConstants.BASE_URL) && !voAvailableRepresentations[i].segments) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function setExpectedLiveEdge(liveEdge) {\n    timelineConverter.setExpectedLiveEdge(liveEdge);\n    dashMetrics.updateManifestUpdateInfo({\n      presentationStartTime: liveEdge\n    });\n  }\n\n  function updateRepresentation(representation, isDynamic) {\n    representation.segmentAvailabilityRange = timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic);\n\n    if (representation.segmentAvailabilityRange.end < representation.segmentAvailabilityRange.start) {\n      var error = new _DashJSError2.default(errors.SEGMENTS_UNAVAILABLE_ERROR_CODE, errors.SEGMENTS_UNAVAILABLE_ERROR_MESSAGE, {\n        availabilityDelay: representation.segmentAvailabilityRange.start - representation.segmentAvailabilityRange.end\n      });\n      endDataUpdate(error);\n      return;\n    }\n\n    if (isDynamic) {\n      setExpectedLiveEdge(representation.segmentAvailabilityRange.end);\n    }\n  }\n\n  function updateAvailabilityWindow(isDynamic, notifyUpdate) {\n    checkConfig();\n\n    for (var i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n      updateRepresentation(voAvailableRepresentations[i], isDynamic);\n\n      if (notifyUpdate) {\n        eventBus.trigger(events.REPRESENTATION_UPDATE_STARTED, {\n          representation: voAvailableRepresentations[i]\n        }, {\n          streamId: streamInfo.id,\n          mediaType: type\n        });\n      }\n    }\n  }\n\n  function resetAvailabilityWindow() {\n    voAvailableRepresentations.forEach(function (rep) {\n      rep.segmentAvailabilityRange = null;\n    });\n  }\n\n  function startDataUpdate() {\n    updating = true;\n    eventBus.trigger(events.DATA_UPDATE_STARTED, {}, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function endDataUpdate(error) {\n    updating = false;\n    eventBus.trigger(events.DATA_UPDATE_COMPLETED, {\n      data: realAdaptation,\n      currentRepresentation: currentVoRepresentation,\n      error: error\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function postponeUpdate(postponeTimePeriod) {\n    var delay = postponeTimePeriod;\n\n    var update = function update() {\n      if (isUpdating()) return;\n      startDataUpdate(); // clear the segmentAvailabilityRange for all reps.\n      // this ensures all are updated before the live edge search starts\n\n      resetAvailabilityWindow();\n      updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n    };\n\n    eventBus.trigger(events.AST_IN_FUTURE, {\n      delay: delay\n    });\n    setTimeout(update, delay);\n  }\n\n  function onRepresentationUpdated(e) {\n    if (!isUpdating()) return;\n\n    if (e.error) {\n      endDataUpdate(e.error);\n      return;\n    }\n\n    var r = e.representation;\n    var manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate();\n    var alreadyAdded = false;\n    var postponeTimePeriod = 0;\n    var repInfo = void 0,\n        err = void 0,\n        repSwitch = void 0;\n\n    if (r.adaptation.period.mpd.manifest.type === dashConstants.DYNAMIC && !r.adaptation.period.mpd.manifest.ignorePostponeTimePeriod && playbackController.getStreamController().getStreams().length <= 1) {\n      // We must put things to sleep unless till e.g. the startTime calculation in ScheduleController.onLiveEdgeSearchCompleted fall after the segmentAvailabilityRange.start\n      postponeTimePeriod = getRepresentationUpdatePostponeTimePeriod(r);\n    }\n\n    if (postponeTimePeriod > 0) {\n      postponeUpdate(postponeTimePeriod);\n      err = new _DashJSError2.default(errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE, errors.SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE);\n      endDataUpdate(err);\n      return;\n    }\n\n    if (manifestUpdateInfo) {\n      for (var i = 0; i < manifestUpdateInfo.representationInfo.length; i++) {\n        repInfo = manifestUpdateInfo.representationInfo[i];\n\n        if (repInfo.index === r.index && repInfo.mediaType === getType()) {\n          alreadyAdded = true;\n          break;\n        }\n      }\n\n      if (!alreadyAdded) {\n        dashMetrics.addManifestUpdateRepresentationInfo(r, getType());\n      }\n    }\n\n    if (isAllRepresentationsUpdated()) {\n      abrController.setPlaybackQuality(getType(), streamInfo, getQualityForRepresentation(currentVoRepresentation));\n      dashMetrics.updateManifestUpdateInfo({\n        latency: currentVoRepresentation.segmentAvailabilityRange.end - playbackController.getTime()\n      });\n      repSwitch = dashMetrics.getCurrentRepresentationSwitch(getCurrentRepresentation().adaptation.type);\n\n      if (!repSwitch) {\n        addRepresentationSwitch();\n      }\n\n      endDataUpdate();\n    }\n  }\n\n  function getRepresentationUpdatePostponeTimePeriod(representation) {\n    try {\n      var streamController = playbackController.getStreamController();\n      var activeStreamInfo = streamController.getActiveStreamInfo();\n      var startTimeAnchor = representation.segmentAvailabilityRange.start;\n\n      if (activeStreamInfo && activeStreamInfo.id && activeStreamInfo.id !== streamInfo.id) {\n        // We need to consider the currently playing period if a period switch is performed.\n        startTimeAnchor = Math.min(playbackController.getTime(), startTimeAnchor);\n      }\n\n      var segmentAvailabilityTimePeriod = representation.segmentAvailabilityRange.end - startTimeAnchor;\n      var liveDelay = playbackController.getLiveDelay();\n      return (liveDelay - segmentAvailabilityTimePeriod) * 1000;\n    } catch (e) {\n      return 0;\n    }\n  }\n\n  function onWallclockTimeUpdated(e) {\n    if (e.isDynamic) {\n      updateAvailabilityWindow(e.isDynamic);\n    }\n  }\n\n  function onQualityChanged(e) {\n    currentVoRepresentation = getRepresentationForQuality(e.newQuality);\n    addRepresentationSwitch();\n  }\n\n  function onManifestValidityChanged(e) {\n    if (e.newDuration) {\n      var representation = getCurrentRepresentation();\n\n      if (representation && representation.adaptation.period) {\n        var period = representation.adaptation.period;\n        period.duration = e.newDuration;\n      }\n    }\n  }\n\n  instance = {\n    getStreamId: getStreamId,\n    getType: getType,\n    getData: getData,\n    isUpdating: isUpdating,\n    updateData: updateData,\n    updateRepresentation: updateRepresentation,\n    getCurrentRepresentation: getCurrentRepresentation,\n    getRepresentationForQuality: getRepresentationForQuality,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nRepresentationController.__dashjs_factory_name = 'RepresentationController';\nexports.default = _FactoryMaker2.default.getClassFactory(RepresentationController);","map":{"version":3,"mappings":"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","names":["RepresentationController","config","eventBus","events","errors","abrController","dashMetrics","playbackController","timelineConverter","type","streamInfo","dashConstants","instance","realAdaptation","updating","voAvailableRepresentations","currentVoRepresentation","setup","resetInitialSettings","on","QUALITY_CHANGE_REQUESTED","onQualityChanged","REPRESENTATION_UPDATE_COMPLETED","onRepresentationUpdated","WALLCLOCK_TIME_UPDATED","onWallclockTimeUpdated","MANIFEST_VALIDITY_CHANGED","onManifestValidityChanged","getStreamId","id","getType","checkConfig","Error","Constants","MISSING_CONFIG_ERROR","getData","isUpdating","getCurrentRepresentation","reset","off","updateData","newRealAdaptation","availableRepresentations","quality","startDataUpdate","getRepresentationForQuality","VIDEO","AUDIO","FRAGMENTED_TEXT","endDataUpdate","updateAvailabilityWindow","getIsDynamic","addRepresentationSwitch","now","Date","currentRepresentation","currentVideoTimeMs","getTime","adaptation","undefined","length","getQualityForRepresentation","voRepresentation","indexOf","isAllRepresentationsUpdated","i","ln","segmentInfoType","segmentAvailabilityRange","hasInitialization","SEGMENT_BASE","BASE_URL","segments","setExpectedLiveEdge","liveEdge","updateManifestUpdateInfo","presentationStartTime","updateRepresentation","representation","isDynamic","calcSegmentAvailabilityRange","end","start","error","DashJSError","SEGMENTS_UNAVAILABLE_ERROR_CODE","SEGMENTS_UNAVAILABLE_ERROR_MESSAGE","availabilityDelay","notifyUpdate","trigger","REPRESENTATION_UPDATE_STARTED","streamId","mediaType","resetAvailabilityWindow","forEach","rep","DATA_UPDATE_STARTED","DATA_UPDATE_COMPLETED","data","postponeUpdate","postponeTimePeriod","delay","update","AST_IN_FUTURE","setTimeout","e","r","manifestUpdateInfo","getCurrentManifestUpdate","alreadyAdded","repInfo","err","repSwitch","period","mpd","manifest","DYNAMIC","ignorePostponeTimePeriod","getStreamController","getStreams","getRepresentationUpdatePostponeTimePeriod","SEGMENTS_UPDATE_FAILED_ERROR_CODE","SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE","representationInfo","index","addManifestUpdateRepresentationInfo","setPlaybackQuality","latency","getCurrentRepresentationSwitch","streamController","activeStreamInfo","getActiveStreamInfo","startTimeAnchor","Math","min","segmentAvailabilityTimePeriod","liveDelay","getLiveDelay","newQuality","newDuration","duration","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/dash/controllers/RepresentationController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../../streaming/constants/Constants';\nimport DashJSError from '../../streaming/vo/DashJSError';\nimport FactoryMaker from '../../core/FactoryMaker';\n\nfunction RepresentationController(config) {\n\n    config = config || {};\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const errors = config.errors;\n    const abrController = config.abrController;\n    const dashMetrics = config.dashMetrics;\n    const playbackController = config.playbackController;\n    const timelineConverter = config.timelineConverter;\n    const type = config.type;\n    const streamInfo = config.streamInfo;\n    const dashConstants = config.dashConstants;\n\n    let instance,\n        realAdaptation,\n        updating,\n        voAvailableRepresentations,\n        currentVoRepresentation;\n\n    function setup() {\n        resetInitialSettings();\n\n        eventBus.on(events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.on(events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n        eventBus.on(events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n        eventBus.on(events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function checkConfig() {\n        if (!abrController || !dashMetrics || !playbackController || !timelineConverter) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function getData() {\n        return realAdaptation;\n    }\n\n    function isUpdating() {\n        return updating;\n    }\n\n    function getCurrentRepresentation() {\n        return currentVoRepresentation;\n    }\n\n    function resetInitialSettings() {\n        realAdaptation = null;\n        updating = true;\n        voAvailableRepresentations = [];\n    }\n\n    function reset() {\n        eventBus.off(events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.off(events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n        eventBus.off(events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n        eventBus.off(events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n\n        resetInitialSettings();\n    }\n\n    function updateData(newRealAdaptation, availableRepresentations, type, quality) {\n        checkConfig();\n\n        startDataUpdate();\n\n        voAvailableRepresentations = availableRepresentations;\n\n        currentVoRepresentation = getRepresentationForQuality(quality);\n        realAdaptation = newRealAdaptation;\n\n        if (type !== Constants.VIDEO && type !== Constants.AUDIO && type !== Constants.FRAGMENTED_TEXT) {\n            endDataUpdate();\n            return;\n        }\n\n        updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n    }\n\n    function addRepresentationSwitch() {\n        checkConfig();\n        const now = new Date();\n        const currentRepresentation = getCurrentRepresentation();\n        const currentVideoTimeMs = playbackController.getTime() * 1000;\n        if (currentRepresentation) {\n            dashMetrics.addRepresentationSwitch(currentRepresentation.adaptation.type, now, currentVideoTimeMs, currentRepresentation.id);\n        }\n    }\n\n    function getRepresentationForQuality(quality) {\n        return quality === null || quality === undefined || quality >= voAvailableRepresentations.length ? null : voAvailableRepresentations[quality];\n    }\n\n    function getQualityForRepresentation(voRepresentation) {\n        return voAvailableRepresentations.indexOf(voRepresentation);\n    }\n\n    function isAllRepresentationsUpdated() {\n        for (let i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n            let segmentInfoType = voAvailableRepresentations[i].segmentInfoType;\n            if (voAvailableRepresentations[i].segmentAvailabilityRange === null || !voAvailableRepresentations[i].hasInitialization() ||\n                ((segmentInfoType === dashConstants.SEGMENT_BASE || segmentInfoType === dashConstants.BASE_URL) && !voAvailableRepresentations[i].segments)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function setExpectedLiveEdge(liveEdge) {\n        timelineConverter.setExpectedLiveEdge(liveEdge);\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\n    }\n\n    function updateRepresentation(representation, isDynamic) {\n        representation.segmentAvailabilityRange = timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic);\n\n        if (representation.segmentAvailabilityRange.end < representation.segmentAvailabilityRange.start) {\n            let error = new DashJSError(errors.SEGMENTS_UNAVAILABLE_ERROR_CODE, errors.SEGMENTS_UNAVAILABLE_ERROR_MESSAGE, {availabilityDelay: representation.segmentAvailabilityRange.start - representation.segmentAvailabilityRange.end});\n            endDataUpdate(error);\n            return;\n        }\n\n        if (isDynamic) {\n            setExpectedLiveEdge(representation.segmentAvailabilityRange.end);\n        }\n    }\n\n    function updateAvailabilityWindow(isDynamic, notifyUpdate) {\n        checkConfig();\n\n        for (let i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n            updateRepresentation(voAvailableRepresentations[i], isDynamic);\n            if (notifyUpdate) {\n                eventBus.trigger(events.REPRESENTATION_UPDATE_STARTED,\n                    { representation: voAvailableRepresentations[i] },\n                    { streamId: streamInfo.id, mediaType: type }\n                );\n            }\n        }\n    }\n\n    function resetAvailabilityWindow() {\n        voAvailableRepresentations.forEach(rep => {\n            rep.segmentAvailabilityRange = null;\n        });\n    }\n\n    function startDataUpdate() {\n        updating = true;\n        eventBus.trigger(events.DATA_UPDATE_STARTED,\n            {},\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function endDataUpdate(error) {\n        updating = false;\n        eventBus.trigger(events.DATA_UPDATE_COMPLETED,\n            {\n                data: realAdaptation,\n                currentRepresentation: currentVoRepresentation,\n                error: error\n            },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function postponeUpdate(postponeTimePeriod) {\n        let delay = postponeTimePeriod;\n        let update = function () {\n            if (isUpdating()) return;\n\n            startDataUpdate();\n\n            // clear the segmentAvailabilityRange for all reps.\n            // this ensures all are updated before the live edge search starts\n            resetAvailabilityWindow();\n\n            updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n        };\n        eventBus.trigger(events.AST_IN_FUTURE, { delay: delay });\n        setTimeout(update, delay);\n    }\n\n    function onRepresentationUpdated(e) {\n        if (!isUpdating()) return;\n\n        if (e.error) {\n            endDataUpdate(e.error);\n            return;\n        }\n\n        let r = e.representation;\n        let manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate();\n        let alreadyAdded = false;\n        let postponeTimePeriod = 0;\n        let repInfo,\n            err,\n            repSwitch;\n\n        if (r.adaptation.period.mpd.manifest.type === dashConstants.DYNAMIC && !r.adaptation.period.mpd.manifest.ignorePostponeTimePeriod && playbackController.getStreamController().getStreams().length <= 1) {\n            // We must put things to sleep unless till e.g. the startTime calculation in ScheduleController.onLiveEdgeSearchCompleted fall after the segmentAvailabilityRange.start\n            postponeTimePeriod = getRepresentationUpdatePostponeTimePeriod(r);\n        }\n\n        if (postponeTimePeriod > 0) {\n            postponeUpdate(postponeTimePeriod);\n            err = new DashJSError(errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE, errors.SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE);\n            endDataUpdate(err);\n            return;\n        }\n\n        if (manifestUpdateInfo) {\n            for (let i = 0; i < manifestUpdateInfo.representationInfo.length; i++) {\n                repInfo = manifestUpdateInfo.representationInfo[i];\n                if (repInfo.index === r.index && repInfo.mediaType === getType()) {\n                    alreadyAdded = true;\n                    break;\n                }\n            }\n\n            if (!alreadyAdded) {\n                dashMetrics.addManifestUpdateRepresentationInfo(r, getType());\n            }\n        }\n\n        if (isAllRepresentationsUpdated()) {\n            abrController.setPlaybackQuality(getType(), streamInfo, getQualityForRepresentation(currentVoRepresentation));\n            dashMetrics.updateManifestUpdateInfo({latency: currentVoRepresentation.segmentAvailabilityRange.end - playbackController.getTime()});\n\n            repSwitch = dashMetrics.getCurrentRepresentationSwitch(getCurrentRepresentation().adaptation.type);\n\n            if (!repSwitch) {\n                addRepresentationSwitch();\n            }\n            endDataUpdate();\n        }\n    }\n\n    function getRepresentationUpdatePostponeTimePeriod(representation) {\n        try {\n            const streamController = playbackController.getStreamController();\n            const activeStreamInfo = streamController.getActiveStreamInfo();\n            let startTimeAnchor = representation.segmentAvailabilityRange.start;\n\n            if (activeStreamInfo && activeStreamInfo.id && activeStreamInfo.id !== streamInfo.id) {\n                // We need to consider the currently playing period if a period switch is performed.\n                startTimeAnchor = Math.min(playbackController.getTime(), startTimeAnchor);\n            }\n\n            let segmentAvailabilityTimePeriod = representation.segmentAvailabilityRange.end - startTimeAnchor;\n            let liveDelay = playbackController.getLiveDelay();\n\n            return (liveDelay - segmentAvailabilityTimePeriod) * 1000;\n        } catch (e) {\n            return 0;\n        }\n    }\n\n    function onWallclockTimeUpdated(e) {\n        if (e.isDynamic) {\n            updateAvailabilityWindow(e.isDynamic);\n        }\n    }\n\n    function onQualityChanged(e) {\n        currentVoRepresentation = getRepresentationForQuality(e.newQuality);\n        addRepresentationSwitch();\n    }\n\n    function onManifestValidityChanged(e) {\n        if (e.newDuration) {\n            const representation = getCurrentRepresentation();\n            if (representation && representation.adaptation.period) {\n                const period = representation.adaptation.period;\n                period.duration = e.newDuration;\n            }\n        }\n    }\n\n    instance = {\n        getStreamId: getStreamId,\n        getType: getType,\n        getData: getData,\n        isUpdating: isUpdating,\n        updateData: updateData,\n        updateRepresentation: updateRepresentation,\n        getCurrentRepresentation: getCurrentRepresentation,\n        getRepresentationForQuality: getRepresentationForQuality,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nRepresentationController.__dashjs_factory_name = 'RepresentationController';\nexport default FactoryMaker.getClassFactory(RepresentationController);\n"]},"metadata":{},"sourceType":"script"}