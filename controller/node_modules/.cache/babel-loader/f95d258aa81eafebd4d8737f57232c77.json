{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _HTTPRequest = require('../vo/metrics/HTTPRequest');\n\nvar _TextTrackInfo = require('../vo/TextTrackInfo');\n\nvar _TextTrackInfo2 = _interopRequireDefault(_TextTrackInfo);\n\nvar _BoxParser = require('../utils/BoxParser');\n\nvar _BoxParser2 = _interopRequireDefault(_BoxParser);\n\nvar _CustomTimeRanges = require('../utils/CustomTimeRanges');\n\nvar _CustomTimeRanges2 = _interopRequireDefault(_CustomTimeRanges);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _TextTracks = require('./TextTracks');\n\nvar _TextTracks2 = _interopRequireDefault(_TextTracks);\n\nvar _EmbeddedTextHtmlRender = require('./EmbeddedTextHtmlRender');\n\nvar _EmbeddedTextHtmlRender2 = _interopRequireDefault(_EmbeddedTextHtmlRender);\n\nvar _codemIsoboxer = require('codem-isoboxer');\n\nvar _codemIsoboxer2 = _interopRequireDefault(_codemIsoboxer);\n\nvar _cea608Parser = require('../../../externals/cea608-parser');\n\nvar _cea608Parser2 = _interopRequireDefault(_cea608Parser);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _DashJSError = require('../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _Errors = require('../../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction TextSourceBuffer() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var embeddedInitialized = false;\n  var instance = void 0,\n      logger = void 0,\n      boxParser = void 0,\n      errHandler = void 0,\n      adapter = void 0,\n      manifestModel = void 0,\n      mediaController = void 0,\n      parser = void 0,\n      vttParser = void 0,\n      ttmlParser = void 0,\n      mediaInfos = void 0,\n      textTracks = void 0,\n      fragmentedFragmentModel = void 0,\n      initializationSegmentReceived = void 0,\n      timescale = void 0,\n      fragmentedTracks = void 0,\n      videoModel = void 0,\n      streamController = void 0,\n      firstFragmentedSubtitleStart = void 0,\n      currFragmentedTrackIdx = void 0,\n      embeddedTracks = void 0,\n      embeddedTimescale = void 0,\n      embeddedLastSequenceNumber = void 0,\n      embeddedCea608FieldParsers = void 0,\n      embeddedTextHtmlRender = void 0,\n      mseTimeOffset = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    resetInitialSettings();\n  }\n\n  function resetFragmented() {\n    fragmentedFragmentModel = null;\n    timescale = NaN;\n    fragmentedTracks = [];\n    firstFragmentedSubtitleStart = null;\n    initializationSegmentReceived = false;\n  }\n\n  function resetInitialSettings() {\n    resetFragmented();\n    mediaInfos = [];\n    parser = null;\n  }\n\n  function initialize(mimeType, streamInfo, mediaInfoArr, fragmentModel) {\n    if (!embeddedInitialized) {\n      initEmbedded();\n    }\n\n    textTracks.setConfig({\n      videoModel: videoModel\n    });\n    textTracks.initialize();\n\n    if (!boxParser) {\n      boxParser = (0, _BoxParser2.default)(context).getInstance();\n    }\n\n    addMediaInfos(mimeType, streamInfo, mediaInfoArr, fragmentModel);\n  }\n\n  function addMediaInfos(mimeType, streamInfo, mediaInfoArr, fragmentModel) {\n    var isFragmented = !adapter.getIsTextTrack(mimeType);\n    mediaInfos = mediaInfos.concat(mediaInfoArr);\n\n    if (isFragmented) {\n      fragmentedFragmentModel = fragmentModel;\n      instance.buffered = (0, _CustomTimeRanges2.default)(context).create();\n      fragmentedTracks = mediaController.getTracksFor(_Constants2.default.FRAGMENTED_TEXT, streamInfo);\n      var currFragTrack = mediaController.getCurrentTrackFor(_Constants2.default.FRAGMENTED_TEXT, streamInfo);\n\n      for (var i = 0; i < fragmentedTracks.length; i++) {\n        if (fragmentedTracks[i] === currFragTrack) {\n          setCurrentFragmentedTrackIdx(i);\n          break;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < mediaInfos.length; _i++) {\n      createTextTrackFromMediaInfo(null, mediaInfos[_i]);\n    }\n  }\n\n  function abort() {\n    textTracks.deleteAllTextTracks();\n    resetFragmented();\n    boxParser = null;\n    mediaInfos = [];\n  }\n\n  function reset() {\n    resetInitialSettings();\n    streamController = null;\n    videoModel = null;\n    textTracks = null;\n  }\n\n  function onVideoChunkReceived(e) {\n    var chunk = e.chunk;\n\n    if (chunk.mediaInfo.embeddedCaptions) {\n      append(chunk.bytes, chunk);\n    }\n  }\n\n  function initEmbedded() {\n    embeddedTracks = [];\n    textTracks = (0, _TextTracks2.default)(context).getInstance();\n    textTracks.setConfig({\n      videoModel: videoModel\n    });\n    textTracks.initialize();\n    boxParser = (0, _BoxParser2.default)(context).getInstance();\n    currFragmentedTrackIdx = null;\n    embeddedTimescale = 0;\n    embeddedCea608FieldParsers = [];\n    embeddedLastSequenceNumber = null;\n    embeddedInitialized = true;\n    embeddedTextHtmlRender = (0, _EmbeddedTextHtmlRender2.default)(context).getInstance();\n    var streamProcessors = streamController.getActiveStreamProcessors();\n\n    for (var i in streamProcessors) {\n      if (streamProcessors[i].getType() === 'video') {\n        mseTimeOffset = streamProcessors[i].getRepresentationInfo().MSETimeOffset;\n        break;\n      }\n    }\n\n    eventBus.on(_Events2.default.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n    eventBus.on(_Events2.default.BUFFER_CLEARED, onVideoBufferCleared, this);\n  }\n\n  function resetEmbedded() {\n    eventBus.off(_Events2.default.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n    eventBus.off(_Events2.default.BUFFER_CLEARED, onVideoBufferCleared, this);\n\n    if (textTracks) {\n      textTracks.deleteAllTextTracks();\n    }\n\n    embeddedInitialized = false;\n    embeddedTracks = [];\n    embeddedCea608FieldParsers = [null, null];\n    embeddedLastSequenceNumber = null;\n  }\n\n  function addEmbeddedTrack(mediaInfo) {\n    if (!embeddedInitialized) {\n      initEmbedded();\n    }\n\n    if (mediaInfo) {\n      if (mediaInfo.id === _Constants2.default.CC1 || mediaInfo.id === _Constants2.default.CC3) {\n        for (var i = 0; i < embeddedTracks.length; i++) {\n          if (embeddedTracks[i].id === mediaInfo.id) {\n            return;\n          }\n        }\n\n        embeddedTracks.push(mediaInfo);\n      } else {\n        logger.warn('Embedded track ' + mediaInfo.id + ' not supported!');\n      }\n    }\n  }\n\n  function setConfig(config) {\n    if (!config) {\n      return;\n    }\n\n    if (config.errHandler) {\n      errHandler = config.errHandler;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n\n    if (config.manifestModel) {\n      manifestModel = config.manifestModel;\n    }\n\n    if (config.mediaController) {\n      mediaController = config.mediaController;\n    }\n\n    if (config.videoModel) {\n      videoModel = config.videoModel;\n    }\n\n    if (config.streamController) {\n      streamController = config.streamController;\n    }\n\n    if (config.textTracks) {\n      textTracks = config.textTracks;\n    }\n\n    if (config.vttParser) {\n      vttParser = config.vttParser;\n    }\n\n    if (config.ttmlParser) {\n      ttmlParser = config.ttmlParser;\n    }\n  }\n\n  function getConfig() {\n    var config = {\n      fragmentModel: fragmentedFragmentModel,\n      fragmentedTracks: fragmentedTracks,\n      videoModel: videoModel\n    };\n    return config;\n  }\n\n  function setCurrentFragmentedTrackIdx(idx) {\n    currFragmentedTrackIdx = idx;\n  }\n\n  function createTextTrackFromMediaInfo(captionData, mediaInfo) {\n    var textTrackInfo = new _TextTrackInfo2.default();\n    var trackKindMap = {\n      subtitle: 'subtitles',\n      caption: 'captions'\n    }; //Dash Spec has no \"s\" on end of KIND but HTML needs plural.\n\n    var getKind = function getKind() {\n      var kind = mediaInfo.roles.length > 0 ? trackKindMap[mediaInfo.roles[0]] : trackKindMap.caption;\n      kind = kind === trackKindMap.caption || kind === trackKindMap.subtitle ? kind : trackKindMap.caption;\n      return kind;\n    };\n\n    var checkTTML = function checkTTML() {\n      var ttml = false;\n\n      if (mediaInfo.codec && mediaInfo.codec.search(_Constants2.default.STPP) >= 0) {\n        ttml = true;\n      }\n\n      if (mediaInfo.mimeType && mediaInfo.mimeType.search(_Constants2.default.TTML) >= 0) {\n        ttml = true;\n      }\n\n      return ttml;\n    };\n\n    textTrackInfo.captionData = captionData;\n    textTrackInfo.lang = mediaInfo.lang;\n    textTrackInfo.labels = mediaInfo.labels;\n    textTrackInfo.id = mediaInfo.id ? mediaInfo.id : mediaInfo.index; // AdaptationSet id (an unsigned int) as it's optional parameter, use mediaInfo.index\n\n    textTrackInfo.index = mediaInfo.index; // AdaptationSet index in manifest\n\n    textTrackInfo.isTTML = checkTTML();\n    textTrackInfo.defaultTrack = getIsDefault(mediaInfo);\n    textTrackInfo.isFragmented = !adapter.getIsTextTrack(mediaInfo.mimeType);\n    textTrackInfo.isEmbedded = mediaInfo.isEmbedded ? true : false;\n    textTrackInfo.kind = getKind();\n    textTrackInfo.roles = mediaInfo.roles;\n    textTrackInfo.accessibility = mediaInfo.accessibility;\n    var totalNrTracks = (mediaInfos ? mediaInfos.length : 0) + embeddedTracks.length;\n    textTracks.addTextTrack(textTrackInfo, totalNrTracks);\n  }\n\n  function append(bytes, chunk) {\n    var result = void 0,\n        sampleList = void 0,\n        i = void 0,\n        j = void 0,\n        k = void 0,\n        samplesInfo = void 0,\n        ccContent = void 0;\n    var mediaInfo = chunk.mediaInfo;\n    var mediaType = mediaInfo.type;\n    var mimeType = mediaInfo.mimeType;\n    var codecType = mediaInfo.codec || mimeType;\n\n    if (!codecType) {\n      logger.error('No text type defined');\n      return;\n    }\n\n    if (mediaType === _Constants2.default.FRAGMENTED_TEXT) {\n      if (!initializationSegmentReceived && chunk.segmentType === 'InitializationSegment') {\n        initializationSegmentReceived = true;\n        timescale = boxParser.getMediaTimescaleFromMoov(bytes);\n      } else {\n        if (!initializationSegmentReceived) {\n          return;\n        }\n\n        samplesInfo = boxParser.getSamplesInfo(bytes);\n        sampleList = samplesInfo.sampleList;\n\n        if (firstFragmentedSubtitleStart === null && sampleList.length > 0) {\n          firstFragmentedSubtitleStart = sampleList[0].cts - chunk.start * timescale;\n        }\n\n        if (codecType.search(_Constants2.default.STPP) >= 0) {\n          parser = parser !== null ? parser : getParser(codecType);\n\n          for (i = 0; i < sampleList.length; i++) {\n            var sample = sampleList[i];\n            var sampleStart = sample.cts;\n            var sampleRelStart = sampleStart - firstFragmentedSubtitleStart;\n            this.buffered.add(sampleRelStart / timescale, (sampleRelStart + sample.duration) / timescale);\n            var dataView = new DataView(bytes, sample.offset, sample.subSizes[0]);\n            ccContent = _codemIsoboxer2.default.Utils.dataViewToString(dataView, _Constants2.default.UTF8);\n            var images = [];\n            var subOffset = sample.offset + sample.subSizes[0];\n\n            for (j = 1; j < sample.subSizes.length; j++) {\n              var inData = new Uint8Array(bytes, subOffset, sample.subSizes[j]);\n              var raw = String.fromCharCode.apply(null, inData);\n              images.push(raw);\n              subOffset += sample.subSizes[j];\n            }\n\n            try {\n              // Only used for Miscrosoft Smooth Streaming support - caption time is relative to sample time. In this case, we apply an offset.\n              var manifest = manifestModel.getValue();\n              var offsetTime = manifest.ttmlTimeIsRelative ? sampleStart / timescale : 0;\n              result = parser.parse(ccContent, offsetTime, sampleStart / timescale, (sampleStart + sample.duration) / timescale, images);\n              textTracks.addCaptions(currFragmentedTrackIdx, firstFragmentedSubtitleStart / timescale, result);\n            } catch (e) {\n              fragmentedFragmentModel.removeExecutedRequestsBeforeTime();\n              this.remove();\n              logger.error('TTML parser error: ' + e.message);\n            }\n          }\n        } else {\n          // WebVTT case\n          var captionArray = [];\n\n          for (i = 0; i < sampleList.length; i++) {\n            var _sample = sampleList[i];\n            _sample.cts -= firstFragmentedSubtitleStart;\n            this.buffered.add(_sample.cts / timescale, (_sample.cts + _sample.duration) / timescale);\n            var sampleData = bytes.slice(_sample.offset, _sample.offset + _sample.size); // There are boxes inside the sampleData, so we need a ISOBoxer to get at it.\n\n            var sampleBoxes = _codemIsoboxer2.default.parseBuffer(sampleData);\n\n            for (j = 0; j < sampleBoxes.boxes.length; j++) {\n              var box1 = sampleBoxes.boxes[j];\n              logger.debug('VTT box1: ' + box1.type);\n\n              if (box1.type === 'vtte') {\n                continue; //Empty box\n              }\n\n              if (box1.type === 'vttc') {\n                logger.debug('VTT vttc boxes.length = ' + box1.boxes.length);\n\n                for (k = 0; k < box1.boxes.length; k++) {\n                  var box2 = box1.boxes[k];\n                  logger.debug('VTT box2: ' + box2.type);\n\n                  if (box2.type === 'payl') {\n                    var cue_text = box2.cue_text;\n                    logger.debug('VTT cue_text = ' + cue_text);\n                    var start_time = _sample.cts / timescale;\n                    var end_time = (_sample.cts + _sample.duration) / timescale;\n                    captionArray.push({\n                      start: start_time,\n                      end: end_time,\n                      data: cue_text,\n                      styles: {}\n                    });\n                    logger.debug('VTT ' + start_time + '-' + end_time + ' : ' + cue_text);\n                  }\n                }\n              }\n            }\n          }\n\n          if (captionArray.length > 0) {\n            textTracks.addCaptions(currFragmentedTrackIdx, 0, captionArray);\n          }\n        }\n      }\n    } else if (mediaType === _Constants2.default.TEXT) {\n      var _dataView = new DataView(bytes, 0, bytes.byteLength);\n\n      ccContent = _codemIsoboxer2.default.Utils.dataViewToString(_dataView, _Constants2.default.UTF8);\n\n      try {\n        result = getParser(codecType).parse(ccContent, 0);\n        textTracks.addCaptions(textTracks.getCurrentTrackIdx(), 0, result);\n      } catch (e) {\n        errHandler.error(new _DashJSError2.default(_Errors2.default.TIMED_TEXT_ERROR_ID_PARSE_CODE, _Errors2.default.TIMED_TEXT_ERROR_MESSAGE_PARSE + e.message, ccContent));\n      }\n    } else if (mediaType === _Constants2.default.VIDEO) {\n      //embedded text\n      if (chunk.segmentType === _HTTPRequest.HTTPRequest.INIT_SEGMENT_TYPE) {\n        if (embeddedTimescale === 0) {\n          embeddedTimescale = boxParser.getMediaTimescaleFromMoov(bytes);\n\n          for (i = 0; i < embeddedTracks.length; i++) {\n            createTextTrackFromMediaInfo(null, embeddedTracks[i]);\n          }\n        }\n      } else {\n        // MediaSegment\n        if (embeddedTimescale === 0) {\n          logger.warn('CEA-608: No timescale for embeddedTextTrack yet');\n          return;\n        }\n\n        var makeCueAdderForIndex = function makeCueAdderForIndex(self, trackIndex) {\n          function newCue(startTime, endTime, captionScreen) {\n            var captionsArray = null;\n\n            if (videoModel.getTTMLRenderingDiv()) {\n              captionsArray = embeddedTextHtmlRender.createHTMLCaptionsFromScreen(videoModel.getElement(), startTime, endTime, captionScreen);\n            } else {\n              var text = captionScreen.getDisplayText();\n              captionsArray = [{\n                start: startTime,\n                end: endTime,\n                data: text,\n                styles: {}\n              }];\n            }\n\n            if (captionsArray) {\n              textTracks.addCaptions(trackIndex, 0, captionsArray);\n            }\n          }\n\n          return newCue;\n        };\n\n        samplesInfo = boxParser.getSamplesInfo(bytes);\n        var sequenceNumber = samplesInfo.lastSequenceNumber;\n\n        if (!embeddedCea608FieldParsers[0] && !embeddedCea608FieldParsers[1]) {\n          // Time to setup the CEA-608 parsing\n          var field = void 0,\n              handler = void 0,\n              trackIdx = void 0;\n\n          for (i = 0; i < embeddedTracks.length; i++) {\n            if (embeddedTracks[i].id === _Constants2.default.CC1) {\n              field = 0;\n              trackIdx = textTracks.getTrackIdxForId(_Constants2.default.CC1);\n            } else if (embeddedTracks[i].id === _Constants2.default.CC3) {\n              field = 1;\n              trackIdx = textTracks.getTrackIdxForId(_Constants2.default.CC3);\n            }\n\n            if (trackIdx === -1) {\n              logger.warn('CEA-608: data before track is ready.');\n              return;\n            }\n\n            handler = makeCueAdderForIndex(this, trackIdx);\n            embeddedCea608FieldParsers[i] = new _cea608Parser2.default.Cea608Parser(i + 1, {\n              'newCue': handler\n            }, null);\n          }\n        }\n\n        if (embeddedTimescale) {\n          if (embeddedLastSequenceNumber !== null && sequenceNumber !== embeddedLastSequenceNumber + samplesInfo.numSequences) {\n            for (i = 0; i < embeddedCea608FieldParsers.length; i++) {\n              if (embeddedCea608FieldParsers[i]) {\n                embeddedCea608FieldParsers[i].reset();\n              }\n            }\n          }\n\n          var allCcData = extractCea608Data(bytes, samplesInfo.sampleList);\n\n          for (var fieldNr = 0; fieldNr < embeddedCea608FieldParsers.length; fieldNr++) {\n            var ccData = allCcData.fields[fieldNr];\n            var fieldParser = embeddedCea608FieldParsers[fieldNr];\n\n            if (fieldParser) {\n              for (i = 0; i < ccData.length; i++) {\n                fieldParser.addData(ccData[i][0] / embeddedTimescale, ccData[i][1]);\n              }\n            }\n          }\n\n          embeddedLastSequenceNumber = sequenceNumber;\n        }\n      }\n    }\n  }\n  /**\n  * Extract CEA-608 data from a buffer of data.\n  * @param {ArrayBuffer} data\n  * @param {Array} samples cue information\n  * @returns {Object|null} ccData corresponding to one segment.\n  */\n\n\n  function extractCea608Data(data, samples) {\n    if (samples.length === 0) {\n      return null;\n    }\n\n    var allCcData = {\n      splits: [],\n      fields: [[], []]\n    };\n    var raw = new DataView(data);\n\n    for (var i = 0; i < samples.length; i++) {\n      var sample = samples[i];\n\n      var cea608Ranges = _cea608Parser2.default.findCea608Nalus(raw, sample.offset, sample.size);\n\n      var lastSampleTime = null;\n      var idx = 0;\n\n      for (var j = 0; j < cea608Ranges.length; j++) {\n        var ccData = _cea608Parser2.default.extractCea608DataFromRange(raw, cea608Ranges[j]);\n\n        for (var k = 0; k < 2; k++) {\n          if (ccData[k].length > 0) {\n            if (sample.cts !== lastSampleTime) {\n              idx = 0;\n            } else {\n              idx += 1;\n            }\n\n            allCcData.fields[k].push([sample.cts + mseTimeOffset * embeddedTimescale, ccData[k], idx]);\n            lastSampleTime = sample.cts;\n          }\n        }\n      }\n    } // Sort by sampleTime ascending order\n    // If two packets have the same sampleTime, use them in the order\n    // they were received\n\n\n    allCcData.fields.forEach(function sortField(field) {\n      field.sort(function (a, b) {\n        if (a[0] === b[0]) {\n          return a[2] - b[2];\n        }\n\n        return a[0] - b[0];\n      });\n    });\n    return allCcData;\n  }\n\n  function getIsDefault(mediaInfo) {\n    //TODO How to tag default. currently same order as listed in manifest.\n    // Is there a way to mark a text adaptation set as the default one? DASHIF meeting talk about using role which is being used for track KIND\n    // Eg subtitles etc. You can have multiple role tags per adaptation Not defined in the spec yet.\n    var isDefault = false;\n\n    if (embeddedTracks.length > 1 && mediaInfo.isEmbedded) {\n      isDefault = mediaInfo.id && mediaInfo.id === _Constants2.default.CC1; // CC1 if both CC1 and CC3 exist\n    } else if (embeddedTracks.length === 1) {\n      if (mediaInfo.id && typeof mediaInfo.id === 'string' && mediaInfo.id.substring(0, 2) === 'CC') {\n        // Either CC1 or CC3\n        isDefault = true;\n      }\n    } else if (embeddedTracks.length === 0) {\n      isDefault = mediaInfo.index === mediaInfos[0].index;\n    }\n\n    return isDefault;\n  }\n\n  function getParser(codecType) {\n    var parser = void 0;\n\n    if (codecType.search(_Constants2.default.VTT) >= 0) {\n      parser = vttParser;\n    } else if (codecType.search(_Constants2.default.TTML) >= 0 || codecType.search(_Constants2.default.STPP) >= 0) {\n      parser = ttmlParser;\n    }\n\n    return parser;\n  }\n\n  function remove(start, end) {\n    //if start and end are not defined, remove all\n    if (start === undefined && start === end) {\n      start = this.buffered.start(0);\n      end = this.buffered.end(this.buffered.length - 1);\n    }\n\n    this.buffered.remove(start, end);\n  }\n\n  function onVideoBufferCleared(e) {\n    embeddedTracks.forEach(function (track) {\n      var trackIdx = textTracks.getTrackIdxForId(track.id);\n\n      if (trackIdx >= 0) {\n        textTracks.deleteCuesFromTrackIdx(trackIdx, e.from, e.to);\n      }\n    });\n  }\n\n  instance = {\n    initialize: initialize,\n    append: append,\n    abort: abort,\n    addEmbeddedTrack: addEmbeddedTrack,\n    resetEmbedded: resetEmbedded,\n    setConfig: setConfig,\n    getConfig: getConfig,\n    setCurrentFragmentedTrackIdx: setCurrentFragmentedTrackIdx,\n    remove: remove,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nTextSourceBuffer.__dashjs_factory_name = 'TextSourceBuffer';\nexports.default = _FactoryMaker2.default.getSingletonFactory(TextSourceBuffer);","map":{"version":3,"mappings":"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","names":["TextSourceBuffer","context","eventBus","getInstance","embeddedInitialized","instance","logger","boxParser","errHandler","adapter","manifestModel","mediaController","parser","vttParser","ttmlParser","mediaInfos","textTracks","fragmentedFragmentModel","initializationSegmentReceived","timescale","fragmentedTracks","videoModel","streamController","firstFragmentedSubtitleStart","currFragmentedTrackIdx","embeddedTracks","embeddedTimescale","embeddedLastSequenceNumber","embeddedCea608FieldParsers","embeddedTextHtmlRender","mseTimeOffset","setup","getLogger","resetInitialSettings","resetFragmented","NaN","initialize","mimeType","streamInfo","mediaInfoArr","fragmentModel","initEmbedded","setConfig","addMediaInfos","isFragmented","getIsTextTrack","concat","buffered","create","getTracksFor","Constants","FRAGMENTED_TEXT","currFragTrack","getCurrentTrackFor","i","length","setCurrentFragmentedTrackIdx","createTextTrackFromMediaInfo","abort","deleteAllTextTracks","reset","onVideoChunkReceived","e","chunk","mediaInfo","embeddedCaptions","append","bytes","streamProcessors","getActiveStreamProcessors","getType","getRepresentationInfo","MSETimeOffset","on","Events","VIDEO_CHUNK_RECEIVED","BUFFER_CLEARED","onVideoBufferCleared","resetEmbedded","off","addEmbeddedTrack","id","CC1","CC3","push","warn","config","getConfig","idx","captionData","textTrackInfo","TextTrackInfo","trackKindMap","subtitle","caption","getKind","kind","roles","checkTTML","ttml","codec","search","STPP","TTML","lang","labels","index","isTTML","defaultTrack","getIsDefault","isEmbedded","accessibility","totalNrTracks","addTextTrack","result","sampleList","j","k","samplesInfo","ccContent","mediaType","type","codecType","error","segmentType","getMediaTimescaleFromMoov","getSamplesInfo","cts","start","getParser","sample","sampleStart","sampleRelStart","add","duration","dataView","DataView","offset","subSizes","ISOBoxer","Utils","dataViewToString","UTF8","images","subOffset","inData","Uint8Array","raw","String","fromCharCode","apply","manifest","getValue","offsetTime","ttmlTimeIsRelative","parse","addCaptions","removeExecutedRequestsBeforeTime","remove","message","captionArray","sampleData","slice","size","sampleBoxes","parseBuffer","boxes","box1","debug","box2","cue_text","start_time","end_time","end","data","styles","TEXT","byteLength","getCurrentTrackIdx","DashJSError","Errors","TIMED_TEXT_ERROR_ID_PARSE_CODE","TIMED_TEXT_ERROR_MESSAGE_PARSE","VIDEO","HTTPRequest","INIT_SEGMENT_TYPE","makeCueAdderForIndex","self","trackIndex","newCue","startTime","endTime","captionScreen","captionsArray","getTTMLRenderingDiv","createHTMLCaptionsFromScreen","getElement","text","getDisplayText","sequenceNumber","lastSequenceNumber","field","handler","trackIdx","getTrackIdxForId","cea608parser","Cea608Parser","numSequences","allCcData","extractCea608Data","fieldNr","ccData","fields","fieldParser","addData","samples","splits","cea608Ranges","findCea608Nalus","lastSampleTime","extractCea608DataFromRange","forEach","sortField","sort","a","b","isDefault","substring","VTT","undefined","track","deleteCuesFromTrackIdx","from","to","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/text/TextSourceBuffer.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport { HTTPRequest } from '../vo/metrics/HTTPRequest';\nimport TextTrackInfo from '../vo/TextTrackInfo';\nimport BoxParser from '../utils/BoxParser';\nimport CustomTimeRanges from '../utils/CustomTimeRanges';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport TextTracks from './TextTracks';\nimport EmbeddedTextHtmlRender from './EmbeddedTextHtmlRender';\nimport ISOBoxer from 'codem-isoboxer';\nimport cea608parser from '../../../externals/cea608-parser';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport DashJSError from '../vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\n\nfunction TextSourceBuffer() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    let embeddedInitialized = false;\n\n    let instance,\n        logger,\n        boxParser,\n        errHandler,\n        adapter,\n        manifestModel,\n        mediaController,\n        parser,\n        vttParser,\n        ttmlParser,\n        mediaInfos,\n        textTracks,\n        fragmentedFragmentModel,\n        initializationSegmentReceived,\n        timescale,\n        fragmentedTracks,\n        videoModel,\n        streamController,\n        firstFragmentedSubtitleStart,\n        currFragmentedTrackIdx,\n        embeddedTracks,\n        embeddedTimescale,\n        embeddedLastSequenceNumber,\n        embeddedCea608FieldParsers,\n        embeddedTextHtmlRender,\n        mseTimeOffset;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        resetInitialSettings();\n    }\n\n    function resetFragmented () {\n        fragmentedFragmentModel = null;\n        timescale = NaN;\n        fragmentedTracks = [];\n        firstFragmentedSubtitleStart = null;\n        initializationSegmentReceived = false;\n    }\n\n    function resetInitialSettings() {\n        resetFragmented();\n\n        mediaInfos = [];\n        parser = null;\n    }\n\n    function initialize(mimeType, streamInfo, mediaInfoArr, fragmentModel) {\n        if (!embeddedInitialized) {\n            initEmbedded();\n        }\n\n        textTracks.setConfig({\n            videoModel: videoModel\n        });\n        textTracks.initialize();\n\n        if (!boxParser) {\n            boxParser = BoxParser(context).getInstance();\n        }\n\n        addMediaInfos(mimeType, streamInfo, mediaInfoArr, fragmentModel);\n    }\n\n    function addMediaInfos(mimeType, streamInfo, mediaInfoArr, fragmentModel) {\n        const isFragmented = !adapter.getIsTextTrack(mimeType);\n\n        mediaInfos = mediaInfos.concat(mediaInfoArr);\n\n        if (isFragmented) {\n            fragmentedFragmentModel = fragmentModel;\n            instance.buffered = CustomTimeRanges(context).create();\n            fragmentedTracks = mediaController.getTracksFor(Constants.FRAGMENTED_TEXT, streamInfo);\n            const currFragTrack = mediaController.getCurrentTrackFor(Constants.FRAGMENTED_TEXT, streamInfo);\n            for (let i = 0; i < fragmentedTracks.length; i++) {\n                if (fragmentedTracks[i] === currFragTrack) {\n                    setCurrentFragmentedTrackIdx(i);\n                    break;\n                }\n            }\n        }\n\n        for (let i = 0; i < mediaInfos.length; i++) {\n            createTextTrackFromMediaInfo(null, mediaInfos[i]);\n        }\n    }\n\n    function abort() {\n        textTracks.deleteAllTextTracks();\n        resetFragmented();\n        boxParser = null;\n        mediaInfos = [];\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        streamController = null;\n        videoModel = null;\n        textTracks = null;\n    }\n\n    function onVideoChunkReceived(e) {\n        const chunk = e.chunk;\n\n        if (chunk.mediaInfo.embeddedCaptions) {\n            append(chunk.bytes, chunk);\n        }\n    }\n\n    function initEmbedded() {\n        embeddedTracks = [];\n        textTracks = TextTracks(context).getInstance();\n        textTracks.setConfig({\n            videoModel: videoModel\n        });\n        textTracks.initialize();\n        boxParser = BoxParser(context).getInstance();\n        currFragmentedTrackIdx = null;\n        embeddedTimescale = 0;\n        embeddedCea608FieldParsers = [];\n        embeddedLastSequenceNumber = null;\n        embeddedInitialized = true;\n        embeddedTextHtmlRender = EmbeddedTextHtmlRender(context).getInstance();\n\n        const streamProcessors = streamController.getActiveStreamProcessors();\n        for (const i in streamProcessors) {\n            if (streamProcessors[i].getType() === 'video') {\n                mseTimeOffset = streamProcessors[i].getRepresentationInfo().MSETimeOffset;\n                break;\n            }\n        }\n\n        eventBus.on(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n        eventBus.on(Events.BUFFER_CLEARED, onVideoBufferCleared, this);\n    }\n\n    function resetEmbedded() {\n        eventBus.off(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n        eventBus.off(Events.BUFFER_CLEARED, onVideoBufferCleared, this);\n        if (textTracks) {\n            textTracks.deleteAllTextTracks();\n        }\n        embeddedInitialized = false;\n        embeddedTracks = [];\n        embeddedCea608FieldParsers = [null, null];\n        embeddedLastSequenceNumber = null;\n    }\n\n    function addEmbeddedTrack(mediaInfo) {\n        if (!embeddedInitialized) {\n            initEmbedded();\n        }\n        if (mediaInfo) {\n            if (mediaInfo.id === Constants.CC1 || mediaInfo.id === Constants.CC3) {\n                for (let i = 0; i < embeddedTracks.length; i++) {\n                    if (embeddedTracks[i].id === mediaInfo.id) {\n                        return;\n                    }\n                }\n                embeddedTracks.push(mediaInfo);\n            } else {\n                logger.warn('Embedded track ' + mediaInfo.id + ' not supported!');\n            }\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.mediaController) {\n            mediaController = config.mediaController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.textTracks) {\n            textTracks = config.textTracks;\n        }\n        if (config.vttParser) {\n            vttParser = config.vttParser;\n        }\n        if (config.ttmlParser) {\n            ttmlParser = config.ttmlParser;\n        }\n    }\n\n    function getConfig() {\n        const config = {\n            fragmentModel: fragmentedFragmentModel,\n            fragmentedTracks: fragmentedTracks,\n            videoModel: videoModel\n        };\n\n        return config;\n    }\n\n    function setCurrentFragmentedTrackIdx(idx) {\n        currFragmentedTrackIdx = idx;\n    }\n\n    function createTextTrackFromMediaInfo(captionData, mediaInfo) {\n        const textTrackInfo = new TextTrackInfo();\n        const trackKindMap = { subtitle: 'subtitles', caption: 'captions' }; //Dash Spec has no \"s\" on end of KIND but HTML needs plural.\n        const getKind = function () {\n            let kind = (mediaInfo.roles.length > 0) ? trackKindMap[mediaInfo.roles[0]] : trackKindMap.caption;\n            kind = (kind === trackKindMap.caption || kind === trackKindMap.subtitle) ? kind : trackKindMap.caption;\n            return kind;\n        };\n\n        const checkTTML = function () {\n            let ttml = false;\n            if (mediaInfo.codec && mediaInfo.codec.search(Constants.STPP) >= 0) {\n                ttml = true;\n            }\n            if (mediaInfo.mimeType && mediaInfo.mimeType.search(Constants.TTML) >= 0) {\n                ttml = true;\n            }\n            return ttml;\n        };\n\n        textTrackInfo.captionData = captionData;\n        textTrackInfo.lang = mediaInfo.lang;\n        textTrackInfo.labels = mediaInfo.labels;\n        textTrackInfo.id = mediaInfo.id ? mediaInfo.id : mediaInfo.index; // AdaptationSet id (an unsigned int) as it's optional parameter, use mediaInfo.index\n        textTrackInfo.index = mediaInfo.index; // AdaptationSet index in manifest\n        textTrackInfo.isTTML = checkTTML();\n        textTrackInfo.defaultTrack = getIsDefault(mediaInfo);\n        textTrackInfo.isFragmented = !adapter.getIsTextTrack(mediaInfo.mimeType);\n        textTrackInfo.isEmbedded = mediaInfo.isEmbedded ? true : false;\n        textTrackInfo.kind = getKind();\n        textTrackInfo.roles = mediaInfo.roles;\n        textTrackInfo.accessibility = mediaInfo.accessibility;\n        const totalNrTracks = (mediaInfos ? mediaInfos.length : 0) + embeddedTracks.length;\n        textTracks.addTextTrack(textTrackInfo, totalNrTracks);\n    }\n\n    function append(bytes, chunk) {\n        let result,\n            sampleList,\n            i, j, k,\n            samplesInfo,\n            ccContent;\n        const mediaInfo = chunk.mediaInfo;\n        const mediaType = mediaInfo.type;\n        const mimeType = mediaInfo.mimeType;\n        const codecType = mediaInfo.codec || mimeType;\n        if (!codecType) {\n            logger.error('No text type defined');\n            return;\n        }\n\n        if (mediaType === Constants.FRAGMENTED_TEXT) {\n            if (!initializationSegmentReceived && chunk.segmentType === 'InitializationSegment') {\n                initializationSegmentReceived = true;\n                timescale = boxParser.getMediaTimescaleFromMoov(bytes);\n            } else {\n                if (!initializationSegmentReceived) {\n                    return;\n                }\n                samplesInfo = boxParser.getSamplesInfo(bytes);\n                sampleList = samplesInfo.sampleList;\n                if (firstFragmentedSubtitleStart === null && sampleList.length > 0) {\n                    firstFragmentedSubtitleStart = sampleList[0].cts - chunk.start * timescale;\n                }\n                if (codecType.search(Constants.STPP) >= 0) {\n                    parser = parser !== null ? parser : getParser(codecType);\n                    for (i = 0; i < sampleList.length; i++) {\n                        const sample = sampleList[i];\n                        const sampleStart = sample.cts;\n                        const sampleRelStart = sampleStart - firstFragmentedSubtitleStart;\n                        this.buffered.add(sampleRelStart / timescale, (sampleRelStart + sample.duration) / timescale);\n                        const dataView = new DataView(bytes, sample.offset, sample.subSizes[0]);\n                        ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8);\n                        const images = [];\n                        let subOffset = sample.offset + sample.subSizes[0];\n                        for (j = 1; j < sample.subSizes.length; j++) {\n                            const inData = new Uint8Array(bytes, subOffset, sample.subSizes[j]);\n                            const raw = String.fromCharCode.apply(null, inData);\n                            images.push(raw);\n                            subOffset += sample.subSizes[j];\n                        }\n                        try {\n                            // Only used for Miscrosoft Smooth Streaming support - caption time is relative to sample time. In this case, we apply an offset.\n                            const manifest = manifestModel.getValue();\n                            const offsetTime = manifest.ttmlTimeIsRelative ? sampleStart / timescale : 0;\n                            result = parser.parse(ccContent, offsetTime, sampleStart / timescale, (sampleStart + sample.duration) / timescale, images);\n                            textTracks.addCaptions(currFragmentedTrackIdx, firstFragmentedSubtitleStart / timescale, result);\n                        } catch (e) {\n                            fragmentedFragmentModel.removeExecutedRequestsBeforeTime();\n                            this.remove();\n                            logger.error('TTML parser error: ' + e.message);\n                        }\n                    }\n                } else {\n                    // WebVTT case\n                    const captionArray = [];\n                    for (i = 0 ; i < sampleList.length; i++) {\n                        const sample = sampleList[i];\n                        sample.cts -= firstFragmentedSubtitleStart;\n                        this.buffered.add(sample.cts / timescale, (sample.cts + sample.duration) / timescale);\n                        const sampleData = bytes.slice(sample.offset, sample.offset + sample.size);\n                        // There are boxes inside the sampleData, so we need a ISOBoxer to get at it.\n                        const sampleBoxes = ISOBoxer.parseBuffer(sampleData);\n\n                        for (j = 0 ; j < sampleBoxes.boxes.length; j++) {\n                            const box1 = sampleBoxes.boxes[j];\n                            logger.debug('VTT box1: ' + box1.type);\n                            if (box1.type === 'vtte') {\n                                continue; //Empty box\n                            }\n                            if (box1.type === 'vttc') {\n                                logger.debug('VTT vttc boxes.length = ' + box1.boxes.length);\n                                for (k = 0 ; k < box1.boxes.length; k++) {\n                                    const box2 = box1.boxes[k];\n                                    logger.debug('VTT box2: ' + box2.type);\n                                    if (box2.type === 'payl') {\n                                        const cue_text = box2.cue_text;\n                                        logger.debug('VTT cue_text = ' + cue_text);\n                                        const start_time = sample.cts / timescale;\n                                        const end_time = (sample.cts + sample.duration) / timescale;\n                                        captionArray.push({\n                                            start: start_time,\n                                            end: end_time,\n                                            data: cue_text,\n                                            styles: {}\n                                        });\n                                        logger.debug('VTT ' + start_time + '-' + end_time + ' : ' + cue_text);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (captionArray.length > 0) {\n                        textTracks.addCaptions(currFragmentedTrackIdx, 0, captionArray);\n                    }\n                }\n            }\n        } else if (mediaType === Constants.TEXT) {\n            const dataView = new DataView(bytes, 0, bytes.byteLength);\n            ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8);\n\n            try {\n                result = getParser(codecType).parse(ccContent, 0);\n                textTracks.addCaptions(textTracks.getCurrentTrackIdx(), 0, result);\n            } catch (e) {\n                errHandler.error(new DashJSError(Errors.TIMED_TEXT_ERROR_ID_PARSE_CODE, Errors.TIMED_TEXT_ERROR_MESSAGE_PARSE + e.message, ccContent));\n            }\n        } else if (mediaType === Constants.VIDEO) { //embedded text\n            if (chunk.segmentType === HTTPRequest.INIT_SEGMENT_TYPE) {\n                if (embeddedTimescale === 0) {\n                    embeddedTimescale = boxParser.getMediaTimescaleFromMoov(bytes);\n                    for (i = 0; i < embeddedTracks.length; i++) {\n                        createTextTrackFromMediaInfo(null, embeddedTracks[i]);\n                    }\n                }\n            } else { // MediaSegment\n                if (embeddedTimescale === 0) {\n                    logger.warn('CEA-608: No timescale for embeddedTextTrack yet');\n                    return;\n                }\n                const makeCueAdderForIndex = function (self, trackIndex) {\n                    function newCue(startTime, endTime, captionScreen) {\n                        let captionsArray = null;\n                        if (videoModel.getTTMLRenderingDiv()) {\n                            captionsArray = embeddedTextHtmlRender.createHTMLCaptionsFromScreen(videoModel.getElement(), startTime, endTime, captionScreen);\n                        } else {\n                            const text = captionScreen.getDisplayText();\n                            captionsArray = [{\n                                start: startTime,\n                                end: endTime,\n                                data: text,\n                                styles: {}\n                            }];\n                        }\n                        if (captionsArray) {\n                            textTracks.addCaptions(trackIndex, 0, captionsArray);\n                        }\n                    }\n                    return newCue;\n                };\n\n                samplesInfo = boxParser.getSamplesInfo(bytes);\n\n                const sequenceNumber = samplesInfo.lastSequenceNumber;\n\n                if (!embeddedCea608FieldParsers[0] && !embeddedCea608FieldParsers[1]) {\n                    // Time to setup the CEA-608 parsing\n                    let field, handler, trackIdx;\n                    for (i = 0; i < embeddedTracks.length; i++) {\n                        if (embeddedTracks[i].id === Constants.CC1) {\n                            field = 0;\n                            trackIdx = textTracks.getTrackIdxForId(Constants.CC1);\n                        } else if (embeddedTracks[i].id === Constants.CC3) {\n                            field = 1;\n                            trackIdx = textTracks.getTrackIdxForId(Constants.CC3);\n                        }\n                        if (trackIdx === -1) {\n                            logger.warn('CEA-608: data before track is ready.');\n                            return;\n                        }\n                        handler = makeCueAdderForIndex(this, trackIdx);\n                        embeddedCea608FieldParsers[i] = new cea608parser.Cea608Parser(i + 1, {\n                            'newCue': handler\n                        }, null);\n                    }\n                }\n\n                if (embeddedTimescale) {\n                    if (embeddedLastSequenceNumber !== null && sequenceNumber !== embeddedLastSequenceNumber + samplesInfo.numSequences) {\n                        for (i = 0; i < embeddedCea608FieldParsers.length; i++) {\n                            if (embeddedCea608FieldParsers[i]) {\n                                embeddedCea608FieldParsers[i].reset();\n                            }\n                        }\n                    }\n\n                    const allCcData = extractCea608Data(bytes, samplesInfo.sampleList);\n\n                    for (let fieldNr = 0; fieldNr < embeddedCea608FieldParsers.length; fieldNr++) {\n                        const ccData = allCcData.fields[fieldNr];\n                        const fieldParser = embeddedCea608FieldParsers[fieldNr];\n                        if (fieldParser) {\n                            for (i = 0; i < ccData.length; i++) {\n                                fieldParser.addData(ccData[i][0] / embeddedTimescale, ccData[i][1]);\n                            }\n                        }\n                    }\n                    embeddedLastSequenceNumber = sequenceNumber;\n                }\n            }\n        }\n    }\n    /**\n     * Extract CEA-608 data from a buffer of data.\n     * @param {ArrayBuffer} data\n     * @param {Array} samples cue information\n     * @returns {Object|null} ccData corresponding to one segment.\n     */\n    function extractCea608Data(data, samples) {\n        if (samples.length === 0) {\n            return null;\n        }\n\n        const allCcData = {\n            splits: [],\n            fields: [[], []]\n        };\n        const raw = new DataView(data);\n        for (let i = 0; i < samples.length; i++) {\n            const sample = samples[i];\n            const cea608Ranges = cea608parser.findCea608Nalus(raw, sample.offset, sample.size);\n            let lastSampleTime = null;\n            let idx = 0;\n            for (let j = 0; j < cea608Ranges.length; j++) {\n                const ccData = cea608parser.extractCea608DataFromRange(raw, cea608Ranges[j]);\n                for (let k = 0; k < 2; k++) {\n                    if (ccData[k].length > 0) {\n                        if (sample.cts !== lastSampleTime) {\n                            idx = 0;\n                        } else {\n                            idx += 1;\n                        }\n                        allCcData.fields[k].push([sample.cts + (mseTimeOffset * embeddedTimescale), ccData[k], idx]);\n                        lastSampleTime = sample.cts;\n                    }\n                }\n            }\n        }\n\n        // Sort by sampleTime ascending order\n        // If two packets have the same sampleTime, use them in the order\n        // they were received\n        allCcData.fields.forEach(function sortField(field) {\n            field.sort(function (a, b) {\n                if (a[0] === b[0]) {\n                    return a[2] - b[2];\n                }\n                return a[0] - b[0];\n            });\n        });\n\n        return allCcData;\n    }\n\n    function getIsDefault(mediaInfo) {\n        //TODO How to tag default. currently same order as listed in manifest.\n        // Is there a way to mark a text adaptation set as the default one? DASHIF meeting talk about using role which is being used for track KIND\n        // Eg subtitles etc. You can have multiple role tags per adaptation Not defined in the spec yet.\n        let isDefault = false;\n        if (embeddedTracks.length > 1 && mediaInfo.isEmbedded) {\n            isDefault = (mediaInfo.id && mediaInfo.id === Constants.CC1); // CC1 if both CC1 and CC3 exist\n        } else if (embeddedTracks.length === 1) {\n            if (mediaInfo.id && typeof mediaInfo.id === 'string' && mediaInfo.id.substring(0, 2) === 'CC') { // Either CC1 or CC3\n                isDefault = true;\n            }\n        } else if (embeddedTracks.length === 0) {\n            isDefault = (mediaInfo.index === mediaInfos[0].index);\n        }\n        return isDefault;\n    }\n\n    function getParser(codecType) {\n        let parser;\n        if (codecType.search(Constants.VTT) >= 0) {\n            parser = vttParser;\n        } else if (codecType.search(Constants.TTML) >= 0 || codecType.search(Constants.STPP) >= 0) {\n            parser = ttmlParser;\n        }\n        return parser;\n    }\n\n    function remove(start, end) {\n        //if start and end are not defined, remove all\n        if ((start === undefined) && (start === end)) {\n            start = this.buffered.start(0);\n            end = this.buffered.end(this.buffered.length - 1);\n        }\n        this.buffered.remove(start, end);\n    }\n\n    function onVideoBufferCleared(e) {\n        embeddedTracks.forEach(function (track) {\n            const trackIdx = textTracks.getTrackIdxForId(track.id);\n            if (trackIdx >= 0) {\n                textTracks.deleteCuesFromTrackIdx(trackIdx, e.from, e.to);\n            }\n        });\n    }\n\n    instance = {\n        initialize: initialize,\n        append: append,\n        abort: abort,\n        addEmbeddedTrack: addEmbeddedTrack,\n        resetEmbedded: resetEmbedded,\n        setConfig: setConfig,\n        getConfig: getConfig,\n        setCurrentFragmentedTrackIdx: setCurrentFragmentedTrackIdx,\n        remove: remove,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTextSourceBuffer.__dashjs_factory_name = 'TextSourceBuffer';\nexport default FactoryMaker.getSingletonFactory(TextSourceBuffer);\n"]},"metadata":{},"sourceType":"script"}