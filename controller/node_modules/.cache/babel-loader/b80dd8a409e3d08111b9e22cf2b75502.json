{"ast":null,"code":"/* \r\n * Copyright (c) 2016, Pierre-Anthony Lemieux <pal@sandflow.com>\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\n\n/**\r\n * @module imscDoc\r\n */\n;\n\n(function (imscDoc, sax, imscNames, imscStyles, imscUtils) {\n  /**\r\n   * Allows a client to provide callbacks to handle children of the <metadata> element\r\n   * @typedef {Object} MetadataHandler\r\n   * @property {?OpenTagCallBack} onOpenTag\r\n   * @property {?CloseTagCallBack} onCloseTag\r\n   * @property {?TextCallBack} onText\r\n   */\n\n  /**\r\n   * Called when the opening tag of an element node is encountered.\r\n   * @callback OpenTagCallBack\r\n   * @param {string} ns Namespace URI of the element\r\n   * @param {string} name Local name of the element\r\n   * @param {Object[]} attributes List of attributes, each consisting of a\r\n   *                              `uri`, `name` and `value`\r\n   */\n\n  /**\r\n   * Called when the closing tag of an element node is encountered.\r\n   * @callback CloseTagCallBack\r\n   */\n\n  /**\r\n   * Called when a text node is encountered.\r\n   * @callback TextCallBack\r\n   * @param {string} contents Contents of the text node\r\n   */\n\n  /**\r\n   * Parses an IMSC1 document into an opaque in-memory representation that exposes\r\n   * a single method <pre>getMediaTimeEvents()</pre> that returns a list of time\r\n   * offsets (in seconds) of the ISD, i.e. the points in time where the visual\r\n   * representation of the document change. `metadataHandler` allows the caller to\r\n   * be called back when nodes are present in <metadata> elements. \r\n   * \r\n   * @param {string} xmlstring XML document\r\n   * @param {?module:imscUtils.ErrorHandler} errorHandler Error callback\r\n   * @param {?MetadataHandler} metadataHandler Callback for <Metadata> elements\r\n   * @returns {Object} Opaque in-memory representation of an IMSC1 document\r\n   */\n  imscDoc.fromXML = function (xmlstring, errorHandler, metadataHandler) {\n    var p = sax.parser(true, {\n      xmlns: true\n    });\n    var estack = [];\n    var xmllangstack = [];\n    var xmlspacestack = [];\n    var metadata_depth = 0;\n    var doc = null;\n\n    p.onclosetag = function (node) {\n      if (estack[0] instanceof Region) {\n        /* merge referenced styles */\n        if (doc.head !== null && doc.head.styling !== null) {\n          mergeReferencedStyles(doc.head.styling, estack[0].styleRefs, estack[0].styleAttrs, errorHandler);\n        }\n\n        delete estack[0].styleRefs;\n      } else if (estack[0] instanceof Styling) {\n        /* flatten chained referential styling */\n        for (var sid in estack[0].styles) {\n          if (!estack[0].styles.hasOwnProperty(sid)) continue;\n          mergeChainedStyles(estack[0], estack[0].styles[sid], errorHandler);\n        }\n      } else if (estack[0] instanceof P || estack[0] instanceof Span) {\n        /* merge anonymous spans */\n        if (estack[0].contents.length > 1) {\n          var cs = [estack[0].contents[0]];\n          var c;\n\n          for (c = 1; c < estack[0].contents.length; c++) {\n            if (estack[0].contents[c] instanceof AnonymousSpan && cs[cs.length - 1] instanceof AnonymousSpan) {\n              cs[cs.length - 1].text += estack[0].contents[c].text;\n            } else {\n              cs.push(estack[0].contents[c]);\n            }\n          }\n\n          estack[0].contents = cs;\n        } // remove redundant nested anonymous spans (9.3.3(1)(c))\n\n\n        if (estack[0] instanceof Span && estack[0].contents.length === 1 && estack[0].contents[0] instanceof AnonymousSpan) {\n          estack[0].text = estack[0].contents[0].text;\n          delete estack[0].contents;\n        }\n      } else if (estack[0] instanceof ForeignElement) {\n        if (estack[0].node.uri === imscNames.ns_tt && estack[0].node.local === 'metadata') {\n          /* leave the metadata element */\n          metadata_depth--;\n        } else if (metadata_depth > 0 && metadataHandler && 'onCloseTag' in metadataHandler) {\n          /* end of child of metadata element */\n          metadataHandler.onCloseTag();\n        }\n      } // TODO: delete stylerefs?\n      // maintain the xml:space stack\n\n\n      xmlspacestack.shift(); // maintain the xml:lang stack\n\n      xmllangstack.shift(); // prepare for the next element\n\n      estack.shift();\n    };\n\n    p.ontext = function (str) {\n      if (estack[0] === undefined) {\n        /* ignoring text outside of elements */\n      } else if (estack[0] instanceof Span || estack[0] instanceof P) {\n        /* ignore children text nodes in ruby container spans */\n        if (estack[0] instanceof Span) {\n          var ruby = estack[0].styleAttrs[imscStyles.byName.ruby.qname];\n\n          if (ruby === 'container' || ruby === 'textContainer' || ruby === 'baseContainer') {\n            return;\n          }\n        }\n        /* create an anonymous span */\n\n\n        var s = new AnonymousSpan();\n        s.initFromText(doc, estack[0], str, xmllangstack[0], xmlspacestack[0], errorHandler);\n        estack[0].contents.push(s);\n      } else if (estack[0] instanceof ForeignElement && metadata_depth > 0 && metadataHandler && 'onText' in metadataHandler) {\n        /* text node within a child of metadata element */\n        metadataHandler.onText(str);\n      }\n    };\n\n    p.onopentag = function (node) {\n      // maintain the xml:space stack\n      var xmlspace = node.attributes[\"xml:space\"];\n\n      if (xmlspace) {\n        xmlspacestack.unshift(xmlspace.value);\n      } else {\n        if (xmlspacestack.length === 0) {\n          xmlspacestack.unshift(\"default\");\n        } else {\n          xmlspacestack.unshift(xmlspacestack[0]);\n        }\n      }\n      /* maintain the xml:lang stack */\n\n\n      var xmllang = node.attributes[\"xml:lang\"];\n\n      if (xmllang) {\n        xmllangstack.unshift(xmllang.value);\n      } else {\n        if (xmllangstack.length === 0) {\n          xmllangstack.unshift(\"\");\n        } else {\n          xmllangstack.unshift(xmllangstack[0]);\n        }\n      }\n      /* process the element */\n\n\n      if (node.uri === imscNames.ns_tt) {\n        if (node.local === 'tt') {\n          if (doc !== null) {\n            reportFatal(errorHandler, \"Two <tt> elements at (\" + this.line + \",\" + this.column + \")\");\n          }\n\n          doc = new TT();\n          doc.initFromNode(node, xmllangstack[0], errorHandler);\n          estack.unshift(doc);\n        } else if (node.local === 'head') {\n          if (!(estack[0] instanceof TT)) {\n            reportFatal(errorHandler, \"Parent of <head> element is not <tt> at (\" + this.line + \",\" + this.column + \")\");\n          }\n\n          estack.unshift(doc.head);\n        } else if (node.local === 'styling') {\n          if (!(estack[0] instanceof Head)) {\n            reportFatal(errorHandler, \"Parent of <styling> element is not <head> at (\" + this.line + \",\" + this.column + \")\");\n          }\n\n          estack.unshift(doc.head.styling);\n        } else if (node.local === 'style') {\n          var s;\n\n          if (estack[0] instanceof Styling) {\n            s = new Style();\n            s.initFromNode(node, errorHandler);\n            /* ignore <style> element missing @id */\n\n            if (!s.id) {\n              reportError(errorHandler, \"<style> element missing @id attribute\");\n            } else {\n              doc.head.styling.styles[s.id] = s;\n            }\n\n            estack.unshift(s);\n          } else if (estack[0] instanceof Region) {\n            /* nested styles can be merged with specified styles\r\n             * immediately, with lower priority\r\n             * (see 8.4.4.2(3) at TTML1 )\r\n             */\n            s = new Style();\n            s.initFromNode(node, errorHandler);\n            mergeStylesIfNotPresent(s.styleAttrs, estack[0].styleAttrs);\n            estack.unshift(s);\n          } else {\n            reportFatal(errorHandler, \"Parent of <style> element is not <styling> or <region> at (\" + this.line + \",\" + this.column + \")\");\n          }\n        } else if (node.local === 'initial') {\n          var ini;\n\n          if (estack[0] instanceof Styling) {\n            ini = new Initial();\n            ini.initFromNode(node, errorHandler);\n\n            for (var qn in ini.styleAttrs) {\n              if (!ini.styleAttrs.hasOwnProperty(qn)) continue;\n              doc.head.styling.initials[qn] = ini.styleAttrs[qn];\n            }\n\n            estack.unshift(ini);\n          } else {\n            reportFatal(errorHandler, \"Parent of <initial> element is not <styling> at (\" + this.line + \",\" + this.column + \")\");\n          }\n        } else if (node.local === 'layout') {\n          if (!(estack[0] instanceof Head)) {\n            reportFatal(errorHandler, \"Parent of <layout> element is not <head> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          estack.unshift(doc.head.layout);\n        } else if (node.local === 'region') {\n          if (!(estack[0] instanceof Layout)) {\n            reportFatal(errorHandler, \"Parent of <region> element is not <layout> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var r = new Region();\n          r.initFromNode(doc, node, xmllangstack[0], errorHandler);\n\n          if (!r.id || r.id in doc.head.layout.regions) {\n            reportError(errorHandler, \"Ignoring <region> with duplicate or missing @id at \" + this.line + \",\" + this.column + \")\");\n          } else {\n            doc.head.layout.regions[r.id] = r;\n          }\n\n          estack.unshift(r);\n        } else if (node.local === 'body') {\n          if (!(estack[0] instanceof TT)) {\n            reportFatal(errorHandler, \"Parent of <body> element is not <tt> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          if (doc.body !== null) {\n            reportFatal(errorHandler, \"Second <body> element at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var b = new Body();\n          b.initFromNode(doc, node, xmllangstack[0], errorHandler);\n          doc.body = b;\n          estack.unshift(b);\n        } else if (node.local === 'div') {\n          if (!(estack[0] instanceof Div || estack[0] instanceof Body)) {\n            reportFatal(errorHandler, \"Parent of <div> element is not <body> or <div> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var d = new Div();\n          d.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\n          /* transform smpte:backgroundImage to TTML2 image element */\n\n          var bi = d.styleAttrs[imscStyles.byName.backgroundImage.qname];\n\n          if (bi) {\n            d.contents.push(new Image(bi));\n            delete d.styleAttrs[imscStyles.byName.backgroundImage.qname];\n          }\n\n          estack[0].contents.push(d);\n          estack.unshift(d);\n        } else if (node.local === 'image') {\n          if (!(estack[0] instanceof Div)) {\n            reportFatal(errorHandler, \"Parent of <image> element is not <div> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var img = new Image();\n          img.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\n          estack[0].contents.push(img);\n          estack.unshift(img);\n        } else if (node.local === 'p') {\n          if (!(estack[0] instanceof Div)) {\n            reportFatal(errorHandler, \"Parent of <p> element is not <div> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var p = new P();\n          p.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\n          estack[0].contents.push(p);\n          estack.unshift(p);\n        } else if (node.local === 'span') {\n          if (!(estack[0] instanceof Span || estack[0] instanceof P)) {\n            reportFatal(errorHandler, \"Parent of <span> element is not <span> or <p> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var ns = new Span();\n          ns.initFromNode(doc, estack[0], node, xmllangstack[0], xmlspacestack[0], errorHandler);\n          estack[0].contents.push(ns);\n          estack.unshift(ns);\n        } else if (node.local === 'br') {\n          if (!(estack[0] instanceof Span || estack[0] instanceof P)) {\n            reportFatal(errorHandler, \"Parent of <br> element is not <span> or <p> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var nb = new Br();\n          nb.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\n          estack[0].contents.push(nb);\n          estack.unshift(nb);\n        } else if (node.local === 'set') {\n          if (!(estack[0] instanceof Span || estack[0] instanceof P || estack[0] instanceof Div || estack[0] instanceof Body || estack[0] instanceof Region || estack[0] instanceof Br)) {\n            reportFatal(errorHandler, \"Parent of <set> element is not a content element or a region at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var st = new Set();\n          st.initFromNode(doc, estack[0], node, errorHandler);\n          estack[0].sets.push(st);\n          estack.unshift(st);\n        } else {\n          /* element in the TT namespace, but not a content element */\n          estack.unshift(new ForeignElement(node));\n        }\n      } else {\n        /* ignore elements not in the TTML namespace unless in metadata element */\n        estack.unshift(new ForeignElement(node));\n      }\n      /* handle metadata callbacks */\n\n\n      if (estack[0] instanceof ForeignElement) {\n        if (node.uri === imscNames.ns_tt && node.local === 'metadata') {\n          /* enter the metadata element */\n          metadata_depth++;\n        } else if (metadata_depth > 0 && metadataHandler && 'onOpenTag' in metadataHandler) {\n          /* start of child of metadata element */\n          var attrs = [];\n\n          for (var a in node.attributes) {\n            attrs[node.attributes[a].uri + \" \" + node.attributes[a].local] = {\n              uri: node.attributes[a].uri,\n              local: node.attributes[a].local,\n              value: node.attributes[a].value\n            };\n          }\n\n          metadataHandler.onOpenTag(node.uri, node.local, attrs);\n        }\n      }\n    }; // parse the document\n\n\n    p.write(xmlstring).close(); // all referential styling has been flatten, so delete styles\n\n    delete doc.head.styling.styles; // create default region if no regions specified\n\n    var hasRegions = false;\n    /* AFAIK the only way to determine whether an object has members */\n\n    for (var i in doc.head.layout.regions) {\n      if (doc.head.layout.regions.hasOwnProperty(i)) {\n        hasRegions = true;\n        break;\n      }\n    }\n\n    if (!hasRegions) {\n      /* create default region */\n      var dr = Region.prototype.createDefaultRegion(doc.lang);\n      doc.head.layout.regions[dr.id] = dr;\n    }\n    /* resolve desired timing for regions */\n\n\n    for (var region_i in doc.head.layout.regions) {\n      if (!doc.head.layout.regions.hasOwnProperty(region_i)) continue;\n      resolveTiming(doc, doc.head.layout.regions[region_i], null, null);\n    }\n    /* resolve desired timing for content elements */\n\n\n    if (doc.body) {\n      resolveTiming(doc, doc.body, null, null);\n    }\n    /* remove undefined spans in ruby containers */\n\n\n    if (doc.body) {\n      cleanRubyContainers(doc.body);\n    }\n\n    return doc;\n  };\n\n  function cleanRubyContainers(element) {\n    if (!('contents' in element)) return;\n    var rubyval = 'styleAttrs' in element ? element.styleAttrs[imscStyles.byName.ruby.qname] : null;\n    var isrubycontainer = element.kind === 'span' && (rubyval === \"container\" || rubyval === \"textContainer\" || rubyval === \"baseContainer\");\n\n    for (var i = element.contents.length - 1; i >= 0; i--) {\n      if (isrubycontainer && !('styleAttrs' in element.contents[i] && imscStyles.byName.ruby.qname in element.contents[i].styleAttrs)) {\n        /* prune undefined <span> in ruby containers */\n        delete element.contents[i];\n      } else {\n        cleanRubyContainers(element.contents[i]);\n      }\n    }\n  }\n\n  function resolveTiming(doc, element, prev_sibling, parent) {\n    /* are we in a seq container? */\n    var isinseq = parent && parent.timeContainer === \"seq\";\n    /* determine implicit begin */\n\n    var implicit_begin = 0;\n    /* default */\n\n    if (parent) {\n      if (isinseq && prev_sibling) {\n        /*\r\n         * if seq time container, offset from the previous sibling end\r\n         */\n        implicit_begin = prev_sibling.end;\n      } else {\n        implicit_begin = parent.begin;\n      }\n    }\n    /* compute desired begin */\n\n\n    element.begin = element.explicit_begin ? element.explicit_begin + implicit_begin : implicit_begin;\n    /* determine implicit end */\n\n    var implicit_end = element.begin;\n    var s = null;\n\n    if (\"sets\" in element) {\n      for (var set_i = 0; set_i < element.sets.length; set_i++) {\n        resolveTiming(doc, element.sets[set_i], s, element);\n\n        if (element.timeContainer === \"seq\") {\n          implicit_end = element.sets[set_i].end;\n        } else {\n          implicit_end = Math.max(implicit_end, element.sets[set_i].end);\n        }\n\n        s = element.sets[set_i];\n      }\n    }\n\n    if (!('contents' in element)) {\n      /* anonymous spans and regions and <set> and <br>s and spans with only children text nodes */\n      if (isinseq) {\n        /* in seq container, implicit duration is zero */\n        implicit_end = element.begin;\n      } else {\n        /* in par container, implicit duration is indefinite */\n        implicit_end = Number.POSITIVE_INFINITY;\n      }\n    } else if (\"contents\" in element) {\n      for (var content_i = 0; content_i < element.contents.length; content_i++) {\n        resolveTiming(doc, element.contents[content_i], s, element);\n\n        if (element.timeContainer === \"seq\") {\n          implicit_end = element.contents[content_i].end;\n        } else {\n          implicit_end = Math.max(implicit_end, element.contents[content_i].end);\n        }\n\n        s = element.contents[content_i];\n      }\n    }\n    /* determine desired end */\n\n    /* it is never made really clear in SMIL that the explicit end is offset by the implicit begin */\n\n\n    if (element.explicit_end !== null && element.explicit_dur !== null) {\n      element.end = Math.min(element.begin + element.explicit_dur, implicit_begin + element.explicit_end);\n    } else if (element.explicit_end === null && element.explicit_dur !== null) {\n      element.end = element.begin + element.explicit_dur;\n    } else if (element.explicit_end !== null && element.explicit_dur === null) {\n      element.end = implicit_begin + element.explicit_end;\n    } else {\n      element.end = implicit_end;\n    }\n\n    delete element.explicit_begin;\n    delete element.explicit_dur;\n    delete element.explicit_end;\n\n    doc._registerEvent(element);\n  }\n\n  function ForeignElement(node) {\n    this.node = node;\n  }\n\n  function TT() {\n    this.events = [];\n    this.head = new Head();\n    this.body = null;\n  }\n\n  TT.prototype.initFromNode = function (node, xmllang, errorHandler) {\n    /* compute cell resolution */\n    var cr = extractCellResolution(node, errorHandler);\n    this.cellLength = {\n      'h': new imscUtils.ComputedLength(0, 1 / cr.h),\n      'w': new imscUtils.ComputedLength(1 / cr.w, 0)\n    };\n    /* extract frame rate and tick rate */\n\n    var frtr = extractFrameAndTickRate(node, errorHandler);\n    this.effectiveFrameRate = frtr.effectiveFrameRate;\n    this.tickRate = frtr.tickRate;\n    /* extract aspect ratio */\n\n    this.aspectRatio = extractAspectRatio(node, errorHandler);\n    /* check timebase */\n\n    var attr = findAttribute(node, imscNames.ns_ttp, \"timeBase\");\n\n    if (attr !== null && attr !== \"media\") {\n      reportFatal(errorHandler, \"Unsupported time base\");\n    }\n    /* retrieve extent */\n\n\n    var e = extractExtent(node, errorHandler);\n\n    if (e === null) {\n      this.pxLength = {\n        'h': null,\n        'w': null\n      };\n    } else {\n      if (e.h.unit !== \"px\" || e.w.unit !== \"px\") {\n        reportFatal(errorHandler, \"Extent on TT must be in px or absent\");\n      }\n\n      this.pxLength = {\n        'h': new imscUtils.ComputedLength(0, 1 / e.h.value),\n        'w': new imscUtils.ComputedLength(1 / e.w.value, 0)\n      };\n    }\n    /** set root container dimensions to (1, 1) arbitrarily\r\n      * the root container is mapped to actual dimensions at rendering\r\n    **/\n\n\n    this.dimensions = {\n      'h': new imscUtils.ComputedLength(0, 1),\n      'w': new imscUtils.ComputedLength(1, 0)\n    };\n    /* xml:lang */\n\n    this.lang = xmllang;\n  };\n  /* register a temporal events */\n\n\n  TT.prototype._registerEvent = function (elem) {\n    /* skip if begin is not < then end */\n    if (elem.end <= elem.begin) return;\n    /* index the begin time of the event */\n\n    var b_i = indexOf(this.events, elem.begin);\n\n    if (!b_i.found) {\n      this.events.splice(b_i.index, 0, elem.begin);\n    }\n    /* index the end time of the event */\n\n\n    if (elem.end !== Number.POSITIVE_INFINITY) {\n      var e_i = indexOf(this.events, elem.end);\n\n      if (!e_i.found) {\n        this.events.splice(e_i.index, 0, elem.end);\n      }\n    }\n  };\n  /*\r\n   * Retrieves the range of ISD times covered by the document\r\n   * \r\n   * @returns {Array} Array of two elements: min_begin_time and max_begin_time\r\n   * \r\n   */\n\n\n  TT.prototype.getMediaTimeRange = function () {\n    return [this.events[0], this.events[this.events.length - 1]];\n  };\n  /*\r\n   * Returns list of ISD begin times  \r\n   * \r\n   * @returns {Array}\r\n   */\n\n\n  TT.prototype.getMediaTimeEvents = function () {\n    return this.events;\n  };\n  /*\r\n   * Represents a TTML Head element\r\n   */\n\n\n  function Head() {\n    this.styling = new Styling();\n    this.layout = new Layout();\n  }\n  /*\r\n   * Represents a TTML Styling element\r\n   */\n\n\n  function Styling() {\n    this.styles = {};\n    this.initials = {};\n  }\n  /*\r\n   * Represents a TTML Style element\r\n   */\n\n\n  function Style() {\n    this.id = null;\n    this.styleAttrs = null;\n    this.styleRefs = null;\n  }\n\n  Style.prototype.initFromNode = function (node, errorHandler) {\n    this.id = elementGetXMLID(node);\n    this.styleAttrs = elementGetStyles(node, errorHandler);\n    this.styleRefs = elementGetStyleRefs(node);\n  };\n  /*\r\n   * Represents a TTML initial element\r\n   */\n\n\n  function Initial() {\n    this.styleAttrs = null;\n  }\n\n  Initial.prototype.initFromNode = function (node, errorHandler) {\n    this.styleAttrs = {};\n\n    for (var i in node.attributes) {\n      if (node.attributes[i].uri === imscNames.ns_itts || node.attributes[i].uri === imscNames.ns_ebutts || node.attributes[i].uri === imscNames.ns_tts) {\n        var qname = node.attributes[i].uri + \" \" + node.attributes[i].local;\n        this.styleAttrs[qname] = node.attributes[i].value;\n      }\n    }\n  };\n  /*\r\n   * Represents a TTML Layout element\r\n   * \r\n   */\n\n\n  function Layout() {\n    this.regions = {};\n  }\n  /*\r\n   * Represents a TTML image element\r\n   */\n\n\n  function Image(src, type) {\n    ContentElement.call(this, 'image');\n    this.src = src;\n    this.type = type;\n  }\n\n  Image.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\n    this.src = 'src' in node.attributes ? node.attributes.src.value : null;\n\n    if (!this.src) {\n      reportError(errorHandler, \"Invalid image@src attribute\");\n    }\n\n    this.type = 'type' in node.attributes ? node.attributes.type.value : null;\n\n    if (!this.type) {\n      reportError(errorHandler, \"Invalid image@type attribute\");\n    }\n\n    StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    this.lang = xmllang;\n  };\n  /*\r\n   * TTML element utility functions\r\n   * \r\n   */\n\n\n  function ContentElement(kind) {\n    this.kind = kind;\n  }\n\n  function IdentifiedElement(id) {\n    this.id = id;\n  }\n\n  IdentifiedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    this.id = elementGetXMLID(node);\n  };\n\n  function LayoutElement(id) {\n    this.regionID = id;\n  }\n\n  LayoutElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    this.regionID = elementGetRegionID(node);\n  };\n\n  function StyledElement(styleAttrs) {\n    this.styleAttrs = styleAttrs;\n  }\n\n  StyledElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    this.styleAttrs = elementGetStyles(node, errorHandler);\n\n    if (doc.head !== null && doc.head.styling !== null) {\n      mergeReferencedStyles(doc.head.styling, elementGetStyleRefs(node), this.styleAttrs, errorHandler);\n    }\n  };\n\n  function AnimatedElement(sets) {\n    this.sets = sets;\n  }\n\n  AnimatedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    this.sets = [];\n  };\n\n  function ContainerElement(contents) {\n    this.contents = contents;\n  }\n\n  ContainerElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    this.contents = [];\n  };\n\n  function TimedElement(explicit_begin, explicit_end, explicit_dur) {\n    this.explicit_begin = explicit_begin;\n    this.explicit_end = explicit_end;\n    this.explicit_dur = explicit_dur;\n  }\n\n  TimedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    var t = processTiming(doc, parent, node, errorHandler);\n    this.explicit_begin = t.explicit_begin;\n    this.explicit_end = t.explicit_end;\n    this.explicit_dur = t.explicit_dur;\n    this.timeContainer = elementGetTimeContainer(node, errorHandler);\n  };\n  /*\r\n   * Represents a TTML body element\r\n   */\n\n\n  function Body() {\n    ContentElement.call(this, 'body');\n  }\n\n  Body.prototype.initFromNode = function (doc, node, xmllang, errorHandler) {\n    StyledElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    LayoutElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    ContainerElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML div element\r\n   */\n\n\n  function Div() {\n    ContentElement.call(this, 'div');\n  }\n\n  Div.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\n    StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML p element\r\n   */\n\n\n  function P() {\n    ContentElement.call(this, 'p');\n  }\n\n  P.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\n    StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML span element\r\n   */\n\n\n  function Span() {\n    ContentElement.call(this, 'span');\n  }\n\n  Span.prototype.initFromNode = function (doc, parent, node, xmllang, xmlspace, errorHandler) {\n    StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    this.space = xmlspace;\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML anonymous span element\r\n   */\n\n\n  function AnonymousSpan() {\n    ContentElement.call(this, 'span');\n  }\n\n  AnonymousSpan.prototype.initFromText = function (doc, parent, text, xmllang, xmlspace, errorHandler) {\n    TimedElement.prototype.initFromNode.call(this, doc, parent, null, errorHandler);\n    this.text = text;\n    this.space = xmlspace;\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML br element\r\n   */\n\n\n  function Br() {\n    ContentElement.call(this, 'br');\n  }\n\n  Br.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\n    LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML Region element\r\n   * \r\n   */\n\n\n  function Region() {}\n\n  Region.prototype.createDefaultRegion = function (xmllang) {\n    var r = new Region();\n    IdentifiedElement.call(r, '');\n    StyledElement.call(r, {});\n    AnimatedElement.call(r, []);\n    TimedElement.call(r, 0, Number.POSITIVE_INFINITY, null);\n    this.lang = xmllang;\n    return r;\n  };\n\n  Region.prototype.initFromNode = function (doc, node, xmllang, errorHandler) {\n    IdentifiedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    /* add specified styles */\n\n    this.styleAttrs = elementGetStyles(node, errorHandler);\n    /* remember referential styles for merging after nested styling is processed*/\n\n    this.styleRefs = elementGetStyleRefs(node);\n    /* xml:lang */\n\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML Set element\r\n   * \r\n   */\n\n\n  function Set() {}\n\n  Set.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    var styles = elementGetStyles(node, errorHandler);\n    this.qname = null;\n    this.value = null;\n\n    for (var qname in styles) {\n      if (!styles.hasOwnProperty(qname)) continue;\n\n      if (this.qname) {\n        reportError(errorHandler, \"More than one style specified on set\");\n        break;\n      }\n\n      this.qname = qname;\n      this.value = styles[qname];\n    }\n  };\n  /*\r\n   * Utility functions\r\n   * \r\n   */\n\n\n  function elementGetXMLID(node) {\n    return node && 'xml:id' in node.attributes ? node.attributes['xml:id'].value || null : null;\n  }\n\n  function elementGetRegionID(node) {\n    return node && 'region' in node.attributes ? node.attributes.region.value : '';\n  }\n\n  function elementGetTimeContainer(node, errorHandler) {\n    var tc = node && 'timeContainer' in node.attributes ? node.attributes.timeContainer.value : null;\n\n    if (!tc || tc === \"par\") {\n      return \"par\";\n    } else if (tc === \"seq\") {\n      return \"seq\";\n    } else {\n      reportError(errorHandler, \"Illegal value of timeContainer (assuming 'par')\");\n      return \"par\";\n    }\n  }\n\n  function elementGetStyleRefs(node) {\n    return node && 'style' in node.attributes ? node.attributes.style.value.split(\" \") : [];\n  }\n\n  function elementGetStyles(node, errorHandler) {\n    var s = {};\n\n    if (node !== null) {\n      for (var i in node.attributes) {\n        var qname = node.attributes[i].uri + \" \" + node.attributes[i].local;\n        var sa = imscStyles.byQName[qname];\n\n        if (sa !== undefined) {\n          var val = sa.parse(node.attributes[i].value);\n\n          if (val !== null) {\n            s[qname] = val;\n            /* TODO: consider refactoring errorHandler into parse and compute routines */\n\n            if (sa === imscStyles.byName.zIndex) {\n              reportWarning(errorHandler, \"zIndex attribute present but not used by IMSC1 since regions do not overlap\");\n            }\n          } else {\n            reportError(errorHandler, \"Cannot parse styling attribute \" + qname + \" --> \" + node.attributes[i].value);\n          }\n        }\n      }\n    }\n\n    return s;\n  }\n\n  function findAttribute(node, ns, name) {\n    for (var i in node.attributes) {\n      if (node.attributes[i].uri === ns && node.attributes[i].local === name) {\n        return node.attributes[i].value;\n      }\n    }\n\n    return null;\n  }\n\n  function extractAspectRatio(node, errorHandler) {\n    var ar = findAttribute(node, imscNames.ns_ittp, \"aspectRatio\");\n\n    if (ar === null) {\n      ar = findAttribute(node, imscNames.ns_ttp, \"displayAspectRatio\");\n    }\n\n    var rslt = null;\n\n    if (ar !== null) {\n      var ASPECT_RATIO_RE = /(\\d+)\\s+(\\d+)/;\n      var m = ASPECT_RATIO_RE.exec(ar);\n\n      if (m !== null) {\n        var w = parseInt(m[1]);\n        var h = parseInt(m[2]);\n\n        if (w !== 0 && h !== 0) {\n          rslt = w / h;\n        } else {\n          reportError(errorHandler, \"Illegal aspectRatio values (ignoring)\");\n        }\n      } else {\n        reportError(errorHandler, \"Malformed aspectRatio attribute (ignoring)\");\n      }\n    }\n\n    return rslt;\n  }\n  /*\r\n   * Returns the cellResolution attribute from a node\r\n   * \r\n   */\n\n\n  function extractCellResolution(node, errorHandler) {\n    var cr = findAttribute(node, imscNames.ns_ttp, \"cellResolution\"); // initial value\n\n    var h = 15;\n    var w = 32;\n\n    if (cr !== null) {\n      var CELL_RESOLUTION_RE = /(\\d+) (\\d+)/;\n      var m = CELL_RESOLUTION_RE.exec(cr);\n\n      if (m !== null) {\n        w = parseInt(m[1]);\n        h = parseInt(m[2]);\n      } else {\n        reportWarning(errorHandler, \"Malformed cellResolution value (using initial value instead)\");\n      }\n    }\n\n    return {\n      'w': w,\n      'h': h\n    };\n  }\n\n  function extractFrameAndTickRate(node, errorHandler) {\n    // subFrameRate is ignored per IMSC1 specification\n    // extract frame rate\n    var fps_attr = findAttribute(node, imscNames.ns_ttp, \"frameRate\"); // initial value\n\n    var fps = 30; // match variable\n\n    var m;\n\n    if (fps_attr !== null) {\n      var FRAME_RATE_RE = /(\\d+)/;\n      m = FRAME_RATE_RE.exec(fps_attr);\n\n      if (m !== null) {\n        fps = parseInt(m[1]);\n      } else {\n        reportWarning(errorHandler, \"Malformed frame rate attribute (using initial value instead)\");\n      }\n    } // extract frame rate multiplier\n\n\n    var frm_attr = findAttribute(node, imscNames.ns_ttp, \"frameRateMultiplier\"); // initial value\n\n    var frm = 1;\n\n    if (frm_attr !== null) {\n      var FRAME_RATE_MULT_RE = /(\\d+) (\\d+)/;\n      m = FRAME_RATE_MULT_RE.exec(frm_attr);\n\n      if (m !== null) {\n        frm = parseInt(m[1]) / parseInt(m[2]);\n      } else {\n        reportWarning(errorHandler, \"Malformed frame rate multiplier attribute (using initial value instead)\");\n      }\n    }\n\n    var efps = frm * fps; // extract tick rate\n\n    var tr = 1;\n    var trattr = findAttribute(node, imscNames.ns_ttp, \"tickRate\");\n\n    if (trattr === null) {\n      if (fps_attr !== null) tr = efps;\n    } else {\n      var TICK_RATE_RE = /(\\d+)/;\n      m = TICK_RATE_RE.exec(trattr);\n\n      if (m !== null) {\n        tr = parseInt(m[1]);\n      } else {\n        reportWarning(errorHandler, \"Malformed tick rate attribute (using initial value instead)\");\n      }\n    }\n\n    return {\n      effectiveFrameRate: efps,\n      tickRate: tr\n    };\n  }\n\n  function extractExtent(node, errorHandler) {\n    var attr = findAttribute(node, imscNames.ns_tts, \"extent\");\n    if (attr === null) return null;\n    var s = attr.split(\" \");\n\n    if (s.length !== 2) {\n      reportWarning(errorHandler, \"Malformed extent (ignoring)\");\n      return null;\n    }\n\n    var w = imscUtils.parseLength(s[0]);\n    var h = imscUtils.parseLength(s[1]);\n\n    if (!h || !w) {\n      reportWarning(errorHandler, \"Malformed extent values (ignoring)\");\n      return null;\n    }\n\n    return {\n      'h': h,\n      'w': w\n    };\n  }\n\n  function parseTimeExpression(tickRate, effectiveFrameRate, str) {\n    var CLOCK_TIME_FRACTION_RE = /^(\\d{2,}):(\\d\\d):(\\d\\d(?:\\.\\d+)?)$/;\n    var CLOCK_TIME_FRAMES_RE = /^(\\d{2,}):(\\d\\d):(\\d\\d)\\:(\\d{2,})$/;\n    var OFFSET_FRAME_RE = /^(\\d+(?:\\.\\d+)?)f$/;\n    var OFFSET_TICK_RE = /^(\\d+(?:\\.\\d+)?)t$/;\n    var OFFSET_MS_RE = /^(\\d+(?:\\.\\d+)?)ms$/;\n    var OFFSET_S_RE = /^(\\d+(?:\\.\\d+)?)s$/;\n    var OFFSET_H_RE = /^(\\d+(?:\\.\\d+)?)h$/;\n    var OFFSET_M_RE = /^(\\d+(?:\\.\\d+)?)m$/;\n    var m;\n    var r = null;\n\n    if ((m = OFFSET_FRAME_RE.exec(str)) !== null) {\n      if (effectiveFrameRate !== null) {\n        r = parseFloat(m[1]) / effectiveFrameRate;\n      }\n    } else if ((m = OFFSET_TICK_RE.exec(str)) !== null) {\n      if (tickRate !== null) {\n        r = parseFloat(m[1]) / tickRate;\n      }\n    } else if ((m = OFFSET_MS_RE.exec(str)) !== null) {\n      r = parseFloat(m[1]) / 1000.0;\n    } else if ((m = OFFSET_S_RE.exec(str)) !== null) {\n      r = parseFloat(m[1]);\n    } else if ((m = OFFSET_H_RE.exec(str)) !== null) {\n      r = parseFloat(m[1]) * 3600.0;\n    } else if ((m = OFFSET_M_RE.exec(str)) !== null) {\n      r = parseFloat(m[1]) * 60.0;\n    } else if ((m = CLOCK_TIME_FRACTION_RE.exec(str)) !== null) {\n      r = parseInt(m[1]) * 3600 + parseInt(m[2]) * 60 + parseFloat(m[3]);\n    } else if ((m = CLOCK_TIME_FRAMES_RE.exec(str)) !== null) {\n      /* this assumes that HH:MM:SS is a clock-time-with-fraction */\n      if (effectiveFrameRate !== null) {\n        r = parseInt(m[1]) * 3600 + parseInt(m[2]) * 60 + parseInt(m[3]) + (m[4] === null ? 0 : parseInt(m[4]) / effectiveFrameRate);\n      }\n    }\n\n    return r;\n  }\n\n  function processTiming(doc, parent, node, errorHandler) {\n    /* determine explicit begin */\n    var explicit_begin = null;\n\n    if (node && 'begin' in node.attributes) {\n      explicit_begin = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.begin.value);\n\n      if (explicit_begin === null) {\n        reportWarning(errorHandler, \"Malformed begin value \" + node.attributes.begin.value + \" (using 0)\");\n      }\n    }\n    /* determine explicit duration */\n\n\n    var explicit_dur = null;\n\n    if (node && 'dur' in node.attributes) {\n      explicit_dur = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.dur.value);\n\n      if (explicit_dur === null) {\n        reportWarning(errorHandler, \"Malformed dur value \" + node.attributes.dur.value + \" (ignoring)\");\n      }\n    }\n    /* determine explicit end */\n\n\n    var explicit_end = null;\n\n    if (node && 'end' in node.attributes) {\n      explicit_end = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.end.value);\n\n      if (explicit_end === null) {\n        reportWarning(errorHandler, \"Malformed end value (ignoring)\");\n      }\n    }\n\n    return {\n      explicit_begin: explicit_begin,\n      explicit_end: explicit_end,\n      explicit_dur: explicit_dur\n    };\n  }\n\n  function mergeChainedStyles(styling, style, errorHandler) {\n    while (style.styleRefs.length > 0) {\n      var sref = style.styleRefs.pop();\n\n      if (!(sref in styling.styles)) {\n        reportError(errorHandler, \"Non-existant style id referenced\");\n        continue;\n      }\n\n      mergeChainedStyles(styling, styling.styles[sref], errorHandler);\n      mergeStylesIfNotPresent(styling.styles[sref].styleAttrs, style.styleAttrs);\n    }\n  }\n\n  function mergeReferencedStyles(styling, stylerefs, styleattrs, errorHandler) {\n    for (var i = stylerefs.length - 1; i >= 0; i--) {\n      var sref = stylerefs[i];\n\n      if (!(sref in styling.styles)) {\n        reportError(errorHandler, \"Non-existant style id referenced\");\n        continue;\n      }\n\n      mergeStylesIfNotPresent(styling.styles[sref].styleAttrs, styleattrs);\n    }\n  }\n\n  function mergeStylesIfNotPresent(from_styles, into_styles) {\n    for (var sname in from_styles) {\n      if (!from_styles.hasOwnProperty(sname)) continue;\n      if (sname in into_styles) continue;\n      into_styles[sname] = from_styles[sname];\n    }\n  }\n  /* TODO: validate style format at parsing */\n\n  /*\r\n   * ERROR HANDLING UTILITY FUNCTIONS\r\n   * \r\n   */\n\n\n  function reportInfo(errorHandler, msg) {\n    if (errorHandler && errorHandler.info && errorHandler.info(msg)) throw msg;\n  }\n\n  function reportWarning(errorHandler, msg) {\n    if (errorHandler && errorHandler.warn && errorHandler.warn(msg)) throw msg;\n  }\n\n  function reportError(errorHandler, msg) {\n    if (errorHandler && errorHandler.error && errorHandler.error(msg)) throw msg;\n  }\n\n  function reportFatal(errorHandler, msg) {\n    if (errorHandler && errorHandler.fatal) errorHandler.fatal(msg);\n    throw msg;\n  }\n  /*\r\n   * Binary search utility function\r\n   * \r\n   * @typedef {Object} BinarySearchResult\r\n   * @property {boolean} found Was an exact match found?\r\n   * @property {number} index Position of the exact match or insert position\r\n   * \r\n   * @returns {BinarySearchResult}\r\n   */\n\n\n  function indexOf(arr, searchval) {\n    var min = 0;\n    var max = arr.length - 1;\n    var cur;\n\n    while (min <= max) {\n      cur = Math.floor((min + max) / 2);\n      var curval = arr[cur];\n\n      if (curval < searchval) {\n        min = cur + 1;\n      } else if (curval > searchval) {\n        max = cur - 1;\n      } else {\n        return {\n          found: true,\n          index: cur\n        };\n      }\n    }\n\n    return {\n      found: false,\n      index: min\n    };\n  }\n})(typeof exports === 'undefined' ? this.imscDoc = {} : exports, typeof sax === 'undefined' ? require(\"sax\") : sax, typeof imscNames === 'undefined' ? require(\"./names\") : imscNames, typeof imscStyles === 'undefined' ? require(\"./styles\") : imscStyles, typeof imscUtils === 'undefined' ? require(\"./utils\") : imscUtils);","map":{"version":3,"names":["imscDoc","sax","imscNames","imscStyles","imscUtils","fromXML","xmlstring","errorHandler","metadataHandler","p","parser","xmlns","estack","xmllangstack","xmlspacestack","metadata_depth","doc","onclosetag","node","Region","head","styling","mergeReferencedStyles","styleRefs","styleAttrs","Styling","sid","styles","hasOwnProperty","mergeChainedStyles","P","Span","contents","length","cs","c","AnonymousSpan","text","push","ForeignElement","uri","ns_tt","local","onCloseTag","shift","ontext","str","undefined","ruby","byName","qname","s","initFromText","onText","onopentag","xmlspace","attributes","unshift","value","xmllang","reportFatal","line","column","TT","initFromNode","Head","Style","id","reportError","mergeStylesIfNotPresent","ini","Initial","qn","initials","layout","Layout","r","regions","body","b","Body","Div","d","bi","backgroundImage","Image","img","ns","nb","Br","st","Set","sets","attrs","a","onOpenTag","write","close","hasRegions","i","dr","prototype","createDefaultRegion","lang","region_i","resolveTiming","cleanRubyContainers","element","rubyval","isrubycontainer","kind","prev_sibling","parent","isinseq","timeContainer","implicit_begin","end","begin","explicit_begin","implicit_end","set_i","Math","max","Number","POSITIVE_INFINITY","content_i","explicit_end","explicit_dur","min","_registerEvent","events","cr","extractCellResolution","cellLength","ComputedLength","h","w","frtr","extractFrameAndTickRate","effectiveFrameRate","tickRate","aspectRatio","extractAspectRatio","attr","findAttribute","ns_ttp","e","extractExtent","pxLength","unit","dimensions","elem","b_i","indexOf","found","splice","index","e_i","getMediaTimeRange","getMediaTimeEvents","elementGetXMLID","elementGetStyles","elementGetStyleRefs","ns_itts","ns_ebutts","ns_tts","src","type","ContentElement","call","StyledElement","TimedElement","AnimatedElement","LayoutElement","IdentifiedElement","regionID","elementGetRegionID","ContainerElement","t","processTiming","elementGetTimeContainer","space","region","tc","style","split","sa","byQName","val","parse","zIndex","reportWarning","name","ar","ns_ittp","rslt","ASPECT_RATIO_RE","m","exec","parseInt","CELL_RESOLUTION_RE","fps_attr","fps","FRAME_RATE_RE","frm_attr","frm","FRAME_RATE_MULT_RE","efps","tr","trattr","TICK_RATE_RE","parseLength","parseTimeExpression","CLOCK_TIME_FRACTION_RE","CLOCK_TIME_FRAMES_RE","OFFSET_FRAME_RE","OFFSET_TICK_RE","OFFSET_MS_RE","OFFSET_S_RE","OFFSET_H_RE","OFFSET_M_RE","parseFloat","dur","sref","pop","stylerefs","styleattrs","from_styles","into_styles","sname","reportInfo","msg","info","warn","error","fatal","arr","searchval","cur","floor","curval","exports","require"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/imsc/src/main/js/doc.js"],"sourcesContent":["/* \r\n * Copyright (c) 2016, Pierre-Anthony Lemieux <pal@sandflow.com>\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * @module imscDoc\r\n */\r\n\r\n;\r\n(function (imscDoc, sax, imscNames, imscStyles, imscUtils) {\r\n\r\n\r\n    /**\r\n     * Allows a client to provide callbacks to handle children of the <metadata> element\r\n     * @typedef {Object} MetadataHandler\r\n     * @property {?OpenTagCallBack} onOpenTag\r\n     * @property {?CloseTagCallBack} onCloseTag\r\n     * @property {?TextCallBack} onText\r\n     */\r\n\r\n    /**\r\n     * Called when the opening tag of an element node is encountered.\r\n     * @callback OpenTagCallBack\r\n     * @param {string} ns Namespace URI of the element\r\n     * @param {string} name Local name of the element\r\n     * @param {Object[]} attributes List of attributes, each consisting of a\r\n     *                              `uri`, `name` and `value`\r\n     */\r\n\r\n    /**\r\n     * Called when the closing tag of an element node is encountered.\r\n     * @callback CloseTagCallBack\r\n     */\r\n\r\n    /**\r\n     * Called when a text node is encountered.\r\n     * @callback TextCallBack\r\n     * @param {string} contents Contents of the text node\r\n     */\r\n\r\n    /**\r\n     * Parses an IMSC1 document into an opaque in-memory representation that exposes\r\n     * a single method <pre>getMediaTimeEvents()</pre> that returns a list of time\r\n     * offsets (in seconds) of the ISD, i.e. the points in time where the visual\r\n     * representation of the document change. `metadataHandler` allows the caller to\r\n     * be called back when nodes are present in <metadata> elements. \r\n     * \r\n     * @param {string} xmlstring XML document\r\n     * @param {?module:imscUtils.ErrorHandler} errorHandler Error callback\r\n     * @param {?MetadataHandler} metadataHandler Callback for <Metadata> elements\r\n     * @returns {Object} Opaque in-memory representation of an IMSC1 document\r\n     */\r\n\r\n    imscDoc.fromXML = function (xmlstring, errorHandler, metadataHandler) {\r\n        var p = sax.parser(true, {xmlns: true});\r\n        var estack = [];\r\n        var xmllangstack = [];\r\n        var xmlspacestack = [];\r\n        var metadata_depth = 0;\r\n        var doc = null;\r\n\r\n        p.onclosetag = function (node) {\r\n\r\n            \r\n            if (estack[0] instanceof Region) {\r\n\r\n                /* merge referenced styles */\r\n\r\n                if (doc.head !== null && doc.head.styling !== null) {\r\n                    mergeReferencedStyles(doc.head.styling, estack[0].styleRefs, estack[0].styleAttrs, errorHandler);\r\n                }\r\n\r\n                delete estack[0].styleRefs;\r\n\r\n            } else if (estack[0] instanceof Styling) {\r\n\r\n                /* flatten chained referential styling */\r\n\r\n                for (var sid in estack[0].styles) {\r\n\r\n                    if (! estack[0].styles.hasOwnProperty(sid)) continue;\r\n\r\n                    mergeChainedStyles(estack[0], estack[0].styles[sid], errorHandler);\r\n\r\n                }\r\n\r\n            } else if (estack[0] instanceof P || estack[0] instanceof Span) {\r\n\r\n                /* merge anonymous spans */\r\n\r\n                if (estack[0].contents.length > 1) {\r\n\r\n                    var cs = [estack[0].contents[0]];\r\n\r\n                    var c;\r\n\r\n                    for (c = 1; c < estack[0].contents.length; c++) {\r\n\r\n                        if (estack[0].contents[c] instanceof AnonymousSpan &&\r\n                                cs[cs.length - 1] instanceof AnonymousSpan) {\r\n\r\n                            cs[cs.length - 1].text += estack[0].contents[c].text;\r\n\r\n                        } else {\r\n\r\n                            cs.push(estack[0].contents[c]);\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    estack[0].contents = cs;\r\n\r\n                }\r\n\r\n                // remove redundant nested anonymous spans (9.3.3(1)(c))\r\n\r\n                if (estack[0] instanceof Span &&\r\n                        estack[0].contents.length === 1 &&\r\n                        estack[0].contents[0] instanceof AnonymousSpan) {\r\n\r\n                    estack[0].text = estack[0].contents[0].text;\r\n                    delete estack[0].contents;\r\n\r\n                }\r\n\r\n            } else if (estack[0] instanceof ForeignElement) {\r\n\r\n                if (estack[0].node.uri === imscNames.ns_tt &&\r\n                        estack[0].node.local === 'metadata') {\r\n\r\n                    /* leave the metadata element */\r\n\r\n                    metadata_depth--;\r\n\r\n                } else if (metadata_depth > 0 &&\r\n                        metadataHandler &&\r\n                        'onCloseTag' in metadataHandler) {\r\n\r\n                    /* end of child of metadata element */\r\n\r\n                    metadataHandler.onCloseTag();\r\n\r\n                }\r\n\r\n            }\r\n\r\n            // TODO: delete stylerefs?\r\n\r\n            // maintain the xml:space stack\r\n\r\n            xmlspacestack.shift();\r\n\r\n            // maintain the xml:lang stack\r\n\r\n            xmllangstack.shift();\r\n\r\n            // prepare for the next element\r\n\r\n            estack.shift();\r\n        };\r\n\r\n        p.ontext = function (str) {\r\n\r\n            if (estack[0] === undefined) {\r\n\r\n                /* ignoring text outside of elements */\r\n\r\n            } else if (estack[0] instanceof Span || estack[0] instanceof P) {\r\n\r\n                /* ignore children text nodes in ruby container spans */\r\n\r\n                if (estack[0] instanceof Span) {\r\n\r\n                    var ruby = estack[0].styleAttrs[imscStyles.byName.ruby.qname];\r\n\r\n                    if (ruby === 'container' || ruby === 'textContainer' || ruby === 'baseContainer') {\r\n\r\n                        return;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                /* create an anonymous span */\r\n\r\n                var s = new AnonymousSpan();\r\n\r\n                s.initFromText(doc, estack[0], str, xmllangstack[0], xmlspacestack[0], errorHandler);\r\n\r\n                estack[0].contents.push(s);\r\n\r\n            } else if (estack[0] instanceof ForeignElement &&\r\n                    metadata_depth > 0 &&\r\n                    metadataHandler &&\r\n                    'onText' in metadataHandler) {\r\n\r\n                /* text node within a child of metadata element */\r\n\r\n                metadataHandler.onText(str);\r\n\r\n            }\r\n\r\n        };\r\n\r\n\r\n        p.onopentag = function (node) {\r\n\r\n            // maintain the xml:space stack\r\n\r\n            var xmlspace = node.attributes[\"xml:space\"];\r\n\r\n            if (xmlspace) {\r\n\r\n                xmlspacestack.unshift(xmlspace.value);\r\n\r\n            } else {\r\n\r\n                if (xmlspacestack.length === 0) {\r\n\r\n                    xmlspacestack.unshift(\"default\");\r\n\r\n                } else {\r\n\r\n                    xmlspacestack.unshift(xmlspacestack[0]);\r\n\r\n                }\r\n\r\n            }\r\n\r\n            /* maintain the xml:lang stack */\r\n\r\n\r\n            var xmllang = node.attributes[\"xml:lang\"];\r\n\r\n            if (xmllang) {\r\n\r\n                xmllangstack.unshift(xmllang.value);\r\n\r\n            } else {\r\n\r\n                if (xmllangstack.length === 0) {\r\n\r\n                    xmllangstack.unshift(\"\");\r\n\r\n                } else {\r\n\r\n                    xmllangstack.unshift(xmllangstack[0]);\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n            /* process the element */\r\n\r\n            if (node.uri === imscNames.ns_tt) {\r\n\r\n                if (node.local === 'tt') {\r\n\r\n                    if (doc !== null) {\r\n\r\n                        reportFatal(errorHandler, \"Two <tt> elements at (\" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    doc = new TT();\r\n\r\n                    doc.initFromNode(node, xmllangstack[0], errorHandler);\r\n\r\n                    estack.unshift(doc);\r\n\r\n                } else if (node.local === 'head') {\r\n\r\n                    if (!(estack[0] instanceof TT)) {\r\n                        reportFatal(errorHandler, \"Parent of <head> element is not <tt> at (\" + this.line + \",\" + this.column + \")\");\r\n                    }\r\n\r\n                    estack.unshift(doc.head);\r\n\r\n                } else if (node.local === 'styling') {\r\n\r\n                    if (!(estack[0] instanceof Head)) {\r\n                        reportFatal(errorHandler, \"Parent of <styling> element is not <head> at (\" + this.line + \",\" + this.column + \")\");\r\n                    }\r\n\r\n                    estack.unshift(doc.head.styling);\r\n\r\n                } else if (node.local === 'style') {\r\n\r\n                    var s;\r\n\r\n                    if (estack[0] instanceof Styling) {\r\n\r\n                        s = new Style();\r\n\r\n                        s.initFromNode(node, errorHandler);\r\n\r\n                        /* ignore <style> element missing @id */\r\n\r\n                        if (!s.id) {\r\n\r\n                            reportError(errorHandler, \"<style> element missing @id attribute\");\r\n\r\n                        } else {\r\n\r\n                            doc.head.styling.styles[s.id] = s;\r\n\r\n                        }\r\n\r\n                        estack.unshift(s);\r\n\r\n                    } else if (estack[0] instanceof Region) {\r\n\r\n                        /* nested styles can be merged with specified styles\r\n                         * immediately, with lower priority\r\n                         * (see 8.4.4.2(3) at TTML1 )\r\n                         */\r\n\r\n                        s = new Style();\r\n\r\n                        s.initFromNode(node, errorHandler);\r\n\r\n                        mergeStylesIfNotPresent(s.styleAttrs, estack[0].styleAttrs);\r\n\r\n                        estack.unshift(s);\r\n\r\n                    } else {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <style> element is not <styling> or <region> at (\" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                }  else if (node.local === 'initial') {\r\n\r\n                    var ini;\r\n\r\n                    if (estack[0] instanceof Styling) {\r\n\r\n                        ini = new Initial();\r\n\r\n                        ini.initFromNode(node, errorHandler);\r\n                        \r\n                        for (var qn in ini.styleAttrs) {\r\n\r\n                            if (! ini.styleAttrs.hasOwnProperty(qn)) continue;\r\n                            \r\n                            doc.head.styling.initials[qn] = ini.styleAttrs[qn];\r\n                            \r\n                        }\r\n                        \r\n                        estack.unshift(ini);\r\n\r\n                    } else {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <initial> element is not <styling> at (\" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                } else if (node.local === 'layout') {\r\n\r\n                    if (!(estack[0] instanceof Head)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <layout> element is not <head> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    estack.unshift(doc.head.layout);\r\n\r\n                } else if (node.local === 'region') {\r\n\r\n                    if (!(estack[0] instanceof Layout)) {\r\n                        reportFatal(errorHandler, \"Parent of <region> element is not <layout> at \" + this.line + \",\" + this.column + \")\");\r\n                    }\r\n\r\n                    var r = new Region();\r\n\r\n                    r.initFromNode(doc, node, xmllangstack[0], errorHandler);\r\n\r\n                    if (!r.id || r.id in doc.head.layout.regions) {\r\n\r\n                        reportError(errorHandler, \"Ignoring <region> with duplicate or missing @id at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    } else {\r\n\r\n                        doc.head.layout.regions[r.id] = r;\r\n\r\n                    }\r\n\r\n                    estack.unshift(r);\r\n\r\n                } else if (node.local === 'body') {\r\n\r\n                    if (!(estack[0] instanceof TT)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <body> element is not <tt> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    if (doc.body !== null) {\r\n\r\n                        reportFatal(errorHandler, \"Second <body> element at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var b = new Body();\r\n\r\n                    b.initFromNode(doc, node, xmllangstack[0], errorHandler);\r\n\r\n                    doc.body = b;\r\n\r\n                    estack.unshift(b);\r\n\r\n                } else if (node.local === 'div') {\r\n\r\n                    if (!(estack[0] instanceof Div || estack[0] instanceof Body)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <div> element is not <body> or <div> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var d = new Div();\r\n\r\n                    d.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\r\n                    \r\n                    /* transform smpte:backgroundImage to TTML2 image element */\r\n                    \r\n                    var bi = d.styleAttrs[imscStyles.byName.backgroundImage.qname];\r\n                    \r\n                    if (bi) {\r\n                        d.contents.push(new Image(bi));\r\n                        delete d.styleAttrs[imscStyles.byName.backgroundImage.qname];                  \r\n                    }\r\n\r\n                    estack[0].contents.push(d);\r\n\r\n                    estack.unshift(d);\r\n\r\n                } else if (node.local === 'image') {\r\n\r\n                    if (!(estack[0] instanceof Div)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <image> element is not <div> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var img = new Image();\r\n                    \r\n                    img.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\r\n                    \r\n                    estack[0].contents.push(img);\r\n\r\n                    estack.unshift(img);\r\n\r\n                } else if (node.local === 'p') {\r\n\r\n                    if (!(estack[0] instanceof Div)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <p> element is not <div> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var p = new P();\r\n\r\n                    p.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\r\n\r\n                    estack[0].contents.push(p);\r\n\r\n                    estack.unshift(p);\r\n\r\n                } else if (node.local === 'span') {\r\n\r\n                    if (!(estack[0] instanceof Span || estack[0] instanceof P)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <span> element is not <span> or <p> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var ns = new Span();\r\n\r\n                    ns.initFromNode(doc, estack[0], node, xmllangstack[0], xmlspacestack[0], errorHandler);\r\n\r\n                    estack[0].contents.push(ns);\r\n\r\n                    estack.unshift(ns);\r\n\r\n                } else if (node.local === 'br') {\r\n\r\n                    if (!(estack[0] instanceof Span || estack[0] instanceof P)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <br> element is not <span> or <p> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var nb = new Br();\r\n\r\n                    nb.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\r\n\r\n                    estack[0].contents.push(nb);\r\n\r\n                    estack.unshift(nb);\r\n\r\n                } else if (node.local === 'set') {\r\n\r\n                    if (!(estack[0] instanceof Span ||\r\n                            estack[0] instanceof P ||\r\n                            estack[0] instanceof Div ||\r\n                            estack[0] instanceof Body ||\r\n                            estack[0] instanceof Region ||\r\n                            estack[0] instanceof Br)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <set> element is not a content element or a region at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var st = new Set();\r\n\r\n                    st.initFromNode(doc, estack[0], node, errorHandler);\r\n\r\n                    estack[0].sets.push(st);\r\n\r\n                    estack.unshift(st);\r\n\r\n                } else {\r\n\r\n                    /* element in the TT namespace, but not a content element */\r\n\r\n                    estack.unshift(new ForeignElement(node));\r\n                }\r\n\r\n            } else {\r\n\r\n                /* ignore elements not in the TTML namespace unless in metadata element */\r\n\r\n                estack.unshift(new ForeignElement(node));\r\n\r\n            }\r\n\r\n            /* handle metadata callbacks */\r\n\r\n            if (estack[0] instanceof ForeignElement) {\r\n\r\n                if (node.uri === imscNames.ns_tt &&\r\n                        node.local === 'metadata') {\r\n\r\n                    /* enter the metadata element */\r\n\r\n                    metadata_depth++;\r\n\r\n                } else if (\r\n                        metadata_depth > 0 &&\r\n                        metadataHandler &&\r\n                        'onOpenTag' in metadataHandler\r\n                        ) {\r\n\r\n                    /* start of child of metadata element */\r\n\r\n                    var attrs = [];\r\n\r\n                    for (var a in node.attributes) {\r\n                        attrs[node.attributes[a].uri + \" \" + node.attributes[a].local] =\r\n                                {\r\n                                    uri: node.attributes[a].uri,\r\n                                    local: node.attributes[a].local,\r\n                                    value: node.attributes[a].value\r\n                                };\r\n                    }\r\n\r\n                    metadataHandler.onOpenTag(node.uri, node.local, attrs);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        };\r\n\r\n        // parse the document\r\n\r\n        p.write(xmlstring).close();\r\n\r\n        // all referential styling has been flatten, so delete styles\r\n\r\n        delete doc.head.styling.styles;\r\n       \r\n        // create default region if no regions specified\r\n\r\n        var hasRegions = false;\r\n\r\n        /* AFAIK the only way to determine whether an object has members */\r\n\r\n        for (var i in doc.head.layout.regions) {\r\n\r\n            if (doc.head.layout.regions.hasOwnProperty(i)) {\r\n                hasRegions = true;\r\n                break;\r\n            }\r\n\r\n        }\r\n\r\n        if (!hasRegions) {\r\n\r\n            /* create default region */\r\n\r\n            var dr = Region.prototype.createDefaultRegion(doc.lang);\r\n\r\n            doc.head.layout.regions[dr.id] = dr;\r\n\r\n        }\r\n\r\n        /* resolve desired timing for regions */\r\n\r\n        for (var region_i in doc.head.layout.regions) {\r\n\r\n            if (! doc.head.layout.regions.hasOwnProperty(region_i)) continue;\r\n\r\n            resolveTiming(doc, doc.head.layout.regions[region_i], null, null);\r\n\r\n        }\r\n\r\n        /* resolve desired timing for content elements */\r\n\r\n        if (doc.body) {\r\n            resolveTiming(doc, doc.body, null, null);\r\n        }\r\n\r\n        /* remove undefined spans in ruby containers */\r\n\r\n        if (doc.body) {\r\n            cleanRubyContainers(doc.body);\r\n        }\r\n\r\n        return doc;\r\n    };\r\n\r\n    function cleanRubyContainers(element) {\r\n        \r\n        if (! ('contents' in element)) return;\r\n\r\n        var rubyval = 'styleAttrs' in element ? element.styleAttrs[imscStyles.byName.ruby.qname] : null;\r\n\r\n        var isrubycontainer = (element.kind === 'span' && (rubyval === \"container\" || rubyval === \"textContainer\" || rubyval === \"baseContainer\"));\r\n\r\n        for (var i = element.contents.length - 1; i >= 0; i--) {\r\n\r\n            if (isrubycontainer && !('styleAttrs' in element.contents[i] && imscStyles.byName.ruby.qname in element.contents[i].styleAttrs)) {\r\n\r\n                /* prune undefined <span> in ruby containers */\r\n\r\n                delete element.contents[i];\r\n\r\n            } else {\r\n\r\n                cleanRubyContainers(element.contents[i]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function resolveTiming(doc, element, prev_sibling, parent) {\r\n\r\n        /* are we in a seq container? */\r\n\r\n        var isinseq = parent && parent.timeContainer === \"seq\";\r\n\r\n        /* determine implicit begin */\r\n\r\n        var implicit_begin = 0; /* default */\r\n\r\n        if (parent) {\r\n\r\n            if (isinseq && prev_sibling) {\r\n\r\n                /*\r\n                 * if seq time container, offset from the previous sibling end\r\n                 */\r\n\r\n                implicit_begin = prev_sibling.end;\r\n\r\n\r\n            } else {\r\n\r\n                implicit_begin = parent.begin;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* compute desired begin */\r\n\r\n        element.begin = element.explicit_begin ? element.explicit_begin + implicit_begin : implicit_begin;\r\n\r\n\r\n        /* determine implicit end */\r\n\r\n        var implicit_end = element.begin;\r\n\r\n        var s = null;\r\n\r\n        if (\"sets\" in element) {\r\n\r\n            for (var set_i = 0; set_i < element.sets.length; set_i++) {\r\n\r\n                resolveTiming(doc, element.sets[set_i], s, element);\r\n\r\n                if (element.timeContainer === \"seq\") {\r\n\r\n                    implicit_end = element.sets[set_i].end;\r\n\r\n                } else {\r\n\r\n                    implicit_end = Math.max(implicit_end, element.sets[set_i].end);\r\n\r\n                }\r\n\r\n                s = element.sets[set_i];\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if (!('contents' in element)) {\r\n\r\n            /* anonymous spans and regions and <set> and <br>s and spans with only children text nodes */\r\n\r\n            if (isinseq) {\r\n\r\n                /* in seq container, implicit duration is zero */\r\n\r\n                implicit_end = element.begin;\r\n\r\n            } else {\r\n\r\n                /* in par container, implicit duration is indefinite */\r\n\r\n                implicit_end = Number.POSITIVE_INFINITY;\r\n\r\n            }\r\n\r\n        } else if (\"contents\" in element) {\r\n \r\n            for (var content_i = 0; content_i < element.contents.length; content_i++) {\r\n\r\n                resolveTiming(doc, element.contents[content_i], s, element);\r\n\r\n                if (element.timeContainer === \"seq\") {\r\n\r\n                    implicit_end = element.contents[content_i].end;\r\n\r\n                } else {\r\n\r\n                    implicit_end = Math.max(implicit_end, element.contents[content_i].end);\r\n\r\n                }\r\n\r\n                s = element.contents[content_i];\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* determine desired end */\r\n        /* it is never made really clear in SMIL that the explicit end is offset by the implicit begin */\r\n\r\n        if (element.explicit_end !== null && element.explicit_dur !== null) {\r\n\r\n            element.end = Math.min(element.begin + element.explicit_dur, implicit_begin + element.explicit_end);\r\n\r\n        } else if (element.explicit_end === null && element.explicit_dur !== null) {\r\n\r\n            element.end = element.begin + element.explicit_dur;\r\n\r\n        } else if (element.explicit_end !== null && element.explicit_dur === null) {\r\n\r\n            element.end = implicit_begin + element.explicit_end;\r\n\r\n        } else {\r\n\r\n            element.end = implicit_end;\r\n        }\r\n\r\n        delete element.explicit_begin;\r\n        delete element.explicit_dur;\r\n        delete element.explicit_end;\r\n\r\n        doc._registerEvent(element);\r\n\r\n    }\r\n\r\n    function ForeignElement(node) {\r\n        this.node = node;\r\n    }\r\n\r\n    function TT() {\r\n        this.events = [];\r\n        this.head = new Head();\r\n        this.body = null;\r\n    }\r\n\r\n    TT.prototype.initFromNode = function (node, xmllang, errorHandler) {\r\n\r\n        /* compute cell resolution */\r\n\r\n        var cr = extractCellResolution(node, errorHandler);\r\n        \r\n        this.cellLength = {\r\n                'h': new imscUtils.ComputedLength(0, 1/cr.h),\r\n                'w': new imscUtils.ComputedLength(1/cr.w, 0)\r\n            };\r\n\r\n        /* extract frame rate and tick rate */\r\n\r\n        var frtr = extractFrameAndTickRate(node, errorHandler);\r\n\r\n        this.effectiveFrameRate = frtr.effectiveFrameRate;\r\n\r\n        this.tickRate = frtr.tickRate;\r\n\r\n        /* extract aspect ratio */\r\n\r\n        this.aspectRatio = extractAspectRatio(node, errorHandler);\r\n\r\n        /* check timebase */\r\n\r\n        var attr = findAttribute(node, imscNames.ns_ttp, \"timeBase\");\r\n\r\n        if (attr !== null && attr !== \"media\") {\r\n\r\n            reportFatal(errorHandler, \"Unsupported time base\");\r\n\r\n        }\r\n\r\n        /* retrieve extent */\r\n\r\n        var e = extractExtent(node, errorHandler);\r\n\r\n        if (e === null) {\r\n\r\n            this.pxLength = {\r\n                'h': null,\r\n                'w': null\r\n            };\r\n\r\n        } else {\r\n\r\n            if (e.h.unit !== \"px\" || e.w.unit !== \"px\") {\r\n                reportFatal(errorHandler, \"Extent on TT must be in px or absent\");\r\n            }\r\n\r\n            this.pxLength = {\r\n                'h': new imscUtils.ComputedLength(0, 1 / e.h.value),\r\n                'w': new imscUtils.ComputedLength(1 / e.w.value, 0)\r\n            };\r\n        }\r\n        \r\n        /** set root container dimensions to (1, 1) arbitrarily\r\n          * the root container is mapped to actual dimensions at rendering\r\n        **/\r\n        \r\n        this.dimensions = {\r\n                'h': new imscUtils.ComputedLength(0, 1),\r\n                'w': new imscUtils.ComputedLength(1, 0)\r\n\r\n        };\r\n\r\n        /* xml:lang */\r\n\r\n        this.lang = xmllang;\r\n\r\n    };\r\n\r\n    /* register a temporal events */\r\n    TT.prototype._registerEvent = function (elem) {\r\n\r\n        /* skip if begin is not < then end */\r\n\r\n        if (elem.end <= elem.begin)\r\n            return;\r\n\r\n        /* index the begin time of the event */\r\n\r\n        var b_i = indexOf(this.events, elem.begin);\r\n\r\n        if (!b_i.found) {\r\n            this.events.splice(b_i.index, 0, elem.begin);\r\n        }\r\n\r\n        /* index the end time of the event */\r\n\r\n        if (elem.end !== Number.POSITIVE_INFINITY) {\r\n\r\n            var e_i = indexOf(this.events, elem.end);\r\n\r\n            if (!e_i.found) {\r\n                this.events.splice(e_i.index, 0, elem.end);\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Retrieves the range of ISD times covered by the document\r\n     * \r\n     * @returns {Array} Array of two elements: min_begin_time and max_begin_time\r\n     * \r\n     */\r\n    TT.prototype.getMediaTimeRange = function () {\r\n\r\n        return [this.events[0], this.events[this.events.length - 1]];\r\n    };\r\n\r\n    /*\r\n     * Returns list of ISD begin times  \r\n     * \r\n     * @returns {Array}\r\n     */\r\n    TT.prototype.getMediaTimeEvents = function () {\r\n\r\n        return this.events;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML Head element\r\n     */\r\n\r\n    function Head() {\r\n        this.styling = new Styling();\r\n        this.layout = new Layout();\r\n    }\r\n\r\n    /*\r\n     * Represents a TTML Styling element\r\n     */\r\n\r\n    function Styling() {\r\n        this.styles = {};\r\n        this.initials = {};\r\n    }\r\n\r\n    /*\r\n     * Represents a TTML Style element\r\n     */\r\n\r\n    function Style() {\r\n        this.id = null;\r\n        this.styleAttrs = null;\r\n        this.styleRefs = null;\r\n    }\r\n\r\n    Style.prototype.initFromNode = function (node, errorHandler) {\r\n        this.id = elementGetXMLID(node);\r\n        this.styleAttrs = elementGetStyles(node, errorHandler);\r\n        this.styleRefs = elementGetStyleRefs(node);\r\n    };\r\n    \r\n    /*\r\n     * Represents a TTML initial element\r\n     */\r\n\r\n    function Initial() {\r\n        this.styleAttrs = null;\r\n    }\r\n\r\n    Initial.prototype.initFromNode = function (node, errorHandler) {\r\n        \r\n        this.styleAttrs = {};\r\n        \r\n        for (var i in node.attributes) {\r\n\r\n            if (node.attributes[i].uri === imscNames.ns_itts ||\r\n                node.attributes[i].uri === imscNames.ns_ebutts ||\r\n                node.attributes[i].uri === imscNames.ns_tts) {\r\n                \r\n                var qname = node.attributes[i].uri + \" \" + node.attributes[i].local;\r\n                \r\n                this.styleAttrs[qname] = node.attributes[i].value;\r\n\r\n            }\r\n        }\r\n        \r\n    };\r\n\r\n    /*\r\n     * Represents a TTML Layout element\r\n     * \r\n     */\r\n\r\n    function Layout() {\r\n        this.regions = {};\r\n    }\r\n    \r\n    /*\r\n     * Represents a TTML image element\r\n     */\r\n\r\n    function Image(src, type) {\r\n        ContentElement.call(this, 'image');\r\n        this.src = src;\r\n        this.type = type;\r\n    }\r\n\r\n    Image.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\r\n        this.src = 'src' in node.attributes ? node.attributes.src.value : null;\r\n        \r\n        if (! this.src) {\r\n            reportError(errorHandler, \"Invalid image@src attribute\");\r\n        }\r\n        \r\n        this.type = 'type' in node.attributes ? node.attributes.type.value : null;\r\n        \r\n        if (! this.type) {\r\n            reportError(errorHandler, \"Invalid image@type attribute\");\r\n        }\r\n        \r\n        StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * TTML element utility functions\r\n     * \r\n     */\r\n\r\n    function ContentElement(kind) {\r\n        this.kind = kind;\r\n    }\r\n\r\n    function IdentifiedElement(id) {\r\n        this.id = id;\r\n    }\r\n\r\n    IdentifiedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n        this.id = elementGetXMLID(node);\r\n    };\r\n\r\n    function LayoutElement(id) {\r\n        this.regionID = id;\r\n    }\r\n\r\n    LayoutElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n        this.regionID = elementGetRegionID(node);\r\n    };\r\n\r\n    function StyledElement(styleAttrs) {\r\n        this.styleAttrs = styleAttrs;\r\n    }\r\n\r\n    StyledElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n\r\n        this.styleAttrs = elementGetStyles(node, errorHandler);\r\n\r\n        if (doc.head !== null && doc.head.styling !== null) {\r\n            mergeReferencedStyles(doc.head.styling, elementGetStyleRefs(node), this.styleAttrs, errorHandler);\r\n        }\r\n\r\n    };\r\n\r\n    function AnimatedElement(sets) {\r\n        this.sets = sets;\r\n    }\r\n\r\n    AnimatedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n        this.sets = [];\r\n    };\r\n\r\n    function ContainerElement(contents) {\r\n        this.contents = contents;\r\n    }\r\n\r\n    ContainerElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n        this.contents = [];\r\n    };\r\n\r\n    function TimedElement(explicit_begin, explicit_end, explicit_dur) {\r\n        this.explicit_begin = explicit_begin;\r\n        this.explicit_end = explicit_end;\r\n        this.explicit_dur = explicit_dur;\r\n    }\r\n\r\n    TimedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n        var t = processTiming(doc, parent, node, errorHandler);\r\n        this.explicit_begin = t.explicit_begin;\r\n        this.explicit_end = t.explicit_end;\r\n        this.explicit_dur = t.explicit_dur;\r\n\r\n        this.timeContainer = elementGetTimeContainer(node, errorHandler);\r\n    };\r\n\r\n\r\n    /*\r\n     * Represents a TTML body element\r\n     */\r\n\r\n\r\n\r\n    function Body() {\r\n        ContentElement.call(this, 'body');\r\n    }\r\n\r\n\r\n    Body.prototype.initFromNode = function (doc, node, xmllang, errorHandler) {\r\n        StyledElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        LayoutElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        ContainerElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML div element\r\n     */\r\n\r\n    function Div() {\r\n        ContentElement.call(this, 'div');\r\n    }\r\n\r\n    Div.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\r\n        StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML p element\r\n     */\r\n\r\n    function P() {\r\n        ContentElement.call(this, 'p');\r\n    }\r\n\r\n    P.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\r\n        StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML span element\r\n     */\r\n\r\n    function Span() {\r\n        ContentElement.call(this, 'span');\r\n    }\r\n\r\n    Span.prototype.initFromNode = function (doc, parent, node, xmllang, xmlspace, errorHandler) {\r\n        StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        this.space = xmlspace;\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML anonymous span element\r\n     */\r\n\r\n    function AnonymousSpan() {\r\n        ContentElement.call(this, 'span');\r\n    }\r\n\r\n    AnonymousSpan.prototype.initFromText = function (doc, parent, text, xmllang, xmlspace, errorHandler) {\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, null, errorHandler);\r\n\r\n        this.text = text;\r\n        this.space = xmlspace;\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML br element\r\n     */\r\n\r\n    function Br() {\r\n        ContentElement.call(this, 'br');\r\n    }\r\n\r\n    Br.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\r\n        LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML Region element\r\n     * \r\n     */\r\n\r\n    function Region() {\r\n    }\r\n\r\n    Region.prototype.createDefaultRegion = function (xmllang) {\r\n        var r = new Region();\r\n\r\n        IdentifiedElement.call(r, '');\r\n        StyledElement.call(r, {});\r\n        AnimatedElement.call(r, []);\r\n        TimedElement.call(r, 0, Number.POSITIVE_INFINITY, null);\r\n\r\n        this.lang = xmllang;\r\n\r\n        return r;\r\n    };\r\n\r\n    Region.prototype.initFromNode = function (doc, node, xmllang, errorHandler) {\r\n        IdentifiedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n\r\n        /* add specified styles */\r\n\r\n        this.styleAttrs = elementGetStyles(node, errorHandler);\r\n\r\n        /* remember referential styles for merging after nested styling is processed*/\r\n\r\n        this.styleRefs = elementGetStyleRefs(node);\r\n\r\n        /* xml:lang */\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML Set element\r\n     * \r\n     */\r\n\r\n    function Set() {\r\n    }\r\n\r\n    Set.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        var styles = elementGetStyles(node, errorHandler);\r\n\r\n        this.qname = null;\r\n        this.value = null;\r\n\r\n        for (var qname in styles) {\r\n\r\n            if (! styles.hasOwnProperty(qname)) continue;\r\n\r\n            if (this.qname) {\r\n\r\n                reportError(errorHandler, \"More than one style specified on set\");\r\n                break;\r\n\r\n            }\r\n\r\n            this.qname = qname;\r\n            this.value = styles[qname];\r\n\r\n        }\r\n\r\n    };\r\n\r\n    /*\r\n     * Utility functions\r\n     * \r\n     */\r\n\r\n\r\n    function elementGetXMLID(node) {\r\n        return node && 'xml:id' in node.attributes ? node.attributes['xml:id'].value || null : null;\r\n    }\r\n\r\n    function elementGetRegionID(node) {\r\n        return node && 'region' in node.attributes ? node.attributes.region.value : '';\r\n    }\r\n\r\n    function elementGetTimeContainer(node, errorHandler) {\r\n\r\n        var tc = node && 'timeContainer' in node.attributes ? node.attributes.timeContainer.value : null;\r\n\r\n        if ((!tc) || tc === \"par\") {\r\n\r\n            return \"par\";\r\n\r\n        } else if (tc === \"seq\") {\r\n\r\n            return \"seq\";\r\n\r\n        } else {\r\n\r\n            reportError(errorHandler, \"Illegal value of timeContainer (assuming 'par')\");\r\n\r\n            return \"par\";\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function elementGetStyleRefs(node) {\r\n\r\n        return node && 'style' in node.attributes ? node.attributes.style.value.split(\" \") : [];\r\n\r\n    }\r\n\r\n    function elementGetStyles(node, errorHandler) {\r\n\r\n        var s = {};\r\n\r\n        if (node !== null) {\r\n\r\n            for (var i in node.attributes) {\r\n\r\n                var qname = node.attributes[i].uri + \" \" + node.attributes[i].local;\r\n\r\n                var sa = imscStyles.byQName[qname];\r\n\r\n                if (sa !== undefined) {\r\n\r\n                    var val = sa.parse(node.attributes[i].value);\r\n\r\n                    if (val !== null) {\r\n\r\n                        s[qname] = val;\r\n\r\n                        /* TODO: consider refactoring errorHandler into parse and compute routines */\r\n\r\n                        if (sa === imscStyles.byName.zIndex) {\r\n                            reportWarning(errorHandler, \"zIndex attribute present but not used by IMSC1 since regions do not overlap\");\r\n                        }\r\n\r\n                    } else {\r\n\r\n                        reportError(errorHandler, \"Cannot parse styling attribute \" + qname + \" --> \" + node.attributes[i].value);\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    function findAttribute(node, ns, name) {\r\n        for (var i in node.attributes) {\r\n\r\n            if (node.attributes[i].uri === ns &&\r\n                    node.attributes[i].local === name) {\r\n\r\n                return node.attributes[i].value;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function extractAspectRatio(node, errorHandler) {\r\n\r\n        var ar = findAttribute(node, imscNames.ns_ittp, \"aspectRatio\");\r\n\r\n        if (ar === null) {\r\n            \r\n            ar = findAttribute(node, imscNames.ns_ttp, \"displayAspectRatio\");\r\n            \r\n        }\r\n\r\n        var rslt = null;\r\n\r\n        if (ar !== null) {\r\n\r\n            var ASPECT_RATIO_RE = /(\\d+)\\s+(\\d+)/;\r\n\r\n            var m = ASPECT_RATIO_RE.exec(ar);\r\n\r\n            if (m !== null) {\r\n\r\n                var w = parseInt(m[1]);\r\n\r\n                var h = parseInt(m[2]);\r\n\r\n                if (w !== 0 && h !== 0) {\r\n\r\n                    rslt = w / h;\r\n\r\n                } else {\r\n\r\n                    reportError(errorHandler, \"Illegal aspectRatio values (ignoring)\");\r\n                }\r\n\r\n            } else {\r\n\r\n                reportError(errorHandler, \"Malformed aspectRatio attribute (ignoring)\");\r\n            }\r\n\r\n        }\r\n\r\n        return rslt;\r\n\r\n    }\r\n\r\n    /*\r\n     * Returns the cellResolution attribute from a node\r\n     * \r\n     */\r\n    function extractCellResolution(node, errorHandler) {\r\n\r\n        var cr = findAttribute(node, imscNames.ns_ttp, \"cellResolution\");\r\n\r\n        // initial value\r\n\r\n        var h = 15;\r\n        var w = 32;\r\n\r\n        if (cr !== null) {\r\n\r\n            var CELL_RESOLUTION_RE = /(\\d+) (\\d+)/;\r\n\r\n            var m = CELL_RESOLUTION_RE.exec(cr);\r\n\r\n            if (m !== null) {\r\n\r\n                w = parseInt(m[1]);\r\n\r\n                h = parseInt(m[2]);\r\n\r\n            } else {\r\n\r\n                reportWarning(errorHandler, \"Malformed cellResolution value (using initial value instead)\");\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return {'w': w, 'h': h};\r\n\r\n    }\r\n\r\n\r\n    function extractFrameAndTickRate(node, errorHandler) {\r\n\r\n        // subFrameRate is ignored per IMSC1 specification\r\n\r\n        // extract frame rate\r\n\r\n        var fps_attr = findAttribute(node, imscNames.ns_ttp, \"frameRate\");\r\n\r\n        // initial value\r\n\r\n        var fps = 30;\r\n\r\n        // match variable\r\n\r\n        var m;\r\n\r\n        if (fps_attr !== null) {\r\n\r\n            var FRAME_RATE_RE = /(\\d+)/;\r\n\r\n            m = FRAME_RATE_RE.exec(fps_attr);\r\n\r\n            if (m !== null) {\r\n\r\n                fps = parseInt(m[1]);\r\n\r\n            } else {\r\n\r\n                reportWarning(errorHandler, \"Malformed frame rate attribute (using initial value instead)\");\r\n            }\r\n\r\n        }\r\n\r\n        // extract frame rate multiplier\r\n\r\n        var frm_attr = findAttribute(node, imscNames.ns_ttp, \"frameRateMultiplier\");\r\n\r\n        // initial value\r\n\r\n        var frm = 1;\r\n\r\n        if (frm_attr !== null) {\r\n\r\n            var FRAME_RATE_MULT_RE = /(\\d+) (\\d+)/;\r\n\r\n            m = FRAME_RATE_MULT_RE.exec(frm_attr);\r\n\r\n            if (m !== null) {\r\n\r\n                frm = parseInt(m[1]) / parseInt(m[2]);\r\n\r\n            } else {\r\n\r\n                reportWarning(errorHandler, \"Malformed frame rate multiplier attribute (using initial value instead)\");\r\n            }\r\n\r\n        }\r\n\r\n        var efps = frm * fps;\r\n\r\n        // extract tick rate\r\n\r\n        var tr = 1;\r\n\r\n        var trattr = findAttribute(node, imscNames.ns_ttp, \"tickRate\");\r\n\r\n        if (trattr === null) {\r\n\r\n            if (fps_attr !== null)\r\n                tr = efps;\r\n\r\n        } else {\r\n\r\n            var TICK_RATE_RE = /(\\d+)/;\r\n\r\n            m = TICK_RATE_RE.exec(trattr);\r\n\r\n            if (m !== null) {\r\n\r\n                tr = parseInt(m[1]);\r\n\r\n            } else {\r\n\r\n                reportWarning(errorHandler, \"Malformed tick rate attribute (using initial value instead)\");\r\n            }\r\n\r\n        }\r\n\r\n        return {effectiveFrameRate: efps, tickRate: tr};\r\n\r\n    }\r\n\r\n    function extractExtent(node, errorHandler) {\r\n\r\n        var attr = findAttribute(node, imscNames.ns_tts, \"extent\");\r\n\r\n        if (attr === null)\r\n            return null;\r\n\r\n        var s = attr.split(\" \");\r\n\r\n        if (s.length !== 2) {\r\n\r\n            reportWarning(errorHandler, \"Malformed extent (ignoring)\");\r\n\r\n            return null;\r\n        }\r\n\r\n        var w = imscUtils.parseLength(s[0]);\r\n\r\n        var h = imscUtils.parseLength(s[1]);\r\n\r\n        if (!h || !w) {\r\n\r\n            reportWarning(errorHandler, \"Malformed extent values (ignoring)\");\r\n\r\n            return null;\r\n        }\r\n\r\n        return {'h': h, 'w': w};\r\n\r\n    }\r\n\r\n    function parseTimeExpression(tickRate, effectiveFrameRate, str) {\r\n\r\n        var CLOCK_TIME_FRACTION_RE = /^(\\d{2,}):(\\d\\d):(\\d\\d(?:\\.\\d+)?)$/;\r\n        var CLOCK_TIME_FRAMES_RE = /^(\\d{2,}):(\\d\\d):(\\d\\d)\\:(\\d{2,})$/;\r\n        var OFFSET_FRAME_RE = /^(\\d+(?:\\.\\d+)?)f$/;\r\n        var OFFSET_TICK_RE = /^(\\d+(?:\\.\\d+)?)t$/;\r\n        var OFFSET_MS_RE = /^(\\d+(?:\\.\\d+)?)ms$/;\r\n        var OFFSET_S_RE = /^(\\d+(?:\\.\\d+)?)s$/;\r\n        var OFFSET_H_RE = /^(\\d+(?:\\.\\d+)?)h$/;\r\n        var OFFSET_M_RE = /^(\\d+(?:\\.\\d+)?)m$/;\r\n        var m;\r\n        var r = null;\r\n        if ((m = OFFSET_FRAME_RE.exec(str)) !== null) {\r\n\r\n            if (effectiveFrameRate !== null) {\r\n\r\n                r = parseFloat(m[1]) / effectiveFrameRate;\r\n            }\r\n\r\n        } else if ((m = OFFSET_TICK_RE.exec(str)) !== null) {\r\n\r\n            if (tickRate !== null) {\r\n\r\n                r = parseFloat(m[1]) / tickRate;\r\n            }\r\n\r\n        } else if ((m = OFFSET_MS_RE.exec(str)) !== null) {\r\n\r\n            r = parseFloat(m[1]) / 1000.0;\r\n\r\n        } else if ((m = OFFSET_S_RE.exec(str)) !== null) {\r\n\r\n            r = parseFloat(m[1]);\r\n\r\n        } else if ((m = OFFSET_H_RE.exec(str)) !== null) {\r\n\r\n            r = parseFloat(m[1]) * 3600.0;\r\n\r\n        } else if ((m = OFFSET_M_RE.exec(str)) !== null) {\r\n\r\n            r = parseFloat(m[1]) * 60.0;\r\n\r\n        } else if ((m = CLOCK_TIME_FRACTION_RE.exec(str)) !== null) {\r\n\r\n            r = parseInt(m[1]) * 3600 +\r\n                    parseInt(m[2]) * 60 +\r\n                    parseFloat(m[3]);\r\n\r\n        } else if ((m = CLOCK_TIME_FRAMES_RE.exec(str)) !== null) {\r\n\r\n            /* this assumes that HH:MM:SS is a clock-time-with-fraction */\r\n\r\n            if (effectiveFrameRate !== null) {\r\n\r\n                r = parseInt(m[1]) * 3600 +\r\n                        parseInt(m[2]) * 60 +\r\n                        parseInt(m[3]) +\r\n                        (m[4] === null ? 0 : parseInt(m[4]) / effectiveFrameRate);\r\n            }\r\n\r\n        }\r\n\r\n        return r;\r\n    }\r\n\r\n    function processTiming(doc, parent, node, errorHandler) {\r\n\r\n        /* determine explicit begin */\r\n\r\n        var explicit_begin = null;\r\n\r\n        if (node && 'begin' in node.attributes) {\r\n\r\n            explicit_begin = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.begin.value);\r\n\r\n            if (explicit_begin === null) {\r\n\r\n                reportWarning(errorHandler, \"Malformed begin value \" + node.attributes.begin.value + \" (using 0)\");\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* determine explicit duration */\r\n\r\n        var explicit_dur = null;\r\n\r\n        if (node && 'dur' in node.attributes) {\r\n\r\n            explicit_dur = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.dur.value);\r\n\r\n            if (explicit_dur === null) {\r\n\r\n                reportWarning(errorHandler, \"Malformed dur value \" + node.attributes.dur.value + \" (ignoring)\");\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* determine explicit end */\r\n\r\n        var explicit_end = null;\r\n\r\n        if (node && 'end' in node.attributes) {\r\n\r\n            explicit_end = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.end.value);\r\n\r\n            if (explicit_end === null) {\r\n\r\n                reportWarning(errorHandler, \"Malformed end value (ignoring)\");\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return {explicit_begin: explicit_begin,\r\n            explicit_end: explicit_end,\r\n            explicit_dur: explicit_dur};\r\n\r\n    }\r\n\r\n\r\n\r\n    function mergeChainedStyles(styling, style, errorHandler) {\r\n\r\n        while (style.styleRefs.length > 0) {\r\n\r\n            var sref = style.styleRefs.pop();\r\n\r\n            if (!(sref in styling.styles)) {\r\n                reportError(errorHandler, \"Non-existant style id referenced\");\r\n                continue;\r\n            }\r\n\r\n            mergeChainedStyles(styling, styling.styles[sref], errorHandler);\r\n\r\n            mergeStylesIfNotPresent(styling.styles[sref].styleAttrs, style.styleAttrs);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function mergeReferencedStyles(styling, stylerefs, styleattrs, errorHandler) {\r\n\r\n        for (var i = stylerefs.length - 1; i >= 0; i--) {\r\n\r\n            var sref = stylerefs[i];\r\n\r\n            if (!(sref in styling.styles)) {\r\n                reportError(errorHandler, \"Non-existant style id referenced\");\r\n                continue;\r\n            }\r\n\r\n            mergeStylesIfNotPresent(styling.styles[sref].styleAttrs, styleattrs);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function mergeStylesIfNotPresent(from_styles, into_styles) {\r\n\r\n        for (var sname in from_styles) {\r\n\r\n            if (! from_styles.hasOwnProperty(sname)) continue;\r\n\r\n            if (sname in into_styles)\r\n                continue;\r\n\r\n            into_styles[sname] = from_styles[sname];\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /* TODO: validate style format at parsing */\r\n\r\n\r\n    /*\r\n     * ERROR HANDLING UTILITY FUNCTIONS\r\n     * \r\n     */\r\n\r\n    function reportInfo(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.info && errorHandler.info(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportWarning(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.warn && errorHandler.warn(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportError(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.error && errorHandler.error(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportFatal(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.fatal)\r\n            errorHandler.fatal(msg);\r\n\r\n        throw msg;\r\n\r\n    }\r\n\r\n    /*\r\n     * Binary search utility function\r\n     * \r\n     * @typedef {Object} BinarySearchResult\r\n     * @property {boolean} found Was an exact match found?\r\n     * @property {number} index Position of the exact match or insert position\r\n     * \r\n     * @returns {BinarySearchResult}\r\n     */\r\n\r\n    function indexOf(arr, searchval) {\r\n\r\n        var min = 0;\r\n        var max = arr.length - 1;\r\n        var cur;\r\n\r\n        while (min <= max) {\r\n\r\n            cur = Math.floor((min + max) / 2);\r\n\r\n            var curval = arr[cur];\r\n\r\n            if (curval < searchval) {\r\n\r\n                min = cur + 1;\r\n\r\n            } else if (curval > searchval) {\r\n\r\n                max = cur - 1;\r\n\r\n            } else {\r\n\r\n                return {found: true, index: cur};\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return {found: false, index: min};\r\n    }\r\n\r\n\r\n})(typeof exports === 'undefined' ? this.imscDoc = {} : exports,\r\n        typeof sax === 'undefined' ? require(\"sax\") : sax,\r\n        typeof imscNames === 'undefined' ? require(\"./names\") : imscNames,\r\n        typeof imscStyles === 'undefined' ? require(\"./styles\") : imscStyles,\r\n        typeof imscUtils === 'undefined' ? require(\"./utils\") : imscUtils);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}