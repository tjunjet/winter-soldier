{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar GAP_HANDLER_INTERVAL = 100;\nvar THRESHOLD_TO_STALLS = 30;\nvar GAP_THRESHOLD = 0.1;\n\nfunction GapController() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      lastPlaybackTime = void 0,\n      settings = void 0,\n      wallclockTicked = void 0,\n      gapHandlerInterval = void 0,\n      lastGapJumpPosition = void 0,\n      playbackController = void 0,\n      streamController = void 0,\n      videoModel = void 0,\n      timelineConverter = void 0,\n      adapter = void 0,\n      jumpTimeoutHandler = void 0,\n      logger = void 0;\n\n  function initialize() {\n    registerEvents();\n  }\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    reset();\n  }\n\n  function reset() {\n    stopGapHandler();\n    unregisterEvents();\n    resetInitialSettings();\n  }\n\n  function resetInitialSettings() {\n    gapHandlerInterval = null;\n    lastGapJumpPosition = NaN;\n    wallclockTicked = 0;\n    jumpTimeoutHandler = null;\n  }\n\n  function setConfig(config) {\n    if (!config) {\n      return;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n\n    if (config.playbackController) {\n      playbackController = config.playbackController;\n    }\n\n    if (config.streamController) {\n      streamController = config.streamController;\n    }\n\n    if (config.videoModel) {\n      videoModel = config.videoModel;\n    }\n\n    if (config.timelineConverter) {\n      timelineConverter = config.timelineConverter;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n  }\n\n  function registerEvents() {\n    eventBus.on(_Events2.default.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\n    eventBus.on(_Events2.default.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\n    eventBus.on(_Events2.default.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\n  }\n\n  function unregisterEvents() {\n    eventBus.off(_Events2.default.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\n    eventBus.off(_Events2.default.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\n    eventBus.off(_Events2.default.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\n  }\n\n  function onBytesAppended() {\n    if (!gapHandlerInterval) {\n      startGapHandler();\n    }\n  }\n\n  function _onPlaybackSeeking() {\n    if (jumpTimeoutHandler) {\n      clearTimeout(jumpTimeoutHandler);\n      jumpTimeoutHandler = null;\n    }\n  }\n\n  function _onWallclockTimeUpdated()\n  /*e*/\n  {\n    if (!_shouldCheckForGaps()) {\n      return;\n    }\n\n    wallclockTicked++;\n\n    if (wallclockTicked >= THRESHOLD_TO_STALLS) {\n      var currentTime = playbackController.getTime();\n\n      if (lastPlaybackTime === currentTime) {\n        jumpGap(currentTime, true);\n      } else {\n        lastPlaybackTime = currentTime;\n        lastGapJumpPosition = NaN;\n      }\n\n      wallclockTicked = 0;\n    }\n  }\n\n  function _shouldCheckForGaps() {\n    return settings.get().streaming.jumpGaps && streamController.getActiveStreamProcessors().length > 0 && (!playbackController.isSeeking() || streamController.hasStreamFinishedBuffering(streamController.getActiveStream())) && !playbackController.isPaused() && !streamController.getIsStreamSwitchInProgress() && !streamController.getHasMediaOrIntialisationError();\n  }\n\n  function getNextRangeIndex(ranges, currentTime) {\n    try {\n      if (!ranges || ranges.length <= 1 && currentTime > 0) {\n        return NaN;\n      }\n\n      var nextRangeIndex = NaN;\n      var j = 0;\n\n      while (isNaN(nextRangeIndex) && j < ranges.length) {\n        var rangeEnd = j > 0 ? ranges.end(j - 1) : 0;\n\n        if (currentTime < ranges.start(j) && rangeEnd - currentTime < GAP_THRESHOLD) {\n          nextRangeIndex = j;\n        }\n\n        j += 1;\n      }\n\n      return nextRangeIndex;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function startGapHandler() {\n    try {\n      if (!gapHandlerInterval) {\n        logger.debug('Starting the gap controller');\n        gapHandlerInterval = setInterval(function () {\n          if (!_shouldCheckForGaps()) {\n            return;\n          }\n\n          var currentTime = playbackController.getTime();\n          jumpGap(currentTime);\n        }, GAP_HANDLER_INTERVAL);\n      }\n    } catch (e) {}\n  }\n\n  function stopGapHandler() {\n    logger.debug('Stopping the gap controller');\n\n    if (gapHandlerInterval) {\n      clearInterval(gapHandlerInterval);\n      gapHandlerInterval = null;\n    }\n  }\n\n  function jumpGap(currentTime) {\n    var playbackStalled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var smallGapLimit = settings.get().streaming.smallGapLimit;\n    var jumpLargeGaps = settings.get().streaming.jumpLargeGaps;\n    var ranges = videoModel.getBufferRange();\n    var nextRangeIndex = void 0;\n    var seekToPosition = NaN;\n    var jumpToStreamEnd = false; // Get the range just after current time position\n\n    nextRangeIndex = getNextRangeIndex(ranges, currentTime);\n\n    if (!isNaN(nextRangeIndex)) {\n      var start = ranges.start(nextRangeIndex);\n      var gap = start - currentTime;\n\n      if (gap > 0 && (gap <= smallGapLimit || jumpLargeGaps)) {\n        seekToPosition = start;\n      }\n    } // Playback has stalled before period end. We seek to the end of the period\n\n\n    var timeToStreamEnd = playbackController.getTimeToStreamEnd();\n\n    if (isNaN(seekToPosition) && playbackStalled && isFinite(timeToStreamEnd) && !isNaN(timeToStreamEnd) && timeToStreamEnd < smallGapLimit) {\n      seekToPosition = parseFloat(playbackController.getStreamEndTime().toFixed(5));\n      jumpToStreamEnd = true;\n    }\n\n    if (seekToPosition > 0 && lastGapJumpPosition !== seekToPosition && seekToPosition > currentTime && !jumpTimeoutHandler) {\n      var timeUntilGapEnd = seekToPosition - currentTime;\n\n      if (jumpToStreamEnd) {\n        logger.warn('Jumping to end of stream because of gap from ' + currentTime + ' to ' + seekToPosition + '. Gap duration: ' + timeUntilGapEnd);\n        eventBus.trigger(_Events2.default.GAP_CAUSED_SEEK_TO_PERIOD_END, {\n          seekTime: seekToPosition,\n          duration: timeUntilGapEnd\n        });\n      } else {\n        var isDynamic = playbackController.getIsDynamic();\n\n        var _start = nextRangeIndex > 0 ? ranges.end(nextRangeIndex - 1) : currentTime;\n\n        var timeToWait = !isDynamic ? 0 : timeUntilGapEnd * 1000;\n        jumpTimeoutHandler = window.setTimeout(function () {\n          playbackController.seek(seekToPosition, true, true);\n          logger.warn('Jumping gap starting at ' + _start + ' and ending at ' + seekToPosition + '. Jumping by: ' + timeUntilGapEnd);\n          eventBus.trigger(_Events2.default.GAP_CAUSED_INTERNAL_SEEK, {\n            seekTime: seekToPosition,\n            duration: timeUntilGapEnd\n          });\n          jumpTimeoutHandler = null;\n        }, timeToWait);\n      }\n\n      lastGapJumpPosition = seekToPosition;\n    }\n  }\n\n  instance = {\n    reset: reset,\n    setConfig: setConfig,\n    initialize: initialize\n  };\n  setup();\n  return instance;\n}\n\nGapController.__dashjs_factory_name = 'GapController';\nexports.default = _FactoryMaker2.default.getSingletonFactory(GapController);","map":{"version":3,"mappings":";;;;;;AA8BA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AAjCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,IAAMA,uBAAuB,GAA7B;AACA,IAAMC,sBAAsB,EAA5B;AACA,IAAMC,gBAAgB,GAAtB;;AAEA,SAASC,aAAT,GAAyB;EACrB,IAAMC,UAAU,KAAKA,OAArB;EACA,IAAMC,WAAW,wBAASD,OAAT,EAAkBE,WAAlB,EAAjB;EAEA,IAAIC,iBAAJ;EAAA,IACIC,yBADJ;EAAA,IAEIC,iBAFJ;EAAA,IAGIC,wBAHJ;EAAA,IAIIC,2BAJJ;EAAA,IAKIC,4BALJ;EAAA,IAMIC,2BANJ;EAAA,IAOIC,yBAPJ;EAAA,IAQIC,mBARJ;EAAA,IASIC,0BATJ;EAAA,IAUIC,gBAVJ;EAAA,IAWIC,2BAXJ;EAAA,IAYIC,eAZJ;;EAcA,SAASC,UAAT,GAAsB;IAClBC;EAGJ;;EAAA,SAASC,KAAT,GAAiB;IACbH,SAAS,qBAAMf,OAAN,EAAeE,WAAf,GAA6BiB,SAA7B,CAAuChB,QAAvC,CAATY;IAEAK;EAGJ;;EAAA,SAASA,KAAT,GAAiB;IACbC;IACAC;IACAC;EAGJ;;EAAA,SAASA,oBAAT,GAAgC;IAC5BhB,qBAAqB,IAArBA;IACAC,sBAAsBgB,GAAtBhB;IACAF,kBAAkB,CAAlBA;IACAQ,qBAAqB,IAArBA;EAGJ;;EAAA,SAASW,SAAT,CAAmBC,MAAnB,EAA2B;IACvB,IAAI,CAACA,MAAL,EAAa;MACT;IAEJ;;IAAA,IAAIA,OAAOrB,QAAX,EAAqB;MACjBA,WAAWqB,OAAOrB,QAAlBA;IAEJ;;IAAA,IAAIqB,OAAOjB,kBAAX,EAA+B;MAC3BA,qBAAqBiB,OAAOjB,kBAA5BA;IAEJ;;IAAA,IAAIiB,OAAOhB,gBAAX,EAA6B;MACzBA,mBAAmBgB,OAAOhB,gBAA1BA;IAEJ;;IAAA,IAAIgB,OAAOf,UAAX,EAAuB;MACnBA,aAAae,OAAOf,UAApBA;IAEJ;;IAAA,IAAIe,OAAOd,iBAAX,EAA8B;MAC1BA,oBAAoBc,OAAOd,iBAA3BA;IAEJ;;IAAA,IAAIc,OAAOb,OAAX,EAAoB;MAChBA,UAAUa,OAAOb,OAAjBA;IAEP;EAED;;EAAA,SAASI,cAAT,GAA0B;IACtBhB,SAAS0B,EAAT1B,CAAY2B,iBAAOC,sBAAnB5B,EAA2C6B,uBAA3C7B,EAAoE,IAApEA;IACAA,SAAS0B,EAAT1B,CAAY2B,iBAAOG,gBAAnB9B,EAAqC+B,kBAArC/B,EAAyD,IAAzDA;IACAA,SAAS0B,EAAT1B,CAAY2B,iBAAOK,2BAAnBhC,EAAgDiC,eAAhDjC,EAAiEE,QAAjEF;EAGJ;;EAAA,SAASqB,gBAAT,GAA4B;IACxBrB,SAASkC,GAATlC,CAAa2B,iBAAOC,sBAApB5B,EAA4C6B,uBAA5C7B,EAAqE,IAArEA;IACAA,SAASkC,GAATlC,CAAa2B,iBAAOG,gBAApB9B,EAAsC+B,kBAAtC/B,EAA0D,IAA1DA;IACAA,SAASkC,GAATlC,CAAa2B,iBAAOK,2BAApBhC,EAAiDiC,eAAjDjC,EAAkEE,QAAlEF;EAGJ;;EAAA,SAASiC,eAAT,GAA2B;IACvB,IAAI,CAAC3B,kBAAL,EAAyB;MACrB6B;IAEP;EAED;;EAAA,SAASJ,kBAAT,GAA8B;IAC1B,IAAIlB,kBAAJ,EAAwB;MACpBuB,aAAavB,kBAAbuB;MACAvB,qBAAqB,IAArBA;IAEP;EAED;;EAAA,SAASgB,uBAAT;EAAiC;EAAO;IACpC,IAAI,CAACQ,qBAAL,EAA4B;MACxB;IAGJhC;;IAAAA;;IACA,IAAIA,mBAAmBT,mBAAvB,EAA4C;MACxC,IAAM0C,cAAc9B,mBAAmB+B,OAAnB/B,EAApB;;MACA,IAAIL,qBAAqBmC,WAAzB,EAAsC;QAClCE,QAAQF,WAARE,EAAqB,IAArBA;MADJ,OAEO;QACHrC,mBAAmBmC,WAAnBnC;QACAI,sBAAsBgB,GAAtBhB;MAEJF;;MAAAA,kBAAkB,CAAlBA;IAEP;EAED;;EAAA,SAASgC,mBAAT,GAA+B;IAC3B,OAAOjC,SAASqC,GAATrC,GAAesC,SAAftC,CAAyBuC,QAAzBvC,IAAqCK,iBAAiBmC,yBAAjBnC,GAA6CoC,MAA7CpC,GAAsD,CAA3FL,KACF,CAACI,mBAAmBsC,SAAnBtC,EAAD,IAAmCC,iBAAiBsC,0BAAjBtC,CAA4CA,iBAAiBuC,eAAjBvC,EAA5CA,CADjCL,KACqH,CAACI,mBAAmByC,QAAnBzC,EADtHJ,IACuJ,CAACK,iBAAiByC,2BAAjBzC,EADxJL,IAEH,CAACK,iBAAiB0C,+BAAjB1C,EAFL;EAKJ;;EAAA,SAAS2C,iBAAT,CAA2BC,MAA3B,EAAmCf,WAAnC,EAAgD;IAC5C,IAAI;MAEA,IAAI,CAACe,MAAD,IAAYA,OAAOR,MAAPQ,IAAiB,CAAjBA,IAAsBf,cAAc,CAApD,EAAwD;QACpD,OAAOf,GAAP;MAEJ;;MAAA,IAAI+B,iBAAiB/B,GAArB;MACA,IAAIgC,IAAI,CAAR;;MAEA,OAAOC,MAAMF,cAANE,KAAyBD,IAAIF,OAAOR,MAA3C,EAAmD;QAC/C,IAAMY,WAAWF,IAAI,CAAJA,GAAQF,OAAOK,GAAPL,CAAWE,IAAI,CAAfF,CAARE,GAA4B,CAA7C;;QACA,IAAIjB,cAAce,OAAOM,KAAPN,CAAaE,CAAbF,CAAdf,IAAiCmB,WAAWnB,WAAXmB,GAAyB5D,aAA9D,EAA6E;UACzEyD,iBAAiBC,CAAjBD;QAEJC;;QAAAA,KAAK,CAALA;MAEJ;;MAAA,OAAOD,cAAP;IAEF,CAjBF,CAiBE,OAAOM,CAAP,EAAU;MACR,OAAO,IAAP;IAEP;EAGD;;EAAA,SAASzB,eAAT,GAA2B;IACvB,IAAI;MACA,IAAI,CAAC7B,kBAAL,EAAyB;QACrBQ,OAAO+C,KAAP/C,CAAa,6BAAbA;QACAR,qBAAqBwD,YAAY,YAAM;UACnC,IAAI,CAACzB,qBAAL,EAA4B;YACxB;UAEJ;;UAAA,IAAMC,cAAc9B,mBAAmB+B,OAAnB/B,EAApB;UACAgC,QAAQF,WAARE;QALiB,GAOlB7C,oBAPkBmE,CAArBxD;MASP;IAAC,CAZF,CAYE,OAAOsD,CAAP,EAAU,CAEf;EAED;;EAAA,SAASxC,cAAT,GAA0B;IACtBN,OAAO+C,KAAP/C,CAAa,6BAAbA;;IACA,IAAIR,kBAAJ,EAAwB;MACpByD,cAAczD,kBAAdyD;MACAzD,qBAAqB,IAArBA;IAEP;EAED;;EAAA,SAASkC,OAAT,CAAiBF,WAAjB,EAAuD;IAAA,IAAzB0B,eAAyB,uEAAP,KAAO;IACnD,IAAMC,gBAAgB7D,SAASqC,GAATrC,GAAesC,SAAftC,CAAyB6D,aAA/C;IACA,IAAMC,gBAAgB9D,SAASqC,GAATrC,GAAesC,SAAftC,CAAyB8D,aAA/C;IACA,IAAMb,SAAS3C,WAAWyD,cAAXzD,EAAf;IACA,IAAI4C,uBAAJ;IACA,IAAIc,iBAAiB7C,GAArB;IACA,IAAI8C,kBAAkB,KAAtB,CANmD,CASnD;;IACAf,iBAAiBF,kBAAkBC,MAAlBD,EAA0Bd,WAA1Bc,CAAjBE;;IAEA,IAAI,CAACE,MAAMF,cAANE,CAAL,EAA4B;MACxB,IAAMG,QAAQN,OAAOM,KAAPN,CAAaC,cAAbD,CAAd;MACA,IAAMiB,MAAMX,QAAQrB,WAApB;;MACA,IAAIgC,MAAM,CAANA,KAAYA,OAAOL,aAAPK,IAAwBJ,aAApCI,CAAJ,EAAwD;QACpDF,iBAAiBT,KAAjBS;MAEP;IAED,CApBmD,CAoBnD;;;IACA,IAAMG,kBAAkB/D,mBAAmBgE,kBAAnBhE,EAAxB;;IACA,IAAIgD,MAAMY,cAANZ,KAAyBQ,eAAzBR,IAA4CiB,SAASF,eAATE,CAA5CjB,IAAyE,CAACA,MAAMe,eAANf,CAA1EA,IAAoGe,kBAAkBN,aAA1H,EAAyI;MACrIG,iBAAiBM,WAAWlE,mBAAmBmE,gBAAnBnE,GAAsCoE,OAAtCpE,CAA8C,CAA9CA,CAAXkE,CAAjBN;MACAC,kBAAkB,IAAlBA;IAGJ;;IAAA,IAAID,iBAAiB,CAAjBA,IAAsB7D,wBAAwB6D,cAA9CA,IAAgEA,iBAAiB9B,WAAjF8B,IAAgG,CAACvD,kBAArG,EAAyH;MACrH,IAAMgE,kBAAkBT,iBAAiB9B,WAAzC;;MAEA,IAAI+B,eAAJ,EAAqB;QACjBvD,OAAOgE,IAAPhE,mDAA4DwB,WAA5D,YAA8E8B,cAA9E,wBAA+GS,eAA/G/D;QACAd,SAAS+E,OAAT/E,CAAiB2B,iBAAOqD,6BAAxBhF,EAAuD;UACnDiF,UAAUb,cADyC;UAEnDc,UAAUL;QAFyC,CAAvD7E;MAFJ,OAMO;QACH,IAAMmF,YAAY3E,mBAAmB4E,YAAnB5E,EAAlB;;QACA,IAAMmD,SAAQL,iBAAiB,CAAjBA,GAAqBD,OAAOK,GAAPL,CAAWC,iBAAiB,CAA5BD,CAArBC,GAAsDhB,WAApE;;QACA,IAAM+C,aAAa,CAACF,SAAD,GAAa,CAAb,GAAiBN,kBAAkB,IAAtD;QAEAhE,qBAAqByE,OAAOC,UAAPD,CAAkB,YAAM;UACzC9E,mBAAmBgF,IAAnBhF,CAAwB4D,cAAxB5D,EAAwC,IAAxCA,EAA8C,IAA9CA;UACAM,OAAOgE,IAAPhE,8BAAuC6C,MAAvC,uBAA8DS,cAA9D,sBAA6FS,eAA7F/D;UACAd,SAAS+E,OAAT/E,CAAiB2B,iBAAO8D,wBAAxBzF,EAAkD;YAC9CiF,UAAUb,cADoC;YAE9Cc,UAAUL;UAFoC,CAAlD7E;UAIAa,qBAAqB,IAArBA;QAPiB,GAQlBwE,UARkBC,CAArBzE;MAUJN;;MAAAA,sBAAsB6D,cAAtB7D;IAEP;EAEDL;;EAAAA,WAAW;IACPiB,YADO;IAEPK,oBAFO;IAGPT;EAHO,CAAXb;EAMAe;EAEA,OAAOf,QAAP;AAGJJ;;AAAAA,cAAc4F,qBAAd5F,GAAsC,eAAtCA;kBACe6F,uBAAaC,mBAAbD,CAAiC7F,aAAjC6F,C","names":["GAP_HANDLER_INTERVAL","THRESHOLD_TO_STALLS","GAP_THRESHOLD","GapController","context","eventBus","getInstance","instance","lastPlaybackTime","settings","wallclockTicked","gapHandlerInterval","lastGapJumpPosition","playbackController","streamController","videoModel","timelineConverter","adapter","jumpTimeoutHandler","logger","initialize","registerEvents","setup","getLogger","reset","stopGapHandler","unregisterEvents","resetInitialSettings","NaN","setConfig","config","on","Events","WALLCLOCK_TIME_UPDATED","_onWallclockTimeUpdated","PLAYBACK_SEEKING","_onPlaybackSeeking","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","off","startGapHandler","clearTimeout","_shouldCheckForGaps","currentTime","getTime","jumpGap","get","streaming","jumpGaps","getActiveStreamProcessors","length","isSeeking","hasStreamFinishedBuffering","getActiveStream","isPaused","getIsStreamSwitchInProgress","getHasMediaOrIntialisationError","getNextRangeIndex","ranges","nextRangeIndex","j","isNaN","rangeEnd","end","start","e","debug","setInterval","clearInterval","playbackStalled","smallGapLimit","jumpLargeGaps","getBufferRange","seekToPosition","jumpToStreamEnd","gap","timeToStreamEnd","getTimeToStreamEnd","isFinite","parseFloat","getStreamEndTime","toFixed","timeUntilGapEnd","warn","trigger","GAP_CAUSED_SEEK_TO_PERIOD_END","seekTime","duration","isDynamic","getIsDynamic","timeToWait","window","setTimeout","seek","GAP_CAUSED_INTERNAL_SEEK","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/controllers/GapController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport Events from '../../core/events/Events';\nimport EventBus from '../../core/EventBus';\n\nconst GAP_HANDLER_INTERVAL = 100;\nconst THRESHOLD_TO_STALLS = 30;\nconst GAP_THRESHOLD = 0.1;\n\nfunction GapController() {\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        lastPlaybackTime,\n        settings,\n        wallclockTicked,\n        gapHandlerInterval,\n        lastGapJumpPosition,\n        playbackController,\n        streamController,\n        videoModel,\n        timelineConverter,\n        adapter,\n        jumpTimeoutHandler,\n        logger;\n\n    function initialize() {\n        registerEvents();\n    }\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        reset();\n    }\n\n    function reset() {\n        stopGapHandler();\n        unregisterEvents();\n        resetInitialSettings();\n    }\n\n    function resetInitialSettings() {\n        gapHandlerInterval = null;\n        lastGapJumpPosition = NaN;\n        wallclockTicked = 0;\n        jumpTimeoutHandler = null;\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n        if (config.playbackController) {\n            playbackController = config.playbackController;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.timelineConverter) {\n            timelineConverter = config.timelineConverter;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n    }\n\n    function registerEvents() {\n        eventBus.on(Events.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\n        eventBus.on(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\n    }\n\n    function unregisterEvents() {\n        eventBus.off(Events.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\n        eventBus.off(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\n    }\n\n    function onBytesAppended() {\n        if (!gapHandlerInterval) {\n            startGapHandler();\n        }\n    }\n\n    function _onPlaybackSeeking() {\n        if (jumpTimeoutHandler) {\n            clearTimeout(jumpTimeoutHandler);\n            jumpTimeoutHandler = null;\n        }\n    }\n\n    function _onWallclockTimeUpdated(/*e*/) {\n        if (!_shouldCheckForGaps()) {\n            return;\n        }\n\n        wallclockTicked++;\n        if (wallclockTicked >= THRESHOLD_TO_STALLS) {\n            const currentTime = playbackController.getTime();\n            if (lastPlaybackTime === currentTime) {\n                jumpGap(currentTime, true);\n            } else {\n                lastPlaybackTime = currentTime;\n                lastGapJumpPosition = NaN;\n            }\n            wallclockTicked = 0;\n        }\n    }\n\n    function _shouldCheckForGaps() {\n        return settings.get().streaming.jumpGaps && streamController.getActiveStreamProcessors().length > 0 &&\n            (!playbackController.isSeeking() || streamController.hasStreamFinishedBuffering(streamController.getActiveStream())) && !playbackController.isPaused() && !streamController.getIsStreamSwitchInProgress() &&\n            !streamController.getHasMediaOrIntialisationError();\n    }\n\n    function getNextRangeIndex(ranges, currentTime) {\n        try {\n\n            if (!ranges || (ranges.length <= 1 && currentTime > 0)) {\n                return NaN;\n            }\n            let nextRangeIndex = NaN;\n            let j = 0;\n\n            while (isNaN(nextRangeIndex) && j < ranges.length) {\n                const rangeEnd = j > 0 ? ranges.end(j - 1) : 0;\n                if (currentTime < ranges.start(j) && rangeEnd - currentTime < GAP_THRESHOLD) {\n                    nextRangeIndex = j;\n                }\n                j += 1;\n            }\n            return nextRangeIndex;\n\n        } catch (e) {\n            return null;\n        }\n    }\n\n\n    function startGapHandler() {\n        try {\n            if (!gapHandlerInterval) {\n                logger.debug('Starting the gap controller');\n                gapHandlerInterval = setInterval(() => {\n                    if (!_shouldCheckForGaps()) {\n                        return;\n                    }\n                    const currentTime = playbackController.getTime();\n                    jumpGap(currentTime);\n\n                }, GAP_HANDLER_INTERVAL);\n            }\n        } catch (e) {\n        }\n    }\n\n    function stopGapHandler() {\n        logger.debug('Stopping the gap controller');\n        if (gapHandlerInterval) {\n            clearInterval(gapHandlerInterval);\n            gapHandlerInterval = null;\n        }\n    }\n\n    function jumpGap(currentTime, playbackStalled = false) {\n        const smallGapLimit = settings.get().streaming.smallGapLimit;\n        const jumpLargeGaps = settings.get().streaming.jumpLargeGaps;\n        const ranges = videoModel.getBufferRange();\n        let nextRangeIndex;\n        let seekToPosition = NaN;\n        let jumpToStreamEnd = false;\n\n\n        // Get the range just after current time position\n        nextRangeIndex = getNextRangeIndex(ranges, currentTime);\n\n        if (!isNaN(nextRangeIndex)) {\n            const start = ranges.start(nextRangeIndex);\n            const gap = start - currentTime;\n            if (gap > 0 && (gap <= smallGapLimit || jumpLargeGaps)) {\n                seekToPosition = start;\n            }\n        }\n\n        // Playback has stalled before period end. We seek to the end of the period\n        const timeToStreamEnd = playbackController.getTimeToStreamEnd();\n        if (isNaN(seekToPosition) && playbackStalled && isFinite(timeToStreamEnd) && !isNaN(timeToStreamEnd) && timeToStreamEnd < smallGapLimit) {\n            seekToPosition = parseFloat(playbackController.getStreamEndTime().toFixed(5));\n            jumpToStreamEnd = true;\n        }\n\n        if (seekToPosition > 0 && lastGapJumpPosition !== seekToPosition && seekToPosition > currentTime && !jumpTimeoutHandler) {\n            const timeUntilGapEnd = seekToPosition - currentTime;\n\n            if (jumpToStreamEnd) {\n                logger.warn(`Jumping to end of stream because of gap from ${currentTime} to ${seekToPosition}. Gap duration: ${timeUntilGapEnd}`);\n                eventBus.trigger(Events.GAP_CAUSED_SEEK_TO_PERIOD_END, {\n                    seekTime: seekToPosition,\n                    duration: timeUntilGapEnd\n                });\n            } else {\n                const isDynamic = playbackController.getIsDynamic();\n                const start = nextRangeIndex > 0 ? ranges.end(nextRangeIndex - 1) : currentTime;\n                const timeToWait = !isDynamic ? 0 : timeUntilGapEnd * 1000;\n\n                jumpTimeoutHandler = window.setTimeout(() => {\n                    playbackController.seek(seekToPosition, true, true);\n                    logger.warn(`Jumping gap starting at ${start} and ending at ${seekToPosition}. Jumping by: ${timeUntilGapEnd}`);\n                    eventBus.trigger(Events.GAP_CAUSED_INTERNAL_SEEK, {\n                        seekTime: seekToPosition,\n                        duration: timeUntilGapEnd\n                    });\n                    jumpTimeoutHandler = null;\n                }, timeToWait);\n            }\n            lastGapJumpPosition = seekToPosition;\n        }\n    }\n\n    instance = {\n        reset,\n        setConfig,\n        initialize\n    };\n\n    setup();\n\n    return instance;\n}\n\nGapController.__dashjs_factory_name = 'GapController';\nexport default FactoryMaker.getSingletonFactory(GapController);\n"]},"metadata":{},"sourceType":"script"}