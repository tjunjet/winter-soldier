{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* @class\n* @ignore\n*/\n\n\nvar SimpleXPath = function () {\n  function SimpleXPath(selector) {\n    var _this = this;\n\n    _classCallCheck(this, SimpleXPath); // establish validation of the path, to catch unsupported cases\n\n\n    this.valid = selector[0] == '/'; // first check, we only support absolute addressing\n    // establish parsed path, example:\n    // /MPD/Period[@id=\"foobar\"]/AdaptationSet[@id=\"2\"]/SegmentTemplate/SegmentTimeline\n\n    this.path = selector.split('/').filter(function (component) {\n      return component.length !== 0;\n    }) // remove excess empty components\n    .map(function (component) {\n      var parsed = {\n        name: component\n      };\n      var qualifierPoint = component.indexOf('[');\n\n      if (qualifierPoint != -1) {\n        parsed.name = component.substring(0, qualifierPoint);\n        var qualifier = component.substring(qualifierPoint + 1, component.length - 1); // quick sanity check are there additional qualifiers making this invalid\n\n        _this.valid = _this.valid && qualifier.indexOf('[') == -1;\n        var equalityPoint = qualifier.indexOf('=');\n\n        if (equalityPoint != -1) {\n          parsed.attribute = {\n            name: qualifier.substring(1, equalityPoint),\n            // skip the @\n            value: qualifier.substring(equalityPoint + 1)\n          }; // check for single and double quoted attribute values\n\n          if (['\\'', '\"'].indexOf(parsed.attribute.value[0]) != -1) {\n            parsed.attribute.value = parsed.attribute.value.substring(1, parsed.attribute.value.length - 1);\n          }\n        } else {\n          // positional access in xpath is 1-based index\n          // internal processes will assume 0-based so we normalize that here\n          parsed.position = parseInt(qualifier, 10) - 1;\n        }\n      }\n\n      return parsed;\n    });\n  }\n\n  _createClass(SimpleXPath, [{\n    key: 'isValid',\n    value: function isValid() {\n      return this.valid;\n    }\n  }, {\n    key: 'findsElement',\n    value: function findsElement() {\n      return !this.findsAttribute();\n    }\n  }, {\n    key: 'findsAttribute',\n    value: function findsAttribute() {\n      return this.path[this.path.length - 1].name.startsWith('@');\n    }\n  }, {\n    key: 'getMpdTarget',\n    value: function getMpdTarget(root, isSiblingOperation) {\n      var parent = null;\n      var leaf = root; // assume root is MPD and we start at next level match\n\n      var level = 1;\n      var name = 'MPD';\n\n      while (level < this.path.length && leaf !== null) {\n        // set parent to current\n        parent = leaf; // select next leaf based on component\n\n        var component = this.path[level];\n        name = component.name; // stop one early if this is the last element and an attribute\n\n        if (level !== this.path.length - 1 || !name.startsWith('@')) {\n          var children = parent[name + '_asArray'] || [];\n\n          if (children.length === 0 && parent[name]) {\n            children.push(parent[name]);\n          }\n\n          if (component.position) {\n            leaf = children[component.position] || null;\n          } else if (component.attribute) {\n            (function () {\n              var attr = component.attribute;\n              leaf = children.filter(function (elm) {\n                return elm[attr.name] == attr.value;\n              })[0] || null;\n            })();\n          } else {\n            // default case, select first\n            leaf = children[0] || null;\n          }\n        }\n\n        level++;\n      }\n\n      if (leaf === null) {\n        // given path not found in root\n        return null;\n      } // attributes the target is the leaf node, the name is the attribute\n\n\n      if (name.startsWith('@')) {\n        return {\n          name: name.substring(1),\n          leaf: leaf,\n          target: leaf\n        };\n      } // otherwise we target the parent for sibling operations and leaf for child operations\n\n\n      return {\n        name: name,\n        leaf: leaf,\n        target: isSiblingOperation ? parent : leaf\n      };\n    }\n  }]);\n\n  return SimpleXPath;\n}();\n\nexports.default = SimpleXPath;","map":{"version":3,"mappings":"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","names":["SimpleXPath","selector","_classCallCheck","valid","path","split","filter","component","length","map","parsed","name","qualifierPoint","indexOf","substring","qualifier","_this","equalityPoint","attribute","value","position","parseInt","findsAttribute","startsWith","root","isSiblingOperation","parent","leaf","level","children","push","attr","elm","target"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/dash/vo/SimpleXPath.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n * @class\n * @ignore\n */\nclass SimpleXPath {\n    constructor(selector) {\n        // establish validation of the path, to catch unsupported cases\n        this.valid = selector[0] == '/'; // first check, we only support absolute addressing\n\n        // establish parsed path, example:\n        // /MPD/Period[@id=\"foobar\"]/AdaptationSet[@id=\"2\"]/SegmentTemplate/SegmentTimeline\n        this.path = selector.split('/')\n            .filter((component) => component.length !== 0) // remove excess empty components\n            .map((component) => {\n                let parsed = {\n                    name: component\n                };\n\n                let qualifierPoint = component.indexOf('[');\n                if (qualifierPoint != -1) {\n                    parsed.name = component.substring(0, qualifierPoint);\n\n                    let qualifier = component.substring(qualifierPoint + 1, component.length - 1);\n\n                    // quick sanity check are there additional qualifiers making this invalid\n                    this.valid = this.valid && qualifier.indexOf('[') == -1;\n\n                    let equalityPoint = qualifier.indexOf('=');\n                    if (equalityPoint != -1) {\n                        parsed.attribute = {\n                            name: qualifier.substring(1, equalityPoint), // skip the @\n                            value: qualifier.substring(equalityPoint + 1)\n                        };\n\n                        // check for single and double quoted attribute values\n                        if (['\\'', '\"'].indexOf(parsed.attribute.value[0]) != -1) {\n                            parsed.attribute.value = parsed.attribute.value.substring(1, parsed.attribute.value.length - 1);\n                        }\n                    } else {\n                        // positional access in xpath is 1-based index\n                        // internal processes will assume 0-based so we normalize that here\n                        parsed.position = parseInt(qualifier, 10) - 1;\n                    }\n                }\n\n                return parsed;\n            });\n    }\n\n    isValid() {\n        return this.valid;\n    }\n\n    findsElement() {\n        return !this.findsAttribute();\n    }\n\n    findsAttribute() {\n        return this.path[this.path.length - 1].name.startsWith('@');\n    }\n\n    getMpdTarget(root, isSiblingOperation) {\n        let parent = null;\n        let leaf = root;\n        // assume root is MPD and we start at next level match\n        let level = 1;\n        let name = 'MPD';\n\n        while ( level < this.path.length && leaf !== null) {\n            // set parent to current\n            parent = leaf;\n\n            // select next leaf based on component\n            let component = this.path[level];\n            name = component.name;\n\n            // stop one early if this is the last element and an attribute\n            if (level !== this.path.length - 1 || !name.startsWith('@')) {\n                let children = parent[name + '_asArray'] || [];\n                if (children.length === 0 && parent[name]) {\n                    children.push(parent[name]);\n                }\n\n                if (component.position) {\n                    leaf = children[component.position] || null;\n                } else if (component.attribute) {\n                    let attr = component.attribute;\n                    leaf = children.filter((elm) => elm[attr.name] == attr.value)[0] || null;\n                } else {\n                    // default case, select first\n                    leaf = children[0] || null;\n                }\n            }\n\n            level++;\n        }\n\n        if (leaf === null) {\n            // given path not found in root\n            return null;\n        }\n\n        // attributes the target is the leaf node, the name is the attribute\n        if (name.startsWith('@')) {\n            return {\n                name: name.substring(1),\n                leaf: leaf,\n                target: leaf\n            };\n        }\n\n        // otherwise we target the parent for sibling operations and leaf for child operations\n        return {\n            name: name,\n            leaf: leaf,\n            target: isSiblingOperation ? parent : leaf\n        };\n    }\n}\n\nexport default SimpleXPath;\n"]},"metadata":{},"sourceType":"script"}