{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar _CommonEncryption = require('../CommonEncryption');\n\nvar _CommonEncryption2 = _interopRequireDefault(_CommonEncryption);\n\nvar _MediaCapability = require('../vo/MediaCapability');\n\nvar _MediaCapability2 = _interopRequireDefault(_MediaCapability);\n\nvar _KeySystemConfiguration = require('../vo/KeySystemConfiguration');\n\nvar _KeySystemConfiguration2 = _interopRequireDefault(_KeySystemConfiguration);\n\nvar _ProtectionErrors = require('../errors/ProtectionErrors');\n\nvar _ProtectionErrors2 = _interopRequireDefault(_ProtectionErrors);\n\nvar _DashJSError = require('../../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _LicenseRequest = require('../vo/LicenseRequest');\n\nvar _LicenseRequest2 = _interopRequireDefault(_LicenseRequest);\n\nvar _LicenseResponse = require('../vo/LicenseResponse');\n\nvar _LicenseResponse2 = _interopRequireDefault(_LicenseResponse);\n\nvar _HTTPRequest = require('../../vo/metrics/HTTPRequest');\n\nvar _Utils = require('../../../core/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Constants = require('../../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar NEEDKEY_BEFORE_INITIALIZE_RETRIES = 5;\nvar NEEDKEY_BEFORE_INITIALIZE_TIMEOUT = 500;\nvar LICENSE_SERVER_REQUEST_RETRIES = 3;\nvar LICENSE_SERVER_REQUEST_RETRY_INTERVAL = 1000;\nvar LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT = 8000;\n/**\n* @module ProtectionController\n* @description Provides access to media protection information and functionality.  Each\n* ProtectionController manages a single {@link MediaPlayer.models.ProtectionModel}\n* which encapsulates a set of protection information (EME APIs, selected key system,\n* key sessions).  The APIs of ProtectionController mostly align with the latest EME\n* APIs.  Key system selection is mostly automated when combined with app-overrideable\n* functionality provided in {@link ProtectionKeyController}.\n* @todo ProtectionController does almost all of its tasks automatically after init() is\n* called.  Applications might want more control over this process and want to go through\n* each step manually (key system selection, session creation, session maintenance).\n* @param {Object} config\n*/\n\nfunction ProtectionController(config) {\n  config = config || {};\n  var protectionKeyController = config.protectionKeyController;\n  var protectionModel = config.protectionModel;\n  var eventBus = config.eventBus;\n  var events = config.events;\n  var debug = config.debug;\n  var BASE64 = config.BASE64;\n  var constants = config.constants;\n  var needkeyRetries = [];\n  var cmcdModel = config.cmcdModel;\n  var settings = config.settings;\n  var instance = void 0,\n      logger = void 0,\n      pendingNeedKeyData = void 0,\n      mediaInfoArr = void 0,\n      protDataSet = void 0,\n      sessionType = void 0,\n      robustnessLevel = void 0,\n      keySystem = void 0,\n      licenseRequestFilters = void 0,\n      licenseResponseFilters = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    pendingNeedKeyData = [];\n    mediaInfoArr = [];\n    sessionType = 'temporary';\n    robustnessLevel = '';\n    licenseRequestFilters = [];\n    licenseResponseFilters = [];\n  }\n\n  function checkConfig() {\n    if (!eventBus || !eventBus.hasOwnProperty('on') || !protectionKeyController || !protectionKeyController.hasOwnProperty('getSupportedKeySystemsFromContentProtection')) {\n      throw new Error('Missing config parameter(s)');\n    }\n  }\n  /**\n  * Initialize this protection system with a given audio\n  * or video stream information.\n  *\n  * @param {StreamInfo} [mediaInfo] Media information\n  * @memberof module:ProtectionController\n  * @instance\n  * @todo This API will change when we have better support for allowing applications\n  * to select different adaptation sets for playback.  Right now it is clunky for\n  * applications to create {@link StreamInfo} with the right information,\n  * @ignore\n  */\n\n\n  function initializeForMedia(mediaInfo) {\n    // Not checking here if a session for similar KS/KID combination is already created\n    // because still don't know which keysystem will be selected.\n    // Once Keysystem is selected and before creating the session, we will do that check\n    // so we create the strictly necessary DRM sessions\n    if (!mediaInfo) {\n      throw new Error('mediaInfo can not be null or undefined');\n    }\n\n    checkConfig();\n    eventBus.on(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this);\n    eventBus.on(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this);\n    mediaInfoArr.push(mediaInfo); // ContentProtection elements are specified at the AdaptationSet level, so the CP for audio\n    // and video will be the same.  Just use one valid MediaInfo object\n\n    var supportedKS = protectionKeyController.getSupportedKeySystemsFromContentProtection(mediaInfo.contentProtection);\n\n    if (supportedKS && supportedKS.length > 0) {\n      selectKeySystem(supportedKS, true);\n    }\n  }\n  /**\n  * Removes all entries from the mediaInfoArr array for a specific stream id\n  * @param {String} streamId\n  */\n\n\n  function clearMediaInfoArrayByStreamId(streamId) {\n    mediaInfoArr = mediaInfoArr.filter(function (mediaInfo) {\n      return mediaInfo.streamInfo.id !== streamId;\n    });\n  }\n  /**\n  * Returns a set of supported key systems and CENC initialization data\n  * from the given array of ContentProtection elements.  Only\n  * key systems that are supported by this player will be returned.\n  * Key systems are returned in priority order (highest first).\n  *\n  * @param {Array.<Object>} cps - array of content protection elements parsed\n  * from the manifest\n  * @returns {Array.<Object>} array of objects indicating which supported key\n  * systems were found.  Empty array is returned if no\n  * supported key systems were found\n  * @memberof module:ProtectionKeyController\n  * @instance\n  * @ignore\n  */\n\n\n  function getSupportedKeySystemsFromContentProtection(cps) {\n    checkConfig();\n    return protectionKeyController.getSupportedKeySystemsFromContentProtection(cps);\n  }\n  /**\n  * Create a new key session associated with the given initialization data from\n  * the MPD or from the PSSH box in the media\n  *\n  * @param {ArrayBuffer} initData the initialization data\n  * @param {Uint8Array} cdmData the custom data to provide to licenser\n  * @memberof module:ProtectionController\n  * @instance\n  * @fires ProtectionController#KeySessionCreated\n  * @todo In older versions of the EME spec, there was a one-to-one relationship between\n  * initialization data and key sessions.  That is no longer true in the latest APIs.  This\n  * API will need to modified (and a new \"generateRequest(keySession, initData)\" API created)\n  * to come up to speed with the latest EME standard\n  * @ignore\n  */\n\n\n  function createKeySession(initData, cdmData) {\n    var initDataForKS = _CommonEncryption2.default.getPSSHForKeySystem(keySystem, initData);\n\n    var protData = getProtData(keySystem);\n\n    if (initDataForKS) {\n      // Check for duplicate initData\n      if (_isInitDataDuplicate(initDataForKS)) {\n        return;\n      }\n\n      try {\n        protectionModel.createKeySession(initDataForKS, protData, getSessionType(keySystem), cdmData);\n      } catch (error) {\n        eventBus.trigger(events.KEY_SESSION_CREATED, {\n          data: null,\n          error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_CODE, _ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_MESSAGE + error.message)\n        });\n      }\n    } else if (initData) {\n      protectionModel.createKeySession(initData, protData, getSessionType(keySystem), cdmData);\n    } else {\n      eventBus.trigger(events.KEY_SESSION_CREATED, {\n        data: null,\n        error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_CODE, _ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Selected key system is ' + (keySystem ? keySystem.systemString : null) + '.  needkey/encrypted event contains no initData corresponding to that key system!')\n      });\n    }\n  }\n  /**\n  * Checks if the provided init data is equal to one of the existing init data values\n  * @param {any} initDataForKS\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _isInitDataDuplicate(initDataForKS) {\n    if (!initDataForKS) {\n      return false;\n    }\n\n    try {\n      var currentInitData = protectionModel.getAllInitData();\n\n      for (var i = 0; i < currentInitData.length; i++) {\n        if (protectionKeyController.initDataEquals(initDataForKS, currentInitData[i])) {\n          logger.debug('DRM: Ignoring initData because we have already seen it!');\n          return true;\n        }\n      }\n\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * Loads a key session with the given session ID from persistent storage.  This\n  * essentially creates a new key session\n  *\n  * @param {string} sessionID\n  * @param {string} initData\n  * @memberof module:ProtectionController\n  * @instance\n  * @fires ProtectionController#KeySessionCreated\n  * @ignore\n  */\n\n\n  function loadKeySession(sessionID, initData) {\n    checkConfig();\n    protectionModel.loadKeySession(sessionID, initData, getSessionType(keySystem));\n  }\n  /**\n  * Removes the given key session from persistent storage and closes the session\n  * as if {@link ProtectionController#closeKeySession}\n  * was called\n  *\n  * @param {SessionToken} sessionToken the session\n  * token\n  * @memberof module:ProtectionController\n  * @instance\n  * @fires ProtectionController#KeySessionRemoved\n  * @fires ProtectionController#KeySessionClosed\n  * @ignore\n  */\n\n\n  function removeKeySession(sessionToken) {\n    checkConfig();\n    protectionModel.removeKeySession(sessionToken);\n  }\n  /**\n  * Closes the key session and releases all associated decryption keys.  These\n  * keys will no longer be available for decrypting media\n  *\n  * @param {SessionToken} sessionToken the session\n  * token\n  * @memberof module:ProtectionController\n  * @instance\n  * @fires ProtectionController#KeySessionClosed\n  * @ignore\n  */\n\n\n  function closeKeySession(sessionToken) {\n    checkConfig();\n    protectionModel.closeKeySession(sessionToken);\n  }\n  /**\n  * Sets a server certificate for use by the CDM when signing key messages\n  * intended for a particular license server.  This will fire\n  * an error event if a key system has not yet been selected.\n  *\n  * @param {ArrayBuffer} serverCertificate a CDM-specific license server\n  * certificate\n  * @memberof module:ProtectionController\n  * @instance\n  * @fires ProtectionController#ServerCertificateUpdated\n  */\n\n\n  function setServerCertificate(serverCertificate) {\n    checkConfig();\n    protectionModel.setServerCertificate(serverCertificate);\n  }\n  /**\n  * Associate this protection system with the given HTMLMediaElement.  This\n  * causes the system to register for needkey/encrypted events from the given\n  * element and provides a destination for setting of MediaKeys\n  *\n  * @param {HTMLMediaElement} element the media element to which the protection\n  * system should be associated\n  * @memberof module:ProtectionController\n  * @instance\n  */\n\n\n  function setMediaElement(element) {\n    checkConfig();\n\n    if (element) {\n      protectionModel.setMediaElement(element);\n      eventBus.on(events.NEED_KEY, onNeedKey, this);\n    } else if (element === null) {\n      protectionModel.setMediaElement(element);\n      eventBus.off(events.NEED_KEY, onNeedKey, this);\n    }\n  }\n  /**\n  * Sets the session type to use when creating key sessions.  Either \"temporary\" or\n  * \"persistent-license\".  Default is \"temporary\".\n  *\n  * @param {string} value the session type\n  * @memberof module:ProtectionController\n  * @instance\n  */\n\n\n  function setSessionType(value) {\n    sessionType = value;\n  }\n  /**\n  * Sets the robustness level for video and audio capabilities. Optional to remove Chrome warnings.\n  * Possible values are SW_SECURE_CRYPTO, SW_SECURE_DECODE, HW_SECURE_CRYPTO, HW_SECURE_CRYPTO, HW_SECURE_DECODE, HW_SECURE_ALL.\n  *\n  * @param {string} level the robustness level\n  * @memberof module:ProtectionController\n  * @instance\n  */\n\n\n  function setRobustnessLevel(level) {\n    robustnessLevel = level;\n  }\n  /**\n  * Attach KeySystem-specific data to use for license acquisition with EME\n  *\n  * @param {Object} data an object containing property names corresponding to\n  * key system name strings (e.g. \"org.w3.clearkey\") and associated values\n  * being instances of {@link ProtectionData}\n  * @memberof module:ProtectionController\n  * @instance\n  * @ignore\n  */\n\n\n  function setProtectionData(data) {\n    protDataSet = data;\n    protectionKeyController.setProtectionData(data);\n  }\n  /**\n  * Stop method is called when current playback is stopped/resetted.\n  *\n  * @memberof module:ProtectionController\n  * @instance\n  */\n\n\n  function stop() {\n    if (protectionModel) {\n      protectionModel.stop();\n    }\n  }\n  /**\n  * Destroys all protection data associated with this protection set.  This includes\n  * deleting all key sessions. In the case of persistent key sessions, the sessions\n  * will simply be unloaded and not deleted.  Additionally, if this protection set is\n  * associated with a HTMLMediaElement, it will be detached from that element.\n  *\n  * @memberof module:ProtectionController\n  * @instance\n  * @ignore\n  */\n\n\n  function reset() {\n    checkConfig();\n    licenseRequestFilters = [];\n    licenseResponseFilters = [];\n    eventBus.off(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this);\n    eventBus.off(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this);\n    setMediaElement(null);\n    keySystem = undefined;\n\n    if (protectionModel) {\n      protectionModel.reset();\n      protectionModel = null;\n    }\n\n    needkeyRetries.forEach(function (retryTimeout) {\n      return clearTimeout(retryTimeout);\n    });\n    needkeyRetries = [];\n    mediaInfoArr = [];\n  } ///////////////\n  // Private\n  ///////////////\n\n\n  function getProtData(keySystem) {\n    var protData = null;\n\n    if (keySystem) {\n      var keySystemString = keySystem.systemString;\n\n      if (protDataSet) {\n        protData = keySystemString in protDataSet ? protDataSet[keySystemString] : null;\n      }\n    }\n\n    return protData;\n  }\n\n  function getKeySystemConfiguration(keySystem) {\n    var protData = getProtData(keySystem);\n    var audioCapabilities = [];\n    var videoCapabilities = [];\n    var audioRobustness = protData && protData.audioRobustness && protData.audioRobustness.length > 0 ? protData.audioRobustness : robustnessLevel;\n    var videoRobustness = protData && protData.videoRobustness && protData.videoRobustness.length > 0 ? protData.videoRobustness : robustnessLevel;\n    var ksSessionType = getSessionType(keySystem);\n    var distinctiveIdentifier = protData && protData.distinctiveIdentifier ? protData.distinctiveIdentifier : 'optional';\n    var persistentState = protData && protData.persistentState ? protData.persistentState : ksSessionType === 'temporary' ? 'optional' : 'required';\n    mediaInfoArr.forEach(function (media) {\n      if (media.type === constants.AUDIO) {\n        audioCapabilities.push(new _MediaCapability2.default(media.codec, audioRobustness));\n      } else if (media.type === constants.VIDEO) {\n        videoCapabilities.push(new _MediaCapability2.default(media.codec, videoRobustness));\n      }\n    });\n    return new _KeySystemConfiguration2.default(audioCapabilities, videoCapabilities, distinctiveIdentifier, persistentState, [ksSessionType]);\n  }\n\n  function getSessionType(keySystem) {\n    var protData = getProtData(keySystem);\n    var ksSessionType = protData && protData.sessionType ? protData.sessionType : sessionType;\n    return ksSessionType;\n  }\n\n  function selectKeySystem(supportedKS, fromManifest) {\n    // Reorder key systems according to priority order provided in protectionData\n    supportedKS = supportedKS.sort(function (ksA, ksB) {\n      var indexA = protDataSet && protDataSet[ksA.ks.systemString] && protDataSet[ksA.ks.systemString].priority >= 0 ? protDataSet[ksA.ks.systemString].priority : supportedKS.length;\n      var indexB = protDataSet && protDataSet[ksB.ks.systemString] && protDataSet[ksB.ks.systemString].priority >= 0 ? protDataSet[ksB.ks.systemString].priority : supportedKS.length;\n      return indexA - indexB;\n    }); // First time, so we need to select a key system\n\n    if (keySystem === undefined) {\n      _selectInitialKeySystem(supportedKS, fromManifest);\n    } // We already selected a key system. we only need to trigger a new license exchange if the init data has changed\n    else if (keySystem) {\n      _selectWithExistingKeySystem(supportedKS, fromManifest);\n    } // We are in the process of selecting a key system, so just save the data which might be coming from additional AdaptationSets.\n    else {\n      pendingNeedKeyData.push(supportedKS);\n    }\n  }\n\n  function _selectWithExistingKeySystem(supportedKS, fromManifest) {\n    var self = this;\n    var requestedKeySystems = [];\n    var ksIdx = supportedKS.findIndex(function (entry) {\n      return entry.ks === keySystem;\n    });\n\n    if (ksIdx === -1 || !supportedKS[ksIdx].initData) {\n      return;\n    } //  we only need to call this if the init data has changed\n\n\n    var initDataForKs = _CommonEncryption2.default.getPSSHForKeySystem(keySystem, supportedKS[ksIdx].initData);\n\n    if (_isInitDataDuplicate(initDataForKs)) {\n      return;\n    }\n\n    requestedKeySystems.push({\n      ks: supportedKS[ksIdx].ks,\n      configs: [getKeySystemConfiguration(keySystem)]\n    }); // Ensure that we would be granted key system access using the key\n    // system and codec information\n\n    var onKeySystemAccessComplete = function onKeySystemAccessComplete(event) {\n      eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n\n      if (event.error) {\n        if (!fromManifest) {\n          eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n            error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, _ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + event.error)\n          });\n        }\n      } else {\n        logger.info('DRM: KeySystem Access Granted');\n        eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n          data: event.data\n        });\n        var protData = getProtData(keySystem);\n\n        if (protectionKeyController.isClearKey(keySystem)) {\n          // For Clearkey: if parameters for generating init data was provided by the user, use them for generating\n          // initData and overwrite possible initData indicated in encrypted event (EME)\n          if (protData && protData.hasOwnProperty('clearkeys')) {\n            var initData = {\n              kids: Object.keys(protData.clearkeys)\n            };\n            supportedKS[ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData));\n          }\n        }\n\n        if (supportedKS[ksIdx].sessionId) {\n          // Load MediaKeySession with sessionId\n          loadKeySession(supportedKS[ksIdx].sessionId, supportedKS[ksIdx].initData);\n        } else if (supportedKS[ksIdx].initData) {\n          // Create new MediaKeySession with initData\n          createKeySession(supportedKS[ksIdx].initData, supportedKS[ksIdx].cdmData);\n        }\n      }\n    };\n\n    eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n    protectionModel.requestKeySystemAccess(requestedKeySystems);\n  }\n\n  function _selectInitialKeySystem(supportedKS, fromManifest) {\n    var self = this;\n    var requestedKeySystems = [];\n    var ksIdx = void 0; // First time through, so we need to select a key system\n\n    keySystem = null;\n    pendingNeedKeyData.push(supportedKS); // Add all key systems to our request list since we have yet to select a key system\n\n    for (var i = 0; i < supportedKS.length; i++) {\n      requestedKeySystems.push({\n        ks: supportedKS[i].ks,\n        configs: [getKeySystemConfiguration(supportedKS[i].ks)]\n      });\n    }\n\n    var keySystemAccess = void 0;\n\n    var onKeySystemAccessComplete = function onKeySystemAccessComplete(event) {\n      eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n\n      if (event.error) {\n        keySystem = undefined;\n        eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n\n        if (!fromManifest) {\n          eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n            data: null,\n            error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, _ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + event.error)\n          });\n        }\n      } else {\n        keySystemAccess = event.data;\n        logger.info('DRM: KeySystem Access Granted (' + keySystemAccess.keySystem.systemString + ')!  Selecting key system...');\n        protectionModel.selectKeySystem(keySystemAccess);\n      }\n    };\n\n    var onKeySystemSelected = function onKeySystemSelected(event) {\n      eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n      eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n\n      if (!event.error) {\n        if (!protectionModel) {\n          return;\n        }\n\n        keySystem = protectionModel.getKeySystem();\n        eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n          data: keySystemAccess\n        }); // Set server certificate from protData\n\n        var protData = getProtData(keySystem);\n\n        if (protData && protData.serverCertificate && protData.serverCertificate.length > 0) {\n          protectionModel.setServerCertificate(BASE64.decodeArray(protData.serverCertificate).buffer);\n        } // Create key session for the remaining AdaptationSets which have been added to pendingNeedKeyData\n\n\n        for (var _i = 0; _i < pendingNeedKeyData.length; _i++) {\n          for (ksIdx = 0; ksIdx < pendingNeedKeyData[_i].length; ksIdx++) {\n            if (keySystem === pendingNeedKeyData[_i][ksIdx].ks) {\n              if (protectionKeyController.isClearKey(keySystem)) {\n                // For Clearkey: if parameters for generating init data was provided by the user, use them for generating\n                // initData and overwrite possible initData indicated in encrypted event (EME)\n                if (protData && protData.hasOwnProperty('clearkeys')) {\n                  var initData = {\n                    kids: Object.keys(protData.clearkeys)\n                  };\n                  pendingNeedKeyData[_i][ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData));\n                }\n              }\n\n              if (pendingNeedKeyData[_i][ksIdx].sessionId) {\n                // Load MediaKeySession with sessionId\n                loadKeySession(pendingNeedKeyData[_i][ksIdx].sessionId, pendingNeedKeyData[_i][ksIdx].initData);\n              } else if (pendingNeedKeyData[_i][ksIdx].initData !== null) {\n                // Create new MediaKeySession with initData\n                createKeySession(pendingNeedKeyData[_i][ksIdx].initData, pendingNeedKeyData[_i][ksIdx].cdmData);\n              }\n\n              break;\n            }\n          }\n        }\n      } else {\n        keySystem = undefined;\n\n        if (!fromManifest) {\n          eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n            data: null,\n            error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, _ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + 'Error selecting key system! -- ' + event.error)\n          });\n        }\n      }\n    };\n\n    eventBus.on(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n    eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n    protectionModel.requestKeySystemAccess(requestedKeySystems);\n  }\n\n  function sendLicenseRequestCompleteEvent(data, error) {\n    eventBus.trigger(events.LICENSE_REQUEST_COMPLETE, {\n      data: data,\n      error: error\n    });\n  }\n\n  function onKeyStatusChanged(e) {\n    if (e.error) {\n      eventBus.trigger(events.KEY_STATUSES_CHANGED, {\n        data: null,\n        error: e.error\n      });\n    } else {\n      logger.debug('DRM: key status = ' + e.status);\n    }\n  }\n\n  function onKeyMessage(e) {\n    logger.debug('DRM: onKeyMessage'); // Dispatch event to applications indicating we received a key message\n\n    var keyMessage = e.data;\n    eventBus.trigger(events.KEY_MESSAGE, {\n      data: keyMessage\n    });\n    var messageType = keyMessage.messageType ? keyMessage.messageType : 'license-request';\n    var message = keyMessage.message;\n    var sessionToken = keyMessage.sessionToken;\n    var protData = getProtData(keySystem);\n    var keySystemString = keySystem ? keySystem.systemString : null;\n    var licenseServerData = protectionKeyController.getLicenseServer(keySystem, protData, messageType);\n    var eventData = {\n      sessionToken: sessionToken,\n      messageType: messageType\n    }; // Ensure message from CDM is not empty\n\n    if (!message || message.byteLength === 0) {\n      sendLicenseRequestCompleteEvent(eventData, new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE));\n      return;\n    } // Message not destined for license server\n\n\n    if (!licenseServerData) {\n      logger.debug('DRM: License server request not required for this message (type = ' + e.data.messageType + ').  Session ID = ' + sessionToken.getSessionID());\n      sendLicenseRequestCompleteEvent(eventData);\n      return;\n    } // Perform any special handling for ClearKey\n\n\n    if (protectionKeyController.isClearKey(keySystem)) {\n      var clearkeys = protectionKeyController.processClearKeyLicenseRequest(keySystem, protData, message);\n\n      if (clearkeys) {\n        logger.debug('DRM: ClearKey license request handled by application!');\n        sendLicenseRequestCompleteEvent(eventData);\n        protectionModel.updateKeySession(sessionToken, clearkeys);\n        return;\n      }\n    } // All remaining key system scenarios require a request to a remote license server\n    // Determine license server URL\n\n\n    var url = null;\n\n    if (protData && protData.serverURL) {\n      var serverURL = protData.serverURL;\n\n      if (typeof serverURL === 'string' && serverURL !== '') {\n        url = serverURL;\n      } else if ((typeof serverURL === 'undefined' ? 'undefined' : _typeof(serverURL)) === 'object' && serverURL.hasOwnProperty(messageType)) {\n        url = serverURL[messageType];\n      }\n    } else if (protData && protData.laURL && protData.laURL !== '') {\n      // TODO: Deprecated!\n      url = protData.laURL;\n    } else {\n      // For clearkey use the url defined in the manifest\n      if (protectionKeyController.isClearKey(keySystem)) {\n        url = keySystem.getLicenseServerUrlFromMediaInfo(mediaInfoArr);\n      } else {\n        var psshData = _CommonEncryption2.default.getPSSHData(sessionToken.initData);\n\n        url = keySystem.getLicenseServerURLFromInitData(psshData);\n\n        if (!url) {\n          url = e.data.laURL;\n        }\n      }\n    } // Possibly update or override the URL based on the message\n\n\n    url = licenseServerData.getServerURLFromMessage(url, message, messageType); // Ensure valid license server URL\n\n    if (!url) {\n      sendLicenseRequestCompleteEvent(eventData, new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE));\n      return;\n    } // Set optional XMLHttpRequest headers from protection data and message\n\n\n    var reqHeaders = {};\n    var withCredentials = false;\n\n    var updateHeaders = function updateHeaders(headers) {\n      if (headers) {\n        for (var key in headers) {\n          if ('authorization' === key.toLowerCase()) {\n            withCredentials = true;\n          }\n\n          reqHeaders[key] = headers[key];\n        }\n      }\n    };\n\n    if (protData) {\n      updateHeaders(protData.httpRequestHeaders);\n    }\n\n    updateHeaders(keySystem.getRequestHeadersFromMessage(message)); // Overwrite withCredentials property from protData if present\n\n    if (protData && typeof protData.withCredentials == 'boolean') {\n      withCredentials = protData.withCredentials;\n    }\n\n    var reportError = function reportError(xhr, eventData, keySystemString, messageType) {\n      var errorMsg = xhr.response ? licenseServerData.getErrorResponse(xhr.response, keySystemString, messageType) : 'NONE';\n      sendLicenseRequestCompleteEvent(eventData, new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR complete. status is \"' + xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState + '.  Response is ' + errorMsg));\n    };\n\n    var onLoad = function onLoad(xhr) {\n      if (!protectionModel) {\n        return;\n      }\n\n      if (xhr.status === 200) {\n        var licenseResponse = new _LicenseResponse2.default(xhr.responseURL, _Utils2.default.parseHttpHeaders(xhr.getAllResponseHeaders ? xhr.getAllResponseHeaders() : null), xhr.response);\n        applyFilters(licenseResponseFilters, licenseResponse).then(function () {\n          var licenseMessage = licenseServerData.getLicenseMessage(licenseResponse.data, keySystemString, messageType);\n\n          if (licenseMessage !== null) {\n            sendLicenseRequestCompleteEvent(eventData);\n            protectionModel.updateKeySession(sessionToken, licenseMessage);\n          } else {\n            reportError(xhr, eventData, keySystemString, messageType);\n          }\n        });\n      } else {\n        reportError(xhr, eventData, keySystemString, messageType);\n      }\n    };\n\n    var onAbort = function onAbort(xhr) {\n      sendLicenseRequestCompleteEvent(eventData, new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR aborted. status is \"' + xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState));\n    };\n\n    var onError = function onError(xhr) {\n      sendLicenseRequestCompleteEvent(eventData, new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR error. status is \"' + xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState));\n    };\n\n    var reqPayload = keySystem.getLicenseRequestFromMessage(message);\n    var reqMethod = licenseServerData.getHTTPMethod(messageType);\n    var responseType = licenseServerData.getResponseType(keySystemString, messageType);\n    var timeout = protData && !isNaN(protData.httpTimeout) ? protData.httpTimeout : LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT;\n    var sessionId = sessionToken.getSessionID() || null;\n    var licenseRequest = new _LicenseRequest2.default(url, reqMethod, responseType, reqHeaders, withCredentials, messageType, sessionId, reqPayload);\n    applyFilters(licenseRequestFilters, licenseRequest).then(function () {\n      doLicenseRequest(licenseRequest, LICENSE_SERVER_REQUEST_RETRIES, timeout, onLoad, onAbort, onError);\n    });\n  } // Implement license requests with a retry mechanism to avoid temporary network issues to affect playback experience\n\n\n  function doLicenseRequest(request, retriesCount, timeout, onLoad, onAbort, onError) {\n    var xhr = new XMLHttpRequest();\n\n    if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n      var cmcdMode = settings.get().streaming.cmcd.mode;\n\n      if (cmcdMode === _Constants2.default.CMCD_MODE_QUERY) {\n        var cmcdParams = cmcdModel.getQueryParameter({\n          url: request.url,\n          type: _HTTPRequest.HTTPRequest.LICENSE\n        });\n\n        if (cmcdParams) {\n          request.url = _Utils2.default.addAditionalQueryParameterToUrl(request.url, [cmcdParams]);\n        }\n      }\n    }\n\n    xhr.open(request.method, request.url, true);\n    xhr.responseType = request.responseType;\n    xhr.withCredentials = request.withCredentials;\n\n    if (timeout > 0) {\n      xhr.timeout = timeout;\n    }\n\n    for (var key in request.headers) {\n      xhr.setRequestHeader(key, request.headers[key]);\n    }\n\n    if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n      var _cmcdMode = settings.get().streaming.cmcd.mode;\n\n      if (_cmcdMode === _Constants2.default.CMCD_MODE_HEADER) {\n        var cmcdHeaders = cmcdModel.getHeaderParameters({\n          url: request.url,\n          type: _HTTPRequest.HTTPRequest.LICENSE\n        });\n\n        if (cmcdHeaders) {\n          for (var header in cmcdHeaders) {\n            var value = cmcdHeaders[header];\n\n            if (value) {\n              xhr.setRequestHeader(header, value);\n            }\n          }\n        }\n      }\n    }\n\n    var retryRequest = function retryRequest() {\n      // fail silently and retry\n      retriesCount--;\n      setTimeout(function () {\n        doLicenseRequest(request, retriesCount, timeout, onLoad, onAbort, onError);\n      }, LICENSE_SERVER_REQUEST_RETRY_INTERVAL);\n    };\n\n    xhr.onload = function () {\n      if (this.status === 200 || retriesCount <= 0) {\n        onLoad(this);\n      } else {\n        logger.warn('License request failed (' + this.status + '). Retrying it... Pending retries: ' + retriesCount);\n        retryRequest();\n      }\n    };\n\n    xhr.ontimeout = xhr.onerror = function () {\n      if (retriesCount <= 0) {\n        onError(this);\n      } else {\n        logger.warn('License request network request failed . Retrying it... Pending retries: ' + retriesCount);\n        retryRequest();\n      }\n    };\n\n    xhr.onabort = function () {\n      onAbort(this);\n    }; // deprecated, to be removed\n\n\n    eventBus.trigger(events.LICENSE_REQUEST_SENDING, {\n      url: request.url,\n      headers: request.headers,\n      payload: request.data,\n      sessionId: request.sessionId\n    });\n    xhr.send(request.data);\n  }\n\n  function onNeedKey(event, retry) {\n    logger.debug('DRM: onNeedKey'); // Ignore non-cenc initData\n\n    if (event.key.initDataType !== 'cenc') {\n      logger.warn('DRM:  Only \\'cenc\\' initData is supported!  Ignoring initData of type: ' + event.key.initDataType);\n      return;\n    }\n\n    if (mediaInfoArr.length === 0) {\n      logger.warn('DRM: onNeedKey called before initializeForMedia, wait until initialized');\n      retry = typeof retry === 'undefined' ? 1 : retry + 1;\n\n      if (retry < NEEDKEY_BEFORE_INITIALIZE_RETRIES) {\n        needkeyRetries.push(setTimeout(function () {\n          onNeedKey(event, retry);\n        }, NEEDKEY_BEFORE_INITIALIZE_TIMEOUT));\n        return;\n      }\n    } // Some browsers return initData as Uint8Array (IE), some as ArrayBuffer (Chrome).\n    // Convert to ArrayBuffer\n\n\n    var abInitData = event.key.initData;\n\n    if (ArrayBuffer.isView(abInitData)) {\n      abInitData = abInitData.buffer;\n    } // If key system has already been selected and initData already seen, then do nothing\n\n\n    if (keySystem) {\n      var initDataForKS = _CommonEncryption2.default.getPSSHForKeySystem(keySystem, abInitData);\n\n      if (initDataForKS) {\n        // Check for duplicate initData\n        if (_isInitDataDuplicate(initDataForKS)) {\n          return;\n        }\n      }\n    }\n\n    logger.debug('DRM: initData:', String.fromCharCode.apply(null, new Uint8Array(abInitData)));\n    var supportedKS = protectionKeyController.getSupportedKeySystems(abInitData, protDataSet);\n\n    if (supportedKS.length === 0) {\n      logger.debug('DRM: Received needkey event with initData, but we don\\'t support any of the key systems!');\n      return;\n    }\n\n    selectKeySystem(supportedKS, false);\n  }\n\n  function getKeySystems() {\n    return protectionKeyController ? protectionKeyController.getKeySystems() : [];\n  }\n\n  function setKeySystems(keySystems) {\n    if (protectionKeyController) {\n      protectionKeyController.setKeySystems(keySystems);\n    }\n  }\n\n  function setLicenseRequestFilters(filters) {\n    licenseRequestFilters = filters;\n  }\n\n  function setLicenseResponseFilters(filters) {\n    licenseResponseFilters = filters;\n  }\n\n  function applyFilters(filters, param) {\n    if (!filters) return Promise.resolve();\n    return filters.reduce(function (prev, next) {\n      return prev.then(function () {\n        return next(param);\n      });\n    }, Promise.resolve());\n  }\n\n  instance = {\n    initializeForMedia: initializeForMedia,\n    clearMediaInfoArrayByStreamId: clearMediaInfoArrayByStreamId,\n    createKeySession: createKeySession,\n    loadKeySession: loadKeySession,\n    removeKeySession: removeKeySession,\n    closeKeySession: closeKeySession,\n    setServerCertificate: setServerCertificate,\n    setMediaElement: setMediaElement,\n    setSessionType: setSessionType,\n    setRobustnessLevel: setRobustnessLevel,\n    setProtectionData: setProtectionData,\n    getSupportedKeySystemsFromContentProtection: getSupportedKeySystemsFromContentProtection,\n    getKeySystems: getKeySystems,\n    setKeySystems: setKeySystems,\n    setLicenseRequestFilters: setLicenseRequestFilters,\n    setLicenseResponseFilters: setLicenseResponseFilters,\n    stop: stop,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nProtectionController.__dashjs_factory_name = 'ProtectionController';\nexports.default = dashjs.FactoryMaker.getClassFactory(ProtectionController);\n/* jshint ignore:line */","map":{"version":3,"mappings":"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","names":["NEEDKEY_BEFORE_INITIALIZE_RETRIES","NEEDKEY_BEFORE_INITIALIZE_TIMEOUT","LICENSE_SERVER_REQUEST_RETRIES","LICENSE_SERVER_REQUEST_RETRY_INTERVAL","LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT","ProtectionController","config","protectionKeyController","protectionModel","eventBus","events","debug","BASE64","constants","needkeyRetries","cmcdModel","settings","instance","logger","pendingNeedKeyData","mediaInfoArr","protDataSet","sessionType","robustnessLevel","keySystem","licenseRequestFilters","licenseResponseFilters","setup","getLogger","checkConfig","hasOwnProperty","Error","initializeForMedia","mediaInfo","on","INTERNAL_KEY_MESSAGE","onKeyMessage","INTERNAL_KEY_STATUS_CHANGED","onKeyStatusChanged","push","supportedKS","getSupportedKeySystemsFromContentProtection","contentProtection","length","selectKeySystem","clearMediaInfoArrayByStreamId","streamId","filter","streamInfo","id","cps","createKeySession","initData","cdmData","initDataForKS","CommonEncryption","getPSSHForKeySystem","protData","getProtData","_isInitDataDuplicate","getSessionType","error","trigger","KEY_SESSION_CREATED","data","DashJSError","ProtectionErrors","KEY_SESSION_CREATED_ERROR_CODE","KEY_SESSION_CREATED_ERROR_MESSAGE","message","systemString","currentInitData","getAllInitData","i","initDataEquals","e","loadKeySession","sessionID","removeKeySession","sessionToken","closeKeySession","setServerCertificate","serverCertificate","setMediaElement","element","NEED_KEY","onNeedKey","off","setSessionType","value","setRobustnessLevel","level","setProtectionData","stop","reset","undefined","forEach","clearTimeout","retryTimeout","keySystemString","getKeySystemConfiguration","audioCapabilities","videoCapabilities","audioRobustness","videoRobustness","ksSessionType","distinctiveIdentifier","persistentState","media","type","AUDIO","MediaCapability","codec","VIDEO","KeySystemConfiguration","fromManifest","sort","ksA","ksB","indexA","ks","priority","indexB","_selectInitialKeySystem","_selectWithExistingKeySystem","self","requestedKeySystems","ksIdx","findIndex","entry","initDataForKs","configs","onKeySystemAccessComplete","event","KEY_SYSTEM_ACCESS_COMPLETE","KEY_SYSTEM_SELECTED","KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE","KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE","info","isClearKey","kids","Object","keys","clearkeys","TextEncoder","encode","JSON","stringify","sessionId","requestKeySystemAccess","keySystemAccess","INTERNAL_KEY_SYSTEM_SELECTED","onKeySystemSelected","getKeySystem","decodeArray","buffer","sendLicenseRequestCompleteEvent","LICENSE_REQUEST_COMPLETE","KEY_STATUSES_CHANGED","status","keyMessage","KEY_MESSAGE","messageType","licenseServerData","getLicenseServer","eventData","byteLength","MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE","MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE","getSessionID","processClearKeyLicenseRequest","updateKeySession","url","serverURL","laURL","getLicenseServerUrlFromMediaInfo","psshData","getPSSHData","getLicenseServerURLFromInitData","getServerURLFromMessage","MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE","MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE","reqHeaders","withCredentials","updateHeaders","headers","key","toLowerCase","httpRequestHeaders","getRequestHeadersFromMessage","reportError","xhr","errorMsg","response","getErrorResponse","MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE","MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE","statusText","readyState","onLoad","licenseResponse","LicenseResponse","responseURL","Utils","parseHttpHeaders","getAllResponseHeaders","applyFilters","then","licenseMessage","getLicenseMessage","onAbort","onError","reqPayload","getLicenseRequestFromMessage","reqMethod","getHTTPMethod","responseType","getResponseType","timeout","isNaN","httpTimeout","licenseRequest","LicenseRequest","doLicenseRequest","request","retriesCount","XMLHttpRequest","get","streaming","cmcd","enabled","cmcdMode","mode","Constants","CMCD_MODE_QUERY","cmcdParams","getQueryParameter","HTTPRequest","LICENSE","addAditionalQueryParameterToUrl","open","method","setRequestHeader","CMCD_MODE_HEADER","cmcdHeaders","getHeaderParameters","header","retryRequest","setTimeout","onload","warn","ontimeout","onerror","onabort","LICENSE_REQUEST_SENDING","payload","send","retry","initDataType","abInitData","ArrayBuffer","isView","String","fromCharCode","apply","Uint8Array","getSupportedKeySystems","getKeySystems","setKeySystems","keySystems","setLicenseRequestFilters","filters","setLicenseResponseFilters","param","Promise","resolve","reduce","prev","next","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/protection/controllers/ProtectionController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport CommonEncryption from '../CommonEncryption';\nimport MediaCapability from '../vo/MediaCapability';\nimport KeySystemConfiguration from '../vo/KeySystemConfiguration';\nimport ProtectionErrors from '../errors/ProtectionErrors';\nimport DashJSError from '../../vo/DashJSError';\nimport LicenseRequest from '../vo/LicenseRequest';\nimport LicenseResponse from '../vo/LicenseResponse';\nimport { HTTPRequest } from '../../vo/metrics/HTTPRequest';\nimport Utils from '../../../core/Utils';\nimport Constants from '../../constants/Constants';\n\nconst NEEDKEY_BEFORE_INITIALIZE_RETRIES = 5;\nconst NEEDKEY_BEFORE_INITIALIZE_TIMEOUT = 500;\n\nconst LICENSE_SERVER_REQUEST_RETRIES = 3;\nconst LICENSE_SERVER_REQUEST_RETRY_INTERVAL = 1000;\nconst LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT = 8000;\n\n/**\n * @module ProtectionController\n * @description Provides access to media protection information and functionality.  Each\n * ProtectionController manages a single {@link MediaPlayer.models.ProtectionModel}\n * which encapsulates a set of protection information (EME APIs, selected key system,\n * key sessions).  The APIs of ProtectionController mostly align with the latest EME\n * APIs.  Key system selection is mostly automated when combined with app-overrideable\n * functionality provided in {@link ProtectionKeyController}.\n * @todo ProtectionController does almost all of its tasks automatically after init() is\n * called.  Applications might want more control over this process and want to go through\n * each step manually (key system selection, session creation, session maintenance).\n * @param {Object} config\n */\n\nfunction ProtectionController(config) {\n\n    config = config || {};\n    const protectionKeyController = config.protectionKeyController;\n    let protectionModel = config.protectionModel;\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const debug = config.debug;\n    const BASE64 = config.BASE64;\n    const constants = config.constants;\n    let needkeyRetries = [];\n    const cmcdModel = config.cmcdModel;\n    const settings = config.settings;\n\n    let instance,\n        logger,\n        pendingNeedKeyData,\n        mediaInfoArr,\n        protDataSet,\n        sessionType,\n        robustnessLevel,\n        keySystem,\n        licenseRequestFilters,\n        licenseResponseFilters;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        pendingNeedKeyData = [];\n        mediaInfoArr = [];\n        sessionType = 'temporary';\n        robustnessLevel = '';\n        licenseRequestFilters = [];\n        licenseResponseFilters = [];\n    }\n\n    function checkConfig() {\n        if (!eventBus || !eventBus.hasOwnProperty('on') || !protectionKeyController || !protectionKeyController.hasOwnProperty('getSupportedKeySystemsFromContentProtection')) {\n            throw new Error('Missing config parameter(s)');\n        }\n    }\n\n    /**\n     * Initialize this protection system with a given audio\n     * or video stream information.\n     *\n     * @param {StreamInfo} [mediaInfo] Media information\n     * @memberof module:ProtectionController\n     * @instance\n     * @todo This API will change when we have better support for allowing applications\n     * to select different adaptation sets for playback.  Right now it is clunky for\n     * applications to create {@link StreamInfo} with the right information,\n     * @ignore\n     */\n    function initializeForMedia(mediaInfo) {\n        // Not checking here if a session for similar KS/KID combination is already created\n        // because still don't know which keysystem will be selected.\n        // Once Keysystem is selected and before creating the session, we will do that check\n        // so we create the strictly necessary DRM sessions\n        if (!mediaInfo) {\n            throw new Error('mediaInfo can not be null or undefined');\n        }\n\n        checkConfig();\n\n        eventBus.on(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this);\n        eventBus.on(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this);\n        mediaInfoArr.push(mediaInfo);\n\n        // ContentProtection elements are specified at the AdaptationSet level, so the CP for audio\n        // and video will be the same.  Just use one valid MediaInfo object\n        const supportedKS = protectionKeyController.getSupportedKeySystemsFromContentProtection(mediaInfo.contentProtection);\n        if (supportedKS && supportedKS.length > 0) {\n            selectKeySystem(supportedKS, true);\n        }\n    }\n\n    /**\n     * Removes all entries from the mediaInfoArr array for a specific stream id\n     * @param {String} streamId\n     */\n    function clearMediaInfoArrayByStreamId(streamId) {\n        mediaInfoArr = mediaInfoArr.filter((mediaInfo) => {\n            return mediaInfo.streamInfo.id !== streamId;\n        });\n    }\n\n    /**\n     * Returns a set of supported key systems and CENC initialization data\n     * from the given array of ContentProtection elements.  Only\n     * key systems that are supported by this player will be returned.\n     * Key systems are returned in priority order (highest first).\n     *\n     * @param {Array.<Object>} cps - array of content protection elements parsed\n     * from the manifest\n     * @returns {Array.<Object>} array of objects indicating which supported key\n     * systems were found.  Empty array is returned if no\n     * supported key systems were found\n     * @memberof module:ProtectionKeyController\n     * @instance\n     * @ignore\n     */\n    function getSupportedKeySystemsFromContentProtection(cps) {\n        checkConfig();\n        return protectionKeyController.getSupportedKeySystemsFromContentProtection(cps);\n    }\n\n    /**\n     * Create a new key session associated with the given initialization data from\n     * the MPD or from the PSSH box in the media\n     *\n     * @param {ArrayBuffer} initData the initialization data\n     * @param {Uint8Array} cdmData the custom data to provide to licenser\n     * @memberof module:ProtectionController\n     * @instance\n     * @fires ProtectionController#KeySessionCreated\n     * @todo In older versions of the EME spec, there was a one-to-one relationship between\n     * initialization data and key sessions.  That is no longer true in the latest APIs.  This\n     * API will need to modified (and a new \"generateRequest(keySession, initData)\" API created)\n     * to come up to speed with the latest EME standard\n     * @ignore\n     */\n    function createKeySession(initData, cdmData) {\n        const initDataForKS = CommonEncryption.getPSSHForKeySystem(keySystem, initData);\n        const protData = getProtData(keySystem);\n        if (initDataForKS) {\n\n            // Check for duplicate initData\n            if (_isInitDataDuplicate(initDataForKS)) {\n                return;\n            }\n\n            try {\n                protectionModel.createKeySession(initDataForKS, protData, getSessionType(keySystem), cdmData);\n            } catch (error) {\n                eventBus.trigger(events.KEY_SESSION_CREATED, {\n                    data: null,\n                    error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + error.message)\n                });\n            }\n        } else if (initData) {\n            protectionModel.createKeySession(initData, protData, getSessionType(keySystem), cdmData);\n        } else {\n            eventBus.trigger(events.KEY_SESSION_CREATED, {\n                data: null,\n                error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Selected key system is ' + (keySystem ? keySystem.systemString : null) + '.  needkey/encrypted event contains no initData corresponding to that key system!')\n            });\n        }\n    }\n\n    /**\n     * Checks if the provided init data is equal to one of the existing init data values\n     * @param {any} initDataForKS\n     * @return {boolean}\n     * @private\n     */\n    function _isInitDataDuplicate(initDataForKS) {\n\n        if (!initDataForKS) {\n            return false;\n        }\n\n        try {\n            const currentInitData = protectionModel.getAllInitData();\n            for (let i = 0; i < currentInitData.length; i++) {\n                if (protectionKeyController.initDataEquals(initDataForKS, currentInitData[i])) {\n                    logger.debug('DRM: Ignoring initData because we have already seen it!');\n                    return true;\n                }\n            }\n\n            return false;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Loads a key session with the given session ID from persistent storage.  This\n     * essentially creates a new key session\n     *\n     * @param {string} sessionID\n     * @param {string} initData\n     * @memberof module:ProtectionController\n     * @instance\n     * @fires ProtectionController#KeySessionCreated\n     * @ignore\n     */\n    function loadKeySession(sessionID, initData) {\n        checkConfig();\n        protectionModel.loadKeySession(sessionID, initData, getSessionType(keySystem));\n    }\n\n    /**\n     * Removes the given key session from persistent storage and closes the session\n     * as if {@link ProtectionController#closeKeySession}\n     * was called\n     *\n     * @param {SessionToken} sessionToken the session\n     * token\n     * @memberof module:ProtectionController\n     * @instance\n     * @fires ProtectionController#KeySessionRemoved\n     * @fires ProtectionController#KeySessionClosed\n     * @ignore\n     */\n    function removeKeySession(sessionToken) {\n        checkConfig();\n        protectionModel.removeKeySession(sessionToken);\n    }\n\n    /**\n     * Closes the key session and releases all associated decryption keys.  These\n     * keys will no longer be available for decrypting media\n     *\n     * @param {SessionToken} sessionToken the session\n     * token\n     * @memberof module:ProtectionController\n     * @instance\n     * @fires ProtectionController#KeySessionClosed\n     * @ignore\n     */\n    function closeKeySession(sessionToken) {\n        checkConfig();\n        protectionModel.closeKeySession(sessionToken);\n    }\n\n    /**\n     * Sets a server certificate for use by the CDM when signing key messages\n     * intended for a particular license server.  This will fire\n     * an error event if a key system has not yet been selected.\n     *\n     * @param {ArrayBuffer} serverCertificate a CDM-specific license server\n     * certificate\n     * @memberof module:ProtectionController\n     * @instance\n     * @fires ProtectionController#ServerCertificateUpdated\n     */\n    function setServerCertificate(serverCertificate) {\n        checkConfig();\n        protectionModel.setServerCertificate(serverCertificate);\n    }\n\n    /**\n     * Associate this protection system with the given HTMLMediaElement.  This\n     * causes the system to register for needkey/encrypted events from the given\n     * element and provides a destination for setting of MediaKeys\n     *\n     * @param {HTMLMediaElement} element the media element to which the protection\n     * system should be associated\n     * @memberof module:ProtectionController\n     * @instance\n     */\n    function setMediaElement(element) {\n        checkConfig();\n        if (element) {\n            protectionModel.setMediaElement(element);\n            eventBus.on(events.NEED_KEY, onNeedKey, this);\n        } else if (element === null) {\n            protectionModel.setMediaElement(element);\n            eventBus.off(events.NEED_KEY, onNeedKey, this);\n        }\n    }\n\n    /**\n     * Sets the session type to use when creating key sessions.  Either \"temporary\" or\n     * \"persistent-license\".  Default is \"temporary\".\n     *\n     * @param {string} value the session type\n     * @memberof module:ProtectionController\n     * @instance\n     */\n    function setSessionType(value) {\n        sessionType = value;\n    }\n\n    /**\n     * Sets the robustness level for video and audio capabilities. Optional to remove Chrome warnings.\n     * Possible values are SW_SECURE_CRYPTO, SW_SECURE_DECODE, HW_SECURE_CRYPTO, HW_SECURE_CRYPTO, HW_SECURE_DECODE, HW_SECURE_ALL.\n     *\n     * @param {string} level the robustness level\n     * @memberof module:ProtectionController\n     * @instance\n     */\n    function setRobustnessLevel(level) {\n        robustnessLevel = level;\n    }\n\n    /**\n     * Attach KeySystem-specific data to use for license acquisition with EME\n     *\n     * @param {Object} data an object containing property names corresponding to\n     * key system name strings (e.g. \"org.w3.clearkey\") and associated values\n     * being instances of {@link ProtectionData}\n     * @memberof module:ProtectionController\n     * @instance\n     * @ignore\n     */\n    function setProtectionData(data) {\n        protDataSet = data;\n        protectionKeyController.setProtectionData(data);\n    }\n\n    /**\n     * Stop method is called when current playback is stopped/resetted.\n     *\n     * @memberof module:ProtectionController\n     * @instance\n     */\n    function stop() {\n        if (protectionModel) {\n            protectionModel.stop();\n        }\n    }\n\n\n    /**\n     * Destroys all protection data associated with this protection set.  This includes\n     * deleting all key sessions. In the case of persistent key sessions, the sessions\n     * will simply be unloaded and not deleted.  Additionally, if this protection set is\n     * associated with a HTMLMediaElement, it will be detached from that element.\n     *\n     * @memberof module:ProtectionController\n     * @instance\n     * @ignore\n     */\n    function reset() {\n        checkConfig();\n\n        licenseRequestFilters = [];\n        licenseResponseFilters = [];\n\n        eventBus.off(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this);\n        eventBus.off(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this);\n\n        setMediaElement(null);\n\n        keySystem = undefined;\n\n        if (protectionModel) {\n            protectionModel.reset();\n            protectionModel = null;\n        }\n\n        needkeyRetries.forEach(retryTimeout => clearTimeout(retryTimeout));\n        needkeyRetries = [];\n\n        mediaInfoArr = [];\n    }\n\n    ///////////////\n    // Private\n    ///////////////\n\n    function getProtData(keySystem) {\n        let protData = null;\n        if (keySystem) {\n            const keySystemString = keySystem.systemString;\n\n            if (protDataSet) {\n                protData = (keySystemString in protDataSet) ? protDataSet[keySystemString] : null;\n            }\n        }\n        return protData;\n    }\n\n    function getKeySystemConfiguration(keySystem) {\n        const protData = getProtData(keySystem);\n        const audioCapabilities = [];\n        const videoCapabilities = [];\n        const audioRobustness = (protData && protData.audioRobustness && protData.audioRobustness.length > 0) ? protData.audioRobustness : robustnessLevel;\n        const videoRobustness = (protData && protData.videoRobustness && protData.videoRobustness.length > 0) ? protData.videoRobustness : robustnessLevel;\n        const ksSessionType = getSessionType(keySystem);\n        const distinctiveIdentifier = (protData && protData.distinctiveIdentifier) ? protData.distinctiveIdentifier : 'optional';\n        const persistentState = (protData && protData.persistentState) ? protData.persistentState : (ksSessionType === 'temporary') ? 'optional' : 'required';\n\n        mediaInfoArr.forEach((media) => {\n            if (media.type === constants.AUDIO) {\n                audioCapabilities.push(new MediaCapability(media.codec, audioRobustness));\n            } else if (media.type === constants.VIDEO) {\n                videoCapabilities.push(new MediaCapability(media.codec, videoRobustness));\n            }\n        });\n\n        return new KeySystemConfiguration(\n            audioCapabilities, videoCapabilities, distinctiveIdentifier,\n            persistentState,\n            [ksSessionType]);\n    }\n\n    function getSessionType(keySystem) {\n        const protData = getProtData(keySystem);\n        const ksSessionType = (protData && protData.sessionType) ? protData.sessionType : sessionType;\n        return ksSessionType;\n    }\n\n    function selectKeySystem(supportedKS, fromManifest) {\n\n        // Reorder key systems according to priority order provided in protectionData\n        supportedKS = supportedKS.sort((ksA, ksB) => {\n            let indexA = (protDataSet && protDataSet[ksA.ks.systemString] && protDataSet[ksA.ks.systemString].priority >= 0) ? protDataSet[ksA.ks.systemString].priority : supportedKS.length;\n            let indexB = (protDataSet && protDataSet[ksB.ks.systemString] && protDataSet[ksB.ks.systemString].priority >= 0) ? protDataSet[ksB.ks.systemString].priority : supportedKS.length;\n            return indexA - indexB;\n        });\n\n\n        // First time, so we need to select a key system\n        if (keySystem === undefined) {\n            _selectInitialKeySystem(supportedKS, fromManifest);\n        }\n\n        // We already selected a key system. we only need to trigger a new license exchange if the init data has changed\n        else if (keySystem) {\n            _selectWithExistingKeySystem(supportedKS, fromManifest);\n        }\n\n        // We are in the process of selecting a key system, so just save the data which might be coming from additional AdaptationSets.\n        else {\n            pendingNeedKeyData.push(supportedKS);\n        }\n    }\n\n    function _selectWithExistingKeySystem(supportedKS, fromManifest) {\n        const self = this;\n        const requestedKeySystems = [];\n\n        const ksIdx = supportedKS.findIndex((entry) => {\n            return entry.ks === keySystem;\n        });\n\n        if (ksIdx === -1 || !supportedKS[ksIdx].initData) {\n            return;\n        }\n\n        //  we only need to call this if the init data has changed\n        const initDataForKs = CommonEncryption.getPSSHForKeySystem(keySystem, supportedKS[ksIdx].initData);\n        if (_isInitDataDuplicate(initDataForKs)) {\n            return;\n        }\n\n        requestedKeySystems.push({\n            ks: supportedKS[ksIdx].ks,\n            configs: [getKeySystemConfiguration(keySystem)]\n        });\n\n        // Ensure that we would be granted key system access using the key\n        // system and codec information\n        const onKeySystemAccessComplete = function (event) {\n            eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n            if (event.error) {\n                if (!fromManifest) {\n                    eventBus.trigger(events.KEY_SYSTEM_SELECTED, { error: new DashJSError(ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + event.error) });\n                }\n            } else {\n                logger.info('DRM: KeySystem Access Granted');\n                eventBus.trigger(events.KEY_SYSTEM_SELECTED, { data: event.data });\n                const protData = getProtData(keySystem);\n                if (protectionKeyController.isClearKey(keySystem)) {\n                    // For Clearkey: if parameters for generating init data was provided by the user, use them for generating\n                    // initData and overwrite possible initData indicated in encrypted event (EME)\n                    if (protData && protData.hasOwnProperty('clearkeys')) {\n                        const initData = { kids: Object.keys(protData.clearkeys) };\n                        supportedKS[ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData));\n                    }\n                }\n                if (supportedKS[ksIdx].sessionId) {\n                    // Load MediaKeySession with sessionId\n                    loadKeySession(supportedKS[ksIdx].sessionId, supportedKS[ksIdx].initData);\n                } else if (supportedKS[ksIdx].initData) {\n                    // Create new MediaKeySession with initData\n                    createKeySession(supportedKS[ksIdx].initData, supportedKS[ksIdx].cdmData);\n                }\n            }\n        };\n\n        eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n        protectionModel.requestKeySystemAccess(requestedKeySystems);\n    }\n\n    function _selectInitialKeySystem(supportedKS, fromManifest) {\n        const self = this;\n        const requestedKeySystems = [];\n        let ksIdx;\n\n        // First time through, so we need to select a key system\n        keySystem = null;\n        pendingNeedKeyData.push(supportedKS);\n\n        // Add all key systems to our request list since we have yet to select a key system\n        for (let i = 0; i < supportedKS.length; i++) {\n            requestedKeySystems.push({\n                ks: supportedKS[i].ks,\n                configs: [getKeySystemConfiguration(supportedKS[i].ks)]\n            });\n        }\n\n        let keySystemAccess;\n        const onKeySystemAccessComplete = function (event) {\n            eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n            if (event.error) {\n                keySystem = undefined;\n                eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n                if (!fromManifest) {\n                    eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n                        data: null,\n                        error: new DashJSError(ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + event.error)\n                    });\n                }\n            } else {\n                keySystemAccess = event.data;\n                logger.info('DRM: KeySystem Access Granted (' + keySystemAccess.keySystem.systemString + ')!  Selecting key system...');\n                protectionModel.selectKeySystem(keySystemAccess);\n            }\n        };\n        var onKeySystemSelected = function (event) {\n            eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n            eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n            if (!event.error) {\n                if (!protectionModel) {\n                    return;\n                }\n                keySystem = protectionModel.getKeySystem();\n                eventBus.trigger(events.KEY_SYSTEM_SELECTED, { data: keySystemAccess });\n                // Set server certificate from protData\n                const protData = getProtData(keySystem);\n                if (protData && protData.serverCertificate && protData.serverCertificate.length > 0) {\n                    protectionModel.setServerCertificate(BASE64.decodeArray(protData.serverCertificate).buffer);\n                }\n\n                // Create key session for the remaining AdaptationSets which have been added to pendingNeedKeyData\n                for (let i = 0; i < pendingNeedKeyData.length; i++) {\n                    for (ksIdx = 0; ksIdx < pendingNeedKeyData[i].length; ksIdx++) {\n                        if (keySystem === pendingNeedKeyData[i][ksIdx].ks) {\n                            if (protectionKeyController.isClearKey(keySystem)) {\n                                // For Clearkey: if parameters for generating init data was provided by the user, use them for generating\n                                // initData and overwrite possible initData indicated in encrypted event (EME)\n                                if (protData && protData.hasOwnProperty('clearkeys')) {\n                                    const initData = { kids: Object.keys(protData.clearkeys) };\n                                    pendingNeedKeyData[i][ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData));\n                                }\n                            }\n                            if (pendingNeedKeyData[i][ksIdx].sessionId) {\n                                // Load MediaKeySession with sessionId\n                                loadKeySession(pendingNeedKeyData[i][ksIdx].sessionId, pendingNeedKeyData[i][ksIdx].initData);\n                            } else if (pendingNeedKeyData[i][ksIdx].initData !== null) {\n                                // Create new MediaKeySession with initData\n                                createKeySession(pendingNeedKeyData[i][ksIdx].initData, pendingNeedKeyData[i][ksIdx].cdmData);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } else {\n                keySystem = undefined;\n                if (!fromManifest) {\n                    eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n                        data: null,\n                        error: new DashJSError(ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + 'Error selecting key system! -- ' + event.error)\n                    });\n                }\n            }\n        };\n\n        eventBus.on(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n        eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n        protectionModel.requestKeySystemAccess(requestedKeySystems);\n    }\n\n    function sendLicenseRequestCompleteEvent(data, error) {\n        eventBus.trigger(events.LICENSE_REQUEST_COMPLETE, { data: data, error: error });\n    }\n\n    function onKeyStatusChanged(e) {\n        if (e.error) {\n            eventBus.trigger(events.KEY_STATUSES_CHANGED, { data: null, error: e.error });\n        } else {\n            logger.debug('DRM: key status = ' + e.status);\n        }\n    }\n\n    function onKeyMessage(e) {\n        logger.debug('DRM: onKeyMessage');\n\n        // Dispatch event to applications indicating we received a key message\n        const keyMessage = e.data;\n        eventBus.trigger(events.KEY_MESSAGE, { data: keyMessage });\n        const messageType = (keyMessage.messageType) ? keyMessage.messageType : 'license-request';\n        const message = keyMessage.message;\n        const sessionToken = keyMessage.sessionToken;\n        const protData = getProtData(keySystem);\n        const keySystemString = keySystem ? keySystem.systemString : null;\n        const licenseServerData = protectionKeyController.getLicenseServer(keySystem, protData, messageType);\n        const eventData = { sessionToken: sessionToken, messageType: messageType };\n\n        // Ensure message from CDM is not empty\n        if (!message || message.byteLength === 0) {\n            sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE));\n            return;\n        }\n\n        // Message not destined for license server\n        if (!licenseServerData) {\n            logger.debug('DRM: License server request not required for this message (type = ' + e.data.messageType + ').  Session ID = ' + sessionToken.getSessionID());\n            sendLicenseRequestCompleteEvent(eventData);\n            return;\n        }\n\n        // Perform any special handling for ClearKey\n        if (protectionKeyController.isClearKey(keySystem)) {\n            const clearkeys = protectionKeyController.processClearKeyLicenseRequest(keySystem, protData, message);\n            if (clearkeys) {\n                logger.debug('DRM: ClearKey license request handled by application!');\n                sendLicenseRequestCompleteEvent(eventData);\n                protectionModel.updateKeySession(sessionToken, clearkeys);\n                return;\n            }\n        }\n\n        // All remaining key system scenarios require a request to a remote license server\n        // Determine license server URL\n        let url = null;\n        if (protData && protData.serverURL) {\n            const serverURL = protData.serverURL;\n            if (typeof serverURL === 'string' && serverURL !== '') {\n                url = serverURL;\n            } else if (typeof serverURL === 'object' && serverURL.hasOwnProperty(messageType)) {\n                url = serverURL[messageType];\n            }\n        } else if (protData && protData.laURL && protData.laURL !== '') {\n            // TODO: Deprecated!\n            url = protData.laURL;\n        } else {\n            // For clearkey use the url defined in the manifest\n            if (protectionKeyController.isClearKey(keySystem)) {\n                url = keySystem.getLicenseServerUrlFromMediaInfo(mediaInfoArr);\n            } else {\n                const psshData = CommonEncryption.getPSSHData(sessionToken.initData);\n                url = keySystem.getLicenseServerURLFromInitData(psshData);\n                if (!url) {\n                    url = e.data.laURL;\n                }\n            }\n        }\n        // Possibly update or override the URL based on the message\n        url = licenseServerData.getServerURLFromMessage(url, message, messageType);\n\n        // Ensure valid license server URL\n        if (!url) {\n            sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE));\n            return;\n        }\n\n        // Set optional XMLHttpRequest headers from protection data and message\n        const reqHeaders = {};\n        let withCredentials = false;\n        const updateHeaders = function (headers) {\n            if (headers) {\n                for (const key in headers) {\n                    if ('authorization' === key.toLowerCase()) {\n                        withCredentials = true;\n                    }\n                    reqHeaders[key] = headers[key];\n                }\n            }\n        };\n        if (protData) {\n            updateHeaders(protData.httpRequestHeaders);\n        }\n        updateHeaders(keySystem.getRequestHeadersFromMessage(message));\n\n        // Overwrite withCredentials property from protData if present\n        if (protData && typeof protData.withCredentials == 'boolean') {\n            withCredentials = protData.withCredentials;\n        }\n\n        const reportError = function (xhr, eventData, keySystemString, messageType) {\n            const errorMsg = ((xhr.response) ? licenseServerData.getErrorResponse(xhr.response, keySystemString, messageType) : 'NONE');\n            sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE,\n                ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR complete. status is \"' +\n                xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState + '.  Response is ' + errorMsg));\n        };\n\n        const onLoad = function (xhr) {\n            if (!protectionModel) {\n                return;\n            }\n\n            if (xhr.status === 200) {\n                let licenseResponse = new LicenseResponse(xhr.responseURL, Utils.parseHttpHeaders(xhr.getAllResponseHeaders ? xhr.getAllResponseHeaders() : null), xhr.response);\n                applyFilters(licenseResponseFilters, licenseResponse).then(() => {\n                    const licenseMessage = licenseServerData.getLicenseMessage(licenseResponse.data, keySystemString, messageType);\n                    if (licenseMessage !== null) {\n                        sendLicenseRequestCompleteEvent(eventData);\n                        protectionModel.updateKeySession(sessionToken, licenseMessage);\n                    } else {\n                        reportError(xhr, eventData, keySystemString, messageType);\n                    }\n                });\n            } else {\n                reportError(xhr, eventData, keySystemString, messageType);\n            }\n        };\n\n        const onAbort = function (xhr) {\n            sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE,\n                ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR aborted. status is \"' +\n                xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState));\n        };\n\n        const onError = function (xhr) {\n            sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE,\n                ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR error. status is \"' +\n                xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState));\n        };\n\n        const reqPayload = keySystem.getLicenseRequestFromMessage(message);\n        const reqMethod = licenseServerData.getHTTPMethod(messageType);\n        const responseType = licenseServerData.getResponseType(keySystemString, messageType);\n        const timeout = protData && !isNaN(protData.httpTimeout) ? protData.httpTimeout : LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT;\n        const sessionId = sessionToken.getSessionID() || null;\n\n        let licenseRequest = new LicenseRequest(url, reqMethod, responseType, reqHeaders, withCredentials, messageType, sessionId, reqPayload);\n        applyFilters(licenseRequestFilters, licenseRequest).then(() => {\n            doLicenseRequest(licenseRequest, LICENSE_SERVER_REQUEST_RETRIES, timeout, onLoad, onAbort, onError);\n        });\n    }\n\n    // Implement license requests with a retry mechanism to avoid temporary network issues to affect playback experience\n    function doLicenseRequest(request, retriesCount, timeout, onLoad, onAbort, onError) {\n        const xhr = new XMLHttpRequest();\n\n        if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n            const cmcdMode = settings.get().streaming.cmcd.mode;\n            if (cmcdMode === Constants.CMCD_MODE_QUERY) {\n                const cmcdParams = cmcdModel.getQueryParameter({\n                    url: request.url,\n                    type: HTTPRequest.LICENSE\n                });\n\n                if (cmcdParams) {\n                    request.url = Utils.addAditionalQueryParameterToUrl(request.url, [cmcdParams]);\n                }\n            }\n        }\n\n        xhr.open(request.method, request.url, true);\n        xhr.responseType = request.responseType;\n        xhr.withCredentials = request.withCredentials;\n        if (timeout > 0) {\n            xhr.timeout = timeout;\n        }\n        for (const key in request.headers) {\n            xhr.setRequestHeader(key, request.headers[key]);\n        }\n\n        if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n            const cmcdMode = settings.get().streaming.cmcd.mode;\n            if (cmcdMode === Constants.CMCD_MODE_HEADER) {\n                const cmcdHeaders = cmcdModel.getHeaderParameters({\n                    url: request.url,\n                    type: HTTPRequest.LICENSE\n                });\n\n                if (cmcdHeaders) {\n                    for (const header in cmcdHeaders) {\n                        let value = cmcdHeaders[header];\n                        if (value) {\n                            xhr.setRequestHeader(header, value);\n                        }\n                    }\n                }\n            }\n        }\n\n        const retryRequest = function () {\n            // fail silently and retry\n            retriesCount--;\n            setTimeout(function () {\n                doLicenseRequest(request, retriesCount, timeout, onLoad, onAbort, onError);\n            }, LICENSE_SERVER_REQUEST_RETRY_INTERVAL);\n        };\n\n        xhr.onload = function () {\n            if (this.status === 200 || retriesCount <= 0) {\n                onLoad(this);\n            } else {\n                logger.warn('License request failed (' + this.status + '). Retrying it... Pending retries: ' + retriesCount);\n                retryRequest();\n            }\n        };\n\n        xhr.ontimeout = xhr.onerror = function () {\n            if (retriesCount <= 0) {\n                onError(this);\n            } else {\n                logger.warn('License request network request failed . Retrying it... Pending retries: ' + retriesCount);\n                retryRequest();\n            }\n        };\n\n        xhr.onabort = function () {\n            onAbort(this);\n        };\n\n        // deprecated, to be removed\n        eventBus.trigger(events.LICENSE_REQUEST_SENDING, {\n            url: request.url,\n            headers: request.headers,\n            payload: request.data,\n            sessionId: request.sessionId\n        });\n\n        xhr.send(request.data);\n    }\n\n    function onNeedKey(event, retry) {\n        logger.debug('DRM: onNeedKey');\n        // Ignore non-cenc initData\n        if (event.key.initDataType !== 'cenc') {\n            logger.warn('DRM:  Only \\'cenc\\' initData is supported!  Ignoring initData of type: ' + event.key.initDataType);\n            return;\n        }\n\n        if (mediaInfoArr.length === 0) {\n            logger.warn('DRM: onNeedKey called before initializeForMedia, wait until initialized');\n            retry = typeof retry === 'undefined' ? 1 : retry + 1;\n            if (retry < NEEDKEY_BEFORE_INITIALIZE_RETRIES) {\n                needkeyRetries.push(setTimeout(() => {\n                    onNeedKey(event, retry);\n                }, NEEDKEY_BEFORE_INITIALIZE_TIMEOUT));\n                return;\n            }\n\n        }\n\n        // Some browsers return initData as Uint8Array (IE), some as ArrayBuffer (Chrome).\n        // Convert to ArrayBuffer\n        let abInitData = event.key.initData;\n        if (ArrayBuffer.isView(abInitData)) {\n            abInitData = abInitData.buffer;\n        }\n\n        // If key system has already been selected and initData already seen, then do nothing\n        if (keySystem) {\n            const initDataForKS = CommonEncryption.getPSSHForKeySystem(keySystem, abInitData);\n            if (initDataForKS) {\n\n                // Check for duplicate initData\n                if (_isInitDataDuplicate(initDataForKS)) {\n                    return;\n                }\n            }\n        }\n\n        logger.debug('DRM: initData:', String.fromCharCode.apply(null, new Uint8Array(abInitData)));\n\n        const supportedKS = protectionKeyController.getSupportedKeySystems(abInitData, protDataSet);\n        if (supportedKS.length === 0) {\n            logger.debug('DRM: Received needkey event with initData, but we don\\'t support any of the key systems!');\n            return;\n        }\n\n        selectKeySystem(supportedKS, false);\n    }\n\n    function getKeySystems() {\n        return protectionKeyController ? protectionKeyController.getKeySystems() : [];\n    }\n\n    function setKeySystems(keySystems) {\n        if (protectionKeyController) {\n            protectionKeyController.setKeySystems(keySystems);\n        }\n    }\n\n    function setLicenseRequestFilters (filters) {\n        licenseRequestFilters = filters;\n    }\n\n    function setLicenseResponseFilters (filters) {\n        licenseResponseFilters = filters;\n    }\n\n    function applyFilters (filters, param) {\n        if (!filters) return Promise.resolve();\n        return filters.reduce((prev, next) => {\n            return prev.then(() => {\n                return next(param);\n            });\n        }, Promise.resolve());\n    }\n\n    instance = {\n        initializeForMedia: initializeForMedia,\n        clearMediaInfoArrayByStreamId: clearMediaInfoArrayByStreamId,\n        createKeySession: createKeySession,\n        loadKeySession: loadKeySession,\n        removeKeySession: removeKeySession,\n        closeKeySession: closeKeySession,\n        setServerCertificate: setServerCertificate,\n        setMediaElement: setMediaElement,\n        setSessionType: setSessionType,\n        setRobustnessLevel: setRobustnessLevel,\n        setProtectionData: setProtectionData,\n        getSupportedKeySystemsFromContentProtection: getSupportedKeySystemsFromContentProtection,\n        getKeySystems: getKeySystems,\n        setKeySystems: setKeySystems,\n        setLicenseRequestFilters: setLicenseRequestFilters,\n        setLicenseResponseFilters: setLicenseResponseFilters,\n        stop: stop,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nProtectionController.__dashjs_factory_name = 'ProtectionController';\nexport default dashjs.FactoryMaker.getClassFactory(ProtectionController); /* jshint ignore:line */\n"]},"metadata":{},"sourceType":"script"}