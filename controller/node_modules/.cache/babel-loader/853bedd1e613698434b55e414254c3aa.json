{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _MediaPlayerEvents = require('../../streaming/MediaPlayerEvents');\n\nvar _MediaPlayerEvents2 = _interopRequireDefault(_MediaPlayerEvents);\n\nvar _XHRLoader = require('../net/XHRLoader');\n\nvar _XHRLoader2 = _interopRequireDefault(_XHRLoader);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction EventController() {\n  var MPD_RELOAD_SCHEME = 'urn:mpeg:dash:event:2012';\n  var MPD_RELOAD_VALUE = 1;\n  var MPD_CALLBACK_SCHEME = 'urn:mpeg:dash:event:callback:2015';\n  var MPD_CALLBACK_VALUE = 1;\n  var REMAINING_EVENTS_THRESHOLD = 300;\n  var EVENT_HANDLED_STATES = {\n    DISCARDED: 'discarded',\n    UPDATED: 'updated',\n    ADDED: 'added'\n  };\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      inlineEvents = void 0,\n      // Holds all Inline Events not triggered yet\n  inbandEvents = void 0,\n      // Holds all Inband Events not triggered yet\n  eventInterval = void 0,\n      // variable holding the setInterval\n  lastEventTimerCall = void 0,\n      manifestUpdater = void 0,\n      playbackController = void 0,\n      settings = void 0,\n      eventHandlingInProgress = void 0,\n      isStarted = void 0;\n  /**\n  * Internal setup when class is instanced\n  */\n\n  function _setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n\n    _resetInitialSettings();\n  }\n  /**\n  * Checks if the provded configuration is valid\n  */\n\n\n  function checkConfig() {\n    if (!manifestUpdater || !playbackController) {\n      throw new Error('setConfig function has to be called previously');\n    }\n  }\n  /**\n  * Reset to initial settings\n  */\n\n\n  function _resetInitialSettings() {\n    isStarted = false;\n    inlineEvents = {}; // Format inlineEvents[schemeIdUri]\n\n    inbandEvents = {}; // Format inlineEvents[schemeIdUri]\n\n    eventInterval = null;\n    eventHandlingInProgress = false;\n    lastEventTimerCall = Date.now() / 1000;\n  }\n  /**\n  * Stops the EventController by clearing the event interval\n  */\n\n\n  function _stop() {\n    try {\n      if (eventInterval !== null && isStarted) {\n        clearInterval(eventInterval);\n        eventInterval = null;\n        isStarted = false;\n\n        _onStopEventController();\n      }\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Starts the interval function of the EventController\n  */\n\n\n  function start() {\n    try {\n      checkConfig();\n      logger.debug('Start Event Controller');\n      var refreshDelay = settings.get().streaming.eventControllerRefreshDelay;\n\n      if (!isStarted && !isNaN(refreshDelay)) {\n        isStarted = true;\n        eventInterval = setInterval(_onEventTimer, refreshDelay);\n      }\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Add MPD events to the list of events.\n  * Events that are not in the MPD anymore but not triggered yet will still be deleted.\n  * Existing events might get updated.\n  * @param {Array.<Object>} values\n  */\n\n\n  function addInlineEvents(values) {\n    try {\n      checkConfig();\n\n      if (values) {\n        for (var i = 0; i < values.length; i++) {\n          var event = values[i];\n\n          var result = _addOrUpdateEvent(event, inlineEvents, true);\n\n          if (result === EVENT_HANDLED_STATES.ADDED) {\n            logger.debug('Added inline event with id ' + event.id); // If we see the event for the first time we trigger it in onReceive mode\n\n            _startEvent(event, values, _MediaPlayerEvents2.default.EVENT_MODE_ON_RECEIVE);\n          } else if (result === EVENT_HANDLED_STATES.UPDATED) {\n            logger.debug('Updated inline event with id ' + event.id);\n          }\n        }\n      }\n\n      logger.debug('Added ' + values.length + ' inline events');\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Add EMSG events to the list of events\n  * Messages with the same id within the scope of the same scheme_id_uri and value pair are equivalent , i.e. processing of any one event message box with the same id is sufficient.\n  * @param {Array.<Object>} values\n  */\n\n\n  function addInbandEvents(values) {\n    try {\n      checkConfig();\n\n      for (var i = 0; i < values.length; i++) {\n        var event = values[i];\n\n        var result = _addOrUpdateEvent(event, inbandEvents, false);\n\n        if (result === EVENT_HANDLED_STATES.ADDED) {\n          if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && inbandEvents[event.id] === undefined) {\n            _handleManifestReloadEvent(event);\n          }\n\n          logger.debug('Added inband event with id ' + event.id);\n\n          _startEvent(event, values, _MediaPlayerEvents2.default.EVENT_MODE_ON_RECEIVE);\n        } else {\n          logger.debug('Inband event with scheme_id_uri ' + event.eventStream.schemeIdUri + ', value ' + event.eventStream.value + ' and id ' + event.id + ' was ignored because it has been added before.');\n        }\n      }\n\n      _onEventTimer();\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Adds or updates an event to/in the list of events\n  * @param {object} event\n  * @param {object} events\n  * @param {boolean} shouldOverwriteExistingEvents\n  * @return {string}\n  * @private\n  */\n\n\n  function _addOrUpdateEvent(event, events) {\n    var shouldOverwriteExistingEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var schemeIdUri = event.eventStream.schemeIdUri;\n    var value = event.eventStream.value;\n    var id = event.id;\n    var eventState = EVENT_HANDLED_STATES.DISCARDED;\n\n    if (!events[schemeIdUri]) {\n      events[schemeIdUri] = [];\n    }\n\n    var indexOfExistingEvent = events[schemeIdUri].findIndex(function (e) {\n      return (!value || e.eventStream.value && e.eventStream.value === value) && e.id === id;\n    });\n\n    if (indexOfExistingEvent === -1) {\n      events[schemeIdUri].push(event);\n      eventState = EVENT_HANDLED_STATES.ADDED;\n    } else if (shouldOverwriteExistingEvents) {\n      events[schemeIdUri][indexOfExistingEvent] = event;\n      eventState = EVENT_HANDLED_STATES.UPDATED;\n    }\n\n    return eventState;\n  }\n  /**\n  * Triggers an MPD reload\n  * @param {object} event\n  * @private\n  */\n\n\n  function _handleManifestReloadEvent(event) {\n    try {\n      if (event.eventStream.value == MPD_RELOAD_VALUE) {\n        var validUntil = event.calculatedPresentationTime;\n        var newDuration = void 0;\n\n        if (event.calculatedPresentationTime == 0xFFFFFFFF) {\n          //0xFF... means remaining duration unknown\n          newDuration = NaN;\n        } else {\n          newDuration = event.calculatedPresentationTime + event.duration;\n        } //logger.info('Manifest validity changed: Valid until: ' + validUntil + '; remaining duration: ' + newDuration);\n\n\n        eventBus.trigger(_MediaPlayerEvents2.default.MANIFEST_VALIDITY_CHANGED, {\n          id: event.id,\n          validUntil: validUntil,\n          newDuration: newDuration,\n          newManifestValidAfter: NaN //event.message_data - this is an arraybuffer with a timestring in it, but not used yet\n\n        }, {\n          mode: _MediaPlayerEvents2.default.EVENT_MODE_ON_START\n        });\n      }\n    } catch (e) {}\n  }\n  /**\n  * Iterate through the eventList and trigger the events\n  */\n\n\n  function _onEventTimer() {\n    try {\n      if (!eventHandlingInProgress) {\n        eventHandlingInProgress = true;\n        var currentVideoTime = playbackController.getTime();\n        var presentationTimeThreshold = currentVideoTime - lastEventTimerCall; // For dynamic streams lastEventTimeCall will be large in the first iteration. Avoid firing all events at once.\n\n        presentationTimeThreshold = lastEventTimerCall > 0 ? Math.max(0, presentationTimeThreshold) : 0;\n\n        _triggerEvents(inbandEvents, presentationTimeThreshold, currentVideoTime);\n\n        _triggerEvents(inlineEvents, presentationTimeThreshold, currentVideoTime);\n\n        lastEventTimerCall = currentVideoTime;\n        eventHandlingInProgress = false;\n      }\n    } catch (e) {\n      eventHandlingInProgress = false;\n    }\n  }\n  /**\n  * When the EventController is stopped this callback is triggered. Starts the remaining events.\n  * @private\n  */\n\n\n  function _onStopEventController() {\n    try {\n      // EventController might be stopped before the period is over. Before we stop the event controller we check for events that needs to be triggered at the period boundary.\n      _triggerRemainingEvents(inbandEvents);\n\n      _triggerRemainingEvents(inlineEvents);\n    } catch (e) {}\n  }\n  /**\n  * Iterate over a list of events and trigger the ones for which the presentation time is within the current timing interval\n  * @param {object} events\n  * @param {number} presentationTimeThreshold\n  * @param {number} currentVideoTime\n  * @private\n  */\n\n\n  function _triggerEvents(events, presentationTimeThreshold, currentVideoTime) {\n    try {\n      var callback = function callback(event) {\n        if (event !== undefined) {\n          var duration = !isNaN(event.duration) ? event.duration : 0; // The event is either about to start or has already been started and we are within its duration\n\n          if (event.calculatedPresentationTime <= currentVideoTime && event.calculatedPresentationTime + presentationTimeThreshold + duration >= currentVideoTime) {\n            _startEvent(event, events, _MediaPlayerEvents2.default.EVENT_MODE_ON_START);\n          } else if (_eventHasExpired(currentVideoTime, duration + presentationTimeThreshold, event.calculatedPresentationTime) || _eventIsInvalid(event)) {\n            logger.debug('Deleting event ' + event.id + ' as it is expired or invalid');\n\n            _removeEvent(events, event);\n          }\n        }\n      };\n\n      _iterateAndTriggerCallback(events, callback);\n    } catch (e) {}\n  }\n  /**\n  * Triggers the remaining events after the EventController has been stopped\n  * @param {object} events\n  * @private\n  */\n\n\n  function _triggerRemainingEvents(events) {\n    try {\n      var currentTime = playbackController.getTime();\n\n      var callback = function callback(event) {\n        var periodDuration = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.duration) ? event.eventStream.period.duration : NaN;\n        var periodStart = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.start) ? event.eventStream.period.start : NaN;\n\n        if (isNaN(periodDuration) || isNaN(periodStart)) {\n          return;\n        }\n\n        var calculatedPresentationTimeInSeconds = event.calculatedPresentationTime;\n\n        if (Math.abs(calculatedPresentationTimeInSeconds - currentTime) < REMAINING_EVENTS_THRESHOLD) {\n          _startEvent(event, events, _MediaPlayerEvents2.default.EVENT_MODE_ON_START);\n        }\n      };\n\n      _iterateAndTriggerCallback(events, callback());\n    } catch (e) {}\n  }\n  /**\n  * Iterates over the inline/inband event object and triggers a callback for each event\n  * @param {object} events\n  * @param {function} callback\n  * @private\n  */\n\n\n  function _iterateAndTriggerCallback(events, callback) {\n    try {\n      if (events) {\n        var schemeIdUris = Object.keys(events);\n\n        for (var i = 0; i < schemeIdUris.length; i++) {\n          var schemeIdEvents = events[schemeIdUris[i]];\n          schemeIdEvents.forEach(function (event) {\n            if (event !== undefined) {\n              callback(event);\n            }\n          });\n        }\n      }\n    } catch (e) {}\n  }\n  /**\n  * Checks if an event is expired. For instance if the presentationTime + the duration of an event are smaller than the current video time.\n  * @param {number} currentVideoTime\n  * @param {number} threshold\n  * @param {number} calculatedPresentationTimeInSeconds\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _eventHasExpired(currentVideoTime, threshold, calculatedPresentationTimeInSeconds) {\n    try {\n      return currentVideoTime - threshold > calculatedPresentationTimeInSeconds;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * Checks if an event is invalid. This is the case if the end time of the parent period is smaller than the presentation time of the event.\n  * @param {object} event\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _eventIsInvalid(event) {\n    try {\n      var periodEndTime = event.eventStream.period.start + event.eventStream.period.duration;\n      return event.calculatedPresentationTime > periodEndTime;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * Starts an event. Depending on the schemeIdUri we distinguis between\n  * - MPD Reload events\n  * - MPD Callback events\n  * - Events to be dispatched to the application\n  * Events should be removed from the list before beeing triggered. Otherwise the event handler might cause an error and the remove function will not be called.\n  * @param {object} event\n  * @param {object} events\n  * @param {String} mode\n  * @private\n  */\n\n\n  function _startEvent(event, events, mode) {\n    try {\n      var currentVideoTime = playbackController.getTime();\n      var eventId = event.id;\n\n      if (mode === _MediaPlayerEvents2.default.EVENT_MODE_ON_RECEIVE) {\n        logger.debug('Received event ' + eventId);\n        eventBus.trigger(event.eventStream.schemeIdUri, {\n          event: event\n        }, {\n          mode: mode\n        });\n        return;\n      }\n\n      if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && event.eventStream.value === MPD_RELOAD_VALUE) {\n        if (event.duration !== 0 || event.presentationTimeDelta !== 0) {\n          //If both are set to zero, it indicates the media is over at this point. Don't reload the manifest.\n          logger.debug('Starting manifest refresh event ' + eventId + ' at ' + currentVideoTime);\n\n          _removeEvent(events, event);\n\n          _refreshManifest();\n        }\n      } else if (event.eventStream.schemeIdUri === MPD_CALLBACK_SCHEME && event.eventStream.value === MPD_CALLBACK_VALUE) {\n        logger.debug('Starting callback event ' + eventId + ' at ' + currentVideoTime);\n\n        _removeEvent(events, event);\n\n        _sendCallbackRequest(event.messageData);\n      } else {\n        logger.debug('Starting event ' + eventId + ' at ' + currentVideoTime);\n\n        _removeEvent(events, event);\n\n        eventBus.trigger(event.eventStream.schemeIdUri, {\n          event: event\n        }, {\n          mode: mode\n        });\n      }\n    } catch (e) {}\n  }\n  /**\n  * Removes an event from the list. If this is the last event of type \"schemeIdUri\"  the corresponding schemeIdUri Object in the list of events is deleted.\n  * @param {object} events\n  * @param {object} event\n  * @private\n  */\n\n\n  function _removeEvent(events, event) {\n    var schemeIdUri = event.eventStream.schemeIdUri;\n    var value = event.eventStream.value;\n    var id = event.id;\n    events[schemeIdUri] = events[schemeIdUri].filter(function (e) {\n      return value && e.eventStream.value && e.eventStream.value !== value || e.id !== id;\n    });\n\n    if (events[schemeIdUri].length === 0) {\n      delete events[schemeIdUri];\n    }\n  }\n  /**\n  * Refresh the manifest\n  * @private\n  */\n\n\n  function _refreshManifest() {\n    try {\n      checkConfig();\n      manifestUpdater.refreshManifest();\n    } catch (e) {}\n  }\n  /**\n  * Send a callback request\n  * @param {String} url\n  * @private\n  */\n\n\n  function _sendCallbackRequest(url) {\n    try {\n      var loader = (0, _XHRLoader2.default)(context).create({});\n      loader.load({\n        method: 'get',\n        url: url,\n        request: {\n          responseType: 'arraybuffer'\n        }\n      });\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Set the config of the EventController\n  * @param {object} config\n  */\n\n\n  function setConfig(config) {\n    try {\n      if (!config) {\n        return;\n      }\n\n      if (config.manifestUpdater) {\n        manifestUpdater = config.manifestUpdater;\n      }\n\n      if (config.playbackController) {\n        playbackController = config.playbackController;\n      }\n\n      if (config.settings) {\n        settings = config.settings;\n      }\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Returns all inline events that have not been triggered yet\n  * @return {object}\n  */\n\n\n  function getInlineEvents() {\n    return inlineEvents;\n  }\n  /**\n  * Returns all inband events that have not been triggered yet\n  * @return {object}\n  */\n\n\n  function getInbandEvents() {\n    return inbandEvents;\n  }\n  /**\n  * Stop the EventController and reset all initial settings\n  */\n\n\n  function reset() {\n    _stop();\n\n    _resetInitialSettings();\n  }\n\n  instance = {\n    addInlineEvents: addInlineEvents,\n    addInbandEvents: addInbandEvents,\n    getInbandEvents: getInbandEvents,\n    getInlineEvents: getInlineEvents,\n    start: start,\n    setConfig: setConfig,\n    reset: reset\n  };\n\n  _setup();\n\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nEventController.__dashjs_factory_name = 'EventController';\nexports.default = _FactoryMaker2.default.getSingletonFactory(EventController);","map":{"version":3,"mappings":"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","names":["EventController","MPD_RELOAD_SCHEME","MPD_RELOAD_VALUE","MPD_CALLBACK_SCHEME","MPD_CALLBACK_VALUE","REMAINING_EVENTS_THRESHOLD","EVENT_HANDLED_STATES","DISCARDED","UPDATED","ADDED","context","eventBus","getInstance","instance","logger","inlineEvents","inbandEvents","eventInterval","lastEventTimerCall","manifestUpdater","playbackController","settings","eventHandlingInProgress","isStarted","_setup","getLogger","_resetInitialSettings","checkConfig","Error","Date","now","_stop","clearInterval","_onStopEventController","e","start","debug","refreshDelay","get","streaming","eventControllerRefreshDelay","isNaN","setInterval","_onEventTimer","addInlineEvents","values","i","length","event","result","_addOrUpdateEvent","id","_startEvent","MediaPlayerEvents","EVENT_MODE_ON_RECEIVE","addInbandEvents","eventStream","schemeIdUri","undefined","_handleManifestReloadEvent","value","events","shouldOverwriteExistingEvents","eventState","indexOfExistingEvent","findIndex","push","validUntil","calculatedPresentationTime","newDuration","NaN","duration","trigger","MANIFEST_VALIDITY_CHANGED","newManifestValidAfter","mode","EVENT_MODE_ON_START","currentVideoTime","getTime","presentationTimeThreshold","Math","max","_triggerEvents","_triggerRemainingEvents","callback","_eventHasExpired","_eventIsInvalid","_removeEvent","_iterateAndTriggerCallback","currentTime","periodDuration","period","periodStart","calculatedPresentationTimeInSeconds","abs","schemeIdUris","Object","keys","schemeIdEvents","forEach","threshold","periodEndTime","eventId","presentationTimeDelta","_refreshManifest","_sendCallbackRequest","messageData","filter","refreshManifest","url","loader","create","load","method","request","responseType","setConfig","config","getInlineEvents","getInbandEvents","reset","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/controllers/EventController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport EventBus from '../../core/EventBus';\nimport MediaPlayerEvents from '../../streaming/MediaPlayerEvents';\nimport XHRLoader from '../net/XHRLoader';\n\nfunction EventController() {\n\n    const MPD_RELOAD_SCHEME = 'urn:mpeg:dash:event:2012';\n    const MPD_RELOAD_VALUE = 1;\n\n    const MPD_CALLBACK_SCHEME = 'urn:mpeg:dash:event:callback:2015';\n    const MPD_CALLBACK_VALUE = 1;\n\n    const REMAINING_EVENTS_THRESHOLD = 300;\n\n    const EVENT_HANDLED_STATES = {\n        DISCARDED: 'discarded',\n        UPDATED: 'updated',\n        ADDED: 'added'\n    };\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        inlineEvents, // Holds all Inline Events not triggered yet\n        inbandEvents, // Holds all Inband Events not triggered yet\n        eventInterval, // variable holding the setInterval\n        lastEventTimerCall,\n        manifestUpdater,\n        playbackController,\n        settings,\n        eventHandlingInProgress,\n        isStarted;\n\n    /**\n     * Internal setup when class is instanced\n     */\n    function _setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n    }\n\n    /**\n     * Checks if the provded configuration is valid\n     */\n    function checkConfig() {\n        if (!manifestUpdater || !playbackController) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    /**\n     * Reset to initial settings\n     */\n    function _resetInitialSettings() {\n        isStarted = false;\n        inlineEvents = {}; // Format inlineEvents[schemeIdUri]\n        inbandEvents = {}; // Format inlineEvents[schemeIdUri]\n        eventInterval = null;\n        eventHandlingInProgress = false;\n        lastEventTimerCall = Date.now() / 1000;\n    }\n\n    /**\n     * Stops the EventController by clearing the event interval\n     */\n    function _stop() {\n        try {\n            if (eventInterval !== null && isStarted) {\n                clearInterval(eventInterval);\n                eventInterval = null;\n                isStarted = false;\n                _onStopEventController();\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Starts the interval function of the EventController\n     */\n    function start() {\n        try {\n            checkConfig();\n            logger.debug('Start Event Controller');\n            const refreshDelay = settings.get().streaming.eventControllerRefreshDelay;\n            if (!isStarted && !isNaN(refreshDelay)) {\n                isStarted = true;\n                eventInterval = setInterval(_onEventTimer, refreshDelay);\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Add MPD events to the list of events.\n     * Events that are not in the MPD anymore but not triggered yet will still be deleted.\n     * Existing events might get updated.\n     * @param {Array.<Object>} values\n     */\n    function addInlineEvents(values) {\n        try {\n            checkConfig();\n\n            if (values) {\n                for (let i = 0; i < values.length; i++) {\n                    let event = values[i];\n                    let result = _addOrUpdateEvent(event, inlineEvents, true);\n\n                    if (result === EVENT_HANDLED_STATES.ADDED) {\n                        logger.debug(`Added inline event with id ${event.id}`);\n                        // If we see the event for the first time we trigger it in onReceive mode\n                        _startEvent(event, values, MediaPlayerEvents.EVENT_MODE_ON_RECEIVE);\n                    } else if (result === EVENT_HANDLED_STATES.UPDATED) {\n                        logger.debug(`Updated inline event with id ${event.id}`);\n                    }\n                }\n            }\n            logger.debug(`Added ${values.length} inline events`);\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Add EMSG events to the list of events\n     * Messages with the same id within the scope of the same scheme_id_uri and value pair are equivalent , i.e. processing of any one event message box with the same id is sufficient.\n     * @param {Array.<Object>} values\n     */\n    function addInbandEvents(values) {\n        try {\n            checkConfig();\n\n            for (let i = 0; i < values.length; i++) {\n                let event = values[i];\n                let result = _addOrUpdateEvent(event, inbandEvents, false);\n\n                if (result === EVENT_HANDLED_STATES.ADDED) {\n                    if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && inbandEvents[event.id] === undefined) {\n                        _handleManifestReloadEvent(event);\n                    }\n                    logger.debug('Added inband event with id ' + event.id);\n                    _startEvent(event, values, MediaPlayerEvents.EVENT_MODE_ON_RECEIVE);\n                } else {\n                    logger.debug(`Inband event with scheme_id_uri ${event.eventStream.schemeIdUri}, value ${event.eventStream.value} and id ${event.id} was ignored because it has been added before.`);\n                }\n            }\n            _onEventTimer();\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Adds or updates an event to/in the list of events\n     * @param {object} event\n     * @param {object} events\n     * @param {boolean} shouldOverwriteExistingEvents\n     * @return {string}\n     * @private\n     */\n    function _addOrUpdateEvent(event, events, shouldOverwriteExistingEvents = false) {\n        const schemeIdUri = event.eventStream.schemeIdUri;\n        const value = event.eventStream.value;\n        const id = event.id;\n        let eventState = EVENT_HANDLED_STATES.DISCARDED;\n\n        if (!events[schemeIdUri]) {\n            events[schemeIdUri] = [];\n        }\n\n        const indexOfExistingEvent = events[schemeIdUri].findIndex((e) => {\n            return ((!value || (e.eventStream.value && e.eventStream.value === value)) && (e.id === id));\n        });\n\n        if (indexOfExistingEvent === -1) {\n            events[schemeIdUri].push(event);\n            eventState = EVENT_HANDLED_STATES.ADDED;\n        } else if (shouldOverwriteExistingEvents) {\n            events[schemeIdUri][indexOfExistingEvent] = event;\n            eventState = EVENT_HANDLED_STATES.UPDATED;\n        }\n\n        return eventState;\n    }\n\n    /**\n     * Triggers an MPD reload\n     * @param {object} event\n     * @private\n     */\n    function _handleManifestReloadEvent(event) {\n        try {\n            if (event.eventStream.value == MPD_RELOAD_VALUE) {\n                const validUntil = event.calculatedPresentationTime;\n                let newDuration;\n                if (event.calculatedPresentationTime == 0xFFFFFFFF) {//0xFF... means remaining duration unknown\n                    newDuration = NaN;\n                } else {\n                    newDuration = event.calculatedPresentationTime + event.duration;\n                }\n                //logger.info('Manifest validity changed: Valid until: ' + validUntil + '; remaining duration: ' + newDuration);\n                eventBus.trigger(MediaPlayerEvents.MANIFEST_VALIDITY_CHANGED, {\n                    id: event.id,\n                    validUntil: validUntil,\n                    newDuration: newDuration,\n                    newManifestValidAfter: NaN //event.message_data - this is an arraybuffer with a timestring in it, but not used yet\n                }, {\n                    mode: MediaPlayerEvents.EVENT_MODE_ON_START\n                });\n            }\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Iterate through the eventList and trigger the events\n     */\n    function _onEventTimer() {\n        try {\n            if (!eventHandlingInProgress) {\n                eventHandlingInProgress = true;\n                const currentVideoTime = playbackController.getTime();\n                let presentationTimeThreshold = (currentVideoTime - lastEventTimerCall);\n\n                // For dynamic streams lastEventTimeCall will be large in the first iteration. Avoid firing all events at once.\n                presentationTimeThreshold = lastEventTimerCall > 0 ? Math.max(0, presentationTimeThreshold) : 0;\n\n                _triggerEvents(inbandEvents, presentationTimeThreshold, currentVideoTime);\n                _triggerEvents(inlineEvents, presentationTimeThreshold, currentVideoTime);\n\n                lastEventTimerCall = currentVideoTime;\n                eventHandlingInProgress = false;\n            }\n        } catch (e) {\n            eventHandlingInProgress = false;\n        }\n    }\n\n    /**\n     * When the EventController is stopped this callback is triggered. Starts the remaining events.\n     * @private\n     */\n    function _onStopEventController() {\n        try {\n            // EventController might be stopped before the period is over. Before we stop the event controller we check for events that needs to be triggered at the period boundary.\n            _triggerRemainingEvents(inbandEvents);\n            _triggerRemainingEvents(inlineEvents);\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Iterate over a list of events and trigger the ones for which the presentation time is within the current timing interval\n     * @param {object} events\n     * @param {number} presentationTimeThreshold\n     * @param {number} currentVideoTime\n     * @private\n     */\n    function _triggerEvents(events, presentationTimeThreshold, currentVideoTime) {\n        try {\n            const callback = function (event) {\n                if (event !== undefined) {\n                    const duration = !isNaN(event.duration) ? event.duration : 0;\n                    // The event is either about to start or has already been started and we are within its duration\n                    if ((event.calculatedPresentationTime <= currentVideoTime && event.calculatedPresentationTime + presentationTimeThreshold + duration >= currentVideoTime)) {\n                        _startEvent(event, events, MediaPlayerEvents.EVENT_MODE_ON_START);\n                    } else if (_eventHasExpired(currentVideoTime, duration + presentationTimeThreshold, event.calculatedPresentationTime) || _eventIsInvalid(event)) {\n                        logger.debug(`Deleting event ${event.id} as it is expired or invalid`);\n                        _removeEvent(events, event);\n                    }\n                }\n            };\n\n            _iterateAndTriggerCallback(events, callback);\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Triggers the remaining events after the EventController has been stopped\n     * @param {object} events\n     * @private\n     */\n    function _triggerRemainingEvents(events) {\n        try {\n            const currentTime = playbackController.getTime();\n            const callback = function (event) {\n                const periodDuration = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.duration) ? event.eventStream.period.duration : NaN;\n                const periodStart = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.start) ? event.eventStream.period.start : NaN;\n\n                if (isNaN(periodDuration) || isNaN(periodStart)) {\n                    return;\n                }\n\n                const calculatedPresentationTimeInSeconds = event.calculatedPresentationTime;\n\n                if (Math.abs(calculatedPresentationTimeInSeconds - currentTime) < REMAINING_EVENTS_THRESHOLD) {\n                    _startEvent(event, events, MediaPlayerEvents.EVENT_MODE_ON_START);\n                }\n\n            };\n\n            _iterateAndTriggerCallback(events, callback());\n\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Iterates over the inline/inband event object and triggers a callback for each event\n     * @param {object} events\n     * @param {function} callback\n     * @private\n     */\n    function _iterateAndTriggerCallback(events, callback) {\n        try {\n            if (events) {\n                const schemeIdUris = Object.keys(events);\n                for (let i = 0; i < schemeIdUris.length; i++) {\n                    const schemeIdEvents = events[schemeIdUris[i]];\n                    schemeIdEvents.forEach((event) => {\n                        if (event !== undefined) {\n                            callback(event);\n                        }\n                    });\n                }\n            }\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Checks if an event is expired. For instance if the presentationTime + the duration of an event are smaller than the current video time.\n     * @param {number} currentVideoTime\n     * @param {number} threshold\n     * @param {number} calculatedPresentationTimeInSeconds\n     * @return {boolean}\n     * @private\n     */\n    function _eventHasExpired(currentVideoTime, threshold, calculatedPresentationTimeInSeconds) {\n        try {\n            return currentVideoTime - threshold > calculatedPresentationTimeInSeconds;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Checks if an event is invalid. This is the case if the end time of the parent period is smaller than the presentation time of the event.\n     * @param {object} event\n     * @return {boolean}\n     * @private\n     */\n    function _eventIsInvalid(event) {\n        try {\n            const periodEndTime = event.eventStream.period.start + event.eventStream.period.duration;\n\n            return event.calculatedPresentationTime > periodEndTime;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Starts an event. Depending on the schemeIdUri we distinguis between\n     * - MPD Reload events\n     * - MPD Callback events\n     * - Events to be dispatched to the application\n     * Events should be removed from the list before beeing triggered. Otherwise the event handler might cause an error and the remove function will not be called.\n     * @param {object} event\n     * @param {object} events\n     * @param {String} mode\n     * @private\n     */\n    function _startEvent(event, events, mode) {\n        try {\n            const currentVideoTime = playbackController.getTime();\n            const eventId = event.id;\n\n            if (mode === MediaPlayerEvents.EVENT_MODE_ON_RECEIVE) {\n                logger.debug(`Received event ${eventId}`);\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\n                return;\n            }\n\n            if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && event.eventStream.value === MPD_RELOAD_VALUE) {\n                if (event.duration !== 0 || event.presentationTimeDelta !== 0) { //If both are set to zero, it indicates the media is over at this point. Don't reload the manifest.\n                    logger.debug(`Starting manifest refresh event ${eventId} at ${currentVideoTime}`);\n                    _removeEvent(events, event);\n                    _refreshManifest();\n                }\n            } else if (event.eventStream.schemeIdUri === MPD_CALLBACK_SCHEME && event.eventStream.value === MPD_CALLBACK_VALUE) {\n                logger.debug(`Starting callback event ${eventId} at ${currentVideoTime}`);\n                _removeEvent(events, event);\n                _sendCallbackRequest(event.messageData);\n            } else {\n                logger.debug(`Starting event ${eventId} at ${currentVideoTime}`);\n                _removeEvent(events, event);\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\n            }\n\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Removes an event from the list. If this is the last event of type \"schemeIdUri\"  the corresponding schemeIdUri Object in the list of events is deleted.\n     * @param {object} events\n     * @param {object} event\n     * @private\n     */\n    function _removeEvent(events, event) {\n        const schemeIdUri = event.eventStream.schemeIdUri;\n        const value = event.eventStream.value;\n        const id = event.id;\n\n        events[schemeIdUri] = events[schemeIdUri].filter((e) => {\n            return (value && e.eventStream.value && e.eventStream.value !== value) || (e.id !== id);\n        });\n\n        if (events[schemeIdUri].length === 0) {\n            delete events[schemeIdUri];\n        }\n\n    }\n\n    /**\n     * Refresh the manifest\n     * @private\n     */\n    function _refreshManifest() {\n        try {\n            checkConfig();\n            manifestUpdater.refreshManifest();\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Send a callback request\n     * @param {String} url\n     * @private\n     */\n    function _sendCallbackRequest(url) {\n        try {\n            let loader = XHRLoader(context).create({});\n            loader.load({\n                method: 'get',\n                url: url,\n                request: {\n                    responseType: 'arraybuffer'\n                }\n            });\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Set the config of the EventController\n     * @param {object} config\n     */\n    function setConfig(config) {\n        try {\n            if (!config) {\n                return;\n            }\n            if (config.manifestUpdater) {\n                manifestUpdater = config.manifestUpdater;\n            }\n            if (config.playbackController) {\n                playbackController = config.playbackController;\n            }\n            if (config.settings) {\n                settings = config.settings;\n            }\n\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Returns all inline events that have not been triggered yet\n     * @return {object}\n     */\n    function getInlineEvents() {\n        return inlineEvents;\n    }\n\n    /**\n     * Returns all inband events that have not been triggered yet\n     * @return {object}\n     */\n    function getInbandEvents() {\n        return inbandEvents;\n    }\n\n    /**\n     * Stop the EventController and reset all initial settings\n     */\n    function reset() {\n        _stop();\n        _resetInitialSettings();\n    }\n\n    instance = {\n        addInlineEvents,\n        addInbandEvents,\n        getInbandEvents,\n        getInlineEvents,\n        start,\n        setConfig,\n        reset\n    };\n\n    _setup();\n\n    return instance;\n}\n\nEventController.__dashjs_factory_name = 'EventController';\nexport default FactoryMaker.getSingletonFactory(EventController);\n"]},"metadata":{},"sourceType":"script"}