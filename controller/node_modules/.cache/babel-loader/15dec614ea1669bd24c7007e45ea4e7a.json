{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _MetricsConstants = require('../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500;\n\nfunction PlaybackController() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      streamController = void 0,\n      dashMetrics = void 0,\n      adapter = void 0,\n      videoModel = void 0,\n      timelineConverter = void 0,\n      streamSwitch = void 0,\n      streamSeekTime = void 0,\n      wallclockTimeIntervalId = void 0,\n      liveDelay = void 0,\n      streamInfo = void 0,\n      isDynamic = void 0,\n      mediaPlayerModel = void 0,\n      playOnceInitialized = void 0,\n      lastLivePlaybackTime = void 0,\n      availabilityStartTime = void 0,\n      seekTarget = void 0,\n      internalSeek = void 0,\n      isLowLatencySeekingInProgress = void 0,\n      playbackStalled = void 0,\n      minPlaybackRateChange = void 0,\n      uriFragmentModel = void 0,\n      settings = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    reset();\n  }\n\n  function initialize(sInfo, periodSwitch, seekTime) {\n    streamInfo = sInfo;\n    addAllListeners();\n    isDynamic = streamInfo.manifestInfo.isDynamic;\n    isLowLatencySeekingInProgress = false;\n    playbackStalled = false;\n    streamSwitch = periodSwitch === true;\n    streamSeekTime = seekTime;\n    internalSeek = false;\n    var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : ''; // Detect safari browser (special behavior for low latency streams)\n\n    var isSafari = /safari/.test(ua) && !/chrome/.test(ua);\n    minPlaybackRateChange = isSafari ? 0.25 : 0.02;\n    eventBus.on(_Events2.default.STREAM_INITIALIZED, onStreamInitialized, this);\n    eventBus.on(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n    eventBus.on(_Events2.default.LOADING_PROGRESS, onFragmentLoadProgress, this);\n    eventBus.on(_Events2.default.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n    eventBus.on(_Events2.default.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n    eventBus.on(_Events2.default.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n    eventBus.on(_Events2.default.PLAYBACK_ENDED, onPlaybackEnded, this, {\n      priority: _EventBus2.default.EVENT_PRIORITY_HIGH\n    });\n    eventBus.on(_Events2.default.STREAM_INITIALIZING, onStreamInitializing, this);\n\n    if (playOnceInitialized) {\n      playOnceInitialized = false;\n      play();\n    }\n  }\n\n  function onStreamInitialized(e) {\n    // Seamless period switch\n    if (streamSwitch && isNaN(streamSeekTime)) return; // Seek new stream in priority order:\n    // - at seek time (streamSeekTime) when switching period\n    // - at start time provided in URI parameters\n    // - at stream/period start time (for static streams) or live start time (for dynamic streams)\n\n    var startTime = streamSeekTime;\n\n    if (isNaN(startTime)) {\n      if (isDynamic) {\n        // For dynamic stream, start by default at (live edge - live delay)\n        startTime = e.liveStartTime; // If start time in URI, take min value between live edge time and time from URI (capped by DVR window range)\n\n        var dvrInfo = dashMetrics.getCurrentDVRInfo();\n        var dvrWindow = dvrInfo ? dvrInfo.range : null;\n\n        if (dvrWindow) {\n          // #t shall be relative to period start\n          var startTimeFromUri = getStartTimeFromUriParameters(true);\n\n          if (!isNaN(startTimeFromUri)) {\n            logger.info('Start time from URI parameters: ' + startTimeFromUri);\n            startTime = Math.max(Math.min(startTime, startTimeFromUri), dvrWindow.start);\n          }\n        }\n      } else {\n        // For static stream, start by default at period start\n        startTime = streamInfo.start; // If start time in URI, take max value between period start and time from URI (if in period range)\n\n        var _startTimeFromUri = getStartTimeFromUriParameters(false);\n\n        if (!isNaN(_startTimeFromUri) && _startTimeFromUri < startTime + streamInfo.duration) {\n          logger.info('Start time from URI parameters: ' + _startTimeFromUri);\n          startTime = Math.max(startTime, _startTimeFromUri);\n        }\n      }\n    }\n\n    if (!isNaN(startTime) && startTime !== videoModel.getTime()) {\n      // Trigger PLAYBACK_SEEKING event for controllers\n      eventBus.trigger(_Events2.default.PLAYBACK_SEEKING, {\n        seekTime: startTime\n      }); // Seek video model\n\n      seek(startTime, false, true);\n    }\n  }\n\n  function getTimeToStreamEnd() {\n    return parseFloat((getStreamEndTime() - getTime()).toFixed(5));\n  }\n\n  function getStreamEndTime() {\n    return streamInfo.start + streamInfo.duration;\n  }\n\n  function play() {\n    if (streamInfo && videoModel && videoModel.getElement()) {\n      videoModel.play();\n    } else {\n      playOnceInitialized = true;\n    }\n  }\n\n  function isPaused() {\n    return streamInfo && videoModel ? videoModel.isPaused() : null;\n  }\n\n  function pause() {\n    if (streamInfo && videoModel) {\n      videoModel.pause();\n    }\n  }\n\n  function isSeeking() {\n    return streamInfo && videoModel ? videoModel.isSeeking() : null;\n  }\n\n  function seek(time, stickToBuffered, internal) {\n    if (!streamInfo || !videoModel) return;\n    var currentTime = !isNaN(seekTarget) ? seekTarget : videoModel.getTime();\n    if (time === currentTime) return;\n    internalSeek = internal === true;\n\n    if (!internalSeek) {\n      seekTarget = time;\n      eventBus.trigger(_Events2.default.PLAYBACK_SEEK_ASKED);\n    }\n\n    logger.info('Requesting seek to time: ' + time + (internalSeek ? ' (internal)' : ''));\n    videoModel.setCurrentTime(time, stickToBuffered);\n  }\n\n  function seekToLive() {\n    var DVRMetrics = dashMetrics.getCurrentDVRInfo();\n    var DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n    seek(DVRWindow.end - mediaPlayerModel.getLiveDelay(), true, false);\n  }\n\n  function getTime() {\n    return streamInfo && videoModel ? videoModel.getTime() : null;\n  }\n\n  function getNormalizedTime() {\n    var t = getTime();\n\n    if (isDynamic && !isNaN(availabilityStartTime)) {\n      var timeOffset = availabilityStartTime / 1000; // Fix current time for firefox and safari (returned as an absolute time)\n\n      if (t > timeOffset) {\n        t -= timeOffset;\n      }\n    }\n\n    return t;\n  }\n\n  function getPlaybackRate() {\n    return streamInfo && videoModel ? videoModel.getPlaybackRate() : null;\n  }\n\n  function getPlayedRanges() {\n    return streamInfo && videoModel ? videoModel.getPlayedRanges() : null;\n  }\n\n  function getEnded() {\n    return streamInfo && videoModel ? videoModel.getEnded() : null;\n  }\n\n  function getIsDynamic() {\n    return isDynamic;\n  }\n\n  function getStreamController() {\n    return streamController;\n  }\n  /**\n  * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge\n  * @param {number} fragmentDuration - seconds?\n  * @param {number} dvrWindowSize - seconds?\n  * @param {number} minBufferTime - seconds?\n  * @returns {number} object\n  * @memberof PlaybackController#\n  */\n\n\n  function computeAndSetLiveDelay(fragmentDuration, dvrWindowSize, minBufferTime) {\n    var delay = void 0,\n        ret = void 0,\n        startTime = void 0;\n    var END_OF_PLAYLIST_PADDING = 10;\n    var MIN_BUFFER_TIME_FACTOR = 4;\n    var FRAGMENT_DURATION_FACTOR = 4;\n    var adjustedFragmentDuration = !isNaN(fragmentDuration) && isFinite(fragmentDuration) ? fragmentDuration : NaN;\n    var suggestedPresentationDelay = adapter.getSuggestedPresentationDelay();\n\n    if (settings.get().streaming.lowLatencyEnabled) {\n      delay = 0;\n    } else if (mediaPlayerModel.getLiveDelay()) {\n      delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence\n    } else if (settings.get().streaming.liveDelayFragmentCount !== null && !isNaN(settings.get().streaming.liveDelayFragmentCount) && !isNaN(adjustedFragmentDuration)) {\n      delay = adjustedFragmentDuration * settings.get().streaming.liveDelayFragmentCount;\n    } else if (settings.get().streaming.useSuggestedPresentationDelay === true && suggestedPresentationDelay !== null && !isNaN(suggestedPresentationDelay) && suggestedPresentationDelay > 0) {\n      delay = suggestedPresentationDelay;\n    } else if (!isNaN(adjustedFragmentDuration)) {\n      delay = adjustedFragmentDuration * FRAGMENT_DURATION_FACTOR;\n    } else {\n      delay = !isNaN(minBufferTime) ? minBufferTime * MIN_BUFFER_TIME_FACTOR : streamInfo.manifestInfo.minBufferTime * MIN_BUFFER_TIME_FACTOR;\n    }\n\n    startTime = adapter.getAvailabilityStartTime();\n\n    if (startTime !== null) {\n      availabilityStartTime = startTime;\n    }\n\n    if (dvrWindowSize > 0) {\n      // cap target latency to:\n      // - dvrWindowSize / 2 for short playlists\n      // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists\n      var targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2);\n      ret = Math.min(delay, targetDelayCapping);\n    } else {\n      ret = delay;\n    }\n\n    liveDelay = ret;\n    return ret;\n  }\n\n  function getLiveDelay() {\n    return liveDelay;\n  }\n\n  function setLiveDelay(value) {\n    var useMaxValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (useMaxValue && value < liveDelay) {\n      return;\n    }\n\n    liveDelay = value;\n  }\n\n  function getCurrentLiveLatency() {\n    if (!isDynamic || isNaN(availabilityStartTime)) {\n      return NaN;\n    }\n\n    var currentTime = getNormalizedTime();\n\n    if (isNaN(currentTime) || currentTime === 0) {\n      return 0;\n    }\n\n    var now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000;\n    return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0);\n  }\n\n  function reset() {\n    playOnceInitialized = false;\n    streamSwitch = false;\n    streamSeekTime = NaN;\n    liveDelay = 0;\n    availabilityStartTime = 0;\n    seekTarget = NaN;\n\n    if (videoModel) {\n      eventBus.off(_Events2.default.STREAM_INITIALIZED, onStreamInitialized, this);\n      eventBus.off(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n      eventBus.off(_Events2.default.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n      eventBus.off(_Events2.default.LOADING_PROGRESS, onFragmentLoadProgress, this);\n      eventBus.off(_Events2.default.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n      eventBus.off(_Events2.default.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n      eventBus.off(_Events2.default.PLAYBACK_ENDED, onPlaybackEnded, this);\n      eventBus.off(_Events2.default.STREAM_INITIALIZING, onStreamInitializing, this);\n      stopUpdatingWallclockTime();\n      removeAllListeners();\n    }\n\n    wallclockTimeIntervalId = null;\n    videoModel = null;\n    streamInfo = null;\n    isDynamic = null;\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.streamController) {\n      streamController = config.streamController;\n    }\n\n    if (config.dashMetrics) {\n      dashMetrics = config.dashMetrics;\n    }\n\n    if (config.mediaPlayerModel) {\n      mediaPlayerModel = config.mediaPlayerModel;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n\n    if (config.videoModel) {\n      videoModel = config.videoModel;\n    }\n\n    if (config.timelineConverter) {\n      timelineConverter = config.timelineConverter;\n    }\n\n    if (config.uriFragmentModel) {\n      uriFragmentModel = config.uriFragmentModel;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n  }\n\n  function getStartTimeFromUriParameters(isDynamic) {\n    var fragData = uriFragmentModel.getURIFragmentData();\n\n    if (!fragData || !fragData.t) {\n      return NaN;\n    }\n\n    var refStream = streamController.getStreams()[0];\n    var refStreamStartTime = refStream.getStreamInfo().start; // Consider only start time of MediaRange\n    // TODO: consider end time of MediaRange to stop playback at provided end time\n\n    fragData.t = fragData.t.split(',')[0]; // \"t=<time>\" : time is relative to 1st period start\n    // \"t=posix:<time>\" : time is absolute start time as number of seconds since 01-01-1970\n\n    var posix = fragData.t.indexOf('posix:') !== -1 ? fragData.t.substring(6) === 'now' ? Date.now() / 1000 : parseInt(fragData.t.substring(6)) : NaN;\n    var startTime = isDynamic && !isNaN(posix) ? posix - availabilityStartTime / 1000 : parseInt(fragData.t) + refStreamStartTime;\n    return startTime;\n  }\n\n  function getActualPresentationTime(currentTime, mediatype) {\n    var DVRMetrics = dashMetrics.getCurrentDVRInfo(mediatype);\n    var DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n    var actualTime = void 0;\n\n    if (!DVRWindow) {\n      return NaN;\n    }\n\n    logger.debug('Checking DVR window for at ' + currentTime + ' with DVR window range ' + DVRWindow.start + ' - ' + DVRWindow.end);\n\n    if (currentTime > DVRWindow.end) {\n      actualTime = Math.max(DVRWindow.end - liveDelay, DVRWindow.start);\n    } else if (currentTime > 0 && currentTime + 0.250 < DVRWindow.start && Math.abs(currentTime - DVRWindow.start) < 315360000) {\n      // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz\n      // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate\n      // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource\n      // Checking also duration of the DVR makes sense. We detected temporary situations in which currentTime\n      // is bad reported by the browser which causes playback to jump to start (315360000 = 1 year)\n      //actualTime = DVRWindow.start;\n      actualTime = DVRWindow.start;\n    } else {\n      actualTime = currentTime;\n    }\n\n    return actualTime;\n  }\n\n  function startUpdatingWallclockTime() {\n    if (wallclockTimeIntervalId !== null) return;\n\n    var tick = function tick() {\n      onWallclockTime();\n    };\n\n    wallclockTimeIntervalId = setInterval(tick, settings.get().streaming.wallclockTimeUpdateInterval);\n  }\n\n  function stopUpdatingWallclockTime() {\n    clearInterval(wallclockTimeIntervalId);\n    wallclockTimeIntervalId = null;\n  }\n\n  function updateCurrentTime(mediaType) {\n    if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return;\n    var currentTime = getNormalizedTime();\n    var actualTime = getActualPresentationTime(currentTime, mediaType);\n    var timeChanged = !isNaN(actualTime) && actualTime !== currentTime;\n\n    if (timeChanged && !isSeeking()) {\n      logger.debug('UpdateCurrentTime: Seek to actual time: ' + actualTime + ' from currentTime: ' + currentTime);\n      seek(actualTime);\n    }\n  }\n\n  function onDataUpdateCompleted(e) {\n    if (e.error) return;\n    var representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\n    var info = representationInfo ? representationInfo.mediaInfo.streamInfo : null;\n    if (info === null || streamInfo.id !== info.id) return;\n    streamInfo = info;\n    updateCurrentTime();\n  }\n\n  function onCanPlay() {\n    eventBus.trigger(_Events2.default.CAN_PLAY);\n  }\n\n  function onPlaybackStart() {\n    logger.info('Native video element event: play');\n    updateCurrentTime();\n    startUpdatingWallclockTime();\n    eventBus.trigger(_Events2.default.PLAYBACK_STARTED, {\n      startTime: getTime()\n    });\n  }\n\n  function onPlaybackWaiting() {\n    logger.info('Native video element event: waiting');\n    eventBus.trigger(_Events2.default.PLAYBACK_WAITING, {\n      playingTime: getTime()\n    });\n  }\n\n  function onPlaybackPlaying() {\n    logger.info('Native video element event: playing');\n    eventBus.trigger(_Events2.default.PLAYBACK_PLAYING, {\n      playingTime: getTime()\n    });\n  }\n\n  function onPlaybackPaused() {\n    logger.info('Native video element event: pause');\n    eventBus.trigger(_Events2.default.PLAYBACK_PAUSED, {\n      ended: getEnded()\n    });\n  }\n\n  function onPlaybackSeeking() {\n    // Check if internal seeking to be ignored\n    if (internalSeek) {\n      internalSeek = false;\n      return;\n    }\n\n    var seekTime = getTime(); // On some browsers/devices, in case of live streams, setting current time on video element fails when there is no buffered data at requested time\n    // Then re-set seek target time and video element will be seeked afterwhile once data is buffered (see BufferContoller)\n\n    if (!isNaN(seekTarget) && seekTarget !== seekTime) {\n      seekTime = seekTarget;\n    }\n\n    seekTarget = NaN;\n    logger.info('Seeking to: ' + seekTime);\n    startUpdatingWallclockTime();\n    eventBus.trigger(_Events2.default.PLAYBACK_SEEKING, {\n      seekTime: seekTime\n    });\n  }\n\n  function onPlaybackSeeked() {\n    logger.info('Native video element event: seeked');\n    eventBus.trigger(_Events2.default.PLAYBACK_SEEKED);\n  }\n\n  function onPlaybackTimeUpdated() {\n    if (streamInfo) {\n      eventBus.trigger(_Events2.default.PLAYBACK_TIME_UPDATED, {\n        timeToEnd: getTimeToStreamEnd(),\n        time: getTime()\n      });\n    }\n  }\n\n  function updateLivePlaybackTime() {\n    var now = Date.now();\n\n    if (!lastLivePlaybackTime || now > lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) {\n      lastLivePlaybackTime = now;\n      onPlaybackTimeUpdated();\n    }\n  }\n\n  function onPlaybackProgress() {\n    eventBus.trigger(_Events2.default.PLAYBACK_PROGRESS);\n  }\n\n  function onPlaybackRateChanged() {\n    var rate = getPlaybackRate();\n    logger.info('Native video element event: ratechange: ', rate);\n    eventBus.trigger(_Events2.default.PLAYBACK_RATE_CHANGED, {\n      playbackRate: rate\n    });\n  }\n\n  function onPlaybackMetaDataLoaded() {\n    logger.info('Native video element event: loadedmetadata');\n    eventBus.trigger(_Events2.default.PLAYBACK_METADATA_LOADED);\n    startUpdatingWallclockTime();\n  } // Event to handle the native video element ended event\n\n\n  function onNativePlaybackEnded() {\n    logger.info('Native video element event: ended');\n    pause();\n    stopUpdatingWallclockTime();\n    var streamInfo = streamController ? streamController.getActiveStreamInfo() : null;\n    if (!streamInfo) return;\n    eventBus.trigger(_Events2.default.PLAYBACK_ENDED, {\n      'isLast': streamInfo.isLast\n    });\n  } // Handle DASH PLAYBACK_ENDED event\n\n\n  function onPlaybackEnded(e) {\n    if (wallclockTimeIntervalId && e.isLast) {\n      // PLAYBACK_ENDED was triggered elsewhere, react.\n      logger.info('onPlaybackEnded -- PLAYBACK_ENDED but native video element didn\\'t fire ended');\n      var seekTime = e.seekTime ? e.seekTime : getStreamEndTime();\n      videoModel.setCurrentTime(seekTime);\n      pause();\n      stopUpdatingWallclockTime();\n    }\n  }\n\n  function onPlaybackError(event) {\n    var target = event.target || event.srcElement;\n    eventBus.trigger(_Events2.default.PLAYBACK_ERROR, {\n      error: target.error\n    });\n  }\n\n  function onWallclockTime() {\n    eventBus.trigger(_Events2.default.WALLCLOCK_TIME_UPDATED, {\n      isDynamic: isDynamic,\n      time: new Date()\n    }); // Updates playback time for paused dynamic streams\n    // (video element doesn't call timeupdate when the playback is paused)\n\n    if (getIsDynamic() && isPaused()) {\n      updateLivePlaybackTime();\n    }\n  }\n\n  function onPlaybackProgression() {\n    if (isDynamic && _isCatchupEnabled() && settings.get().streaming.liveCatchup.playbackRate > 0 && !isPaused() && !isSeeking()) {\n      if (_needToCatchUp()) {\n        startPlaybackCatchUp();\n      } else {\n        stopPlaybackCatchUp();\n      }\n    }\n  }\n\n  function _isCatchupEnabled() {\n    return settings.get().streaming.liveCatchup.enabled || settings.get().streaming.lowLatencyEnabled;\n  }\n\n  function getBufferLevel() {\n    var bufferLevel = null;\n    streamController.getActiveStreamProcessors().forEach(function (p) {\n      var bl = p.getBufferLevel();\n\n      if (bufferLevel === null) {\n        bufferLevel = bl;\n      } else {\n        bufferLevel = Math.min(bufferLevel, bl);\n      }\n    });\n    return bufferLevel;\n  }\n  /**\n  * Returns the mode for live playback catchup.\n  * @return {String}\n  * @private\n  */\n\n\n  function _getCatchupMode() {\n    var playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n    return settings.get().streaming.liveCatchup.mode === _Constants2.default.LIVE_CATCHUP_MODE_LOLP && playbackBufferMin !== null && !isNaN(playbackBufferMin) ? _Constants2.default.LIVE_CATCHUP_MODE_LOLP : _Constants2.default.LIVE_CATCHUP_MODE_DEFAULT;\n  }\n  /**\n  * Checks whether the catchup mechanism should be enabled\n  * @return {boolean}\n  */\n\n\n  function _needToCatchUp() {\n    try {\n      if (_isCatchupEnabled() && settings.get().streaming.liveCatchup.playbackRate > 0 && getTime() > 0) {\n        var catchupMode = _getCatchupMode();\n\n        var currentLiveLatency = getCurrentLiveLatency();\n\n        var _liveDelay = mediaPlayerModel.getLiveDelay();\n\n        var liveCatchupLatencyThreshold = mediaPlayerModel.getLiveCatchupLatencyThreshold();\n        var liveCatchUpMinDrift = settings.get().streaming.liveCatchup.minDrift;\n\n        if (catchupMode === _Constants2.default.LIVE_CATCHUP_MODE_LOLP) {\n          var currentBuffer = getBufferLevel();\n          var playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n          return _lolpNeedToCatchUpCustom(currentLiveLatency, _liveDelay, liveCatchUpMinDrift, currentBuffer, playbackBufferMin, liveCatchupLatencyThreshold);\n        } else {\n          return _defaultNeedToCatchUp(currentLiveLatency, _liveDelay, liveCatchupLatencyThreshold, liveCatchUpMinDrift);\n        }\n      }\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * Default algorithm to determine if catchup mode should be enabled\n  * @param {number} currentLiveLatency\n  * @param {number} liveDelay\n  * @param {number} liveCatchupLatencyThreshold\n  * @param {number} minDrift\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _defaultNeedToCatchUp(currentLiveLatency, liveDelay, liveCatchupLatencyThreshold, minDrift) {\n    try {\n      var latencyDrift = Math.abs(currentLiveLatency - liveDelay);\n      return latencyDrift > minDrift && (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold);\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * LoL+ logic to determine if catchup mode should be enabled\n  * @param {number} currentLiveLatency\n  * @param {number} liveDelay\n  * @param {number} minDrift\n  * @param {number} currentBuffer\n  * @param {number} playbackBufferMin\n  * @param {number} liveCatchupLatencyThreshold\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _lolpNeedToCatchUpCustom(currentLiveLatency, liveDelay, minDrift, currentBuffer, playbackBufferMin, liveCatchupLatencyThreshold) {\n    try {\n      var latencyDrift = Math.abs(currentLiveLatency - liveDelay);\n      return (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold) && (latencyDrift > minDrift || currentBuffer < playbackBufferMin);\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * Apply catchup mode\n  */\n\n\n  function startPlaybackCatchUp() {\n    if (videoModel) {\n      var results = void 0;\n      var currentPlaybackRate = videoModel.getPlaybackRate();\n      var liveCatchupPlaybackRate = settings.get().streaming.liveCatchup.playbackRate;\n      var currentLiveLatency = getCurrentLiveLatency();\n\n      var _liveDelay2 = mediaPlayerModel.getLiveDelay();\n\n      var bufferLevel = getBufferLevel(); // Custom playback control: Based on buffer level\n\n      if (_getCatchupMode() === _Constants2.default.LIVE_CATCHUP_MODE_LOLP) {\n        var liveCatchUpMinDrift = settings.get().streaming.liveCatchup.minDrift;\n        var playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n        results = _calculateNewPlaybackRateLolP(liveCatchupPlaybackRate, currentLiveLatency, _liveDelay2, liveCatchUpMinDrift, playbackBufferMin, bufferLevel, currentPlaybackRate);\n      } else {\n        // Default playback control: Based on target and current latency\n        results = _calculateNewPlaybackRateDefault(liveCatchupPlaybackRate, currentLiveLatency, _liveDelay2, bufferLevel, currentPlaybackRate);\n      } // Obtain newRate and apply to video model\n\n\n      var newRate = results.newRate;\n\n      if (newRate) {\n        // non-null\n        videoModel.setPlaybackRate(newRate);\n      }\n\n      var deltaLatency = currentLiveLatency - _liveDelay2;\n\n      if (settings.get().streaming.liveCatchup.maxDrift > 0 && !isLowLatencySeekingInProgress && deltaLatency > settings.get().streaming.liveCatchup.maxDrift) {\n        logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point');\n        isLowLatencySeekingInProgress = true;\n        seekToLive();\n      } else {\n        isLowLatencySeekingInProgress = false;\n      }\n    }\n  }\n  /**\n  * Default algorithm to calculate the new playback rate\n  * @param {number} liveCatchUpPlaybackRate\n  * @param {number} currentLiveLatency\n  * @param {number} liveDelay\n  * @param {number} bufferLevel\n  * @param {number} currentPlaybackRate\n  * @return {{newRate: number}}\n  * @private\n  */\n\n\n  function _calculateNewPlaybackRateDefault(liveCatchUpPlaybackRate, currentLiveLatency, liveDelay, bufferLevel, currentPlaybackRate) {\n    var cpr = liveCatchUpPlaybackRate;\n    var deltaLatency = currentLiveLatency - liveDelay;\n    var d = deltaLatency * 5; // Playback rate must be between (1 - cpr) - (1 + cpr)\n    // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n\n    var s = cpr * 2 / (1 + Math.pow(Math.E, -d));\n    var newRate = 1 - cpr + s; // take into account situations in which there are buffer stalls,\n    // in which increasing playbackRate to reach target latency will\n    // just cause more and more stall situations\n\n    if (playbackStalled) {\n      // const bufferLevel = getBufferLevel();\n      if (bufferLevel > liveDelay / 2) {\n        // playbackStalled = false;\n        playbackStalled = false;\n      } else if (deltaLatency > 0) {\n        newRate = 1.0;\n      }\n    } // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n\n\n    if (Math.abs(currentPlaybackRate - newRate) <= minPlaybackRateChange) {\n      newRate = null;\n    }\n\n    return {\n      newRate: newRate\n    };\n  }\n  /**\n  * Lol+ algorithm to calculate the new playback rate\n  * @param {number} liveCatchUpPlaybackRate\n  * @param {number} currentLiveLatency\n  * @param {number} liveDelay\n  * @param {number} minDrift\n  * @param {number} playbackBufferMin\n  * @param {number} bufferLevel\n  * @param {number} currentPlaybackRate\n  * @return {{newRate: number}}\n  * @private\n  */\n\n\n  function _calculateNewPlaybackRateLolP(liveCatchUpPlaybackRate, currentLiveLatency, liveDelay, minDrift, playbackBufferMin, bufferLevel, currentPlaybackRate) {\n    var cpr = liveCatchUpPlaybackRate;\n    var newRate = void 0; // Hybrid: Buffer-based\n\n    if (bufferLevel < playbackBufferMin) {\n      // Buffer in danger, slow down\n      var deltaBuffer = bufferLevel - playbackBufferMin; // -ve value\n\n      var d = deltaBuffer * 5; // Playback rate must be between (1 - cpr) - (1 + cpr)\n      // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n\n      var s = cpr * 2 / (1 + Math.pow(Math.E, -d));\n      newRate = 1 - cpr + s;\n      logger.debug('[LoL+ playback control_buffer-based] bufferLevel: ' + bufferLevel + ', newRate: ' + newRate);\n    } else {\n      // Hybrid: Latency-based\n      // Buffer is safe, vary playback rate based on latency\n      // Check if latency is within range of target latency\n      var minDifference = 0.02;\n\n      if (Math.abs(currentLiveLatency - liveDelay) <= minDifference * liveDelay) {\n        newRate = 1;\n      } else {\n        var deltaLatency = currentLiveLatency - liveDelay;\n\n        var _d = deltaLatency * 5; // Playback rate must be between (1 - cpr) - (1 + cpr)\n        // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n\n\n        var _s = cpr * 2 / (1 + Math.pow(Math.E, -_d));\n\n        newRate = 1 - cpr + _s;\n      }\n\n      logger.debug('[LoL+ playback control_latency-based] latency: ' + currentLiveLatency + ', newRate: ' + newRate);\n    }\n\n    if (playbackStalled) {\n      if (bufferLevel > liveDelay / 2) {\n        playbackStalled = false;\n      }\n    } // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n\n\n    if (Math.abs(currentPlaybackRate - newRate) <= minPlaybackRateChange) {\n      newRate = null;\n    }\n\n    return {\n      newRate: newRate\n    };\n  }\n\n  function stopPlaybackCatchUp() {\n    if (videoModel) {\n      videoModel.setPlaybackRate(1.0);\n    }\n  }\n\n  function onFragmentLoadProgress(e) {\n    // If using fetch and stream mode is not available, readjust live latency so it is 20% higher than segment duration\n    if (e.stream === false && settings.get().streaming.lowLatencyEnabled && !isNaN(e.request.duration)) {\n      var minDelay = 1.2 * e.request.duration;\n\n      if (minDelay > mediaPlayerModel.getLiveDelay()) {\n        logger.warn('Browser does not support fetch API with StreamReader. Increasing live delay to be 20% higher than segment duration:', minDelay.toFixed(2));\n        var s = {\n          streaming: {\n            liveDelay: minDelay\n          }\n        };\n        settings.update(s);\n      }\n    }\n  }\n\n  function onBufferLevelStateChanged(e) {\n    // do not stall playback when get an event from Stream that is not active\n    if (e.streamId !== streamInfo.id) return;\n\n    if (_isCatchupEnabled()) {\n      if (e.state === _MetricsConstants2.default.BUFFER_EMPTY && !isSeeking()) {\n        if (!playbackStalled) {\n          playbackStalled = true;\n          stopPlaybackCatchUp();\n        }\n      }\n    } else {\n      videoModel.setStallState(e.mediaType, e.state === _MetricsConstants2.default.BUFFER_EMPTY);\n    }\n  }\n\n  function onPlaybackStalled(e) {\n    eventBus.trigger(_Events2.default.PLAYBACK_STALLED, {\n      e: e\n    });\n  }\n\n  function onStreamInitializing(e) {\n    applyServiceDescription(e.streamInfo, e.mediaInfo);\n  }\n\n  function applyServiceDescription(streamInfo, mediaInfo) {\n    if (streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.serviceDescriptions) {\n      // is there a service description for low latency defined?\n      var llsd = void 0;\n\n      for (var i = 0; i < streamInfo.manifestInfo.serviceDescriptions.length; i++) {\n        var sd = streamInfo.manifestInfo.serviceDescriptions[i];\n\n        if (sd.schemeIdUri === _Constants2.default.SERVICE_DESCRIPTION_LL_SCHEME) {\n          llsd = sd;\n          break;\n        }\n      }\n\n      if (llsd) {\n        if (mediaInfo && mediaInfo.supplementalProperties && mediaInfo.supplementalProperties[_Constants2.default.SUPPLEMENTAL_PROPERTY_LL_SCHEME] === 'true') {\n          if (llsd.latency && llsd.latency.target > 0) {\n            logger.debug('Apply LL properties coming from service description. Target Latency (ms):', llsd.latency.target);\n            settings.update({\n              streaming: {\n                lowLatencyEnabled: true,\n                liveDelay: llsd.latency.target / 1000,\n                liveCatchup: {\n                  minDrift: llsd.latency.max > llsd.latency.target ? (llsd.latency.max - llsd.latency.target) / 1000 : undefined\n                }\n              }\n            });\n          }\n\n          if (llsd.playbackRate && llsd.playbackRate.max > 1.0) {\n            logger.debug('Apply LL properties coming from service description. Max PlaybackRate:', llsd.playbackRate.max);\n            settings.update({\n              streaming: {\n                lowLatencyEnabled: true,\n                liveCatchup: {\n                  playbackRate: llsd.playbackRate.max - 1.0\n                }\n              }\n            });\n          }\n        }\n      }\n    }\n  }\n\n  function addAllListeners() {\n    videoModel.addEventListener('canplay', onCanPlay);\n    videoModel.addEventListener('play', onPlaybackStart);\n    videoModel.addEventListener('waiting', onPlaybackWaiting);\n    videoModel.addEventListener('playing', onPlaybackPlaying);\n    videoModel.addEventListener('pause', onPlaybackPaused);\n    videoModel.addEventListener('error', onPlaybackError);\n    videoModel.addEventListener('seeking', onPlaybackSeeking);\n    videoModel.addEventListener('seeked', onPlaybackSeeked);\n    videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated);\n    videoModel.addEventListener('progress', onPlaybackProgress);\n    videoModel.addEventListener('ratechange', onPlaybackRateChanged);\n    videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n    videoModel.addEventListener('stalled', onPlaybackStalled);\n    videoModel.addEventListener('ended', onNativePlaybackEnded);\n  }\n\n  function removeAllListeners() {\n    videoModel.removeEventListener('canplay', onCanPlay);\n    videoModel.removeEventListener('play', onPlaybackStart);\n    videoModel.removeEventListener('waiting', onPlaybackWaiting);\n    videoModel.removeEventListener('playing', onPlaybackPlaying);\n    videoModel.removeEventListener('pause', onPlaybackPaused);\n    videoModel.removeEventListener('error', onPlaybackError);\n    videoModel.removeEventListener('seeking', onPlaybackSeeking);\n    videoModel.removeEventListener('seeked', onPlaybackSeeked);\n    videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated);\n    videoModel.removeEventListener('progress', onPlaybackProgress);\n    videoModel.removeEventListener('ratechange', onPlaybackRateChanged);\n    videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n    videoModel.removeEventListener('stalled', onPlaybackStalled);\n    videoModel.removeEventListener('ended', onNativePlaybackEnded);\n  }\n\n  instance = {\n    initialize: initialize,\n    setConfig: setConfig,\n    getStartTimeFromUriParameters: getStartTimeFromUriParameters,\n    getTimeToStreamEnd: getTimeToStreamEnd,\n    getTime: getTime,\n    getNormalizedTime: getNormalizedTime,\n    getPlaybackRate: getPlaybackRate,\n    getPlayedRanges: getPlayedRanges,\n    getEnded: getEnded,\n    getIsDynamic: getIsDynamic,\n    getStreamController: getStreamController,\n    computeAndSetLiveDelay: computeAndSetLiveDelay,\n    getLiveDelay: getLiveDelay,\n    setLiveDelay: setLiveDelay,\n    getCurrentLiveLatency: getCurrentLiveLatency,\n    play: play,\n    isPaused: isPaused,\n    pause: pause,\n    isSeeking: isSeeking,\n    getStreamEndTime: getStreamEndTime,\n    seek: seek,\n    updateCurrentTime: updateCurrentTime,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nPlaybackController.__dashjs_factory_name = 'PlaybackController';\nexports.default = _FactoryMaker2.default.getSingletonFactory(PlaybackController);","map":{"version":3,"mappings":"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","names":["LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS","PlaybackController","context","eventBus","getInstance","instance","logger","streamController","dashMetrics","adapter","videoModel","timelineConverter","streamSwitch","streamSeekTime","wallclockTimeIntervalId","liveDelay","streamInfo","isDynamic","mediaPlayerModel","playOnceInitialized","lastLivePlaybackTime","availabilityStartTime","seekTarget","internalSeek","isLowLatencySeekingInProgress","playbackStalled","minPlaybackRateChange","uriFragmentModel","settings","setup","getLogger","reset","initialize","sInfo","periodSwitch","seekTime","addAllListeners","manifestInfo","ua","navigator","userAgent","toLowerCase","isSafari","test","on","Events","STREAM_INITIALIZED","onStreamInitialized","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","LOADING_PROGRESS","onFragmentLoadProgress","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","PLAYBACK_PROGRESS","onPlaybackProgression","PLAYBACK_TIME_UPDATED","PLAYBACK_ENDED","onPlaybackEnded","priority","EventBus","EVENT_PRIORITY_HIGH","STREAM_INITIALIZING","onStreamInitializing","play","e","isNaN","startTime","liveStartTime","dvrInfo","getCurrentDVRInfo","dvrWindow","range","startTimeFromUri","getStartTimeFromUriParameters","info","Math","max","min","start","duration","getTime","trigger","PLAYBACK_SEEKING","seek","getTimeToStreamEnd","parseFloat","getStreamEndTime","toFixed","getElement","isPaused","pause","isSeeking","time","stickToBuffered","internal","currentTime","PLAYBACK_SEEK_ASKED","setCurrentTime","seekToLive","DVRMetrics","DVRWindow","end","getLiveDelay","getNormalizedTime","t","timeOffset","getPlaybackRate","getPlayedRanges","getEnded","getIsDynamic","getStreamController","computeAndSetLiveDelay","fragmentDuration","dvrWindowSize","minBufferTime","delay","ret","END_OF_PLAYLIST_PADDING","MIN_BUFFER_TIME_FACTOR","FRAGMENT_DURATION_FACTOR","adjustedFragmentDuration","isFinite","NaN","suggestedPresentationDelay","getSuggestedPresentationDelay","get","streaming","lowLatencyEnabled","liveDelayFragmentCount","useSuggestedPresentationDelay","getAvailabilityStartTime","targetDelayCapping","setLiveDelay","value","useMaxValue","getCurrentLiveLatency","now","Date","getClientTimeOffset","off","stopUpdatingWallclockTime","removeAllListeners","setConfig","config","fragData","getURIFragmentData","refStream","getStreams","refStreamStartTime","getStreamInfo","split","posix","indexOf","substring","parseInt","getActualPresentationTime","mediatype","actualTime","debug","abs","startUpdatingWallclockTime","tick","onWallclockTime","setInterval","wallclockTimeUpdateInterval","clearInterval","updateCurrentTime","mediaType","getReadyState","timeChanged","error","representationInfo","convertDataToRepresentationInfo","currentRepresentation","mediaInfo","id","onCanPlay","CAN_PLAY","onPlaybackStart","PLAYBACK_STARTED","onPlaybackWaiting","PLAYBACK_WAITING","playingTime","onPlaybackPlaying","PLAYBACK_PLAYING","onPlaybackPaused","PLAYBACK_PAUSED","ended","onPlaybackSeeking","onPlaybackSeeked","PLAYBACK_SEEKED","onPlaybackTimeUpdated","timeToEnd","updateLivePlaybackTime","onPlaybackProgress","onPlaybackRateChanged","rate","PLAYBACK_RATE_CHANGED","playbackRate","onPlaybackMetaDataLoaded","PLAYBACK_METADATA_LOADED","onNativePlaybackEnded","getActiveStreamInfo","isLast","onPlaybackError","event","target","srcElement","PLAYBACK_ERROR","WALLCLOCK_TIME_UPDATED","_isCatchupEnabled","liveCatchup","_needToCatchUp","startPlaybackCatchUp","stopPlaybackCatchUp","enabled","getBufferLevel","bufferLevel","getActiveStreamProcessors","forEach","bl","p","_getCatchupMode","playbackBufferMin","mode","Constants","LIVE_CATCHUP_MODE_LOLP","LIVE_CATCHUP_MODE_DEFAULT","catchupMode","currentLiveLatency","liveCatchupLatencyThreshold","getLiveCatchupLatencyThreshold","liveCatchUpMinDrift","minDrift","currentBuffer","_lolpNeedToCatchUpCustom","_defaultNeedToCatchUp","latencyDrift","results","currentPlaybackRate","liveCatchupPlaybackRate","_calculateNewPlaybackRateLolP","_calculateNewPlaybackRateDefault","newRate","setPlaybackRate","deltaLatency","maxDrift","liveCatchUpPlaybackRate","cpr","d","s","pow","E","deltaBuffer","minDifference","stream","request","minDelay","warn","update","streamId","state","MetricsConstants","BUFFER_EMPTY","setStallState","onPlaybackStalled","PLAYBACK_STALLED","applyServiceDescription","serviceDescriptions","llsd","i","length","sd","schemeIdUri","SERVICE_DESCRIPTION_LL_SCHEME","supplementalProperties","SUPPLEMENTAL_PROPERTY_LL_SCHEME","latency","undefined","addEventListener","removeEventListener","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/controllers/PlaybackController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nconst LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500;\n\nfunction PlaybackController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        streamController,\n        dashMetrics,\n        adapter,\n        videoModel,\n        timelineConverter,\n        streamSwitch,\n        streamSeekTime,\n        wallclockTimeIntervalId,\n        liveDelay,\n        streamInfo,\n        isDynamic,\n        mediaPlayerModel,\n        playOnceInitialized,\n        lastLivePlaybackTime,\n        availabilityStartTime,\n        seekTarget,\n        internalSeek,\n        isLowLatencySeekingInProgress,\n        playbackStalled,\n        minPlaybackRateChange,\n        uriFragmentModel,\n        settings;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        reset();\n    }\n\n    function initialize(sInfo, periodSwitch, seekTime) {\n        streamInfo = sInfo;\n        addAllListeners();\n        isDynamic = streamInfo.manifestInfo.isDynamic;\n        isLowLatencySeekingInProgress = false;\n        playbackStalled = false;\n        streamSwitch = periodSwitch === true;\n        streamSeekTime = seekTime;\n        internalSeek = false;\n\n        const ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';\n\n        // Detect safari browser (special behavior for low latency streams)\n        const isSafari = /safari/.test(ua) && !/chrome/.test(ua);\n        minPlaybackRateChange = isSafari ? 0.25 : 0.02;\n\n        eventBus.on(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.on(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_ENDED, onPlaybackEnded, this, { priority: EventBus.EVENT_PRIORITY_HIGH });\n        eventBus.on(Events.STREAM_INITIALIZING, onStreamInitializing, this);\n\n        if (playOnceInitialized) {\n            playOnceInitialized = false;\n            play();\n        }\n    }\n\n    function onStreamInitialized(e) {\n        // Seamless period switch\n        if (streamSwitch && isNaN(streamSeekTime)) return;\n\n        // Seek new stream in priority order:\n        // - at seek time (streamSeekTime) when switching period\n        // - at start time provided in URI parameters\n        // - at stream/period start time (for static streams) or live start time (for dynamic streams)\n        let startTime = streamSeekTime;\n        if (isNaN(startTime)) {\n            if (isDynamic) {\n                // For dynamic stream, start by default at (live edge - live delay)\n                startTime = e.liveStartTime;\n                // If start time in URI, take min value between live edge time and time from URI (capped by DVR window range)\n                const dvrInfo = dashMetrics.getCurrentDVRInfo();\n                const dvrWindow = dvrInfo ? dvrInfo.range : null;\n                if (dvrWindow) {\n                    // #t shall be relative to period start\n                    const startTimeFromUri = getStartTimeFromUriParameters(true);\n                    if (!isNaN(startTimeFromUri)) {\n                        logger.info('Start time from URI parameters: ' + startTimeFromUri);\n                        startTime = Math.max(Math.min(startTime, startTimeFromUri), dvrWindow.start);\n                    }\n                }\n            } else {\n                // For static stream, start by default at period start\n                startTime = streamInfo.start;\n                // If start time in URI, take max value between period start and time from URI (if in period range)\n                const startTimeFromUri = getStartTimeFromUriParameters(false);\n                if (!isNaN(startTimeFromUri) && startTimeFromUri < (startTime + streamInfo.duration)) {\n                    logger.info('Start time from URI parameters: ' + startTimeFromUri);\n                    startTime = Math.max(startTime, startTimeFromUri);\n                }\n            }\n        }\n\n        if (!isNaN(startTime) && startTime !== videoModel.getTime()) {\n            // Trigger PLAYBACK_SEEKING event for controllers\n            eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: startTime });\n            // Seek video model\n            seek(startTime, false, true);\n        }\n    }\n\n    function getTimeToStreamEnd() {\n        return parseFloat((getStreamEndTime() - getTime()).toFixed(5));\n    }\n\n    function getStreamEndTime() {\n        return streamInfo.start + streamInfo.duration;\n    }\n\n    function play() {\n        if (streamInfo && videoModel && videoModel.getElement()) {\n            videoModel.play();\n        } else {\n            playOnceInitialized = true;\n        }\n    }\n\n    function isPaused() {\n        return streamInfo && videoModel ? videoModel.isPaused() : null;\n    }\n\n    function pause() {\n        if (streamInfo && videoModel) {\n            videoModel.pause();\n        }\n    }\n\n    function isSeeking() {\n        return streamInfo && videoModel ? videoModel.isSeeking() : null;\n    }\n\n    function seek(time, stickToBuffered, internal) {\n        if (!streamInfo || !videoModel) return;\n\n        let currentTime = !isNaN(seekTarget) ? seekTarget : videoModel.getTime();\n        if (time === currentTime) return;\n\n        internalSeek = (internal === true);\n\n        if (!internalSeek) {\n            seekTarget = time;\n            eventBus.trigger(Events.PLAYBACK_SEEK_ASKED);\n        }\n        logger.info('Requesting seek to time: ' + time + (internalSeek ? ' (internal)' : ''));\n        videoModel.setCurrentTime(time, stickToBuffered);\n    }\n\n    function seekToLive() {\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo();\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n\n        seek(DVRWindow.end - mediaPlayerModel.getLiveDelay(), true, false);\n    }\n\n    function getTime() {\n        return streamInfo && videoModel ? videoModel.getTime() : null;\n    }\n\n    function getNormalizedTime() {\n        let t = getTime();\n\n        if (isDynamic && !isNaN(availabilityStartTime)) {\n            const timeOffset = availabilityStartTime / 1000;\n            // Fix current time for firefox and safari (returned as an absolute time)\n            if (t > timeOffset) {\n                t -= timeOffset;\n            }\n        }\n        return t;\n    }\n\n    function getPlaybackRate() {\n        return streamInfo && videoModel ? videoModel.getPlaybackRate() : null;\n    }\n\n    function getPlayedRanges() {\n        return streamInfo && videoModel ? videoModel.getPlayedRanges() : null;\n    }\n\n    function getEnded() {\n        return streamInfo && videoModel ? videoModel.getEnded() : null;\n    }\n\n    function getIsDynamic() {\n        return isDynamic;\n    }\n\n    function getStreamController() {\n        return streamController;\n    }\n\n    /**\n     * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge\n     * @param {number} fragmentDuration - seconds?\n     * @param {number} dvrWindowSize - seconds?\n     * @param {number} minBufferTime - seconds?\n     * @returns {number} object\n     * @memberof PlaybackController#\n     */\n    function computeAndSetLiveDelay(fragmentDuration, dvrWindowSize, minBufferTime) {\n        let delay,\n            ret,\n            startTime;\n        const END_OF_PLAYLIST_PADDING = 10;\n        const MIN_BUFFER_TIME_FACTOR = 4;\n        const FRAGMENT_DURATION_FACTOR = 4;\n        const adjustedFragmentDuration = !isNaN(fragmentDuration) && isFinite(fragmentDuration) ? fragmentDuration : NaN;\n\n        let suggestedPresentationDelay = adapter.getSuggestedPresentationDelay();\n\n        if (settings.get().streaming.lowLatencyEnabled) {\n            delay = 0;\n        } else if (mediaPlayerModel.getLiveDelay()) {\n            delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence\n        } else if (settings.get().streaming.liveDelayFragmentCount !== null && !isNaN(settings.get().streaming.liveDelayFragmentCount) && !isNaN(adjustedFragmentDuration)) {\n            delay = adjustedFragmentDuration * settings.get().streaming.liveDelayFragmentCount;\n        } else if (settings.get().streaming.useSuggestedPresentationDelay === true && suggestedPresentationDelay !== null && !isNaN(suggestedPresentationDelay) && suggestedPresentationDelay > 0) {\n            delay = suggestedPresentationDelay;\n        } else if (!isNaN(adjustedFragmentDuration)) {\n            delay = adjustedFragmentDuration * FRAGMENT_DURATION_FACTOR;\n        } else {\n            delay = !isNaN(minBufferTime) ? minBufferTime * MIN_BUFFER_TIME_FACTOR : streamInfo.manifestInfo.minBufferTime * MIN_BUFFER_TIME_FACTOR;\n        }\n\n        startTime = adapter.getAvailabilityStartTime();\n\n        if (startTime !== null) {\n            availabilityStartTime = startTime;\n        }\n\n        if (dvrWindowSize > 0) {\n            // cap target latency to:\n            // - dvrWindowSize / 2 for short playlists\n            // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists\n            const targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2);\n            ret = Math.min(delay, targetDelayCapping);\n        } else {\n            ret = delay;\n        }\n        liveDelay = ret;\n        return ret;\n    }\n\n    function getLiveDelay() {\n        return liveDelay;\n    }\n\n    function setLiveDelay(value, useMaxValue = false) {\n        if (useMaxValue && value < liveDelay) {\n            return;\n        }\n\n        liveDelay = value;\n    }\n\n    function getCurrentLiveLatency() {\n        if (!isDynamic || isNaN(availabilityStartTime)) {\n            return NaN;\n        }\n        let currentTime = getNormalizedTime();\n        if (isNaN(currentTime) || currentTime === 0) {\n            return 0;\n        }\n\n        const now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000;\n        return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0);\n    }\n\n    function reset() {\n        playOnceInitialized = false;\n        streamSwitch = false;\n        streamSeekTime = NaN;\n        liveDelay = 0;\n        availabilityStartTime = 0;\n        seekTarget = NaN;\n        if (videoModel) {\n            eventBus.off(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n            eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n            eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n            eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n            eventBus.off(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n            eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n            eventBus.off(Events.PLAYBACK_ENDED, onPlaybackEnded, this);\n            eventBus.off(Events.STREAM_INITIALIZING, onStreamInitializing, this);\n            stopUpdatingWallclockTime();\n            removeAllListeners();\n        }\n        wallclockTimeIntervalId = null;\n        videoModel = null;\n        streamInfo = null;\n        isDynamic = null;\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.timelineConverter) {\n            timelineConverter = config.timelineConverter;\n        }\n        if (config.uriFragmentModel) {\n            uriFragmentModel = config.uriFragmentModel;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function getStartTimeFromUriParameters(isDynamic) {\n        const fragData = uriFragmentModel.getURIFragmentData();\n        if (!fragData || !fragData.t) {\n            return NaN;\n        }\n        const refStream = streamController.getStreams()[0];\n        const refStreamStartTime = refStream.getStreamInfo().start;\n        // Consider only start time of MediaRange\n        // TODO: consider end time of MediaRange to stop playback at provided end time\n        fragData.t = fragData.t.split(',')[0];\n        // \"t=<time>\" : time is relative to 1st period start\n        // \"t=posix:<time>\" : time is absolute start time as number of seconds since 01-01-1970\n        const posix = fragData.t.indexOf('posix:') !== -1 ? fragData.t.substring(6) === 'now' ? Date.now() / 1000 : parseInt(fragData.t.substring(6)) : NaN;\n        let startTime = (isDynamic && !isNaN(posix)) ? posix - availabilityStartTime / 1000 : parseInt(fragData.t) + refStreamStartTime;\n        return startTime;\n    }\n\n    function getActualPresentationTime(currentTime, mediatype) {\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo(mediatype);\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n        let actualTime;\n\n        if (!DVRWindow) {\n            return NaN;\n        }\n\n        logger.debug(`Checking DVR window for at ${currentTime} with DVR window range ${DVRWindow.start} - ${DVRWindow.end}`);\n        if (currentTime > DVRWindow.end) {\n            actualTime = Math.max(DVRWindow.end - liveDelay, DVRWindow.start);\n\n        } else if (currentTime > 0 && currentTime + 0.250 < DVRWindow.start && Math.abs(currentTime - DVRWindow.start) < 315360000) {\n\n            // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz\n            // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate\n            // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource\n            // Checking also duration of the DVR makes sense. We detected temporary situations in which currentTime\n            // is bad reported by the browser which causes playback to jump to start (315360000 = 1 year)\n            //actualTime = DVRWindow.start;\n            actualTime = DVRWindow.start;\n        } else {\n            actualTime = currentTime;\n        }\n\n        return actualTime;\n    }\n\n    function startUpdatingWallclockTime() {\n        if (wallclockTimeIntervalId !== null) return;\n\n        const tick = function () {\n            onWallclockTime();\n        };\n\n        wallclockTimeIntervalId = setInterval(tick, settings.get().streaming.wallclockTimeUpdateInterval);\n    }\n\n    function stopUpdatingWallclockTime() {\n        clearInterval(wallclockTimeIntervalId);\n        wallclockTimeIntervalId = null;\n    }\n\n    function updateCurrentTime(mediaType) {\n        if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return;\n        const currentTime = getNormalizedTime();\n        const actualTime = getActualPresentationTime(currentTime, mediaType);\n        const timeChanged = (!isNaN(actualTime) && actualTime !== currentTime);\n        if (timeChanged && !isSeeking()) {\n            logger.debug(`UpdateCurrentTime: Seek to actual time: ${actualTime} from currentTime: ${currentTime}`);\n            seek(actualTime);\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.error) return;\n\n        const representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\n        const info = representationInfo ? representationInfo.mediaInfo.streamInfo : null;\n\n        if (info === null || streamInfo.id !== info.id) return;\n        streamInfo = info;\n\n        updateCurrentTime();\n    }\n\n    function onCanPlay() {\n        eventBus.trigger(Events.CAN_PLAY);\n    }\n\n    function onPlaybackStart() {\n        logger.info('Native video element event: play');\n        updateCurrentTime();\n        startUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_STARTED, { startTime: getTime() });\n    }\n\n    function onPlaybackWaiting() {\n        logger.info('Native video element event: waiting');\n        eventBus.trigger(Events.PLAYBACK_WAITING, { playingTime: getTime() });\n    }\n\n    function onPlaybackPlaying() {\n        logger.info('Native video element event: playing');\n        eventBus.trigger(Events.PLAYBACK_PLAYING, { playingTime: getTime() });\n    }\n\n    function onPlaybackPaused() {\n        logger.info('Native video element event: pause');\n        eventBus.trigger(Events.PLAYBACK_PAUSED, { ended: getEnded() });\n    }\n\n    function onPlaybackSeeking() {\n        // Check if internal seeking to be ignored\n        if (internalSeek) {\n            internalSeek = false;\n            return;\n        }\n\n        let seekTime = getTime();\n        // On some browsers/devices, in case of live streams, setting current time on video element fails when there is no buffered data at requested time\n        // Then re-set seek target time and video element will be seeked afterwhile once data is buffered (see BufferContoller)\n        if (!isNaN(seekTarget) && seekTarget !== seekTime) {\n            seekTime = seekTarget;\n        }\n        seekTarget = NaN;\n\n        logger.info('Seeking to: ' + seekTime);\n        startUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: seekTime });\n    }\n\n    function onPlaybackSeeked() {\n        logger.info('Native video element event: seeked');\n        eventBus.trigger(Events.PLAYBACK_SEEKED);\n    }\n\n    function onPlaybackTimeUpdated() {\n        if (streamInfo) {\n            eventBus.trigger(Events.PLAYBACK_TIME_UPDATED, {\n                timeToEnd: getTimeToStreamEnd(),\n                time: getTime()\n            });\n        }\n    }\n\n    function updateLivePlaybackTime() {\n        const now = Date.now();\n        if (!lastLivePlaybackTime || now > lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) {\n            lastLivePlaybackTime = now;\n            onPlaybackTimeUpdated();\n        }\n    }\n\n    function onPlaybackProgress() {\n        eventBus.trigger(Events.PLAYBACK_PROGRESS);\n    }\n\n    function onPlaybackRateChanged() {\n        const rate = getPlaybackRate();\n        logger.info('Native video element event: ratechange: ', rate);\n        eventBus.trigger(Events.PLAYBACK_RATE_CHANGED, { playbackRate: rate });\n    }\n\n    function onPlaybackMetaDataLoaded() {\n        logger.info('Native video element event: loadedmetadata');\n        eventBus.trigger(Events.PLAYBACK_METADATA_LOADED);\n        startUpdatingWallclockTime();\n    }\n\n    // Event to handle the native video element ended event\n    function onNativePlaybackEnded() {\n        logger.info('Native video element event: ended');\n        pause();\n        stopUpdatingWallclockTime();\n        const streamInfo = streamController ? streamController.getActiveStreamInfo() : null;\n        if (!streamInfo) return;\n        eventBus.trigger(Events.PLAYBACK_ENDED, { 'isLast': streamInfo.isLast });\n    }\n\n    // Handle DASH PLAYBACK_ENDED event\n    function onPlaybackEnded(e) {\n        if (wallclockTimeIntervalId && e.isLast) {\n            // PLAYBACK_ENDED was triggered elsewhere, react.\n            logger.info('onPlaybackEnded -- PLAYBACK_ENDED but native video element didn\\'t fire ended');\n            const seekTime = e.seekTime ? e.seekTime : getStreamEndTime();\n            videoModel.setCurrentTime(seekTime);\n            pause();\n            stopUpdatingWallclockTime();\n        }\n    }\n\n    function onPlaybackError(event) {\n        const target = event.target || event.srcElement;\n        eventBus.trigger(Events.PLAYBACK_ERROR, { error: target.error });\n    }\n\n    function onWallclockTime() {\n        eventBus.trigger(Events.WALLCLOCK_TIME_UPDATED, {\n            isDynamic: isDynamic,\n            time: new Date()\n        });\n\n        // Updates playback time for paused dynamic streams\n        // (video element doesn't call timeupdate when the playback is paused)\n        if (getIsDynamic() && isPaused()) {\n            updateLivePlaybackTime();\n        }\n    }\n\n    function onPlaybackProgression() {\n        if (\n            isDynamic &&\n            _isCatchupEnabled() &&\n            settings.get().streaming.liveCatchup.playbackRate > 0 &&\n            !isPaused() &&\n            !isSeeking()\n        ) {\n            if (_needToCatchUp()) {\n                startPlaybackCatchUp();\n            } else {\n                stopPlaybackCatchUp();\n            }\n        }\n    }\n\n    function _isCatchupEnabled() {\n        return settings.get().streaming.liveCatchup.enabled || settings.get().streaming.lowLatencyEnabled;\n    }\n\n    function getBufferLevel() {\n        let bufferLevel = null;\n        streamController.getActiveStreamProcessors().forEach(p => {\n            const bl = p.getBufferLevel();\n            if (bufferLevel === null) {\n                bufferLevel = bl;\n            } else {\n                bufferLevel = Math.min(bufferLevel, bl);\n            }\n        });\n\n        return bufferLevel;\n    }\n\n    /**\n     * Returns the mode for live playback catchup.\n     * @return {String}\n     * @private\n     */\n    function _getCatchupMode() {\n        const playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n\n        return settings.get().streaming.liveCatchup.mode === Constants.LIVE_CATCHUP_MODE_LOLP && playbackBufferMin !== null && !isNaN(playbackBufferMin) ? Constants.LIVE_CATCHUP_MODE_LOLP : Constants.LIVE_CATCHUP_MODE_DEFAULT;\n    }\n\n    /**\n     * Checks whether the catchup mechanism should be enabled\n     * @return {boolean}\n     */\n    function _needToCatchUp() {\n        try {\n            if (_isCatchupEnabled() && settings.get().streaming.liveCatchup.playbackRate > 0 && getTime() > 0) {\n\n                const catchupMode = _getCatchupMode();\n                const currentLiveLatency = getCurrentLiveLatency();\n                const liveDelay = mediaPlayerModel.getLiveDelay();\n                const liveCatchupLatencyThreshold = mediaPlayerModel.getLiveCatchupLatencyThreshold();\n                const liveCatchUpMinDrift = settings.get().streaming.liveCatchup.minDrift;\n\n                if (catchupMode === Constants.LIVE_CATCHUP_MODE_LOLP) {\n                    const currentBuffer = getBufferLevel();\n                    const playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n\n                    return _lolpNeedToCatchUpCustom(currentLiveLatency, liveDelay, liveCatchUpMinDrift, currentBuffer, playbackBufferMin, liveCatchupLatencyThreshold);\n                } else {\n                    return _defaultNeedToCatchUp(currentLiveLatency, liveDelay, liveCatchupLatencyThreshold, liveCatchUpMinDrift);\n                }\n            }\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Default algorithm to determine if catchup mode should be enabled\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} liveCatchupLatencyThreshold\n     * @param {number} minDrift\n     * @return {boolean}\n     * @private\n     */\n    function _defaultNeedToCatchUp(currentLiveLatency, liveDelay, liveCatchupLatencyThreshold, minDrift) {\n        try {\n            const latencyDrift = Math.abs(currentLiveLatency - liveDelay);\n\n            return latencyDrift > minDrift && (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * LoL+ logic to determine if catchup mode should be enabled\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} minDrift\n     * @param {number} currentBuffer\n     * @param {number} playbackBufferMin\n     * @param {number} liveCatchupLatencyThreshold\n     * @return {boolean}\n     * @private\n     */\n    function _lolpNeedToCatchUpCustom(currentLiveLatency, liveDelay, minDrift, currentBuffer, playbackBufferMin, liveCatchupLatencyThreshold) {\n        try {\n            const latencyDrift = Math.abs(currentLiveLatency - liveDelay);\n\n            return (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold) && (latencyDrift > minDrift || currentBuffer < playbackBufferMin);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Apply catchup mode\n     */\n    function startPlaybackCatchUp() {\n        if (videoModel) {\n            let results;\n            const currentPlaybackRate = videoModel.getPlaybackRate();\n            const liveCatchupPlaybackRate = settings.get().streaming.liveCatchup.playbackRate;\n            const currentLiveLatency = getCurrentLiveLatency();\n            const liveDelay = mediaPlayerModel.getLiveDelay();\n            const bufferLevel = getBufferLevel();\n            // Custom playback control: Based on buffer level\n            if (_getCatchupMode() === Constants.LIVE_CATCHUP_MODE_LOLP) {\n                const liveCatchUpMinDrift = settings.get().streaming.liveCatchup.minDrift;\n                const playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n                results = _calculateNewPlaybackRateLolP(liveCatchupPlaybackRate, currentLiveLatency, liveDelay, liveCatchUpMinDrift, playbackBufferMin, bufferLevel, currentPlaybackRate);\n            } else {\n                // Default playback control: Based on target and current latency\n                results = _calculateNewPlaybackRateDefault(liveCatchupPlaybackRate, currentLiveLatency, liveDelay, bufferLevel, currentPlaybackRate);\n            }\n\n            // Obtain newRate and apply to video model\n            let newRate = results.newRate;\n            if (newRate) {  // non-null\n                videoModel.setPlaybackRate(newRate);\n            }\n\n            const deltaLatency = currentLiveLatency - liveDelay;\n            if (settings.get().streaming.liveCatchup.maxDrift > 0 && !isLowLatencySeekingInProgress &&\n                deltaLatency > settings.get().streaming.liveCatchup.maxDrift) {\n                logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point');\n                isLowLatencySeekingInProgress = true;\n                seekToLive();\n            } else {\n                isLowLatencySeekingInProgress = false;\n            }\n        }\n    }\n\n    /**\n     * Default algorithm to calculate the new playback rate\n     * @param {number} liveCatchUpPlaybackRate\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} bufferLevel\n     * @param {number} currentPlaybackRate\n     * @return {{newRate: number}}\n     * @private\n     */\n    function _calculateNewPlaybackRateDefault(liveCatchUpPlaybackRate, currentLiveLatency, liveDelay, bufferLevel, currentPlaybackRate) {\n        const cpr = liveCatchUpPlaybackRate;\n        const deltaLatency = currentLiveLatency - liveDelay;\n        const d = deltaLatency * 5;\n\n        // Playback rate must be between (1 - cpr) - (1 + cpr)\n        // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n        const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n        let newRate = (1 - cpr) + s;\n        // take into account situations in which there are buffer stalls,\n        // in which increasing playbackRate to reach target latency will\n        // just cause more and more stall situations\n        if (playbackStalled) {\n            // const bufferLevel = getBufferLevel();\n            if (bufferLevel > liveDelay / 2) {\n                // playbackStalled = false;\n                playbackStalled = false;\n            } else if (deltaLatency > 0) {\n                newRate = 1.0;\n            }\n        }\n\n        // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n        if (Math.abs(currentPlaybackRate - newRate) <= minPlaybackRateChange) {\n            newRate = null;\n        }\n\n        return {\n            newRate: newRate\n        };\n\n    }\n\n    /**\n     * Lol+ algorithm to calculate the new playback rate\n     * @param {number} liveCatchUpPlaybackRate\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} minDrift\n     * @param {number} playbackBufferMin\n     * @param {number} bufferLevel\n     * @param {number} currentPlaybackRate\n     * @return {{newRate: number}}\n     * @private\n     */\n    function _calculateNewPlaybackRateLolP(liveCatchUpPlaybackRate, currentLiveLatency, liveDelay, minDrift, playbackBufferMin, bufferLevel, currentPlaybackRate) {\n        const cpr = liveCatchUpPlaybackRate;\n        let newRate;\n\n        // Hybrid: Buffer-based\n        if (bufferLevel < playbackBufferMin) {\n            // Buffer in danger, slow down\n            const deltaBuffer = bufferLevel - playbackBufferMin;  // -ve value\n            const d = deltaBuffer * 5;\n\n            // Playback rate must be between (1 - cpr) - (1 + cpr)\n            // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n            const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n            newRate = (1 - cpr) + s;\n\n            logger.debug('[LoL+ playback control_buffer-based] bufferLevel: ' + bufferLevel + ', newRate: ' + newRate);\n        } else {\n            // Hybrid: Latency-based\n            // Buffer is safe, vary playback rate based on latency\n\n            // Check if latency is within range of target latency\n            const minDifference = 0.02;\n            if (Math.abs(currentLiveLatency - liveDelay) <= (minDifference * liveDelay)) {\n                newRate = 1;\n            } else {\n                const deltaLatency = currentLiveLatency - liveDelay;\n                const d = deltaLatency * 5;\n\n                // Playback rate must be between (1 - cpr) - (1 + cpr)\n                // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n                const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n                newRate = (1 - cpr) + s;\n            }\n\n            logger.debug('[LoL+ playback control_latency-based] latency: ' + currentLiveLatency + ', newRate: ' + newRate);\n        }\n\n        if (playbackStalled) {\n            if (bufferLevel > liveDelay / 2) {\n                playbackStalled = false;\n            }\n        }\n\n        // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n        if (Math.abs(currentPlaybackRate - newRate) <= minPlaybackRateChange) {\n            newRate = null;\n        }\n\n        return {\n            newRate: newRate\n        };\n    }\n\n    function stopPlaybackCatchUp() {\n        if (videoModel) {\n            videoModel.setPlaybackRate(1.0);\n        }\n    }\n\n    function onFragmentLoadProgress(e) {\n        // If using fetch and stream mode is not available, readjust live latency so it is 20% higher than segment duration\n        if (e.stream === false && settings.get().streaming.lowLatencyEnabled && !isNaN(e.request.duration)) {\n            const minDelay = 1.2 * e.request.duration;\n            if (minDelay > mediaPlayerModel.getLiveDelay()) {\n                logger.warn('Browser does not support fetch API with StreamReader. Increasing live delay to be 20% higher than segment duration:', minDelay.toFixed(2));\n                const s = { streaming: { liveDelay: minDelay } };\n                settings.update(s);\n            }\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        // do not stall playback when get an event from Stream that is not active\n        if (e.streamId !== streamInfo.id) return;\n\n        if (_isCatchupEnabled()) {\n            if (e.state === MetricsConstants.BUFFER_EMPTY && !isSeeking()) {\n                if (!playbackStalled) {\n                    playbackStalled = true;\n                    stopPlaybackCatchUp();\n                }\n            }\n        } else {\n            videoModel.setStallState(e.mediaType, e.state === MetricsConstants.BUFFER_EMPTY);\n        }\n    }\n\n    function onPlaybackStalled(e) {\n        eventBus.trigger(Events.PLAYBACK_STALLED, { e: e });\n    }\n\n    function onStreamInitializing(e) {\n        applyServiceDescription(e.streamInfo, e.mediaInfo);\n    }\n\n    function applyServiceDescription(streamInfo, mediaInfo) {\n        if (streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.serviceDescriptions) {\n            // is there a service description for low latency defined?\n            let llsd;\n\n            for (let i = 0; i < streamInfo.manifestInfo.serviceDescriptions.length; i++) {\n                const sd = streamInfo.manifestInfo.serviceDescriptions[i];\n                if (sd.schemeIdUri === Constants.SERVICE_DESCRIPTION_LL_SCHEME) {\n                    llsd = sd;\n                    break;\n                }\n            }\n\n            if (llsd) {\n                if (mediaInfo && mediaInfo.supplementalProperties &&\n                    mediaInfo.supplementalProperties[Constants.SUPPLEMENTAL_PROPERTY_LL_SCHEME] === 'true') {\n                    if (llsd.latency && llsd.latency.target > 0) {\n                        logger.debug('Apply LL properties coming from service description. Target Latency (ms):', llsd.latency.target);\n                        settings.update({\n                            streaming: {\n                                lowLatencyEnabled: true,\n                                liveDelay: llsd.latency.target / 1000,\n                                liveCatchup: {\n                                    minDrift: llsd.latency.max > llsd.latency.target ? (llsd.latency.max - llsd.latency.target) / 1000 : undefined\n                                }\n                            }\n                        });\n                    }\n                    if (llsd.playbackRate && llsd.playbackRate.max > 1.0) {\n                        logger.debug('Apply LL properties coming from service description. Max PlaybackRate:', llsd.playbackRate.max);\n                        settings.update({\n                            streaming: {\n                                lowLatencyEnabled: true,\n                                liveCatchup: {\n                                    playbackRate: llsd.playbackRate.max - 1.0\n                                }\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    function addAllListeners() {\n        videoModel.addEventListener('canplay', onCanPlay);\n        videoModel.addEventListener('play', onPlaybackStart);\n        videoModel.addEventListener('waiting', onPlaybackWaiting);\n        videoModel.addEventListener('playing', onPlaybackPlaying);\n        videoModel.addEventListener('pause', onPlaybackPaused);\n        videoModel.addEventListener('error', onPlaybackError);\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\n        videoModel.addEventListener('seeked', onPlaybackSeeked);\n        videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated);\n        videoModel.addEventListener('progress', onPlaybackProgress);\n        videoModel.addEventListener('ratechange', onPlaybackRateChanged);\n        videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n        videoModel.addEventListener('stalled', onPlaybackStalled);\n        videoModel.addEventListener('ended', onNativePlaybackEnded);\n    }\n\n    function removeAllListeners() {\n        videoModel.removeEventListener('canplay', onCanPlay);\n        videoModel.removeEventListener('play', onPlaybackStart);\n        videoModel.removeEventListener('waiting', onPlaybackWaiting);\n        videoModel.removeEventListener('playing', onPlaybackPlaying);\n        videoModel.removeEventListener('pause', onPlaybackPaused);\n        videoModel.removeEventListener('error', onPlaybackError);\n        videoModel.removeEventListener('seeking', onPlaybackSeeking);\n        videoModel.removeEventListener('seeked', onPlaybackSeeked);\n        videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated);\n        videoModel.removeEventListener('progress', onPlaybackProgress);\n        videoModel.removeEventListener('ratechange', onPlaybackRateChanged);\n        videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n        videoModel.removeEventListener('stalled', onPlaybackStalled);\n        videoModel.removeEventListener('ended', onNativePlaybackEnded);\n    }\n\n    instance = {\n        initialize: initialize,\n        setConfig: setConfig,\n        getStartTimeFromUriParameters: getStartTimeFromUriParameters,\n        getTimeToStreamEnd: getTimeToStreamEnd,\n        getTime: getTime,\n        getNormalizedTime: getNormalizedTime,\n        getPlaybackRate: getPlaybackRate,\n        getPlayedRanges: getPlayedRanges,\n        getEnded: getEnded,\n        getIsDynamic: getIsDynamic,\n        getStreamController: getStreamController,\n        computeAndSetLiveDelay: computeAndSetLiveDelay,\n        getLiveDelay: getLiveDelay,\n        setLiveDelay: setLiveDelay,\n        getCurrentLiveLatency: getCurrentLiveLatency,\n        play: play,\n        isPaused: isPaused,\n        pause: pause,\n        isSeeking: isSeeking,\n        getStreamEndTime,\n        seek: seek,\n        updateCurrentTime: updateCurrentTime,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nPlaybackController.__dashjs_factory_name = 'PlaybackController';\nexport default FactoryMaker.getSingletonFactory(PlaybackController);\n"]},"metadata":{},"sourceType":"script"}