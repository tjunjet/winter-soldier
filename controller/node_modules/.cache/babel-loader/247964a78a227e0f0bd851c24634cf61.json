{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _TextSourceBuffer = require('./TextSourceBuffer');\n\nvar _TextSourceBuffer2 = _interopRequireDefault(_TextSourceBuffer);\n\nvar _TextTracks = require('./TextTracks');\n\nvar _TextTracks2 = _interopRequireDefault(_TextTracks);\n\nvar _VTTParser = require('../utils/VTTParser');\n\nvar _VTTParser2 = _interopRequireDefault(_VTTParser);\n\nvar _TTMLParser = require('../utils/TTMLParser');\n\nvar _TTMLParser2 = _interopRequireDefault(_TTMLParser);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _SupervisorTools = require('../utils/SupervisorTools');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction TextController() {\n  var context = this.context;\n  var instance = void 0,\n      textSourceBuffer = void 0,\n      errHandler = void 0,\n      adapter = void 0,\n      manifestModel = void 0,\n      mediaController = void 0,\n      videoModel = void 0,\n      streamController = void 0,\n      textTracks = void 0,\n      vttParser = void 0,\n      ttmlParser = void 0,\n      eventBus = void 0,\n      defaultSettings = void 0,\n      initialSettingsSet = void 0,\n      lastEnabledIndex = void 0,\n      textDefaultEnabled = void 0,\n      // this is used for default settings (each time a file is loaded, we check value of this settings )\n  allTracksAreDisabled = void 0,\n      // this is used for one session (when a file has been loaded, we use this settings to enable/disable text)\n  forceTextStreaming = void 0,\n      textTracksAdded = void 0,\n      disableTextBeforeTextTracksAdded = void 0,\n      previousPeriodSelectedTrack = void 0;\n\n  function setup() {\n    defaultSettings = null;\n    lastEnabledIndex = -1;\n    forceTextStreaming = false;\n    textTracksAdded = false;\n    initialSettingsSet = false;\n    disableTextBeforeTextTracksAdded = false;\n    textTracks = (0, _TextTracks2.default)(context).getInstance();\n    vttParser = (0, _VTTParser2.default)(context).getInstance();\n    ttmlParser = (0, _TTMLParser2.default)(context).getInstance();\n    textSourceBuffer = (0, _TextSourceBuffer2.default)(context).getInstance();\n    eventBus = (0, _EventBus2.default)(context).getInstance();\n    textTracks.initialize();\n    eventBus.on(_Events2.default.TEXT_TRACKS_QUEUE_INITIALIZED, onTextTracksAdded, instance);\n    eventBus.on(_Events2.default.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n    /*\n    * register those event callbacks in order to detect switch of periods and set\n    * correctly the selected track index in the new period.\n    * there is different cases :\n    *   - switch occurs after a seek command from the user\n    *   - switch occurs but codecs in streams are different\n    *   - switch occurs and codecs in streams are not different\n    */\n\n    eventBus.on(_Events2.default.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n    eventBus.on(_Events2.default.STREAM_COMPLETED, onStreamCompleted, instance);\n    eventBus.on(_Events2.default.PERIOD_SWITCH_COMPLETED, onPeriodSwitchCompleted, instance);\n    resetInitialSettings();\n  }\n\n  function onPeriodSwitchStarted(e) {\n    if (previousPeriodSelectedTrack === undefined && e.fromStreamInfo !== null\n    /* test if this is the first period */\n    ) {\n      previousPeriodSelectedTrack = this.getCurrentTrackIdx();\n    }\n  }\n\n  function onStreamCompleted() {\n    if (previousPeriodSelectedTrack === undefined) {\n      previousPeriodSelectedTrack = this.getCurrentTrackIdx();\n    }\n  }\n\n  function onPeriodSwitchCompleted() {\n    if (previousPeriodSelectedTrack !== undefined) {\n      this.setTextTrack(previousPeriodSelectedTrack);\n      previousPeriodSelectedTrack = undefined;\n    }\n  }\n\n  function setConfig(config) {\n    if (!config) {\n      return;\n    }\n\n    if (config.errHandler) {\n      errHandler = config.errHandler;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n\n    if (config.manifestModel) {\n      manifestModel = config.manifestModel;\n    }\n\n    if (config.mediaController) {\n      mediaController = config.mediaController;\n    }\n\n    if (config.videoModel) {\n      videoModel = config.videoModel;\n    }\n\n    if (config.streamController) {\n      streamController = config.streamController;\n    }\n\n    if (config.textTracks) {\n      textTracks = config.textTracks;\n    }\n\n    if (config.vttParser) {\n      vttParser = config.vttParser;\n    }\n\n    if (config.ttmlParser) {\n      ttmlParser = config.ttmlParser;\n    } // create config for source buffer\n\n\n    textSourceBuffer.setConfig({\n      errHandler: errHandler,\n      adapter: adapter,\n      manifestModel: manifestModel,\n      mediaController: mediaController,\n      videoModel: videoModel,\n      streamController: streamController,\n      textTracks: textTracks,\n      vttParser: vttParser,\n      ttmlParser: ttmlParser\n    });\n  }\n\n  function getTextSourceBuffer() {\n    return textSourceBuffer;\n  }\n\n  function getAllTracksAreDisabled() {\n    return allTracksAreDisabled;\n  }\n\n  function addEmbeddedTrack(mediaInfo) {\n    textSourceBuffer.addEmbeddedTrack(mediaInfo);\n  }\n\n  function setTextDefaultLanguage(lang) {\n    (0, _SupervisorTools.checkParameterType)(lang, 'string');\n\n    if (!defaultSettings) {\n      defaultSettings = {};\n    }\n\n    defaultSettings.lang = lang;\n    initialSettingsSet = true;\n  }\n\n  function setInitialSettings(settings) {\n    defaultSettings = settings;\n    initialSettingsSet = true;\n  }\n\n  function getTextDefaultLanguage() {\n    return defaultSettings && defaultSettings.lang || '';\n  }\n\n  function onTextTracksAdded(e) {\n    var _this = this;\n\n    var tracks = e.tracks;\n    var index = e.index;\n\n    if (defaultSettings) {\n      tracks.some(function (item, idx) {\n        // matchSettings is compatible with setTextDefaultLanguage and setInitialSettings\n        if (mediaController.matchSettings(defaultSettings, item)) {\n          _this.setTextTrack(idx);\n\n          index = idx;\n          return true;\n        }\n      });\n    }\n\n    if (textDefaultEnabled === false || textDefaultEnabled === undefined && !defaultSettings || disableTextBeforeTextTracksAdded) {\n      // disable text at startup if explicitely configured with setTextDefaultEnabled(false) or if there is no defaultSettings (configuration or from domStorage)\n      this.setTextTrack(-1);\n    }\n\n    lastEnabledIndex = index;\n    eventBus.trigger(_Events2.default.TEXT_TRACKS_ADDED, {\n      enabled: isTextEnabled(),\n      index: index,\n      tracks: tracks\n    });\n    textTracksAdded = true;\n  }\n\n  function onCurrentTrackChanged(event) {\n    if (!initialSettingsSet && event && event.newMediaInfo) {\n      var mediaInfo = event.newMediaInfo;\n\n      if (mediaInfo.type === _Constants2.default.FRAGMENTED_TEXT) {\n        defaultSettings = {\n          lang: mediaInfo.lang,\n          role: mediaInfo.roles[0],\n          accessibility: mediaInfo.accessibility[0]\n        };\n      }\n    }\n  }\n\n  function setTextDefaultEnabled(enable) {\n    (0, _SupervisorTools.checkParameterType)(enable, 'boolean');\n    textDefaultEnabled = enable;\n\n    if (!textDefaultEnabled) {\n      // disable text at startup\n      this.setTextTrack(-1);\n    } else {\n      allTracksAreDisabled = false;\n    }\n  }\n\n  function getTextDefaultEnabled() {\n    return textDefaultEnabled === undefined ? false : textDefaultEnabled;\n  }\n\n  function enableText(enable) {\n    (0, _SupervisorTools.checkParameterType)(enable, 'boolean');\n\n    if (!textDefaultEnabled && enable) {\n      textDefaultEnabled = true;\n    }\n\n    if (isTextEnabled() !== enable) {\n      // change track selection\n      if (enable) {\n        // apply last enabled track\n        this.setTextTrack(lastEnabledIndex);\n      }\n\n      if (!enable) {\n        // keep last index and disable text track\n        lastEnabledIndex = this.getCurrentTrackIdx();\n\n        if (!textTracksAdded) {\n          disableTextBeforeTextTracksAdded = true;\n        } else {\n          this.setTextTrack(-1);\n        }\n      }\n    }\n  }\n\n  function isTextEnabled() {\n    var enabled = true;\n\n    if (allTracksAreDisabled && !forceTextStreaming) {\n      enabled = false;\n    }\n\n    return enabled;\n  } // when set to true ScheduleController will allow schedule of chunks even if tracks are all disabled. Allowing streaming to hidden track for external players to work with.\n\n\n  function enableForcedTextStreaming(enable) {\n    (0, _SupervisorTools.checkParameterType)(enable, 'boolean');\n    forceTextStreaming = enable;\n  }\n\n  function setTextTrack(idx) {\n    //For external time text file, the only action needed to change a track is marking the track mode to showing.\n    // Fragmented text tracks need the additional step of calling TextController.setTextTrack();\n    var config = textSourceBuffer.getConfig();\n    var fragmentModel = config.fragmentModel;\n    var fragmentedTracks = config.fragmentedTracks;\n    var videoModel = config.videoModel;\n    var mediaInfosArr = void 0,\n        streamProcessor = void 0;\n    allTracksAreDisabled = idx === -1 ? true : false;\n    var oldTrackIdx = textTracks.getCurrentTrackIdx();\n\n    if (oldTrackIdx !== idx) {\n      if (allTracksAreDisabled && mediaController) {\n        mediaController.saveTextSettingsDisabled();\n      }\n\n      textTracks.setModeForTrackIdx(oldTrackIdx, _Constants2.default.TEXT_HIDDEN);\n      textTracks.setCurrentTrackIdx(idx);\n      textTracks.setModeForTrackIdx(idx, _Constants2.default.TEXT_SHOWING);\n      var currentTrackInfo = textTracks.getCurrentTrackInfo();\n\n      if (currentTrackInfo && currentTrackInfo.isFragmented && !currentTrackInfo.isEmbedded) {\n        for (var i = 0; i < fragmentedTracks.length; i++) {\n          var mediaInfo = fragmentedTracks[i];\n\n          if (currentTrackInfo.lang === mediaInfo.lang && currentTrackInfo.index === mediaInfo.index && (mediaInfo.id ? currentTrackInfo.id === mediaInfo.id : currentTrackInfo.id === mediaInfo.index)) {\n            var currentFragTrack = mediaController.getCurrentTrackFor(_Constants2.default.FRAGMENTED_TEXT, streamController.getActiveStreamInfo());\n\n            if (mediaInfo !== currentFragTrack) {\n              fragmentModel.abortRequests();\n              fragmentModel.removeExecutedRequestsBeforeTime();\n              textSourceBuffer.remove();\n              textTracks.deleteCuesFromTrackIdx(oldTrackIdx);\n              mediaController.setTrack(mediaInfo);\n              textSourceBuffer.setCurrentFragmentedTrackIdx(i);\n            } else if (oldTrackIdx === -1) {\n              //in fragmented use case, if the user selects the older track (the one selected before disabled text track)\n              //no CURRENT_TRACK_CHANGED event will be trigger, so dashHandler current time has to be updated and the scheduleController\n              //has to be restarted.\n              var streamProcessors = streamController.getActiveStreamProcessors();\n\n              for (var _i = 0; _i < streamProcessors.length; _i++) {\n                if (streamProcessors[_i].getType() === _Constants2.default.FRAGMENTED_TEXT) {\n                  streamProcessor = streamProcessors[_i];\n                  break;\n                }\n              }\n\n              streamProcessor.setBufferingTime(videoModel.getTime());\n              streamProcessor.getScheduleController().start();\n            }\n          }\n        }\n      } else if (currentTrackInfo && !currentTrackInfo.isFragmented) {\n        var _streamProcessors = streamController.getActiveStreamProcessors();\n\n        for (var _i2 = 0; _i2 < _streamProcessors.length; _i2++) {\n          if (_streamProcessors[_i2].getType() === _Constants2.default.TEXT) {\n            streamProcessor = _streamProcessors[_i2];\n            mediaInfosArr = streamProcessor.getMediaInfoArr();\n            break;\n          }\n        }\n\n        if (streamProcessor && mediaInfosArr) {\n          for (var _i3 = 0; _i3 < mediaInfosArr.length; _i3++) {\n            if (mediaInfosArr[_i3].index === currentTrackInfo.index && mediaInfosArr[_i3].lang === currentTrackInfo.lang) {\n              streamProcessor.selectMediaInfo(mediaInfosArr[_i3]);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function getCurrentTrackIdx() {\n    return textTracks.getCurrentTrackIdx();\n  }\n\n  function resetInitialSettings() {\n    allTracksAreDisabled = true;\n    textTracksAdded = false;\n    disableTextBeforeTextTracksAdded = false;\n  }\n\n  function reset() {\n    resetInitialSettings();\n    textSourceBuffer.resetEmbedded();\n    textSourceBuffer.reset();\n  }\n\n  instance = {\n    setConfig: setConfig,\n    getTextSourceBuffer: getTextSourceBuffer,\n    getAllTracksAreDisabled: getAllTracksAreDisabled,\n    addEmbeddedTrack: addEmbeddedTrack,\n    getTextDefaultLanguage: getTextDefaultLanguage,\n    setTextDefaultLanguage: setTextDefaultLanguage,\n    setTextDefaultEnabled: setTextDefaultEnabled,\n    getTextDefaultEnabled: getTextDefaultEnabled,\n    setInitialSettings: setInitialSettings,\n    enableText: enableText,\n    isTextEnabled: isTextEnabled,\n    setTextTrack: setTextTrack,\n    getCurrentTrackIdx: getCurrentTrackIdx,\n    enableForcedTextStreaming: enableForcedTextStreaming,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nTextController.__dashjs_factory_name = 'TextController';\nexports.default = _FactoryMaker2.default.getSingletonFactory(TextController);","map":{"version":3,"mappings":"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","names":["TextController","context","instance","textSourceBuffer","errHandler","adapter","manifestModel","mediaController","videoModel","streamController","textTracks","vttParser","ttmlParser","eventBus","defaultSettings","initialSettingsSet","lastEnabledIndex","textDefaultEnabled","allTracksAreDisabled","forceTextStreaming","textTracksAdded","disableTextBeforeTextTracksAdded","previousPeriodSelectedTrack","setup","getInstance","initialize","on","Events","TEXT_TRACKS_QUEUE_INITIALIZED","onTextTracksAdded","CURRENT_TRACK_CHANGED","onCurrentTrackChanged","PERIOD_SWITCH_STARTED","onPeriodSwitchStarted","STREAM_COMPLETED","onStreamCompleted","PERIOD_SWITCH_COMPLETED","onPeriodSwitchCompleted","resetInitialSettings","e","undefined","fromStreamInfo","getCurrentTrackIdx","setTextTrack","setConfig","config","getTextSourceBuffer","getAllTracksAreDisabled","addEmbeddedTrack","mediaInfo","setTextDefaultLanguage","lang","setInitialSettings","settings","getTextDefaultLanguage","tracks","index","some","item","idx","matchSettings","_this","trigger","TEXT_TRACKS_ADDED","enabled","isTextEnabled","event","newMediaInfo","type","Constants","FRAGMENTED_TEXT","role","roles","accessibility","setTextDefaultEnabled","enable","getTextDefaultEnabled","enableText","enableForcedTextStreaming","getConfig","fragmentModel","fragmentedTracks","mediaInfosArr","streamProcessor","oldTrackIdx","saveTextSettingsDisabled","setModeForTrackIdx","TEXT_HIDDEN","setCurrentTrackIdx","TEXT_SHOWING","currentTrackInfo","getCurrentTrackInfo","isFragmented","isEmbedded","i","length","id","currentFragTrack","getCurrentTrackFor","getActiveStreamInfo","abortRequests","removeExecutedRequestsBeforeTime","remove","deleteCuesFromTrackIdx","setTrack","setCurrentFragmentedTrackIdx","streamProcessors","getActiveStreamProcessors","getType","setBufferingTime","getTime","getScheduleController","start","TEXT","getMediaInfoArr","selectMediaInfo","reset","resetEmbedded","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/streaming/text/TextController.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport TextSourceBuffer from './TextSourceBuffer';\nimport TextTracks from './TextTracks';\nimport VTTParser from '../utils/VTTParser';\nimport TTMLParser from '../utils/TTMLParser';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport { checkParameterType } from '../utils/SupervisorTools';\n\nfunction TextController() {\n\n    let context = this.context;\n\n    let instance,\n        textSourceBuffer,\n        errHandler,\n        adapter,\n        manifestModel,\n        mediaController,\n        videoModel,\n        streamController,\n        textTracks,\n        vttParser,\n        ttmlParser,\n        eventBus,\n        defaultSettings,\n        initialSettingsSet,\n        lastEnabledIndex,\n        textDefaultEnabled, // this is used for default settings (each time a file is loaded, we check value of this settings )\n        allTracksAreDisabled, // this is used for one session (when a file has been loaded, we use this settings to enable/disable text)\n        forceTextStreaming,\n        textTracksAdded,\n        disableTextBeforeTextTracksAdded,\n        previousPeriodSelectedTrack;\n\n    function setup() {\n\n        defaultSettings = null;\n        lastEnabledIndex = -1;\n        forceTextStreaming = false;\n        textTracksAdded = false;\n        initialSettingsSet = false;\n        disableTextBeforeTextTracksAdded = false;\n        textTracks = TextTracks(context).getInstance();\n        vttParser = VTTParser(context).getInstance();\n        ttmlParser = TTMLParser(context).getInstance();\n        textSourceBuffer = TextSourceBuffer(context).getInstance();\n        eventBus = EventBus(context).getInstance();\n\n        textTracks.initialize();\n        eventBus.on(Events.TEXT_TRACKS_QUEUE_INITIALIZED, onTextTracksAdded, instance);\n        eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n\n        /*\n        * register those event callbacks in order to detect switch of periods and set\n        * correctly the selected track index in the new period.\n        * there is different cases :\n        *   - switch occurs after a seek command from the user\n        *   - switch occurs but codecs in streams are different\n        *   - switch occurs and codecs in streams are not different\n        */\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, instance);\n        eventBus.on(Events.PERIOD_SWITCH_COMPLETED, onPeriodSwitchCompleted, instance);\n\n        resetInitialSettings();\n    }\n\n    function onPeriodSwitchStarted(e) {\n        if (previousPeriodSelectedTrack === undefined && e.fromStreamInfo !== null /* test if this is the first period */) {\n            previousPeriodSelectedTrack = this.getCurrentTrackIdx();\n        }\n    }\n\n    function onStreamCompleted() {\n        if (previousPeriodSelectedTrack === undefined) {\n            previousPeriodSelectedTrack = this.getCurrentTrackIdx();\n        }\n    }\n\n    function onPeriodSwitchCompleted() {\n        if (previousPeriodSelectedTrack !== undefined) {\n            this.setTextTrack(previousPeriodSelectedTrack);\n            previousPeriodSelectedTrack = undefined;\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.mediaController) {\n            mediaController = config.mediaController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.textTracks) {\n            textTracks = config.textTracks;\n        }\n        if (config.vttParser) {\n            vttParser = config.vttParser;\n        }\n        if (config.ttmlParser) {\n            ttmlParser = config.ttmlParser;\n        }\n\n        // create config for source buffer\n        textSourceBuffer.setConfig({\n            errHandler: errHandler,\n            adapter: adapter,\n            manifestModel: manifestModel,\n            mediaController: mediaController,\n            videoModel: videoModel,\n            streamController: streamController,\n            textTracks: textTracks,\n            vttParser: vttParser,\n            ttmlParser: ttmlParser\n        });\n    }\n\n    function getTextSourceBuffer() {\n        return textSourceBuffer;\n    }\n\n    function getAllTracksAreDisabled() {\n        return allTracksAreDisabled;\n    }\n\n    function addEmbeddedTrack(mediaInfo) {\n        textSourceBuffer.addEmbeddedTrack(mediaInfo);\n    }\n\n    function setTextDefaultLanguage(lang) {\n        checkParameterType(lang, 'string');\n        if (!defaultSettings) {\n            defaultSettings = {};\n        }\n        defaultSettings.lang = lang;\n        initialSettingsSet = true;\n    }\n\n    function setInitialSettings(settings) {\n        defaultSettings = settings;\n        initialSettingsSet = true;\n    }\n\n    function getTextDefaultLanguage() {\n        return defaultSettings && defaultSettings.lang || '';\n    }\n\n    function onTextTracksAdded(e) {\n        let tracks = e.tracks;\n        let index = e.index;\n\n        if (defaultSettings) {\n            tracks.some((item, idx) => {\n                // matchSettings is compatible with setTextDefaultLanguage and setInitialSettings\n                if (mediaController.matchSettings(defaultSettings, item)) {\n                    this.setTextTrack(idx);\n                    index = idx;\n                    return true;\n                }\n            });\n        }\n\n        if (textDefaultEnabled === false || ( textDefaultEnabled === undefined && !defaultSettings ) || disableTextBeforeTextTracksAdded) {\n            // disable text at startup if explicitely configured with setTextDefaultEnabled(false) or if there is no defaultSettings (configuration or from domStorage)\n            this.setTextTrack(-1);\n        }\n\n        lastEnabledIndex = index;\n        eventBus.trigger(Events.TEXT_TRACKS_ADDED, {\n            enabled: isTextEnabled(),\n            index: index,\n            tracks: tracks\n        });\n        textTracksAdded = true;\n    }\n\n    function onCurrentTrackChanged(event) {\n        if (!initialSettingsSet && event && event.newMediaInfo) {\n            let mediaInfo = event.newMediaInfo;\n            if (mediaInfo.type === Constants.FRAGMENTED_TEXT) {\n                defaultSettings = {\n                    lang: mediaInfo.lang,\n                    role: mediaInfo.roles[0],\n                    accessibility: mediaInfo.accessibility[0]\n                };\n            }\n        }\n    }\n\n    function setTextDefaultEnabled(enable) {\n        checkParameterType(enable,'boolean');\n        textDefaultEnabled = enable;\n\n        if (!textDefaultEnabled) {\n            // disable text at startup\n            this.setTextTrack(-1);\n        } else {\n            allTracksAreDisabled = false;\n        }\n    }\n\n    function getTextDefaultEnabled() {\n        return textDefaultEnabled === undefined ? false : textDefaultEnabled;\n    }\n\n    function enableText(enable) {\n        checkParameterType(enable,'boolean');\n        if (!textDefaultEnabled && enable) {\n            textDefaultEnabled = true;\n        }\n        if (isTextEnabled() !== enable) {\n            // change track selection\n            if (enable) {\n                // apply last enabled track\n                this.setTextTrack(lastEnabledIndex);\n            }\n\n            if (!enable) {\n                // keep last index and disable text track\n                lastEnabledIndex = this.getCurrentTrackIdx();\n                if (!textTracksAdded) {\n                    disableTextBeforeTextTracksAdded = true;\n                } else {\n                    this.setTextTrack(-1);\n                }\n            }\n        }\n    }\n\n    function isTextEnabled() {\n        let enabled = true;\n        if (allTracksAreDisabled && !forceTextStreaming) {\n            enabled = false;\n        }\n        return enabled;\n    }\n\n    // when set to true ScheduleController will allow schedule of chunks even if tracks are all disabled. Allowing streaming to hidden track for external players to work with.\n    function enableForcedTextStreaming(enable) {\n        checkParameterType(enable,'boolean');\n        forceTextStreaming = enable;\n    }\n\n    function setTextTrack(idx) {\n        //For external time text file, the only action needed to change a track is marking the track mode to showing.\n        // Fragmented text tracks need the additional step of calling TextController.setTextTrack();\n        let config = textSourceBuffer.getConfig();\n        let fragmentModel = config.fragmentModel;\n        let fragmentedTracks = config.fragmentedTracks;\n        let videoModel = config.videoModel;\n        let mediaInfosArr,\n            streamProcessor;\n\n        allTracksAreDisabled = idx === -1 ? true : false;\n\n        let oldTrackIdx = textTracks.getCurrentTrackIdx();\n        if (oldTrackIdx !== idx) {\n            if (allTracksAreDisabled && mediaController) {\n                mediaController.saveTextSettingsDisabled();\n            }\n            textTracks.setModeForTrackIdx(oldTrackIdx, Constants.TEXT_HIDDEN);\n            textTracks.setCurrentTrackIdx(idx);\n            textTracks.setModeForTrackIdx(idx, Constants.TEXT_SHOWING);\n\n            let currentTrackInfo = textTracks.getCurrentTrackInfo();\n\n            if (currentTrackInfo && currentTrackInfo.isFragmented && !currentTrackInfo.isEmbedded) {\n                for (let i = 0; i < fragmentedTracks.length; i++) {\n                    let mediaInfo = fragmentedTracks[i];\n                    if (currentTrackInfo.lang === mediaInfo.lang && currentTrackInfo.index === mediaInfo.index &&\n                        (mediaInfo.id ? currentTrackInfo.id === mediaInfo.id : currentTrackInfo.id === mediaInfo.index)) {\n                        let currentFragTrack = mediaController.getCurrentTrackFor(Constants.FRAGMENTED_TEXT, streamController.getActiveStreamInfo());\n                        if (mediaInfo !== currentFragTrack) {\n                            fragmentModel.abortRequests();\n                            fragmentModel.removeExecutedRequestsBeforeTime();\n                            textSourceBuffer.remove();\n                            textTracks.deleteCuesFromTrackIdx(oldTrackIdx);\n                            mediaController.setTrack(mediaInfo);\n                            textSourceBuffer.setCurrentFragmentedTrackIdx(i);\n                        } else if (oldTrackIdx === -1) {\n                            //in fragmented use case, if the user selects the older track (the one selected before disabled text track)\n                            //no CURRENT_TRACK_CHANGED event will be trigger, so dashHandler current time has to be updated and the scheduleController\n                            //has to be restarted.\n                            const streamProcessors = streamController.getActiveStreamProcessors();\n                            for (let i = 0; i < streamProcessors.length; i++) {\n                                if (streamProcessors[i].getType() === Constants.FRAGMENTED_TEXT) {\n                                    streamProcessor = streamProcessors[i];\n                                    break;\n                                }\n                            }\n                            streamProcessor.setBufferingTime(videoModel.getTime());\n                            streamProcessor.getScheduleController().start();\n                        }\n                    }\n                }\n            } else if (currentTrackInfo && !currentTrackInfo.isFragmented) {\n                const streamProcessors = streamController.getActiveStreamProcessors();\n                for (let i = 0; i < streamProcessors.length; i++) {\n                    if (streamProcessors[i].getType() === Constants.TEXT) {\n                        streamProcessor = streamProcessors[i];\n                        mediaInfosArr = streamProcessor.getMediaInfoArr();\n                        break;\n                    }\n                }\n\n                if (streamProcessor && mediaInfosArr) {\n                    for (let i = 0; i < mediaInfosArr.length; i++) {\n                        if (mediaInfosArr[i].index === currentTrackInfo.index && mediaInfosArr[i].lang === currentTrackInfo.lang) {\n                            streamProcessor.selectMediaInfo(mediaInfosArr[i]);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function getCurrentTrackIdx() {\n        return textTracks.getCurrentTrackIdx();\n    }\n\n    function resetInitialSettings() {\n        allTracksAreDisabled = true;\n        textTracksAdded = false;\n        disableTextBeforeTextTracksAdded = false;\n    }\n\n    function reset() {\n        resetInitialSettings();\n        textSourceBuffer.resetEmbedded();\n        textSourceBuffer.reset();\n    }\n\n    instance = {\n        setConfig: setConfig,\n        getTextSourceBuffer: getTextSourceBuffer,\n        getAllTracksAreDisabled: getAllTracksAreDisabled,\n        addEmbeddedTrack: addEmbeddedTrack,\n        getTextDefaultLanguage: getTextDefaultLanguage,\n        setTextDefaultLanguage: setTextDefaultLanguage,\n        setTextDefaultEnabled: setTextDefaultEnabled,\n        getTextDefaultEnabled: getTextDefaultEnabled,\n        setInitialSettings: setInitialSettings,\n        enableText: enableText,\n        isTextEnabled: isTextEnabled,\n        setTextTrack: setTextTrack,\n        getCurrentTrackIdx: getCurrentTrackIdx,\n        enableForcedTextStreaming: enableForcedTextStreaming,\n        reset: reset\n    };\n    setup();\n    return instance;\n}\n\nTextController.__dashjs_factory_name = 'TextController';\nexport default FactoryMaker.getSingletonFactory(TextController);\n"]},"metadata":{},"sourceType":"script"}