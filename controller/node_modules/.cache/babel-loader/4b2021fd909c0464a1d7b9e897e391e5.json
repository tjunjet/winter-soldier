{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('./FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _MediaPlayerEvents = require('../streaming/MediaPlayerEvents');\n\nvar _MediaPlayerEvents2 = _interopRequireDefault(_MediaPlayerEvents);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar EVENT_PRIORITY_LOW = 0;\nvar EVENT_PRIORITY_HIGH = 5000;\n\nfunction EventBus() {\n  var handlers = {};\n\n  function on(type, listener, scope) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (!type) {\n      throw new Error('event type cannot be null or undefined');\n    }\n\n    if (!listener || typeof listener !== 'function') {\n      throw new Error('listener must be a function: ' + listener);\n    }\n\n    var priority = options.priority || EVENT_PRIORITY_LOW;\n    if (getHandlerIdx(type, listener, scope) >= 0) return;\n    handlers[type] = handlers[type] || [];\n    var handler = {\n      callback: listener,\n      scope: scope,\n      priority: priority\n    };\n\n    if (scope && scope.getStreamId) {\n      handler.streamId = scope.getStreamId();\n    }\n\n    if (scope && scope.getType) {\n      handler.mediaType = scope.getType();\n    }\n\n    if (options && options.mode) {\n      handler.mode = options.mode;\n    }\n\n    var inserted = handlers[type].some(function (item, idx) {\n      if (item && priority > item.priority) {\n        handlers[type].splice(idx, 0, handler);\n        return true;\n      }\n    });\n\n    if (!inserted) {\n      handlers[type].push(handler);\n    }\n  }\n\n  function off(type, listener, scope) {\n    if (!type || !listener || !handlers[type]) return;\n    var idx = getHandlerIdx(type, listener, scope);\n    if (idx < 0) return;\n    handlers[type][idx] = null;\n  }\n\n  function trigger(type) {\n    var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var filters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!type || !handlers[type]) return;\n    payload = payload || {};\n    if (payload.hasOwnProperty('type')) throw new Error('\\'type\\' is a reserved word for event dispatching');\n    payload.type = type;\n\n    if (filters.streamId) {\n      payload.streamId = filters.streamId;\n    }\n\n    if (filters.mediaType) {\n      payload.mediaType = filters.mediaType;\n    }\n\n    handlers[type].filter(function (handler) {\n      if (!handler) {\n        return false;\n      }\n\n      if (filters.streamId && handler.streamId && handler.streamId !== filters.streamId) {\n        return false;\n      }\n\n      if (filters.mediaType && handler.mediaType && handler.mediaType !== filters.mediaType) {\n        return false;\n      } // This is used for dispatching DASH events. By default we use the onStart mode. Consequently we filter everything that has a non matching mode and the onReceive events for handlers that did not specify a mode.\n\n\n      if (filters.mode && handler.mode && handler.mode !== filters.mode || !handler.mode && filters.mode && filters.mode === _MediaPlayerEvents2.default.EVENT_MODE_ON_RECEIVE) {\n        return false;\n      }\n\n      return true;\n    }).forEach(function (handler) {\n      return handler && handler.callback.call(handler.scope, payload);\n    });\n  }\n\n  function getHandlerIdx(type, listener, scope) {\n    var idx = -1;\n    if (!handlers[type]) return idx;\n    handlers[type].some(function (item, index) {\n      if (item && item.callback === listener && (!scope || scope === item.scope)) {\n        idx = index;\n        return true;\n      }\n    });\n    return idx;\n  }\n\n  function reset() {\n    handlers = {};\n  }\n\n  var instance = {\n    on: on,\n    off: off,\n    trigger: trigger,\n    reset: reset\n  };\n  return instance;\n}\n\nEventBus.__dashjs_factory_name = 'EventBus';\n\nvar factory = _FactoryMaker2.default.getSingletonFactory(EventBus);\n\nfactory.EVENT_PRIORITY_LOW = EVENT_PRIORITY_LOW;\nfactory.EVENT_PRIORITY_HIGH = EVENT_PRIORITY_HIGH;\n\n_FactoryMaker2.default.updateSingletonFactory(EventBus.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"mappings":";;;;;;AA8BA;;;;AACA;;;;;;;;AA/BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,IAAMA,qBAAqB,CAA3B;AACA,IAAMC,sBAAsB,IAA5B;;AAEA,SAASC,QAAT,GAAoB;EAEhB,IAAIC,WAAW,EAAf;;EAEA,SAASC,EAAT,CAAYC,IAAZ,EAAkBC,QAAlB,EAA4BC,KAA5B,EAAiD;IAAA,IAAdC,OAAc,uEAAJ,EAAI;;IAE7C,IAAI,CAACH,IAAL,EAAW;MACP,MAAM,IAAII,KAAJ,CAAU,wCAAV,CAAN;IAEJ;;IAAA,IAAI,CAACH,QAAD,IAAa,OAAQA,QAAR,KAAsB,UAAvC,EAAmD;MAC/C,MAAM,IAAIG,KAAJ,CAAU,kCAAkCH,QAA5C,CAAN;IAGJ;;IAAA,IAAII,WAAWF,QAAQE,QAARF,IAAoBR,kBAAnC;IAEA,IAAIW,cAAcN,IAAdM,EAAoBL,QAApBK,EAA8BJ,KAA9BI,KAAwC,CAA5C,EAA+C;IAE/CR,SAASE,IAATF,IAAiBA,SAASE,IAATF,KAAkB,EAAnCA;IAEA,IAAMS,UAAU;MACZC,UAAUP,QADE;MAEZC,YAFY;MAGZG;IAHY,CAAhB;;IAMA,IAAIH,SAASA,MAAMO,WAAnB,EAAgC;MAC5BF,QAAQG,QAARH,GAAmBL,MAAMO,WAANP,EAAnBK;IAEJ;;IAAA,IAAIL,SAASA,MAAMS,OAAnB,EAA4B;MACxBJ,QAAQK,SAARL,GAAoBL,MAAMS,OAANT,EAApBK;IAEJ;;IAAA,IAAIJ,WAAWA,QAAQU,IAAvB,EAA6B;MACzBN,QAAQM,IAARN,GAAeJ,QAAQU,IAAvBN;IAGJ;;IAAA,IAAMO,WAAWhB,SAASE,IAATF,EAAeiB,IAAfjB,CAAoB,UAACkB,IAAD,EAAOC,GAAP,EAAe;MAChD,IAAID,QAAQX,WAAWW,KAAKX,QAA5B,EAAsC;QAClCP,SAASE,IAATF,EAAeoB,MAAfpB,CAAsBmB,GAAtBnB,EAA2B,CAA3BA,EAA8BS,OAA9BT;QACA,OAAO,IAAP;MAEP;IALgB,EAAjB;;IAOA,IAAI,CAACgB,QAAL,EAAe;MACXhB,SAASE,IAATF,EAAeqB,IAAfrB,CAAoBS,OAApBT;IAEP;EAED;;EAAA,SAASsB,GAAT,CAAapB,IAAb,EAAmBC,QAAnB,EAA6BC,KAA7B,EAAoC;IAChC,IAAI,CAACF,IAAD,IAAS,CAACC,QAAV,IAAsB,CAACH,SAASE,IAATF,CAA3B,EAA2C;IAC3C,IAAMmB,MAAMX,cAAcN,IAAdM,EAAoBL,QAApBK,EAA8BJ,KAA9BI,CAAZ;IACA,IAAIW,MAAM,CAAV,EAAa;IACbnB,SAASE,IAATF,EAAemB,GAAfnB,IAAsB,IAAtBA;EAGJ;;EAAA,SAASuB,OAAT,CAAiBrB,IAAjB,EAAmD;IAAA,IAA5BsB,OAA4B,uEAAlB,EAAkB;IAAA,IAAdC,OAAc,uEAAJ,EAAI;IAC/C,IAAI,CAACvB,IAAD,IAAS,CAACF,SAASE,IAATF,CAAd,EAA8B;IAE9BwB,UAAUA,WAAW,EAArBA;IAEA,IAAIA,QAAQE,cAARF,CAAuB,MAAvBA,CAAJ,EAAoC,MAAM,IAAIlB,KAAJ,CAAU,mDAAV,CAAN;IAEpCkB,QAAQtB,IAARsB,GAAetB,IAAfsB;;IAEA,IAAIC,QAAQb,QAAZ,EAAsB;MAClBY,QAAQZ,QAARY,GAAmBC,QAAQb,QAA3BY;IAEJ;;IAAA,IAAIC,QAAQX,SAAZ,EAAuB;MACnBU,QAAQV,SAARU,GAAoBC,QAAQX,SAA5BU;IAGJxB;;IAAAA,SAASE,IAATF,EACK2B,MADL3B,CACY,UAACS,OAAD,EAAa;MACjB,IAAI,CAACA,OAAL,EAAc;QACV,OAAO,KAAP;MAEJ;;MAAA,IAAIgB,QAAQb,QAARa,IAAoBhB,QAAQG,QAA5Ba,IAAwChB,QAAQG,QAARH,KAAqBgB,QAAQb,QAAzE,EAAmF;QAC/E,OAAO,KAAP;MAEJ;;MAAA,IAAIa,QAAQX,SAARW,IAAqBhB,QAAQK,SAA7BW,IAA0ChB,QAAQK,SAARL,KAAsBgB,QAAQX,SAA5E,EAAuF;QACnF,OAAO,KAAP;MAEJ,CAViB,CAUjB;;;MACA,IAAKW,QAAQV,IAARU,IAAgBhB,QAAQM,IAAxBU,IAAgChB,QAAQM,IAARN,KAAiBgB,QAAQV,IAAzDU,IAAmE,CAAChB,QAAQM,IAAT,IAAiBU,QAAQV,IAAzB,IAAiCU,QAAQV,IAARU,KAAiBG,4BAAkBC,qBAA5I,EAAoK;QAChK,OAAO,KAAP;MAEJ;;MAAA,OAAO,IAAP;IAfR,GAiBKC,OAjBL9B,CAiBa;MAAA,OAAWS,WAAWA,QAAQC,QAARD,CAAiBsB,IAAjBtB,CAAsBA,QAAQL,KAA9BK,EAAqCe,OAArCf,CAAtB;IAjBb;EAoBJ;;EAAA,SAASD,aAAT,CAAuBN,IAAvB,EAA6BC,QAA7B,EAAuCC,KAAvC,EAA8C;IAE1C,IAAIe,MAAM,CAAC,CAAX;IAEA,IAAI,CAACnB,SAASE,IAATF,CAAL,EAAqB,OAAOmB,GAAP;IAErBnB,SAASE,IAATF,EAAeiB,IAAfjB,CAAoB,UAACkB,IAAD,EAAOc,KAAP,EAAiB;MACjC,IAAId,QAAQA,KAAKR,QAALQ,KAAkBf,QAA1Be,KAAuC,CAACd,KAAD,IAAUA,UAAUc,KAAKd,KAAhEc,CAAJ,EAA4E;QACxEC,MAAMa,KAANb;QACA,OAAO,IAAP;MAEP;IALD;IAMA,OAAOA,GAAP;EAGJ;;EAAA,SAASc,KAAT,GAAiB;IACbjC,WAAW,EAAXA;EAGJ;;EAAA,IAAMkC,WAAW;IACbjC,IAAIA,EADS;IAEbqB,KAAKA,GAFQ;IAGbC,SAASA,OAHI;IAIbU,OAAOA;EAJM,CAAjB;EAOA,OAAOC,QAAP;AAGJnC;;AAAAA,SAASoC,qBAATpC,GAAiC,UAAjCA;;AACA,IAAMqC,UAAUC,uBAAaC,mBAAbD,CAAiCtC,QAAjCsC,CAAhB;;AACAD,QAAQvC,kBAARuC,GAA6BvC,kBAA7BuC;AACAA,QAAQtC,mBAARsC,GAA8BtC,mBAA9BsC;;AACAC,uBAAaE,sBAAbF,CAAoCtC,SAASoC,qBAA7CE,EAAoED,OAApEC;;kBACeD,O","names":["EVENT_PRIORITY_LOW","EVENT_PRIORITY_HIGH","EventBus","handlers","on","type","listener","scope","options","Error","priority","getHandlerIdx","handler","callback","getStreamId","streamId","getType","mediaType","mode","inserted","some","item","idx","splice","push","off","trigger","payload","filters","hasOwnProperty","filter","MediaPlayerEvents","EVENT_MODE_ON_RECEIVE","forEach","call","index","reset","instance","__dashjs_factory_name","factory","FactoryMaker","getSingletonFactory","updateSingletonFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/core/EventBus.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from './FactoryMaker';\nimport MediaPlayerEvents from '../streaming/MediaPlayerEvents';\n\nconst EVENT_PRIORITY_LOW = 0;\nconst EVENT_PRIORITY_HIGH = 5000;\n\nfunction EventBus() {\n\n    let handlers = {};\n\n    function on(type, listener, scope, options = {}) {\n\n        if (!type) {\n            throw new Error('event type cannot be null or undefined');\n        }\n        if (!listener || typeof (listener) !== 'function') {\n            throw new Error('listener must be a function: ' + listener);\n        }\n\n        let priority = options.priority || EVENT_PRIORITY_LOW;\n\n        if (getHandlerIdx(type, listener, scope) >= 0) return;\n\n        handlers[type] = handlers[type] || [];\n\n        const handler = {\n            callback: listener,\n            scope,\n            priority\n        };\n\n        if (scope && scope.getStreamId) {\n            handler.streamId = scope.getStreamId();\n        }\n        if (scope && scope.getType) {\n            handler.mediaType = scope.getType();\n        }\n        if (options && options.mode) {\n            handler.mode = options.mode;\n        }\n\n        const inserted = handlers[type].some((item, idx) => {\n            if (item && priority > item.priority) {\n                handlers[type].splice(idx, 0, handler);\n                return true;\n            }\n        });\n\n        if (!inserted) {\n            handlers[type].push(handler);\n        }\n    }\n\n    function off(type, listener, scope) {\n        if (!type || !listener || !handlers[type]) return;\n        const idx = getHandlerIdx(type, listener, scope);\n        if (idx < 0) return;\n        handlers[type][idx] = null;\n    }\n\n    function trigger(type, payload = {}, filters = {}) {\n        if (!type || !handlers[type]) return;\n\n        payload = payload || {};\n\n        if (payload.hasOwnProperty('type')) throw new Error('\\'type\\' is a reserved word for event dispatching');\n\n        payload.type = type;\n\n        if (filters.streamId) {\n            payload.streamId = filters.streamId;\n        }\n        if (filters.mediaType) {\n            payload.mediaType = filters.mediaType;\n        }\n\n        handlers[type]\n            .filter((handler) => {\n                if (!handler) {\n                    return false;\n                }\n                if (filters.streamId && handler.streamId && handler.streamId !== filters.streamId) {\n                    return false;\n                }\n                if (filters.mediaType && handler.mediaType && handler.mediaType !== filters.mediaType) {\n                    return false;\n                }\n                // This is used for dispatching DASH events. By default we use the onStart mode. Consequently we filter everything that has a non matching mode and the onReceive events for handlers that did not specify a mode.\n                if ((filters.mode && handler.mode && handler.mode !== filters.mode) || (!handler.mode && filters.mode && filters.mode === MediaPlayerEvents.EVENT_MODE_ON_RECEIVE)) {\n                    return false;\n                }\n                return true;\n            })\n            .forEach(handler => handler && handler.callback.call(handler.scope, payload));\n    }\n\n    function getHandlerIdx(type, listener, scope) {\n\n        let idx = -1;\n\n        if (!handlers[type]) return idx;\n\n        handlers[type].some((item, index) => {\n            if (item && item.callback === listener && (!scope || scope === item.scope)) {\n                idx = index;\n                return true;\n            }\n        });\n        return idx;\n    }\n\n    function reset() {\n        handlers = {};\n    }\n\n    const instance = {\n        on: on,\n        off: off,\n        trigger: trigger,\n        reset: reset\n    };\n\n    return instance;\n}\n\nEventBus.__dashjs_factory_name = 'EventBus';\nconst factory = FactoryMaker.getSingletonFactory(EventBus);\nfactory.EVENT_PRIORITY_LOW = EVENT_PRIORITY_LOW;\nfactory.EVENT_PRIORITY_HIGH = EVENT_PRIORITY_HIGH;\nFactoryMaker.updateSingletonFactory(EventBus.__dashjs_factory_name, factory);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}