{"ast":null,"code":"/* \r\n * Copyright (c) 2016, Pierre-Anthony Lemieux <pal@sandflow.com>\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\n\n/**\r\n * @module imscISD\r\n */\n;\n\n(function (imscISD, imscNames, imscStyles, imscUtils) {\n  // wrapper for non-node envs\n\n  /** \r\n   * Creates a canonical representation of an IMSC1 document returned by <pre>imscDoc.fromXML()</pre>\r\n   * at a given absolute offset in seconds. This offset does not have to be one of the values returned\r\n   * by <pre>getMediaTimeEvents()</pre>.\r\n   * \r\n   * @param {Object} tt IMSC1 document\r\n   * @param {number} offset Absolute offset (in seconds)\r\n   * @param {?module:imscUtils.ErrorHandler} errorHandler Error callback\r\n   * @returns {Object} Opaque in-memory representation of an ISD\r\n   */\n  imscISD.generateISD = function (tt, offset, errorHandler) {\n    /* TODO check for tt and offset validity */\n\n    /* create the ISD object from the IMSC1 doc */\n    var isd = new ISD(tt);\n    /* context */\n\n    var context = {\n      /*rubyfs: []*/\n\n      /* font size of the nearest textContainer or container */\n    };\n    /* Filter body contents - Only process what we need within the offset and discard regions not applicable to the content */\n\n    var body = {};\n    var activeRegions = {};\n    /* gather any regions that might have showBackground=\"always\" and show a background */\n\n    var initialShowBackground = tt.head.styling.initials[imscStyles.byName.showBackground.qname];\n    var initialbackgroundColor = tt.head.styling.initials[imscStyles.byName.backgroundColor.qname];\n\n    for (var layout_child in tt.head.layout.regions) {\n      if (tt.head.layout.regions.hasOwnProperty(layout_child)) {\n        var region = tt.head.layout.regions[layout_child];\n        var showBackground = region.styleAttrs[imscStyles.byName.showBackground.qname] || initialShowBackground;\n        var backgroundColor = region.styleAttrs[imscStyles.byName.backgroundColor.qname] || initialbackgroundColor;\n        activeRegions[region.id] = (showBackground === 'always' || showBackground === undefined) && backgroundColor !== undefined && !(offset < region.begin || offset >= region.end);\n      }\n    }\n    /* If the body specifies a region, catch it, since no filtered content will */\n\n    /* likely specify the region. */\n\n\n    if (tt.body && tt.body.regionID) {\n      activeRegions[tt.body.regionID] = true;\n    }\n\n    function filter(offset, element) {\n      function offsetFilter(element) {\n        return !(offset < element.begin || offset >= element.end);\n      }\n\n      if (element.contents) {\n        var clone = {};\n\n        for (var prop in element) {\n          if (element.hasOwnProperty(prop)) {\n            clone[prop] = element[prop];\n          }\n        }\n\n        clone.contents = [];\n        element.contents.filter(offsetFilter).forEach(function (el) {\n          var filteredElement = filter(offset, el);\n\n          if (filteredElement.regionID) {\n            activeRegions[filteredElement.regionID] = true;\n          }\n\n          if (filteredElement !== null) {\n            clone.contents.push(filteredElement);\n          }\n        });\n        return clone;\n      } else {\n        return element;\n      }\n    }\n\n    if (tt.body !== null) {\n      body = filter(offset, tt.body);\n    } else {\n      body = null;\n    }\n    /* rewritten TTML will always have a default - this covers it. because the region is defaulted to \"\" */\n\n\n    if (activeRegions[\"\"] !== undefined) {\n      activeRegions[\"\"] = true;\n    }\n    /* process regions */\n\n\n    for (var regionID in activeRegions) {\n      if (activeRegions[regionID]) {\n        /* post-order traversal of the body tree per [construct intermediate document] */\n        var c = isdProcessContentElement(tt, offset, tt.head.layout.regions[regionID], body, null, '', tt.head.layout.regions[regionID], errorHandler, context);\n\n        if (c !== null) {\n          /* add the region to the ISD */\n          isd.contents.push(c.element);\n        }\n      }\n    }\n\n    return isd;\n  };\n  /* set of styles not applicable to ruby container spans */\n\n\n  var _rcs_na_styles = [imscStyles.byName.color.qname, imscStyles.byName.textCombine.qname, imscStyles.byName.textDecoration.qname, imscStyles.byName.textEmphasis.qname, imscStyles.byName.textOutline.qname, imscStyles.byName.textShadow.qname];\n\n  function isdProcessContentElement(doc, offset, region, body, parent, inherited_region_id, elem, errorHandler, context) {\n    /* prune if temporally inactive */\n    if (offset < elem.begin || offset >= elem.end) {\n      return null;\n    }\n    /* \r\n     * set the associated region as specified by the regionID attribute, or the \r\n     * inherited associated region otherwise\r\n     */\n\n\n    var associated_region_id = 'regionID' in elem && elem.regionID !== '' ? elem.regionID : inherited_region_id;\n    /* prune the element if either:\r\n     * - the element is not terminal and the associated region is neither the default\r\n     *   region nor the parent region (this allows children to be associated with a \r\n     *   region later on)\r\n     * - the element is terminal and the associated region is not the parent region\r\n     */\n\n    /* TODO: improve detection of terminal elements since <region> has no contents */\n\n    if (parent !== null\n    /* are we in the region element */\n    && associated_region_id !== region.id && (!('contents' in elem) || 'contents' in elem && elem.contents.length === 0 || associated_region_id !== '')) return null;\n    /* create an ISD element, including applying specified styles */\n\n    var isd_element = new ISDContentElement(elem);\n    /* apply set (animation) styling */\n\n    if (\"sets\" in elem) {\n      for (var i = 0; i < elem.sets.length; i++) {\n        if (offset < elem.sets[i].begin || offset >= elem.sets[i].end) continue;\n        isd_element.styleAttrs[elem.sets[i].qname] = elem.sets[i].value;\n      }\n    }\n    /* \r\n     * keep track of specified styling attributes so that we\r\n     * can compute them later\r\n     */\n\n\n    var spec_attr = {};\n\n    for (var qname in isd_element.styleAttrs) {\n      if (!isd_element.styleAttrs.hasOwnProperty(qname)) continue;\n      spec_attr[qname] = true;\n      /* special rule for tts:writingMode (section 7.29.1 of XSL)\r\n       * direction is set consistently with writingMode only\r\n       * if writingMode sets inline-direction to LTR or RTL  \r\n       */\n\n      if (isd_element.kind === 'region' && qname === imscStyles.byName.writingMode.qname && !(imscStyles.byName.direction.qname in isd_element.styleAttrs)) {\n        var wm = isd_element.styleAttrs[qname];\n\n        if (wm === \"lrtb\" || wm === \"lr\") {\n          isd_element.styleAttrs[imscStyles.byName.direction.qname] = \"ltr\";\n        } else if (wm === \"rltb\" || wm === \"rl\") {\n          isd_element.styleAttrs[imscStyles.byName.direction.qname] = \"rtl\";\n        }\n      }\n    }\n    /* inherited styling */\n\n\n    if (parent !== null) {\n      for (var j = 0; j < imscStyles.all.length; j++) {\n        var sa = imscStyles.all[j];\n        /* textDecoration has special inheritance rules */\n\n        if (sa.qname === imscStyles.byName.textDecoration.qname) {\n          /* handle both textDecoration inheritance and specification */\n          var ps = parent.styleAttrs[sa.qname];\n          var es = isd_element.styleAttrs[sa.qname];\n          var outs = [];\n\n          if (es === undefined) {\n            outs = ps;\n          } else if (es.indexOf(\"none\") === -1) {\n            if (es.indexOf(\"noUnderline\") === -1 && ps.indexOf(\"underline\") !== -1 || es.indexOf(\"underline\") !== -1) {\n              outs.push(\"underline\");\n            }\n\n            if (es.indexOf(\"noLineThrough\") === -1 && ps.indexOf(\"lineThrough\") !== -1 || es.indexOf(\"lineThrough\") !== -1) {\n              outs.push(\"lineThrough\");\n            }\n\n            if (es.indexOf(\"noOverline\") === -1 && ps.indexOf(\"overline\") !== -1 || es.indexOf(\"overline\") !== -1) {\n              outs.push(\"overline\");\n            }\n          } else {\n            outs.push(\"none\");\n          }\n\n          isd_element.styleAttrs[sa.qname] = outs;\n        } else if (sa.qname === imscStyles.byName.fontSize.qname && !(sa.qname in isd_element.styleAttrs) && isd_element.kind === 'span' && isd_element.styleAttrs[imscStyles.byName.ruby.qname] === \"textContainer\") {\n          /* special inheritance rule for ruby text container font size */\n          var ruby_fs = parent.styleAttrs[imscStyles.byName.fontSize.qname];\n          isd_element.styleAttrs[sa.qname] = new imscUtils.ComputedLength(0.5 * ruby_fs.rw, 0.5 * ruby_fs.rh);\n        } else if (sa.qname === imscStyles.byName.fontSize.qname && !(sa.qname in isd_element.styleAttrs) && isd_element.kind === 'span' && isd_element.styleAttrs[imscStyles.byName.ruby.qname] === \"text\") {\n          /* special inheritance rule for ruby text font size */\n          var parent_fs = parent.styleAttrs[imscStyles.byName.fontSize.qname];\n\n          if (parent.styleAttrs[imscStyles.byName.ruby.qname] === \"textContainer\") {\n            isd_element.styleAttrs[sa.qname] = parent_fs;\n          } else {\n            isd_element.styleAttrs[sa.qname] = new imscUtils.ComputedLength(0.5 * parent_fs.rw, 0.5 * parent_fs.rh);\n          }\n        } else if (sa.inherit && sa.qname in parent.styleAttrs && !(sa.qname in isd_element.styleAttrs)) {\n          isd_element.styleAttrs[sa.qname] = parent.styleAttrs[sa.qname];\n        }\n      }\n    }\n    /* initial value styling */\n\n\n    for (var k = 0; k < imscStyles.all.length; k++) {\n      var ivs = imscStyles.all[k];\n      /* skip if value is already specified */\n\n      if (ivs.qname in isd_element.styleAttrs) continue;\n      /* skip tts:position if tts:origin is specified */\n\n      if (ivs.qname === imscStyles.byName.position.qname && imscStyles.byName.origin.qname in isd_element.styleAttrs) continue;\n      /* skip tts:origin if tts:position is specified */\n\n      if (ivs.qname === imscStyles.byName.origin.qname && imscStyles.byName.position.qname in isd_element.styleAttrs) continue;\n      /* determine initial value */\n\n      var iv = doc.head.styling.initials[ivs.qname] || ivs.initial;\n\n      if (iv === null) {\n        /* skip processing if no initial value defined */\n        continue;\n      }\n      /* apply initial value to elements other than region only if non-inherited */\n\n\n      if (isd_element.kind === 'region' || ivs.inherit === false && iv !== null) {\n        var piv = ivs.parse(iv);\n\n        if (piv !== null) {\n          isd_element.styleAttrs[ivs.qname] = piv;\n          /* keep track of the style as specified */\n\n          spec_attr[ivs.qname] = true;\n        } else {\n          reportError(errorHandler, \"Invalid initial value for '\" + ivs.qname + \"' on element '\" + isd_element.kind);\n        }\n      }\n    }\n    /* compute styles (only for non-inherited styles) */\n\n    /* TODO: get rid of spec_attr */\n\n\n    for (var z = 0; z < imscStyles.all.length; z++) {\n      var cs = imscStyles.all[z];\n      if (!(cs.qname in spec_attr)) continue;\n\n      if (cs.compute !== null) {\n        var cstyle = cs.compute(\n        /*doc, parent, element, attr, context*/\n        doc, parent, isd_element, isd_element.styleAttrs[cs.qname], context);\n\n        if (cstyle !== null) {\n          isd_element.styleAttrs[cs.qname] = cstyle;\n        } else {\n          /* if the style cannot be computed, replace it by its initial value */\n          isd_element.styleAttrs[cs.qname] = cs.compute(\n          /*doc, parent, element, attr, context*/\n          doc, parent, isd_element, cs.parse(cs.initial), context);\n          reportError(errorHandler, \"Style '\" + cs.qname + \"' on element '\" + isd_element.kind + \"' cannot be computed\");\n        }\n      }\n    }\n    /* prune if tts:display is none */\n\n\n    if (isd_element.styleAttrs[imscStyles.byName.display.qname] === \"none\") return null;\n    /* process contents of the element */\n\n    var contents = null;\n\n    if (parent === null) {\n      /* we are processing the region */\n      if (body === null) {\n        /* if there is no body, still process the region but with empty content */\n        contents = [];\n      } else {\n        /*use the body element as contents */\n        contents = [body];\n      }\n    } else if ('contents' in elem) {\n      contents = elem.contents;\n    }\n\n    for (var x = 0; contents !== null && x < contents.length; x++) {\n      var c = isdProcessContentElement(doc, offset, region, body, isd_element, associated_region_id, contents[x], errorHandler, context);\n      /* \r\n       * keep child element only if they are non-null and their region match \r\n       * the region of this element\r\n       */\n\n      if (c !== null) {\n        isd_element.contents.push(c.element);\n      }\n    }\n    /* remove styles that are not applicable */\n\n\n    for (var qnameb in isd_element.styleAttrs) {\n      if (!isd_element.styleAttrs.hasOwnProperty(qnameb)) continue;\n      /* true if not applicable */\n\n      var na = false;\n      /* special applicability of certain style properties to ruby container spans */\n\n      /* TODO: in the future ruby elements should be translated to elements instead of kept as spans */\n\n      if (isd_element.kind === 'span') {\n        var rsp = isd_element.styleAttrs[imscStyles.byName.ruby.qname];\n        na = (rsp === 'container' || rsp === 'textContainer' || rsp === 'baseContainer') && _rcs_na_styles.indexOf(qnameb) !== -1;\n\n        if (!na) {\n          na = rsp !== 'container' && qnameb === imscStyles.byName.rubyAlign.qname;\n        }\n\n        if (!na) {\n          na = !(rsp === 'textContainer' || rsp === 'text') && qnameb === imscStyles.byName.rubyPosition.qname;\n        }\n      }\n      /* normal applicability */\n\n\n      if (!na) {\n        var da = imscStyles.byQName[qnameb];\n\n        if (\"applies\" in da) {\n          na = da.applies.indexOf(isd_element.kind) === -1;\n        }\n      }\n\n      if (na) {\n        delete isd_element.styleAttrs[qnameb];\n      }\n    }\n    /* trim whitespace around explicit line breaks */\n\n\n    var ruby = isd_element.styleAttrs[imscStyles.byName.ruby.qname];\n\n    if (isd_element.kind === 'p' || isd_element.kind === 'span' && (ruby === \"textContainer\" || ruby === \"text\")) {\n      var elist = [];\n      constructSpanList(isd_element, elist);\n      collapseLWSP(elist);\n      pruneEmptySpans(isd_element);\n    }\n    /* keep element if:\r\n     * * contains a background image\r\n     * * <br/>\r\n     * * if there are children\r\n     * * if it is an image\r\n     * * if <span> and has text\r\n     * * if region and showBackground = always\r\n     */\n\n\n    if (isd_element.kind === 'div' && imscStyles.byName.backgroundImage.qname in isd_element.styleAttrs || isd_element.kind === 'br' || isd_element.kind === 'image' || 'contents' in isd_element && isd_element.contents.length > 0 || isd_element.kind === 'span' && isd_element.text !== null || isd_element.kind === 'region' && isd_element.styleAttrs[imscStyles.byName.showBackground.qname] === 'always') {\n      return {\n        region_id: associated_region_id,\n        element: isd_element\n      };\n    }\n\n    return null;\n  }\n\n  function collapseLWSP(elist) {\n    function isPrevCharLWSP(prev_element) {\n      return prev_element.kind === 'br' || /[\\r\\n\\t ]$/.test(prev_element.text);\n    }\n\n    function isNextCharLWSP(next_element) {\n      return next_element.kind === 'br' || next_element.space === \"preserve\" && /^[\\r\\n]/.test(next_element.text);\n    }\n    /* collapse spaces and remove leading LWSPs */\n\n\n    var element;\n\n    for (var i = 0; i < elist.length;) {\n      element = elist[i];\n\n      if (element.kind === \"br\" || element.space === \"preserve\") {\n        i++;\n        continue;\n      }\n\n      var trimmed_text = element.text.replace(/[\\t\\r\\n ]+/g, ' ');\n\n      if (/^[ ]/.test(trimmed_text)) {\n        if (i === 0 || isPrevCharLWSP(elist[i - 1])) {\n          trimmed_text = trimmed_text.substring(1);\n        }\n      }\n\n      element.text = trimmed_text;\n\n      if (trimmed_text.length === 0) {\n        elist.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n    /* remove trailing LWSPs */\n\n\n    for (i = 0; i < elist.length; i++) {\n      element = elist[i];\n\n      if (element.kind === \"br\" || element.space === \"preserve\") {\n        i++;\n        continue;\n      }\n\n      if (/[ ]$/.test(element.text)) {\n        if (i === elist.length - 1 || isNextCharLWSP(elist[i + 1])) {\n          element.text = element.text.slice(0, -1);\n        }\n      }\n    }\n  }\n\n  function constructSpanList(element, elist) {\n    if (!(\"contents\" in element)) {\n      return;\n    }\n\n    for (var i = 0; i < element.contents.length; i++) {\n      var child = element.contents[i];\n      var ruby = child.styleAttrs[imscStyles.byName.ruby.qname];\n\n      if (child.kind === 'span' && (ruby === \"textContainer\" || ruby === \"text\")) {\n        /* skip ruby text and text containers, which are handled on their own */\n        continue;\n      } else if ('contents' in child) {\n        constructSpanList(child, elist);\n      } else if (child.kind === 'span' && child.text.length !== 0 || child.kind === 'br') {\n        /* skip empty spans */\n        elist.push(child);\n      }\n    }\n  }\n\n  function pruneEmptySpans(element) {\n    if (element.kind === 'br') {\n      return false;\n    } else if ('text' in element) {\n      return element.text.length === 0;\n    } else if ('contents' in element) {\n      var i = element.contents.length;\n\n      while (i--) {\n        if (pruneEmptySpans(element.contents[i])) {\n          element.contents.splice(i, 1);\n        }\n      }\n\n      return element.contents.length === 0;\n    }\n  }\n\n  function ISD(tt) {\n    this.contents = [];\n    this.aspectRatio = tt.aspectRatio;\n    this.lang = tt.lang;\n  }\n\n  function ISDContentElement(ttelem) {\n    /* assume the element is a region if it does not have a kind */\n    this.kind = ttelem.kind || 'region';\n    /* copy lang */\n\n    this.lang = ttelem.lang;\n    /* copy id */\n\n    if (ttelem.id) {\n      this.id = ttelem.id;\n    }\n    /* deep copy of style attributes */\n\n\n    this.styleAttrs = {};\n\n    for (var sname in ttelem.styleAttrs) {\n      if (!ttelem.styleAttrs.hasOwnProperty(sname)) continue;\n      this.styleAttrs[sname] = ttelem.styleAttrs[sname];\n    }\n    /* copy src and type if image */\n\n\n    if ('src' in ttelem) {\n      this.src = ttelem.src;\n    }\n\n    if ('type' in ttelem) {\n      this.type = ttelem.type;\n    }\n    /* TODO: clean this! \r\n     * TODO: ISDElement and document element should be better tied together */\n\n\n    if ('text' in ttelem) {\n      this.text = ttelem.text;\n    } else if (this.kind === 'region' || 'contents' in ttelem) {\n      this.contents = [];\n    }\n\n    if ('space' in ttelem) {\n      this.space = ttelem.space;\n    }\n  }\n  /*\r\n   * ERROR HANDLING UTILITY FUNCTIONS\r\n   * \r\n   */\n\n\n  function reportInfo(errorHandler, msg) {\n    if (errorHandler && errorHandler.info && errorHandler.info(msg)) throw msg;\n  }\n\n  function reportWarning(errorHandler, msg) {\n    if (errorHandler && errorHandler.warn && errorHandler.warn(msg)) throw msg;\n  }\n\n  function reportError(errorHandler, msg) {\n    if (errorHandler && errorHandler.error && errorHandler.error(msg)) throw msg;\n  }\n\n  function reportFatal(errorHandler, msg) {\n    if (errorHandler && errorHandler.fatal) errorHandler.fatal(msg);\n    throw msg;\n  }\n})(typeof exports === 'undefined' ? this.imscISD = {} : exports, typeof imscNames === 'undefined' ? require(\"./names\") : imscNames, typeof imscStyles === 'undefined' ? require(\"./styles\") : imscStyles, typeof imscUtils === 'undefined' ? require(\"./utils\") : imscUtils);","map":{"version":3,"names":["imscISD","imscNames","imscStyles","imscUtils","generateISD","tt","offset","errorHandler","isd","ISD","context","body","activeRegions","initialShowBackground","head","styling","initials","byName","showBackground","qname","initialbackgroundColor","backgroundColor","layout_child","layout","regions","hasOwnProperty","region","styleAttrs","id","undefined","begin","end","regionID","filter","element","offsetFilter","contents","clone","prop","forEach","el","filteredElement","push","c","isdProcessContentElement","_rcs_na_styles","color","textCombine","textDecoration","textEmphasis","textOutline","textShadow","doc","parent","inherited_region_id","elem","associated_region_id","length","isd_element","ISDContentElement","i","sets","value","spec_attr","kind","writingMode","direction","wm","j","all","sa","ps","es","outs","indexOf","fontSize","ruby","ruby_fs","ComputedLength","rw","rh","parent_fs","inherit","k","ivs","position","origin","iv","initial","piv","parse","reportError","z","cs","compute","cstyle","display","x","qnameb","na","rsp","rubyAlign","rubyPosition","da","byQName","applies","elist","constructSpanList","collapseLWSP","pruneEmptySpans","backgroundImage","text","region_id","isPrevCharLWSP","prev_element","test","isNextCharLWSP","next_element","space","trimmed_text","replace","substring","splice","slice","child","aspectRatio","lang","ttelem","sname","src","type","reportInfo","msg","info","reportWarning","warn","error","reportFatal","fatal","exports","require"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/imsc/src/main/js/isd.js"],"sourcesContent":["/* \r\n * Copyright (c) 2016, Pierre-Anthony Lemieux <pal@sandflow.com>\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * @module imscISD\r\n */\r\n\r\n\r\n;\r\n(function (imscISD, imscNames, imscStyles, imscUtils) { // wrapper for non-node envs\r\n\r\n    /** \r\n     * Creates a canonical representation of an IMSC1 document returned by <pre>imscDoc.fromXML()</pre>\r\n     * at a given absolute offset in seconds. This offset does not have to be one of the values returned\r\n     * by <pre>getMediaTimeEvents()</pre>.\r\n     * \r\n     * @param {Object} tt IMSC1 document\r\n     * @param {number} offset Absolute offset (in seconds)\r\n     * @param {?module:imscUtils.ErrorHandler} errorHandler Error callback\r\n     * @returns {Object} Opaque in-memory representation of an ISD\r\n     */\r\n\r\n    imscISD.generateISD = function (tt, offset, errorHandler) {\r\n\r\n        /* TODO check for tt and offset validity */\r\n\r\n        /* create the ISD object from the IMSC1 doc */\r\n\r\n        var isd = new ISD(tt);\r\n\r\n        /* context */\r\n\r\n        var context = {\r\n\r\n            /*rubyfs: []*/ /* font size of the nearest textContainer or container */\r\n\r\n        };\r\n\r\n        /* Filter body contents - Only process what we need within the offset and discard regions not applicable to the content */\r\n        var body = {};\r\n        var activeRegions = {};\r\n\r\n        /* gather any regions that might have showBackground=\"always\" and show a background */\r\n        var initialShowBackground = tt.head.styling.initials[imscStyles.byName.showBackground.qname];\r\n        var initialbackgroundColor = tt.head.styling.initials[imscStyles.byName.backgroundColor.qname];\r\n        for (var layout_child in tt.head.layout.regions)\r\n        {\r\n            if (tt.head.layout.regions.hasOwnProperty(layout_child)) {\r\n                var region = tt.head.layout.regions[layout_child];\r\n                var showBackground = region.styleAttrs[imscStyles.byName.showBackground.qname] || initialShowBackground;\r\n                var backgroundColor = region.styleAttrs[imscStyles.byName.backgroundColor.qname] || initialbackgroundColor;\r\n                activeRegions[region.id] = (\r\n                    (showBackground === 'always' || showBackground === undefined) &&\r\n                    backgroundColor !== undefined &&\r\n                    !(offset < region.begin || offset >= region.end)\r\n                    );\r\n            }\r\n        }\r\n\r\n        /* If the body specifies a region, catch it, since no filtered content will */\r\n        /* likely specify the region. */\r\n        if (tt.body && tt.body.regionID) {\r\n            activeRegions[tt.body.regionID] = true;\r\n        }\r\n\r\n        function filter(offset, element) {\r\n            function offsetFilter(element) {\r\n                return !(offset < element.begin || offset >= element.end);    \r\n            }    \r\n        \r\n            if (element.contents) {\r\n                var clone = {};\r\n                for (var prop in element) {\r\n                    if (element.hasOwnProperty(prop)) {\r\n                        clone[prop] = element[prop];\r\n                    }\r\n                }\r\n                clone.contents = [];\r\n\r\n                element.contents.filter(offsetFilter).forEach(function (el) {\r\n                    var filteredElement = filter(offset, el);\r\n                    if (filteredElement.regionID) {\r\n                        activeRegions[filteredElement.regionID] = true;\r\n                    }\r\n        \r\n                    if (filteredElement !== null) {\r\n                        clone.contents.push(filteredElement);\r\n                    }\r\n                });\r\n                return clone;\r\n            } else {\r\n                return element;\r\n            }\r\n        }\r\n\r\n        if (tt.body !== null) {\r\n            body = filter(offset, tt.body);\r\n        } else {\r\n            body = null;\r\n        }\r\n\r\n        /* rewritten TTML will always have a default - this covers it. because the region is defaulted to \"\" */\r\n        if (activeRegions[\"\"] !== undefined) {\r\n            activeRegions[\"\"] = true;\r\n        }\r\n\r\n        /* process regions */      \r\n        for (var regionID in activeRegions) {\r\n            if (activeRegions[regionID]) {\r\n                /* post-order traversal of the body tree per [construct intermediate document] */\r\n\r\n                var c = isdProcessContentElement(tt, offset, tt.head.layout.regions[regionID], body, null, '', tt.head.layout.regions[regionID], errorHandler, context);\r\n\r\n                if (c !== null) {\r\n\r\n                    /* add the region to the ISD */\r\n\r\n                    isd.contents.push(c.element);\r\n                }\r\n            }\r\n        }\r\n\r\n        return isd;\r\n    };\r\n\r\n    /* set of styles not applicable to ruby container spans */\r\n\r\n    var _rcs_na_styles = [\r\n        imscStyles.byName.color.qname,\r\n        imscStyles.byName.textCombine.qname,\r\n        imscStyles.byName.textDecoration.qname,\r\n        imscStyles.byName.textEmphasis.qname,\r\n        imscStyles.byName.textOutline.qname,\r\n        imscStyles.byName.textShadow.qname\r\n    ];\r\n\r\n    function isdProcessContentElement(doc, offset, region, body, parent, inherited_region_id, elem, errorHandler, context) {\r\n\r\n        /* prune if temporally inactive */\r\n\r\n        if (offset < elem.begin || offset >= elem.end) {\r\n            return null;\r\n        }\r\n\r\n        /* \r\n         * set the associated region as specified by the regionID attribute, or the \r\n         * inherited associated region otherwise\r\n         */\r\n\r\n        var associated_region_id = 'regionID' in elem && elem.regionID !== '' ? elem.regionID : inherited_region_id;\r\n\r\n        /* prune the element if either:\r\n         * - the element is not terminal and the associated region is neither the default\r\n         *   region nor the parent region (this allows children to be associated with a \r\n         *   region later on)\r\n         * - the element is terminal and the associated region is not the parent region\r\n         */\r\n\r\n        /* TODO: improve detection of terminal elements since <region> has no contents */\r\n\r\n        if (parent !== null /* are we in the region element */ &&\r\n            associated_region_id !== region.id &&\r\n            (\r\n                (!('contents' in elem)) ||\r\n                ('contents' in elem && elem.contents.length === 0) ||\r\n                associated_region_id !== ''\r\n                )\r\n            )\r\n            return null;\r\n\r\n        /* create an ISD element, including applying specified styles */\r\n\r\n        var isd_element = new ISDContentElement(elem);\r\n\r\n        /* apply set (animation) styling */\r\n\r\n        if (\"sets\" in elem) {\r\n            for (var i = 0; i < elem.sets.length; i++) {\r\n\r\n                if (offset < elem.sets[i].begin || offset >= elem.sets[i].end)\r\n                    continue;\r\n\r\n                isd_element.styleAttrs[elem.sets[i].qname] = elem.sets[i].value;\r\n\r\n            }\r\n        }\r\n\r\n        /* \r\n         * keep track of specified styling attributes so that we\r\n         * can compute them later\r\n         */\r\n\r\n        var spec_attr = {};\r\n\r\n        for (var qname in isd_element.styleAttrs) {\r\n\r\n            if (! isd_element.styleAttrs.hasOwnProperty(qname)) continue;\r\n\r\n            spec_attr[qname] = true;\r\n\r\n            /* special rule for tts:writingMode (section 7.29.1 of XSL)\r\n             * direction is set consistently with writingMode only\r\n             * if writingMode sets inline-direction to LTR or RTL  \r\n             */\r\n\r\n            if (isd_element.kind === 'region' &&\r\n                qname === imscStyles.byName.writingMode.qname &&\r\n                !(imscStyles.byName.direction.qname in isd_element.styleAttrs)) {\r\n\r\n                var wm = isd_element.styleAttrs[qname];\r\n\r\n                if (wm === \"lrtb\" || wm === \"lr\") {\r\n\r\n                    isd_element.styleAttrs[imscStyles.byName.direction.qname] = \"ltr\";\r\n\r\n                } else if (wm === \"rltb\" || wm === \"rl\") {\r\n\r\n                    isd_element.styleAttrs[imscStyles.byName.direction.qname] = \"rtl\";\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        /* inherited styling */\r\n\r\n        if (parent !== null) {\r\n\r\n            for (var j = 0; j < imscStyles.all.length; j++) {\r\n\r\n                var sa = imscStyles.all[j];\r\n\r\n                /* textDecoration has special inheritance rules */\r\n\r\n                if (sa.qname === imscStyles.byName.textDecoration.qname) {\r\n\r\n                    /* handle both textDecoration inheritance and specification */\r\n\r\n                    var ps = parent.styleAttrs[sa.qname];\r\n                    var es = isd_element.styleAttrs[sa.qname];\r\n                    var outs = [];\r\n\r\n                    if (es === undefined) {\r\n\r\n                        outs = ps;\r\n\r\n                    } else if (es.indexOf(\"none\") === -1) {\r\n\r\n                        if ((es.indexOf(\"noUnderline\") === -1 &&\r\n                            ps.indexOf(\"underline\") !== -1) ||\r\n                            es.indexOf(\"underline\") !== -1) {\r\n\r\n                            outs.push(\"underline\");\r\n\r\n                        }\r\n\r\n                        if ((es.indexOf(\"noLineThrough\") === -1 &&\r\n                            ps.indexOf(\"lineThrough\") !== -1) ||\r\n                            es.indexOf(\"lineThrough\") !== -1) {\r\n\r\n                            outs.push(\"lineThrough\");\r\n\r\n                        }\r\n\r\n                        if ((es.indexOf(\"noOverline\") === -1 &&\r\n                            ps.indexOf(\"overline\") !== -1) ||\r\n                            es.indexOf(\"overline\") !== -1) {\r\n\r\n                            outs.push(\"overline\");\r\n\r\n                        }\r\n\r\n                    } else {\r\n\r\n                        outs.push(\"none\");\r\n\r\n                    }\r\n\r\n                    isd_element.styleAttrs[sa.qname] = outs;\r\n\r\n                } else if (sa.qname === imscStyles.byName.fontSize.qname &&\r\n                    !(sa.qname in isd_element.styleAttrs) &&\r\n                    isd_element.kind === 'span' &&\r\n                    isd_element.styleAttrs[imscStyles.byName.ruby.qname] === \"textContainer\") {\r\n                    \r\n                    /* special inheritance rule for ruby text container font size */\r\n                    \r\n                    var ruby_fs = parent.styleAttrs[imscStyles.byName.fontSize.qname];\r\n\r\n                    isd_element.styleAttrs[sa.qname] = new imscUtils.ComputedLength(\r\n                        0.5 * ruby_fs.rw,\r\n                        0.5 * ruby_fs.rh);\r\n\r\n                } else if (sa.qname === imscStyles.byName.fontSize.qname &&\r\n                    !(sa.qname in isd_element.styleAttrs) &&\r\n                    isd_element.kind === 'span' &&\r\n                    isd_element.styleAttrs[imscStyles.byName.ruby.qname] === \"text\") {\r\n                    \r\n                    /* special inheritance rule for ruby text font size */\r\n                    \r\n                    var parent_fs = parent.styleAttrs[imscStyles.byName.fontSize.qname];\r\n                    \r\n                    if (parent.styleAttrs[imscStyles.byName.ruby.qname] === \"textContainer\") {\r\n                        \r\n                        isd_element.styleAttrs[sa.qname] = parent_fs;\r\n                        \r\n                    } else {\r\n                        \r\n                        isd_element.styleAttrs[sa.qname] = new imscUtils.ComputedLength(\r\n                            0.5 * parent_fs.rw,\r\n                            0.5 * parent_fs.rh);\r\n                    }\r\n                    \r\n                } else if (sa.inherit &&\r\n                    (sa.qname in parent.styleAttrs) &&\r\n                    !(sa.qname in isd_element.styleAttrs)) {\r\n\r\n                    isd_element.styleAttrs[sa.qname] = parent.styleAttrs[sa.qname];\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* initial value styling */\r\n\r\n        for (var k = 0; k < imscStyles.all.length; k++) {\r\n            \r\n            var ivs = imscStyles.all[k];\r\n\r\n            /* skip if value is already specified */\r\n\r\n            if (ivs.qname in isd_element.styleAttrs) continue;\r\n\r\n            /* skip tts:position if tts:origin is specified */\r\n\r\n            if (ivs.qname === imscStyles.byName.position.qname &&\r\n                imscStyles.byName.origin.qname in isd_element.styleAttrs)\r\n                continue;\r\n\r\n            /* skip tts:origin if tts:position is specified */\r\n\r\n            if (ivs.qname === imscStyles.byName.origin.qname &&\r\n                imscStyles.byName.position.qname in isd_element.styleAttrs)\r\n                continue;\r\n            \r\n            /* determine initial value */\r\n            \r\n            var iv = doc.head.styling.initials[ivs.qname] || ivs.initial;\r\n\r\n            if (iv === null) {\r\n                /* skip processing if no initial value defined */\r\n\r\n                continue;\r\n            }\r\n\r\n            /* apply initial value to elements other than region only if non-inherited */\r\n\r\n            if (isd_element.kind === 'region' || (ivs.inherit === false && iv !== null)) {\r\n\r\n                var piv = ivs.parse(iv);\r\n\r\n                if (piv !== null) {\r\n\r\n                    isd_element.styleAttrs[ivs.qname] = piv;\r\n\r\n                    /* keep track of the style as specified */\r\n\r\n                    spec_attr[ivs.qname] = true;\r\n\r\n                } else {\r\n\r\n                    reportError(errorHandler, \"Invalid initial value for '\" + ivs.qname + \"' on element '\" + isd_element.kind);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* compute styles (only for non-inherited styles) */\r\n        /* TODO: get rid of spec_attr */\r\n\r\n        for (var z = 0; z < imscStyles.all.length; z++) {\r\n            \r\n            var cs = imscStyles.all[z];\r\n\r\n            if (!(cs.qname in spec_attr)) continue;\r\n\r\n            if (cs.compute !== null) {\r\n\r\n                var cstyle = cs.compute(\r\n                    /*doc, parent, element, attr, context*/\r\n                    doc,\r\n                    parent,\r\n                    isd_element,\r\n                    isd_element.styleAttrs[cs.qname],\r\n                    context\r\n                    );\r\n\r\n                if (cstyle !== null) {\r\n\r\n                    isd_element.styleAttrs[cs.qname] = cstyle;\r\n                    \r\n                } else {\r\n                    /* if the style cannot be computed, replace it by its initial value */\r\n\r\n                    isd_element.styleAttrs[cs.qname] = cs.compute(\r\n                        /*doc, parent, element, attr, context*/\r\n                        doc,\r\n                        parent,\r\n                        isd_element,\r\n                        cs.parse(cs.initial),\r\n                        context\r\n                    );\r\n\r\n                    reportError(errorHandler, \"Style '\" + cs.qname + \"' on element '\" + isd_element.kind + \"' cannot be computed\");\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /* prune if tts:display is none */\r\n\r\n        if (isd_element.styleAttrs[imscStyles.byName.display.qname] === \"none\")\r\n            return null;\r\n\r\n        /* process contents of the element */\r\n\r\n        var contents = null;\r\n\r\n        if (parent === null) {\r\n\r\n            /* we are processing the region */\r\n\r\n            if (body === null) {\r\n\r\n                /* if there is no body, still process the region but with empty content */\r\n\r\n                contents = [];\r\n\r\n            } else {\r\n\r\n                /*use the body element as contents */\r\n\r\n                contents = [body];\r\n\r\n            }\r\n\r\n        } else if ('contents' in elem) {\r\n\r\n            contents = elem.contents;\r\n\r\n        }\r\n\r\n        for (var x = 0; contents !== null && x < contents.length; x++) {\r\n\r\n            var c = isdProcessContentElement(doc, offset, region, body, isd_element, associated_region_id, contents[x], errorHandler, context);\r\n\r\n            /* \r\n             * keep child element only if they are non-null and their region match \r\n             * the region of this element\r\n             */\r\n\r\n            if (c !== null) {\r\n\r\n                isd_element.contents.push(c.element);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* remove styles that are not applicable */\r\n\r\n        for (var qnameb in isd_element.styleAttrs) {\r\n            if (!isd_element.styleAttrs.hasOwnProperty(qnameb)) continue;\r\n\r\n            /* true if not applicable */\r\n\r\n            var na = false;\r\n\r\n            /* special applicability of certain style properties to ruby container spans */\r\n            /* TODO: in the future ruby elements should be translated to elements instead of kept as spans */\r\n\r\n            if (isd_element.kind === 'span') {\r\n\r\n                var rsp = isd_element.styleAttrs[imscStyles.byName.ruby.qname];\r\n\r\n                na = ( rsp === 'container' || rsp === 'textContainer' || rsp === 'baseContainer' ) && \r\n                    _rcs_na_styles.indexOf(qnameb) !== -1;\r\n\r\n                if (! na) {\r\n\r\n                    na = rsp !== 'container' &&\r\n                        qnameb === imscStyles.byName.rubyAlign.qname;\r\n\r\n                }\r\n\r\n                if (! na) {\r\n\r\n                    na =  (! (rsp === 'textContainer' || rsp === 'text')) &&\r\n                        qnameb === imscStyles.byName.rubyPosition.qname;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            /* normal applicability */\r\n            \r\n            if (! na) {\r\n\r\n                var da = imscStyles.byQName[qnameb];\r\n\r\n                if (\"applies\" in da){\r\n\r\n                    na = da.applies.indexOf(isd_element.kind) === -1;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n            if (na) {\r\n                delete isd_element.styleAttrs[qnameb];\r\n            }\r\n\r\n        }\r\n\r\n        /* trim whitespace around explicit line breaks */\r\n\r\n        var ruby = isd_element.styleAttrs[imscStyles.byName.ruby.qname];\r\n\r\n        if (isd_element.kind === 'p' ||\r\n            (isd_element.kind === 'span' && (ruby === \"textContainer\" || ruby === \"text\"))\r\n            ) {\r\n\r\n            var elist = [];\r\n\r\n            constructSpanList(isd_element, elist);\r\n\r\n            collapseLWSP(elist);\r\n\r\n            pruneEmptySpans(isd_element);\r\n\r\n        }\r\n\r\n        /* keep element if:\r\n         * * contains a background image\r\n         * * <br/>\r\n         * * if there are children\r\n         * * if it is an image\r\n         * * if <span> and has text\r\n         * * if region and showBackground = always\r\n         */\r\n\r\n        if ((isd_element.kind === 'div' && imscStyles.byName.backgroundImage.qname in isd_element.styleAttrs) ||\r\n            isd_element.kind === 'br' ||\r\n            isd_element.kind === 'image' ||\r\n            ('contents' in isd_element && isd_element.contents.length > 0) ||\r\n            (isd_element.kind === 'span' && isd_element.text !== null) ||\r\n            (isd_element.kind === 'region' &&\r\n                isd_element.styleAttrs[imscStyles.byName.showBackground.qname] === 'always')) {\r\n\r\n            return {\r\n                region_id: associated_region_id,\r\n                element: isd_element\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function collapseLWSP(elist) {\r\n\r\n        function isPrevCharLWSP(prev_element) {\r\n            return prev_element.kind === 'br' || /[\\r\\n\\t ]$/.test(prev_element.text);\r\n        }\r\n\r\n        function isNextCharLWSP(next_element) {\r\n            return next_element.kind === 'br' || (next_element.space === \"preserve\" && /^[\\r\\n]/.test(next_element.text));\r\n        }\r\n\r\n        /* collapse spaces and remove leading LWSPs */\r\n\r\n        var element;\r\n\r\n        for (var i = 0; i < elist.length;) {\r\n\r\n            element = elist[i];\r\n\r\n            if (element.kind === \"br\" || element.space === \"preserve\") {\r\n                i++;\r\n                continue;\r\n            }\r\n\r\n            var trimmed_text = element.text.replace(/[\\t\\r\\n ]+/g, ' ');\r\n\r\n            if (/^[ ]/.test(trimmed_text)) {\r\n\r\n                if (i === 0 || isPrevCharLWSP(elist[i - 1])) {\r\n                    trimmed_text = trimmed_text.substring(1);\r\n                }\r\n\r\n            }\r\n\r\n            element.text = trimmed_text;\r\n\r\n            if (trimmed_text.length === 0) {\r\n                elist.splice(i, 1);\r\n            } else {\r\n                i++;\r\n            }\r\n\r\n        }\r\n\r\n        /* remove trailing LWSPs */\r\n\r\n        for (i = 0; i < elist.length; i++) {\r\n\r\n            element = elist[i];\r\n\r\n            if (element.kind === \"br\" || element.space === \"preserve\") {\r\n                i++;\r\n                continue;\r\n            }\r\n\r\n            if (/[ ]$/.test(element.text)) {\r\n\r\n                if (i === (elist.length - 1) || isNextCharLWSP(elist[i + 1])) {\r\n                    element.text = element.text.slice(0, -1);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function constructSpanList(element, elist) {\r\n\r\n        if (! (\"contents\" in element)) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < element.contents.length; i++) {\r\n\r\n            var child = element.contents[i];\r\n            var ruby = child.styleAttrs[imscStyles.byName.ruby.qname];\r\n\r\n            if (child.kind === 'span' && (ruby === \"textContainer\" || ruby === \"text\")) {\r\n\r\n                /* skip ruby text and text containers, which are handled on their own */\r\n            \r\n                continue;\r\n\r\n            } else if ('contents' in child) {\r\n    \r\n                constructSpanList(child, elist);\r\n    \r\n            } else if ((child.kind === 'span' && child.text.length !== 0) || child.kind === 'br') {\r\n\r\n                /* skip empty spans */\r\n\r\n                elist.push(child);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function pruneEmptySpans(element) {\r\n\r\n        if (element.kind === 'br') {\r\n\r\n            return false;\r\n\r\n        } else if ('text' in element) {\r\n\r\n            return  element.text.length === 0;\r\n\r\n        } else if ('contents' in element) {\r\n\r\n            var i = element.contents.length;\r\n\r\n            while (i--) {\r\n\r\n                if (pruneEmptySpans(element.contents[i])) {\r\n                    element.contents.splice(i, 1);\r\n                }\r\n\r\n            }\r\n\r\n            return element.contents.length === 0;\r\n\r\n        }\r\n    }\r\n\r\n    function ISD(tt) {\r\n        this.contents = [];\r\n        this.aspectRatio = tt.aspectRatio;\r\n        this.lang = tt.lang;\r\n    }\r\n\r\n    function ISDContentElement(ttelem) {\r\n\r\n        /* assume the element is a region if it does not have a kind */\r\n\r\n        this.kind = ttelem.kind || 'region';\r\n\r\n        /* copy lang */\r\n\r\n        this.lang = ttelem.lang;\r\n\r\n        /* copy id */\r\n\r\n        if (ttelem.id) {\r\n            this.id = ttelem.id;\r\n        }\r\n\r\n        /* deep copy of style attributes */\r\n        this.styleAttrs = {};\r\n\r\n        for (var sname in ttelem.styleAttrs) {\r\n\r\n            if (! ttelem.styleAttrs.hasOwnProperty(sname)) continue;\r\n\r\n            this.styleAttrs[sname] =\r\n                ttelem.styleAttrs[sname];\r\n        }\r\n        \r\n        /* copy src and type if image */\r\n        \r\n        if ('src' in ttelem) {\r\n            \r\n            this.src = ttelem.src;\r\n            \r\n        }\r\n        \r\n         if ('type' in ttelem) {\r\n            \r\n            this.type = ttelem.type;\r\n            \r\n        }\r\n\r\n        /* TODO: clean this! \r\n         * TODO: ISDElement and document element should be better tied together */\r\n\r\n        if ('text' in ttelem) {\r\n\r\n            this.text = ttelem.text;\r\n\r\n        } else if (this.kind === 'region' || 'contents' in ttelem) {\r\n\r\n            this.contents = [];\r\n        }\r\n\r\n        if ('space' in ttelem) {\r\n\r\n            this.space = ttelem.space;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * ERROR HANDLING UTILITY FUNCTIONS\r\n     * \r\n     */\r\n\r\n    function reportInfo(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.info && errorHandler.info(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportWarning(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.warn && errorHandler.warn(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportError(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.error && errorHandler.error(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportFatal(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.fatal)\r\n            errorHandler.fatal(msg);\r\n\r\n        throw msg;\r\n\r\n    }\r\n\r\n\r\n})(typeof exports === 'undefined' ? this.imscISD = {} : exports,\r\n    typeof imscNames === 'undefined' ? require(\"./names\") : imscNames,\r\n    typeof imscStyles === 'undefined' ? require(\"./styles\") : imscStyles,\r\n    typeof imscUtils === 'undefined' ? require(\"./utils\") : imscUtils\r\n    );\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}