{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unescapeDollarsInTemplate = unescapeDollarsInTemplate;\nexports.replaceIDForTemplate = replaceIDForTemplate;\nexports.replaceTokenForTemplate = replaceTokenForTemplate;\nexports.getIndexBasedSegment = getIndexBasedSegment;\nexports.getTimeBasedSegment = getTimeBasedSegment;\n\nvar _Segment = require('./../vo/Segment');\n\nvar _Segment2 = _interopRequireDefault(_Segment);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction zeroPadToLength(numStr, minStrLength) {\n  while (numStr.length < minStrLength) {\n    numStr = '0' + numStr;\n  }\n\n  return numStr;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction getNumberForSegment(segment, segmentIndex) {\n  return segment.representation.startNumber + segmentIndex;\n}\n\nfunction unescapeDollarsInTemplate(url) {\n  return url ? url.split('$$').join('$') : url;\n}\n\nfunction replaceIDForTemplate(url, value) {\n  if (!value || !url || url.indexOf('$RepresentationID$') === -1) {\n    return url;\n  }\n\n  var v = value.toString();\n  return url.split('$RepresentationID$').join(v);\n}\n\nfunction replaceTokenForTemplate(url, token, value) {\n  var formatTag = '%0';\n  var startPos = void 0,\n      endPos = void 0,\n      formatTagPos = void 0,\n      specifier = void 0,\n      width = void 0,\n      paddedValue = void 0;\n  var tokenLen = token.length;\n  var formatTagLen = formatTag.length;\n\n  if (!url) {\n    return url;\n  } // keep looping round until all instances of <token> have been\n  // replaced. once that has happened, startPos below will be -1\n  // and the completed url will be returned.\n\n\n  while (true) {\n    // check if there is a valid $<token>...$ identifier\n    // if not, return the url as is.\n    startPos = url.indexOf('$' + token);\n\n    if (startPos < 0) {\n      return url;\n    } // the next '$' must be the end of the identifier\n    // if there isn't one, return the url as is.\n\n\n    endPos = url.indexOf('$', startPos + tokenLen);\n\n    if (endPos < 0) {\n      return url;\n    } // now see if there is an additional format tag suffixed to\n    // the identifier within the enclosing '$' characters\n\n\n    formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\n\n    if (formatTagPos > startPos && formatTagPos < endPos) {\n      specifier = url.charAt(endPos - 1);\n      width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10); // support the minimum specifiers required by IEEE 1003.1\n      // (d, i , o, u, x, and X) for completeness\n\n      switch (specifier) {\n        // treat all int types as uint,\n        // hence deliberate fallthrough\n        case 'd':\n        case 'i':\n        case 'u':\n          paddedValue = zeroPadToLength(value.toString(), width);\n          break;\n\n        case 'x':\n          paddedValue = zeroPadToLength(value.toString(16), width);\n          break;\n\n        case 'X':\n          paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\n          break;\n\n        case 'o':\n          paddedValue = zeroPadToLength(value.toString(8), width);\n          break;\n\n        default:\n          return url;\n      }\n    } else {\n      paddedValue = value;\n    }\n\n    url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\n  }\n}\n\nfunction getSegment(representation, duration, presentationStartTime, mediaStartTime, availabilityStartTime, timelineConverter, presentationEndTime, isDynamic, index) {\n  var seg = new _Segment2.default();\n  seg.representation = representation;\n  seg.duration = duration;\n  seg.presentationStartTime = presentationStartTime;\n  seg.mediaStartTime = mediaStartTime;\n  seg.availabilityStartTime = availabilityStartTime;\n  seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n  seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n  seg.replacementNumber = getNumberForSegment(seg, index);\n  seg.availabilityIdx = index;\n  return seg;\n}\n\nfunction isSegmentAvailable(timelineConverter, representation, segment, isDynamic) {\n  var periodEnd = timelineConverter.getPeriodEnd(representation, isDynamic);\n  var periodRelativeEnd = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, periodEnd);\n  var segmentTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, segment.presentationStartTime);\n\n  if (segmentTime >= periodRelativeEnd) {\n    if (isDynamic) {\n      // segment is not available in current period, but it may be segment available in another period that current one (in DVR window)\n      // if not (time > segmentAvailabilityRange.end), then return false\n      if (representation.segmentAvailabilityRange && segment.presentationStartTime >= representation.segmentAvailabilityRange.end) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\n  var duration = void 0,\n      presentationStartTime = void 0,\n      presentationEndTime = void 0;\n  duration = representation.segmentDuration;\n  /*\n  * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\n  * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\n  * in the same way as for the last Media Segment in the Representation.\n  */\n\n  if (isNaN(duration)) {\n    duration = representation.adaptation.period.duration;\n  }\n\n  presentationStartTime = parseFloat((representation.adaptation.period.start + index * duration).toFixed(5));\n  presentationEndTime = parseFloat((presentationStartTime + duration).toFixed(5));\n  var segment = getSegment(representation, duration, presentationStartTime, timelineConverter.calcMediaTimeFromPresentationTime(presentationStartTime, representation), timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic), timelineConverter, presentationEndTime, isDynamic, index);\n\n  if (!isSegmentAvailable(timelineConverter, representation, segment, isDynamic)) {\n    return null;\n  }\n\n  return segment;\n}\n\nfunction getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\n  var scaledTime = time / fTimescale;\n  var scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\n  var presentationStartTime = void 0,\n      presentationEndTime = void 0,\n      seg = void 0;\n  presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n  presentationEndTime = presentationStartTime + scaledDuration;\n  seg = getSegment(representation, scaledDuration, presentationStartTime, scaledTime, representation.adaptation.period.mpd.manifest.loadedTime, timelineConverter, presentationEndTime, isDynamic, index);\n\n  if (!isSegmentAvailable(timelineConverter, representation, seg, isDynamic)) {\n    return null;\n  }\n\n  seg.replacementTime = tManifest ? tManifest : time;\n  url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\n  url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\n  seg.media = url;\n  seg.mediaRange = range;\n  return seg;\n}","map":{"version":3,"mappings":"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","names":["unescapeDollarsInTemplate","replaceIDForTemplate","replaceTokenForTemplate","getIndexBasedSegment","getTimeBasedSegment","zeroPadToLength","numStr","minStrLength","length","getNumberForSegment","segment","segmentIndex","representation","startNumber","url","split","join","value","indexOf","v","toString","token","formatTag","startPos","endPos","formatTagPos","specifier","width","paddedValue","tokenLen","formatTagLen","charAt","parseInt","substring","toUpperCase","getSegment","duration","presentationStartTime","mediaStartTime","availabilityStartTime","timelineConverter","presentationEndTime","isDynamic","index","seg","Segment","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","adaptation","period","mpd","wallStartTime","calcWallTimeForSegment","replacementNumber","availabilityIdx","isSegmentAvailable","periodEnd","getPeriodEnd","periodRelativeEnd","calcPeriodRelativeTimeFromMpdRelativeTime","segmentTime","segmentAvailabilityRange","end","segmentDuration","isNaN","parseFloat","start","toFixed","calcMediaTimeFromPresentationTime","calcAvailabilityStartTimeFromPresentationTime","time","fTimescale","range","tManifest","scaledTime","scaledDuration","Math","min","maxSegmentDuration","calcPresentationTimeFromMediaTime","manifest","loadedTime","replacementTime","media","mediaRange"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/dash/utils/SegmentsUtils.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Segment from './../vo/Segment';\n\nfunction zeroPadToLength(numStr, minStrLength) {\n    while (numStr.length < minStrLength) {\n        numStr = '0' + numStr;\n    }\n    return numStr;\n}\n\nfunction getNumberForSegment(segment, segmentIndex) {\n    return segment.representation.startNumber + segmentIndex;\n}\n\nexport function unescapeDollarsInTemplate(url) {\n    return url ? url.split('$$').join('$') : url;\n}\n\nexport function replaceIDForTemplate(url, value) {\n    if (!value || !url || url.indexOf('$RepresentationID$') === -1) {\n        return url;\n    }\n    let v = value.toString();\n    return url.split('$RepresentationID$').join(v);\n}\n\nexport function replaceTokenForTemplate(url, token, value) {\n    const formatTag = '%0';\n\n    let startPos,\n        endPos,\n        formatTagPos,\n        specifier,\n        width,\n        paddedValue;\n\n    const tokenLen = token.length;\n    const formatTagLen = formatTag.length;\n\n    if (!url) {\n        return url;\n    }\n\n    // keep looping round until all instances of <token> have been\n    // replaced. once that has happened, startPos below will be -1\n    // and the completed url will be returned.\n    while (true) {\n\n        // check if there is a valid $<token>...$ identifier\n        // if not, return the url as is.\n        startPos = url.indexOf('$' + token);\n        if (startPos < 0) {\n            return url;\n        }\n\n        // the next '$' must be the end of the identifier\n        // if there isn't one, return the url as is.\n        endPos = url.indexOf('$', startPos + tokenLen);\n        if (endPos < 0) {\n            return url;\n        }\n\n        // now see if there is an additional format tag suffixed to\n        // the identifier within the enclosing '$' characters\n        formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\n        if (formatTagPos > startPos && formatTagPos < endPos) {\n\n            specifier = url.charAt(endPos - 1);\n            width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);\n\n            // support the minimum specifiers required by IEEE 1003.1\n            // (d, i , o, u, x, and X) for completeness\n            switch (specifier) {\n                // treat all int types as uint,\n                // hence deliberate fallthrough\n                case 'd':\n                case 'i':\n                case 'u':\n                    paddedValue = zeroPadToLength(value.toString(), width);\n                    break;\n                case 'x':\n                    paddedValue = zeroPadToLength(value.toString(16), width);\n                    break;\n                case 'X':\n                    paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\n                    break;\n                case 'o':\n                    paddedValue = zeroPadToLength(value.toString(8), width);\n                    break;\n                default:\n                    return url;\n            }\n        } else {\n            paddedValue = value;\n        }\n\n        url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\n    }\n}\n\nfunction getSegment(representation, duration, presentationStartTime, mediaStartTime, availabilityStartTime,\n                    timelineConverter, presentationEndTime, isDynamic, index) {\n    let seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = duration;\n    seg.presentationStartTime = presentationStartTime;\n    seg.mediaStartTime = mediaStartTime;\n    seg.availabilityStartTime = availabilityStartTime;\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n    seg.replacementNumber = getNumberForSegment(seg, index);\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nfunction isSegmentAvailable(timelineConverter, representation, segment, isDynamic) {\n    const periodEnd = timelineConverter.getPeriodEnd(representation, isDynamic);\n    const periodRelativeEnd = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, periodEnd);\n\n    const segmentTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, segment.presentationStartTime);\n    if (segmentTime >= periodRelativeEnd) {\n        if (isDynamic) {\n            // segment is not available in current period, but it may be segment available in another period that current one (in DVR window)\n            // if not (time > segmentAvailabilityRange.end), then return false\n            if (representation.segmentAvailabilityRange && segment.presentationStartTime >= representation.segmentAvailabilityRange.end) {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\n    let duration,\n        presentationStartTime,\n        presentationEndTime;\n\n    duration = representation.segmentDuration;\n\n    /*\n     * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\n     * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\n     * in the same way as for the last Media Segment in the Representation.\n     */\n    if (isNaN(duration)) {\n        duration = representation.adaptation.period.duration;\n    }\n\n    presentationStartTime = parseFloat((representation.adaptation.period.start + (index * duration)).toFixed(5));\n    presentationEndTime = parseFloat((presentationStartTime + duration).toFixed(5));\n\n    const segment = getSegment(representation, duration, presentationStartTime,\n        timelineConverter.calcMediaTimeFromPresentationTime(presentationStartTime, representation),\n        timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic),\n        timelineConverter, presentationEndTime, isDynamic, index);\n\n    if (!isSegmentAvailable(timelineConverter, representation, segment, isDynamic)) {\n        return null;\n    }\n\n    return segment;\n}\n\nexport function getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\n    const scaledTime = time / fTimescale;\n    const scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\n\n    let presentationStartTime,\n        presentationEndTime,\n        seg;\n\n    presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n    presentationEndTime = presentationStartTime + scaledDuration;\n\n    seg = getSegment(representation, scaledDuration, presentationStartTime,\n        scaledTime,\n        representation.adaptation.period.mpd.manifest.loadedTime,\n        timelineConverter, presentationEndTime, isDynamic, index);\n\n    if (!isSegmentAvailable(timelineConverter, representation, seg, isDynamic)) {\n        return null;\n    }\n\n    seg.replacementTime = tManifest ? tManifest : time;\n\n    url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\n    url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\n    seg.media = url;\n    seg.mediaRange = range;\n\n    return seg;\n}\n"]},"metadata":{},"sourceType":"script"}