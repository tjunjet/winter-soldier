{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FragmentRequest = require('../streaming/vo/FragmentRequest');\n\nvar _FragmentRequest2 = _interopRequireDefault(_FragmentRequest);\n\nvar _HTTPRequest = require('../streaming/vo/metrics/HTTPRequest');\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _SegmentsUtils = require('./utils/SegmentsUtils');\n\nvar _SegmentsController = require('./controllers/SegmentsController');\n\nvar _SegmentsController2 = _interopRequireDefault(_SegmentsController);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction DashHandler(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = config.eventBus;\n  var events = config.events;\n  var debug = config.debug;\n  var dashConstants = config.dashConstants;\n  var urlUtils = config.urlUtils;\n  var type = config.type;\n  var streamInfo = config.streamInfo;\n  var timelineConverter = config.timelineConverter;\n  var dashMetrics = config.dashMetrics;\n  var baseURLController = config.baseURLController;\n  var instance = void 0,\n      logger = void 0,\n      segmentIndex = void 0,\n      lastSegment = void 0,\n      requestedTime = void 0,\n      isDynamicManifest = void 0,\n      dynamicStreamCompleted = void 0,\n      selectedMimeType = void 0,\n      segmentsController = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    resetInitialSettings();\n    segmentsController = (0, _SegmentsController2.default)(context).create(config);\n    eventBus.on(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n    eventBus.on(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n    eventBus.on(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n    eventBus.on(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\n  }\n\n  function initialize(isDynamic) {\n    isDynamicManifest = isDynamic;\n    dynamicStreamCompleted = false;\n    segmentsController.initialize(isDynamic);\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function getStreamInfo() {\n    return streamInfo;\n  }\n\n  function setCurrentIndex(value) {\n    segmentIndex = value;\n  }\n\n  function getCurrentIndex() {\n    return segmentIndex;\n  }\n\n  function resetIndex() {\n    segmentIndex = -1;\n    lastSegment = null;\n  }\n\n  function resetInitialSettings() {\n    resetIndex();\n    requestedTime = null;\n    segmentsController = null;\n    selectedMimeType = null;\n  }\n\n  function reset() {\n    resetInitialSettings();\n    eventBus.off(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n    eventBus.off(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n    eventBus.off(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n    eventBus.off(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\n  }\n\n  function setRequestUrl(request, destination, representation) {\n    var baseURL = baseURLController.resolve(representation.path);\n    var url = void 0,\n        serviceLocation = void 0;\n\n    if (!baseURL || destination === baseURL.url || !urlUtils.isRelative(destination)) {\n      url = destination;\n    } else {\n      url = baseURL.url;\n      serviceLocation = baseURL.serviceLocation;\n\n      if (destination) {\n        url = urlUtils.resolve(destination, url);\n      }\n    }\n\n    if (urlUtils.isRelative(url)) {\n      return false;\n    }\n\n    request.url = url;\n    request.serviceLocation = serviceLocation;\n    return true;\n  }\n\n  function generateInitRequest(mediaInfo, representation, mediaType) {\n    var request = new _FragmentRequest2.default();\n    var period = representation.adaptation.period;\n    var presentationStartTime = period.start;\n    request.mediaType = mediaType;\n    request.type = _HTTPRequest.HTTPRequest.INIT_SEGMENT_TYPE;\n    request.range = representation.range;\n    request.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, period.mpd, isDynamicManifest);\n    request.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamicManifest);\n    request.quality = representation.index;\n    request.mediaInfo = mediaInfo;\n    request.representationId = representation.id;\n\n    if (setRequestUrl(request, representation.initialization, representation)) {\n      request.url = (0, _SegmentsUtils.replaceTokenForTemplate)(request.url, 'Bandwidth', representation.bandwidth);\n      return request;\n    }\n  }\n\n  function getInitRequest(mediaInfo, representation) {\n    if (!representation) return null;\n    var request = generateInitRequest(mediaInfo, representation, getType());\n    return request;\n  }\n\n  function setMimeType(newMimeType) {\n    selectedMimeType = newMimeType;\n  }\n\n  function setExpectedLiveEdge(liveEdge) {\n    timelineConverter.setExpectedLiveEdge(liveEdge);\n    dashMetrics.updateManifestUpdateInfo({\n      presentationStartTime: liveEdge\n    });\n  }\n\n  function onRepresentationUpdateStarted(e) {\n    processRepresentation(e.representation);\n  }\n\n  function processRepresentation(voRepresentation) {\n    var hasInitialization = voRepresentation.hasInitialization();\n    var hasSegments = voRepresentation.hasSegments(); // If representation has initialization and segments information, REPRESENTATION_UPDATE_COMPLETED can be triggered immediately\n    // otherwise, it means that a request has to be made to get initialization and/or segments informations\n\n    if (hasInitialization && hasSegments) {\n      eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, {\n        representation: voRepresentation\n      }, {\n        streamId: streamInfo.id,\n        mediaType: type\n      });\n    } else {\n      segmentsController.update(voRepresentation, selectedMimeType, hasInitialization, hasSegments);\n    }\n  }\n\n  function getRequestForSegment(mediaInfo, segment) {\n    if (segment === null || segment === undefined) {\n      return null;\n    }\n\n    var request = new _FragmentRequest2.default();\n    var representation = segment.representation;\n    var bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth;\n    var url = segment.media;\n    url = (0, _SegmentsUtils.replaceTokenForTemplate)(url, 'Number', segment.replacementNumber);\n    url = (0, _SegmentsUtils.replaceTokenForTemplate)(url, 'Time', segment.replacementTime);\n    url = (0, _SegmentsUtils.replaceTokenForTemplate)(url, 'Bandwidth', bandwidth);\n    url = (0, _SegmentsUtils.replaceIDForTemplate)(url, representation.id);\n    url = (0, _SegmentsUtils.unescapeDollarsInTemplate)(url);\n    request.mediaType = getType();\n    request.type = _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE;\n    request.range = segment.mediaRange;\n    request.startTime = segment.presentationStartTime;\n    request.mediaStartTime = segment.mediaStartTime;\n    request.duration = segment.duration;\n    request.timescale = representation.timescale;\n    request.availabilityStartTime = segment.availabilityStartTime;\n    request.availabilityEndTime = segment.availabilityEndTime;\n    request.wallStartTime = segment.wallStartTime;\n    request.quality = representation.index;\n    request.index = segment.availabilityIdx;\n    request.mediaInfo = mediaInfo;\n    request.adaptationIndex = representation.adaptation.index;\n    request.representationId = representation.id;\n\n    if (setRequestUrl(request, url, representation)) {\n      return request;\n    }\n  }\n\n  function isMediaFinished(representation) {\n    var isFinished = false;\n    if (!representation) return isFinished;\n\n    if (!isDynamicManifest) {\n      if (segmentIndex >= representation.availableSegmentsNumber) {\n        isFinished = true;\n      }\n    } else {\n      if (dynamicStreamCompleted) {\n        isFinished = true;\n      } else if (lastSegment) {\n        var time = parseFloat((lastSegment.presentationStartTime - representation.adaptation.period.start).toFixed(5));\n        var endTime = lastSegment.duration > 0 ? time + 1.5 * lastSegment.duration : time;\n        var duration = representation.adaptation.period.duration;\n        isFinished = endTime >= duration;\n      }\n    }\n\n    return isFinished;\n  }\n\n  function getSegmentRequestForTime(mediaInfo, representation, time, options) {\n    var request = null;\n\n    if (!representation || !representation.segmentInfoType) {\n      return request;\n    }\n\n    var idx = segmentIndex;\n    var keepIdx = options ? options.keepIdx : false;\n    var ignoreIsFinished = options && options.ignoreIsFinished ? true : false;\n\n    if (requestedTime !== time) {\n      // When playing at live edge with 0 delay we may loop back with same time and index until it is available. Reduces verboseness of logs.\n      requestedTime = time;\n      logger.debug('Getting the request for time : ' + time);\n    }\n\n    var segment = segmentsController.getSegmentByTime(representation, time);\n\n    if (segment) {\n      segmentIndex = segment.availabilityIdx;\n      lastSegment = segment;\n      logger.debug('Index for time ' + time + ' is ' + segmentIndex);\n      request = getRequestForSegment(mediaInfo, segment);\n    } else {\n      var finished = !ignoreIsFinished ? isMediaFinished(representation) : false;\n\n      if (finished) {\n        request = new _FragmentRequest2.default();\n        request.action = _FragmentRequest2.default.ACTION_COMPLETE;\n        request.index = segmentIndex - 1;\n        request.mediaType = type;\n        request.mediaInfo = mediaInfo;\n        logger.debug('Signal complete in getSegmentRequestForTime');\n      }\n    }\n\n    if (keepIdx && idx >= 0) {\n      segmentIndex = representation.segmentInfoType === dashConstants.SEGMENT_TIMELINE && isDynamicManifest ? segmentIndex : idx;\n    }\n\n    return request;\n  }\n  /**\n  * This function returns the next segment request without modifying any internal variables. Any class (e.g CMCD Model) that needs information about the upcoming request should use this method.\n  * @param {object} mediaInfo\n  * @param {object} representation\n  * @return {FragmentRequest|null}\n  */\n\n\n  function getNextSegmentRequestIdempotent(mediaInfo, representation) {\n    var request = null;\n    var indexToRequest = segmentIndex + 1;\n    var segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\n    if (!segment) return null;\n    request = getRequestForSegment(mediaInfo, segment);\n    return request;\n  }\n  /**\n  * Main function to get the next segment request.\n  * @param {object} mediaInfo\n  * @param {object} representation\n  * @return {FragmentRequest|null}\n  */\n\n\n  function getNextSegmentRequest(mediaInfo, representation) {\n    var request = null;\n\n    if (!representation || !representation.segmentInfoType) {\n      return null;\n    }\n\n    requestedTime = null;\n    var indexToRequest = segmentIndex + 1;\n    logger.debug('Getting the next request at index: ' + indexToRequest); // check that there is a segment in this index\n\n    var segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\n\n    if (!segment && isEndlessMedia(representation) && !dynamicStreamCompleted) {\n      logger.debug(getType() + ' No segment found at index: ' + indexToRequest + '. Wait for next loop');\n      return null;\n    } else {\n      if (segment) {\n        request = getRequestForSegment(mediaInfo, segment);\n        segmentIndex = segment.availabilityIdx;\n      } else {\n        if (isDynamicManifest) {\n          segmentIndex = indexToRequest - 1;\n        } else {\n          segmentIndex = indexToRequest;\n        }\n      }\n    }\n\n    if (segment) {\n      lastSegment = segment;\n    } else {\n      var finished = isMediaFinished(representation, segment);\n\n      if (finished) {\n        request = new _FragmentRequest2.default();\n        request.action = _FragmentRequest2.default.ACTION_COMPLETE;\n        request.index = segmentIndex - 1;\n        request.mediaType = getType();\n        request.mediaInfo = mediaInfo;\n        logger.debug('Signal complete');\n      }\n    }\n\n    return request;\n  }\n\n  function isEndlessMedia(representation) {\n    return !isFinite(representation.adaptation.period.duration);\n  }\n\n  function onInitializationLoaded(e) {\n    var representation = e.representation;\n    if (!representation.segments) return;\n    eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, {\n      representation: representation\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function onSegmentsLoaded(e) {\n    if (e.error) return;\n    var fragments = e.segments;\n    var representation = e.representation;\n    var segments = [];\n    var count = 0;\n    var i = void 0,\n        len = void 0,\n        s = void 0,\n        seg = void 0;\n\n    for (i = 0, len = fragments ? fragments.length : 0; i < len; i++) {\n      s = fragments[i];\n      seg = (0, _SegmentsUtils.getTimeBasedSegment)(timelineConverter, isDynamicManifest, representation, s.startTime, s.duration, s.timescale, s.media, s.mediaRange, count);\n\n      if (seg) {\n        segments.push(seg);\n        seg = null;\n        count++;\n      }\n    }\n\n    if (segments.length > 0) {\n      representation.segmentAvailabilityRange = {\n        start: segments[0].presentationStartTime,\n        end: segments[segments.length - 1].presentationStartTime\n      };\n      representation.availableSegmentsNumber = segments.length;\n      representation.segments = segments;\n\n      if (isDynamicManifest) {\n        var _lastSegment = segments[segments.length - 1];\n        var liveEdge = _lastSegment.presentationStartTime - 8; // the last segment is the Expected, not calculated, live edge.\n\n        setExpectedLiveEdge(liveEdge);\n      }\n    }\n\n    if (!representation.hasInitialization()) {\n      return;\n    }\n\n    eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, {\n      representation: representation\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function onDynamicToStatic() {\n    logger.debug('Dynamic stream complete');\n    dynamicStreamCompleted = true;\n  }\n\n  instance = {\n    initialize: initialize,\n    getStreamId: getStreamId,\n    getType: getType,\n    getStreamInfo: getStreamInfo,\n    getInitRequest: getInitRequest,\n    getRequestForSegment: getRequestForSegment,\n    getSegmentRequestForTime: getSegmentRequestForTime,\n    getNextSegmentRequest: getNextSegmentRequest,\n    setCurrentIndex: setCurrentIndex,\n    getCurrentIndex: getCurrentIndex,\n    isMediaFinished: isMediaFinished,\n    reset: reset,\n    resetIndex: resetIndex,\n    setMimeType: setMimeType,\n    getNextSegmentRequestIdempotent: getNextSegmentRequestIdempotent\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nDashHandler.__dashjs_factory_name = 'DashHandler';\nexports.default = _FactoryMaker2.default.getClassFactory(DashHandler);","map":{"version":3,"mappings":"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","names":["DashHandler","config","context","eventBus","events","debug","dashConstants","urlUtils","type","streamInfo","timelineConverter","dashMetrics","baseURLController","instance","logger","segmentIndex","lastSegment","requestedTime","isDynamicManifest","dynamicStreamCompleted","selectedMimeType","segmentsController","setup","getLogger","resetInitialSettings","create","on","INITIALIZATION_LOADED","onInitializationLoaded","SEGMENTS_LOADED","onSegmentsLoaded","REPRESENTATION_UPDATE_STARTED","onRepresentationUpdateStarted","DYNAMIC_TO_STATIC","onDynamicToStatic","initialize","isDynamic","getStreamId","id","getType","getStreamInfo","setCurrentIndex","value","getCurrentIndex","resetIndex","reset","off","setRequestUrl","request","destination","representation","baseURL","resolve","path","url","serviceLocation","isRelative","generateInitRequest","mediaInfo","mediaType","FragmentRequest","period","adaptation","presentationStartTime","start","HTTPRequest","INIT_SEGMENT_TYPE","range","availabilityStartTime","calcAvailabilityStartTimeFromPresentationTime","mpd","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","duration","quality","index","representationId","initialization","bandwidth","getInitRequest","setMimeType","newMimeType","setExpectedLiveEdge","liveEdge","updateManifestUpdateInfo","e","processRepresentation","voRepresentation","hasInitialization","hasSegments","trigger","REPRESENTATION_UPDATE_COMPLETED","streamId","update","getRequestForSegment","segment","undefined","manifest","Period_asArray","AdaptationSet_asArray","Representation_asArray","media","replacementNumber","replacementTime","MEDIA_SEGMENT_TYPE","mediaRange","startTime","mediaStartTime","timescale","wallStartTime","availabilityIdx","adaptationIndex","isMediaFinished","isFinished","availableSegmentsNumber","time","parseFloat","toFixed","endTime","getSegmentRequestForTime","options","segmentInfoType","idx","keepIdx","ignoreIsFinished","getSegmentByTime","finished","action","ACTION_COMPLETE","SEGMENT_TIMELINE","getNextSegmentRequestIdempotent","indexToRequest","getSegmentByIndex","getNextSegmentRequest","isEndlessMedia","isFinite","segments","error","fragments","count","i","len","s","seg","length","push","segmentAvailabilityRange","end","__dashjs_factory_name","FactoryMaker","getClassFactory"],"sources":["/home/landsys/react-node-video-streaming/client/node_modules/dashjs/src/dash/DashHandler.js"],"sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport {HTTPRequest} from '../streaming/vo/metrics/HTTPRequest';\nimport FactoryMaker from '../core/FactoryMaker';\nimport {\n    replaceIDForTemplate,\n    unescapeDollarsInTemplate,\n    replaceTokenForTemplate,\n    getTimeBasedSegment\n} from './utils/SegmentsUtils';\n\nimport SegmentsController from './controllers/SegmentsController';\n\nfunction DashHandler(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const debug = config.debug;\n    const dashConstants = config.dashConstants;\n    const urlUtils = config.urlUtils;\n    const type = config.type;\n    const streamInfo = config.streamInfo;\n\n    const timelineConverter = config.timelineConverter;\n    const dashMetrics = config.dashMetrics;\n    const baseURLController = config.baseURLController;\n\n    let instance,\n        logger,\n        segmentIndex,\n        lastSegment,\n        requestedTime,\n        isDynamicManifest,\n        dynamicStreamCompleted,\n        selectedMimeType,\n        segmentsController;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n\n        segmentsController = SegmentsController(context).create(config);\n\n        eventBus.on(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n        eventBus.on(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n        eventBus.on(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n        eventBus.on(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\n    }\n\n    function initialize(isDynamic) {\n        isDynamicManifest = isDynamic;\n        dynamicStreamCompleted = false;\n        segmentsController.initialize(isDynamic);\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function setCurrentIndex(value) {\n        segmentIndex = value;\n    }\n\n    function getCurrentIndex() {\n        return segmentIndex;\n    }\n\n    function resetIndex() {\n        segmentIndex = -1;\n        lastSegment = null;\n    }\n\n    function resetInitialSettings() {\n        resetIndex();\n        requestedTime = null;\n        segmentsController = null;\n        selectedMimeType = null;\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n        eventBus.off(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n        eventBus.off(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n        eventBus.off(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\n    }\n\n    function setRequestUrl(request, destination, representation) {\n        const baseURL = baseURLController.resolve(representation.path);\n        let url,\n            serviceLocation;\n\n        if (!baseURL || (destination === baseURL.url) || (!urlUtils.isRelative(destination))) {\n            url = destination;\n        } else {\n            url = baseURL.url;\n            serviceLocation = baseURL.serviceLocation;\n\n            if (destination) {\n                url = urlUtils.resolve(destination, url);\n            }\n        }\n\n        if (urlUtils.isRelative(url)) {\n            return false;\n        }\n\n        request.url = url;\n        request.serviceLocation = serviceLocation;\n\n        return true;\n    }\n\n    function generateInitRequest(mediaInfo, representation, mediaType) {\n        const request = new FragmentRequest();\n        const period = representation.adaptation.period;\n        const presentationStartTime = period.start;\n\n        request.mediaType = mediaType;\n        request.type = HTTPRequest.INIT_SEGMENT_TYPE;\n        request.range = representation.range;\n        request.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, period.mpd, isDynamicManifest);\n        request.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamicManifest);\n        request.quality = representation.index;\n        request.mediaInfo = mediaInfo;\n        request.representationId = representation.id;\n\n        if (setRequestUrl(request, representation.initialization, representation)) {\n            request.url = replaceTokenForTemplate(request.url, 'Bandwidth', representation.bandwidth);\n            return request;\n        }\n    }\n\n    function getInitRequest(mediaInfo, representation) {\n        if (!representation) return null;\n        const request = generateInitRequest(mediaInfo, representation, getType());\n        return request;\n    }\n\n    function setMimeType(newMimeType) {\n        selectedMimeType = newMimeType;\n    }\n\n    function setExpectedLiveEdge(liveEdge) {\n        timelineConverter.setExpectedLiveEdge(liveEdge);\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\n    }\n\n    function onRepresentationUpdateStarted(e) {\n        processRepresentation(e.representation);\n    }\n\n    function processRepresentation(voRepresentation) {\n        const hasInitialization = voRepresentation.hasInitialization();\n        const hasSegments = voRepresentation.hasSegments();\n\n        // If representation has initialization and segments information, REPRESENTATION_UPDATE_COMPLETED can be triggered immediately\n        // otherwise, it means that a request has to be made to get initialization and/or segments informations\n        if (hasInitialization && hasSegments) {\n            eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\n                { representation: voRepresentation },\n                { streamId: streamInfo.id, mediaType: type }\n            );\n        } else {\n            segmentsController.update(voRepresentation, selectedMimeType, hasInitialization, hasSegments);\n        }\n    }\n\n    function getRequestForSegment(mediaInfo, segment) {\n        if (segment === null || segment === undefined) {\n            return null;\n        }\n\n        const request = new FragmentRequest();\n        const representation = segment.representation;\n        const bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth;\n        let url = segment.media;\n\n        url = replaceTokenForTemplate(url, 'Number', segment.replacementNumber);\n        url = replaceTokenForTemplate(url, 'Time', segment.replacementTime);\n        url = replaceTokenForTemplate(url, 'Bandwidth', bandwidth);\n        url = replaceIDForTemplate(url, representation.id);\n        url = unescapeDollarsInTemplate(url);\n\n        request.mediaType = getType();\n        request.type = HTTPRequest.MEDIA_SEGMENT_TYPE;\n        request.range = segment.mediaRange;\n        request.startTime = segment.presentationStartTime;\n        request.mediaStartTime = segment.mediaStartTime;\n        request.duration = segment.duration;\n        request.timescale = representation.timescale;\n        request.availabilityStartTime = segment.availabilityStartTime;\n        request.availabilityEndTime = segment.availabilityEndTime;\n        request.wallStartTime = segment.wallStartTime;\n        request.quality = representation.index;\n        request.index = segment.availabilityIdx;\n        request.mediaInfo = mediaInfo;\n        request.adaptationIndex = representation.adaptation.index;\n        request.representationId = representation.id;\n\n        if (setRequestUrl(request, url, representation)) {\n            return request;\n        }\n    }\n\n    function isMediaFinished(representation) {\n        let isFinished = false;\n\n        if (!representation) return isFinished;\n\n        if (!isDynamicManifest) {\n            if (segmentIndex >= representation.availableSegmentsNumber) {\n                isFinished = true;\n            }\n        } else {\n            if (dynamicStreamCompleted) {\n                isFinished = true;\n            } else if (lastSegment) {\n                const time = parseFloat((lastSegment.presentationStartTime - representation.adaptation.period.start).toFixed(5));\n                const endTime = lastSegment.duration > 0 ? time + 1.5 * lastSegment.duration : time;\n                const duration = representation.adaptation.period.duration;\n\n                isFinished = endTime >= duration;\n            }\n        }\n        return isFinished;\n    }\n\n    function getSegmentRequestForTime(mediaInfo, representation, time, options) {\n        let request = null;\n\n        if (!representation || !representation.segmentInfoType) {\n            return request;\n        }\n\n        const idx = segmentIndex;\n        const keepIdx = options ? options.keepIdx : false;\n        const ignoreIsFinished = (options && options.ignoreIsFinished) ? true : false;\n\n        if (requestedTime !== time) { // When playing at live edge with 0 delay we may loop back with same time and index until it is available. Reduces verboseness of logs.\n            requestedTime = time;\n            logger.debug('Getting the request for time : ' + time);\n        }\n\n        const segment = segmentsController.getSegmentByTime(representation, time);\n        if (segment) {\n            segmentIndex = segment.availabilityIdx;\n            lastSegment = segment;\n            logger.debug('Index for time ' + time + ' is ' + segmentIndex);\n            request = getRequestForSegment(mediaInfo, segment);\n        } else {\n            const finished = !ignoreIsFinished ? isMediaFinished(representation) : false;\n            if (finished) {\n                request = new FragmentRequest();\n                request.action = FragmentRequest.ACTION_COMPLETE;\n                request.index = segmentIndex - 1;\n                request.mediaType = type;\n                request.mediaInfo = mediaInfo;\n                logger.debug('Signal complete in getSegmentRequestForTime');\n            }\n        }\n\n        if (keepIdx && idx >= 0) {\n            segmentIndex = representation.segmentInfoType === dashConstants.SEGMENT_TIMELINE && isDynamicManifest ? segmentIndex : idx;\n        }\n\n        return request;\n    }\n\n    /**\n     * This function returns the next segment request without modifying any internal variables. Any class (e.g CMCD Model) that needs information about the upcoming request should use this method.\n     * @param {object} mediaInfo\n     * @param {object} representation\n     * @return {FragmentRequest|null}\n     */\n    function getNextSegmentRequestIdempotent(mediaInfo, representation) {\n        let request = null;\n        let indexToRequest = segmentIndex + 1;\n        const segment = segmentsController.getSegmentByIndex(\n            representation,\n            indexToRequest,\n            lastSegment ? lastSegment.mediaStartTime : -1\n        );\n        if (!segment) return null;\n        request = getRequestForSegment(mediaInfo, segment);\n        return request;\n    }\n\n    /**\n     * Main function to get the next segment request.\n     * @param {object} mediaInfo\n     * @param {object} representation\n     * @return {FragmentRequest|null}\n     */\n    function getNextSegmentRequest(mediaInfo, representation) {\n        let request = null;\n\n        if (!representation || !representation.segmentInfoType) {\n            return null;\n        }\n\n        requestedTime = null;\n\n        let indexToRequest = segmentIndex + 1;\n\n        logger.debug('Getting the next request at index: ' + indexToRequest);\n        // check that there is a segment in this index\n        const segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\n        if (!segment && isEndlessMedia(representation) && !dynamicStreamCompleted) {\n            logger.debug(getType() + ' No segment found at index: ' + indexToRequest + '. Wait for next loop');\n            return null;\n        } else {\n            if (segment) {\n                request = getRequestForSegment(mediaInfo, segment);\n                segmentIndex = segment.availabilityIdx;\n            } else {\n                if (isDynamicManifest) {\n                    segmentIndex = indexToRequest - 1;\n                } else {\n                    segmentIndex = indexToRequest;\n                }\n            }\n        }\n\n        if (segment) {\n            lastSegment = segment;\n        } else {\n            const finished = isMediaFinished(representation, segment);\n            if (finished) {\n                request = new FragmentRequest();\n                request.action = FragmentRequest.ACTION_COMPLETE;\n                request.index = segmentIndex - 1;\n                request.mediaType = getType();\n                request.mediaInfo = mediaInfo;\n                logger.debug('Signal complete');\n            }\n        }\n\n        return request;\n    }\n\n    function isEndlessMedia(representation) {\n        return !isFinite(representation.adaptation.period.duration);\n    }\n\n    function onInitializationLoaded(e) {\n        const representation = e.representation;\n        if (!representation.segments) return;\n\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\n            { representation: representation },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function onSegmentsLoaded(e) {\n        if (e.error) return;\n\n        const fragments = e.segments;\n        const representation = e.representation;\n        const segments = [];\n        let count = 0;\n\n        let i,\n            len,\n            s,\n            seg;\n\n        for (i = 0, len = fragments ? fragments.length : 0; i < len; i++) {\n            s = fragments[i];\n\n            seg = getTimeBasedSegment(\n                timelineConverter,\n                isDynamicManifest,\n                representation,\n                s.startTime,\n                s.duration,\n                s.timescale,\n                s.media,\n                s.mediaRange,\n                count);\n\n            if (seg) {\n                segments.push(seg);\n                seg = null;\n                count++;\n            }\n        }\n\n        if (segments.length > 0) {\n            representation.segmentAvailabilityRange = {\n                start: segments[0].presentationStartTime,\n                end: segments[segments.length - 1].presentationStartTime\n            };\n            representation.availableSegmentsNumber = segments.length;\n            representation.segments = segments;\n\n            if (isDynamicManifest) {\n                const lastSegment = segments[segments.length - 1];\n                const liveEdge = lastSegment.presentationStartTime - 8;\n                // the last segment is the Expected, not calculated, live edge.\n                setExpectedLiveEdge(liveEdge);\n            }\n        }\n\n        if (!representation.hasInitialization()) {\n            return;\n        }\n\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\n            { representation: representation },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function onDynamicToStatic() {\n        logger.debug('Dynamic stream complete');\n        dynamicStreamCompleted = true;\n    }\n\n    instance = {\n        initialize: initialize,\n        getStreamId: getStreamId,\n        getType: getType,\n        getStreamInfo: getStreamInfo,\n        getInitRequest: getInitRequest,\n        getRequestForSegment: getRequestForSegment,\n        getSegmentRequestForTime: getSegmentRequestForTime,\n        getNextSegmentRequest: getNextSegmentRequest,\n        setCurrentIndex: setCurrentIndex,\n        getCurrentIndex: getCurrentIndex,\n        isMediaFinished: isMediaFinished,\n        reset: reset,\n        resetIndex: resetIndex,\n        setMimeType: setMimeType,\n        getNextSegmentRequestIdempotent\n    };\n\n    setup();\n\n    return instance;\n}\n\nDashHandler.__dashjs_factory_name = 'DashHandler';\nexport default FactoryMaker.getClassFactory(DashHandler);\n"]},"metadata":{},"sourceType":"script"}